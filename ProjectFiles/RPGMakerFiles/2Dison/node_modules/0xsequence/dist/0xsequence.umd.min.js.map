{"version":3,"file":"0xsequence.umd.min.js","sources":["../../abi/src/wallet/erc5719.ts","../../abi/src/wallet/erc1271.ts","../../abi/src/wallet/index.ts","../../abi/src/wallet/erc6492.ts","../../abi/src/wallet/factory.ts","../../abi/src/wallet/mainModule.ts","../../abi/src/wallet/mainModuleUpgradable.ts","../../abi/src/wallet/sequenceUtils.ts","../../abi/src/wallet/libs/requireFreshSigners.ts","../../api/src/api.gen.ts","../../api/src/index.ts","../../../node_modules/.pnpm/js-base64@3.7.7/node_modules/js-base64/base64.mjs","../../../node_modules/.pnpm/@0xsequence+ethauth@1.0.0_ethers@6.13.4_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@0xsequence/ethauth/dist/index.es.js","../../network/src/constants.ts","../../network/src/utils.ts","../../utils/src/bigint.ts","../../utils/src/base64.ts","../../utils/src/digest.ts","../../utils/src/is-node-or-browser.ts","../../utils/src/jwt-decode.ts","../../utils/src/logger.ts","../../utils/src/merkletree/Base.ts","../../utils/src/merkletree/MerkleTree.ts","../../utils/src/merkle.ts","../../utils/src/network.ts","../../utils/src/promise-cache.ts","../../utils/src/rand.ts","../../utils/src/sanitize.ts","../../utils/src/typed-data.ts","../../utils/src/types.ts","../../network/src/config.ts","../../network/src/json-rpc/router.ts","../../network/src/json-rpc/utils.ts","../../network/src/json-rpc/handler.ts","../../network/src/json-rpc/middleware/allow-provider.ts","../../network/src/json-rpc/middleware/cached-provider.ts","../../network/src/json-rpc/middleware/eager-provider.ts","../../network/src/json-rpc/middleware/exception-provider.ts","../../network/src/json-rpc/middleware/logging-provider.ts","../../network/src/json-rpc/middleware/signing-provider.ts","../../network/src/json-rpc/middleware/singleflight.ts","../../network/src/json-rpc-provider.ts","../../core/src/commons/signature.ts","../../core/src/commons/validateEIP1271.ts","../../core/src/commons/signer.ts","../../core/src/v1/signature.ts","../../core/src/v1/config.ts","../../core/src/v1/index.ts","../../core/src/v2/chained.ts","../../core/src/v2/signature.ts","../../core/src/v2/config.ts","../../core/src/v2/index.ts","../../core/src/commons/context.ts","../../core/src/commons/transaction.ts","../../core/src/commons/validateEIP6492.ts","../../core/src/commons/reader.ts","../../core/src/commons/orchestrator.ts","../../core/src/universal/index.ts","../../core/src/version.ts","../../core/src/index.ts","../../migration/src/version.ts","../../migration/src/migrations/index.ts","../../migration/src/migrations/migration_01_02.ts","../../migration/src/migrator.ts","../../migration/src/defaults.ts","../../relayer/src/provider-relayer.ts","../../relayer/src/local-relayer.ts","../../relayer/src/rpc-relayer/relayer.gen.ts","../../relayer/src/rpc-relayer/index.ts","../../relayer/src/index.ts","../../wallet/src/signer.ts","../../wallet/src/utils.ts","../../signhub/src/signers/signer.ts","../../signhub/src/signers/wrapper.ts","../../signhub/src/orchestrator.ts","../../wallet/src/wallet.ts","../../account/src/signer.ts","../../account/src/account.ts","../../indexer/src/indexer.gen.ts","../../indexer/src/index.ts","../../metadata/src/metadata.gen.ts","../../metadata/src/index.ts","../../auth/src/services.ts","../../auth/src/authorization.ts","../../replacer/src/cached.ts","../../replacer/src/index.ts","../../replacer/src/ipfs.ts","../../sessions/src/trackers/arweave.ts","../../sessions/src/trackers/debug.ts","../../sessions/src/trackers/stores/memoryStore.ts","../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/wrap-idb-value.js","../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/index.js","../../sessions/src/trackers/stores/indexedDBStore.ts","../../sessions/src/trackers/stores/index.ts","../../sessions/src/trackers/local.ts","../../sessions/src/trackers/remote/sessions.gen.ts","../../sessions/src/trackers/remote/index.ts","../../sessions/src/trackers/multiple.ts","../../sessions/src/trackers/promise-cache.ts","../../sessions/src/trackers/deduped.ts","../../sessions/src/trackers/cached.ts","../../auth/src/session.ts","../../auth/src/proof.ts","../../guard/src/guard.gen.ts","../../guard/src/signer.ts","../../network/src/json-rpc/middleware/network-provider.ts","../../network/src/json-rpc/middleware/public-provider.ts","../../provider/src/transactions.ts","../../../node_modules/.pnpm/eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js","../../provider/src/types.ts","../../provider/src/transports/base-provider-transport.ts","../../provider/src/eip191exceptions.ts","../../provider/src/utils.ts","../../provider/src/transports/base-wallet-transport.ts","../../provider/src/transports/proxy-transport/proxy-message-channel.ts","../../provider/src/transports/proxy-transport/proxy-message-provider.ts","../../provider/src/transports/unreal-transport/overridelogs.ts","../../provider/src/transports/unreal-transport/unreal-message-provider.ts","../../provider/src/transports/extension-transport/extension-message-handler.ts","../../provider/src/transports/extension-transport/extension-message-provider.ts","../../provider/src/transports/extension-transport/base-injected-transport.ts","../../provider/src/transports/window-transport/window-message-provider.ts","../../provider/src/transports/mux-transport/mux-message-provider.ts","../../provider/src/transports/wallet-request-handler.ts","../../provider/src/signer.ts","../../provider/src/utils/index.ts","../../provider/src/provider.ts","../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_assert.js","../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/utils.js","../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/_md.js","../../../node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/esm/sha256.js","../../../node_modules/.pnpm/@databeat+tracker@0.9.3/node_modules/@databeat/tracker/dist/databeat-tracker.mjs","../../provider/src/analytics.ts","../../provider/src/client.ts","../../provider/src/extended.ts","../../provider/src/init.ts","../../provider/src/transports/proxy-transport/proxy-message-handler.ts","../../provider/src/transports/window-transport/window-message-handler.ts","../../provider/src/transports/unreal-transport/unreal-message-handler.ts","../src/transactions.ts","../../utils/src/access-key.ts","../../utils/src/promisify.ts","../../utils/src/query-string.ts","../../utils/src/sleep.ts","../../utils/src/web.ts"],"sourcesContent":["export const abi = [\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        type: 'bytes32'\n      }\n    ],\n    name: 'getAlternativeSignature',\n    outputs: [\n      {\n        internalType: 'string',\n        type: 'string'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  }\n]\n","export const abi = [\n  {\n    type: 'function',\n    name: 'isValidSignature',\n    constant: true,\n    inputs: [\n      {\n        type: 'bytes32'\n      },\n      {\n        type: 'bytes'\n      }\n    ],\n    outputs: [\n      {\n        type: 'bytes4'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  }\n]\n\nexport const returns = {\n  isValidSignatureBytes32: '0x1626ba7e'\n}\n","import * as erc5719 from './erc5719'\nimport * as erc1271 from './erc1271'\nimport * as erc6492 from './erc6492'\nimport * as factory from './factory'\nimport * as mainModule from './mainModule'\nimport * as mainModuleUpgradable from './mainModuleUpgradable'\nimport * as sequenceUtils from './sequenceUtils'\nimport * as requireFreshSigner from './libs/requireFreshSigners'\n\nexport const walletContracts = {\n  erc6492,\n  erc5719,\n  erc1271,\n  factory,\n  mainModule,\n  mainModuleUpgradable,\n  sequenceUtils,\n  requireFreshSigner\n}\n","export const abi = [\n  { inputs: [{ internalType: 'bytes', name: 'error', type: 'bytes' }], name: 'ERC1271Revert', type: 'error' },\n  { inputs: [{ internalType: 'bytes', name: 'error', type: 'bytes' }], name: 'ERC6492DeployFailed', type: 'error' },\n  {\n    inputs: [\n      { internalType: 'address', name: '_signer', type: 'address' },\n      { internalType: 'bytes32', name: '_hash', type: 'bytes32' },\n      { internalType: 'bytes', name: '_signature', type: 'bytes' }\n    ],\n    name: 'isValidSig',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '_signer', type: 'address' },\n      { internalType: 'bytes32', name: '_hash', type: 'bytes32' },\n      { internalType: 'bytes', name: '_signature', type: 'bytes' },\n      { internalType: 'bool', name: 'allowSideEffects', type: 'bool' },\n      { internalType: 'bool', name: 'deployAlreadyDeployed', type: 'bool' }\n    ],\n    name: 'isValidSigImpl',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '_signer', type: 'address' },\n      { internalType: 'bytes32', name: '_hash', type: 'bytes32' },\n      { internalType: 'bytes', name: '_signature', type: 'bytes' }\n    ],\n    name: 'isValidSigNoThrow',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '_signer', type: 'address' },\n      { internalType: 'bytes32', name: '_hash', type: 'bytes32' },\n      { internalType: 'bytes', name: '_signature', type: 'bytes' }\n    ],\n    name: 'isValidSigWithSideEffects',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '_signer', type: 'address' },\n      { internalType: 'bytes32', name: '_hash', type: 'bytes32' },\n      { internalType: 'bytes', name: '_signature', type: 'bytes' }\n    ],\n    name: 'isValidSigWithSideEffectsNoThrow',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }\n]\n","export const abi = [\n  {\n    type: 'function',\n    name: 'deploy',\n    constant: false,\n    inputs: [\n      {\n        type: 'address'\n      },\n      {\n        type: 'bytes32'\n      }\n    ],\n    outputs: [],\n    payable: true,\n    stateMutability: 'payable'\n  }\n]\n","export const abi = [\n  {\n    type: 'function',\n    name: 'nonce',\n    constant: true,\n    inputs: [],\n    outputs: [\n      {\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  },\n  {\n    type: 'function',\n    name: 'readNonce',\n    constant: true,\n    inputs: [\n      {\n        type: 'uint256'\n      }\n    ],\n    outputs: [\n      {\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  },\n  {\n    type: 'function',\n    name: 'updateImplementation',\n    constant: false,\n    inputs: [\n      {\n        type: 'address'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  },\n  {\n    type: 'function',\n    name: 'selfExecute',\n    constant: false,\n    inputs: [\n      {\n        components: [\n          {\n            type: 'bool',\n            name: 'delegateCall'\n          },\n          {\n            type: 'bool',\n            name: 'revertOnError'\n          },\n          {\n            type: 'uint256',\n            name: 'gasLimit'\n          },\n          {\n            type: 'address',\n            name: 'target'\n          },\n          {\n            type: 'uint256',\n            name: 'value'\n          },\n          {\n            type: 'bytes',\n            name: 'data'\n          }\n        ],\n        type: 'tuple[]'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    constant: false,\n    inputs: [\n      {\n        components: [\n          {\n            type: 'bool',\n            name: 'delegateCall'\n          },\n          {\n            type: 'bool',\n            name: 'revertOnError'\n          },\n          {\n            type: 'uint256',\n            name: 'gasLimit'\n          },\n          {\n            type: 'address',\n            name: 'target'\n          },\n          {\n            type: 'uint256',\n            name: 'value'\n          },\n          {\n            type: 'bytes',\n            name: 'data'\n          }\n        ],\n        type: 'tuple[]'\n      },\n      {\n        type: 'uint256'\n      },\n      {\n        type: 'bytes'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  },\n  {\n    type: 'function',\n    name: 'createContract',\n    inputs: [\n      {\n        type: 'bytes'\n      }\n    ],\n    payable: true,\n    stateMutability: 'payable'\n  },\n  {\n    type: 'function',\n    name: 'setExtraImageHash',\n    constant: false,\n    inputs: [\n      {\n        type: 'bytes32',\n        name: 'imageHash'\n      },\n      {\n        type: 'uint256',\n        name: 'expiration'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  }\n]\n","export const abi = [\n  {\n    type: 'function',\n    name: 'updateImageHash',\n    constant: true,\n    inputs: [\n      {\n        type: 'bytes32'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'view'\n  },\n  {\n    type: 'function',\n    name: 'imageHash',\n    constant: true,\n    inputs: [],\n    outputs: [\n      {\n        type: 'bytes32'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  }\n]\n","export const abi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_factory',\n        type: 'address'\n      },\n      {\n        internalType: 'address',\n        name: '_mainModule',\n        type: 'address'\n      }\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: '_imageHash',\n        type: 'bytes32'\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: '_threshold',\n        type: 'uint256'\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: '_signers',\n        type: 'bytes'\n      }\n    ],\n    name: 'RequiredConfig',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_signer',\n        type: 'address'\n      }\n    ],\n    name: 'RequiredSigner',\n    type: 'event'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callBalanceOf',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callBlockNumber',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_i',\n        type: 'uint256'\n      }\n    ],\n    name: 'callBlockhash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callChainId',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'id',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'pure',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callCode',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'code',\n        type: 'bytes'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callCodeHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'codeHash',\n        type: 'bytes32'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callCodeSize',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'size',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callCoinbase',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callDifficulty',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callGasLeft',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callGasLimit',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callGasPrice',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callOrigin',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callTimestamp',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'knownImageHashes',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32'\n      }\n    ],\n    name: 'lastImageHashUpdate',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'lastSignerUpdate',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'lastWalletUpdate',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'bool',\n            name: 'delegateCall',\n            type: 'bool'\n          },\n          {\n            internalType: 'bool',\n            name: 'revertOnError',\n            type: 'bool'\n          },\n          {\n            internalType: 'uint256',\n            name: 'gasLimit',\n            type: 'uint256'\n          },\n          {\n            internalType: 'address',\n            name: 'target',\n            type: 'address'\n          },\n          {\n            internalType: 'uint256',\n            name: 'value',\n            type: 'uint256'\n          },\n          {\n            internalType: 'bytes',\n            name: 'data',\n            type: 'bytes'\n          }\n        ],\n        internalType: 'struct IModuleCalls.Transaction[]',\n        name: '_txs',\n        type: 'tuple[]'\n      }\n    ],\n    name: 'multiCall',\n    outputs: [\n      {\n        internalType: 'bool[]',\n        name: '_successes',\n        type: 'bool[]'\n      },\n      {\n        internalType: 'bytes[]',\n        name: '_results',\n        type: 'bytes[]'\n      }\n    ],\n    stateMutability: 'payable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        internalType: 'uint256',\n        name: '_threshold',\n        type: 'uint256'\n      },\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'weight',\n            type: 'uint256'\n          },\n          {\n            internalType: 'address',\n            name: 'signer',\n            type: 'address'\n          }\n        ],\n        internalType: 'struct RequireUtils.Member[]',\n        name: '_members',\n        type: 'tuple[]'\n      },\n      {\n        internalType: 'bool',\n        name: '_index',\n        type: 'bool'\n      }\n    ],\n    name: 'publishConfig',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        internalType: 'bytes32',\n        name: '_hash',\n        type: 'bytes32'\n      },\n      {\n        internalType: 'uint256',\n        name: '_sizeMembers',\n        type: 'uint256'\n      },\n      {\n        internalType: 'bytes',\n        name: '_signature',\n        type: 'bytes'\n      },\n      {\n        internalType: 'bool',\n        name: '_index',\n        type: 'bool'\n      }\n    ],\n    name: 'publishInitialSigners',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        internalType: 'uint256',\n        name: '_nonce',\n        type: 'uint256'\n      }\n    ],\n    name: 'requireMinNonce',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_expiration',\n        type: 'uint256'\n      }\n    ],\n    name: 'requireNonExpired',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function'\n  }\n]\n","export const abi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'requireFreshSigner',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  }\n]\n","/* eslint-disable */\n// sequence-api v0.4.0 470a0f88ea399c2a57ff8c22da54358c033ed5f0\n// --\n// Code generated by webrpc-gen@v0.18.7 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=api.ridl -target=typescript -client -out=./clients/api.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = 'v1'\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = 'v0.4.0'\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = '470a0f88ea399c2a57ff8c22da54358c033ed5f0'\n\n//\n// Types\n//\n\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport enum SardinePaymentType {\n  ach = 'ach',\n  debit = 'debit',\n  credit = 'credit',\n  us_debit = 'us_debit',\n  international_debit = 'international_debit',\n  international_credit = 'international_credit'\n}\n\nexport enum SardineQuoteType {\n  buy = 'buy',\n  sell = 'sell'\n}\n\nexport enum TokenType {\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  checks: RuntimeChecks\n  numTxnsRelayed: { [key: string]: NumTxnsRelayed }\n}\n\nexport interface NumTxnsRelayed {\n  chainID: number\n  prev: number\n  current: number\n  period: number\n}\n\nexport interface RuntimeChecks {}\n\nexport interface SequenceContext {\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n  utils: string\n}\n\nexport interface User {\n  address: string\n  username: string\n  avatar: string\n  bio: string\n  location: string\n  locale: string\n  backup?: boolean\n  backupConfirmed?: boolean\n  maxInvites?: number\n  updatedAt?: string\n  createdAt?: string\n}\n\nexport interface WalletBackup {\n  accountAddress: string\n  secretHash: string\n  encryptedWallet: string\n  userConfirmed: boolean\n  updatedAt?: string\n  createdAt?: string\n}\n\nexport interface Friend {\n  id: number\n  userAddress: string\n  friendAddress: string\n  nickname: string\n  user?: User\n  createdAt?: string\n}\n\nexport interface InviteCode {\n  usesLeft: number\n  ownerAccount: string\n  email?: string\n  url: string\n  createdAt?: string\n  expiresAt?: string\n}\n\nexport interface InviteCodeAccount {\n  claimedByUserAddress: string\n  claimedAt?: string\n}\n\nexport interface InviteInfo {\n  expiryInHours: number\n  max: number\n  invites: Array<InviteCode>\n}\n\nexport interface ContractCall {\n  signature: string\n  function: string\n  args: Array<TupleComponent>\n}\n\nexport interface TupleComponent {\n  name?: string\n  type: string\n  value: any\n}\n\nexport interface Transaction {\n  delegateCall: boolean\n  revertOnError: boolean\n  gasLimit: string\n  target: string\n  value: string\n  data: string\n  call?: ContractCall\n}\n\nexport interface UserStorage {\n  userAddress: string\n  key: string\n  value: any\n}\n\nexport interface Token {\n  chainId: number\n  contractAddress: string\n  tokenId?: string\n}\n\nexport interface Price {\n  value: number\n  currency: string\n}\n\nexport interface TokenPrice {\n  token: Token\n  price?: Price\n  price24hChange?: Price\n  floorPrice: Price\n  buyPrice: Price\n  sellPrice: Price\n  updatedAt: string\n}\n\nexport interface ExchangeRate {\n  name: string\n  symbol: string\n  value: number\n  vsCurrency: string\n  currencyType: string\n}\n\nexport interface LinkedWallet {\n  id: number\n  walletType?: string\n  walletAddress: string\n  linkedWalletAddress: string\n  createdAt?: string\n}\n\nexport interface Page {\n  pageSize?: number\n  page?: number\n  totalRecords?: number\n  column?: string\n  before?: any\n  after?: any\n  sort?: Array<SortBy>\n  more?: boolean\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface SardineNFTCheckoutParams {\n  name: string\n  imageUrl: string\n  network: string\n  recipientAddress: string\n  blockchainNftId: string\n  contractAddress: string\n  quantity: number\n  decimals?: number\n  tokenAmount: string\n  tokenAddress: string\n  tokenSymbol: string\n  tokenDecimals?: number\n  calldata: string\n  platform: string\n  approvedSpenderAddress?: string\n}\n\nexport interface SardineNFTCheckout {\n  token: string\n  expiresAt: string\n  orderId: string\n}\n\nexport interface SardineOrder {\n  id: string\n  createdAt?: string\n  referenceId: string\n  status: string\n  fiatCurrency: string\n  fiatExchangeRateUSD: number\n  transactionId: string\n  expiresAt?: string\n  total: number\n  subTotal: number\n  transactionFee: number\n  networkFee: number\n  paymentCurrency?: string\n  paymentMethodType?: string\n  transactionType: string\n  name: string\n  price: number\n  imageUrl: string\n  contractAddress?: string\n  transactionHash?: string\n  recipientAddress: string\n}\n\nexport interface SardineRegion {\n  countryCode: string\n  isAllowedOnRamp: boolean\n  isAllowedOnNFT: boolean\n  isBasicKycRequired: Array<string>\n  isSsnRequired: Array<string>\n  name: string\n  currencyCode: string\n  isPayrollSupported: boolean\n  supportedDocuments: Array<string>\n  paymentMethods: Array<SardineRegionPaymentMethod>\n  states: Array<SardineRegionState>\n}\n\nexport interface SardineRegionPaymentMethod {\n  name: string\n  isAllowedOnRamp: boolean\n  isAllowedOnNFT: boolean\n  subTypes: Array<string>\n  type: string\n  subType: string\n}\n\nexport interface SardineRegionState {\n  code: string\n  name: string\n  isAllowedOnRamp: boolean\n  isAllowedOnNFT: boolean\n}\n\nexport interface SardineSupportedToken {\n  network: string\n  assetSymbol: string\n  assetName: string\n  chainId: string\n  tokenName: string\n  token: string\n  tokenAddress: string\n}\n\nexport interface SardineEnabledToken {\n  network: string\n  assetSymbol: string\n  assetName: string\n  chainId: string\n  tokenName: string\n  token: string\n  tokenAddress: string\n}\n\nexport interface SardineGetQuoteParams {\n  assetType: string\n  network: string\n  total: number\n  currency?: string\n  paymentType?: SardinePaymentType\n  quoteType?: SardineQuoteType\n  walletAddress?: string\n}\n\nexport interface SardineQuote {\n  quantity: number\n  network: string\n  assetType: string\n  total: number\n  currency: string\n  expiresAt: string\n  paymentType: string\n  price: number\n  subtotal: number\n  transactionFee: number\n  networkFee: number\n  highNetworkFee: boolean\n  minTransactionValue: number\n  maxTransactionValue: number\n  liquidityProvider: string\n}\n\nexport interface SardineFiatCurrency {\n  currencyCode: string\n  name: string\n  currencySymbol: string\n  paymentOptions: Array<SardinePaymentOption>\n  supportingCountries: Array<string>\n}\n\nexport interface SardinePaymentOption {\n  name: string\n  dailyLimit: number\n  weeklyLimit: number\n  monthlyLimit: number\n  maxAmount: number\n  minAmount: number\n  subTypes: Array<string>\n  type: string\n  subType: string\n  processingTime: string\n}\n\nexport interface SwapPrice {\n  currencyAddress: string\n  currencyBalance: string\n  price: string\n  to: string\n  transactionValue: string\n}\n\nexport interface SwapQuote {\n  currencyAddress: string\n  currencyBalance: string\n  price: string\n  maxPrice: string\n  to: string\n  transactionData: string\n  transactionValue: string\n  approveData: string\n}\n\nexport interface CurrencyGroup {\n  name: string\n  tokens: Array<CurrencyGroupToken>\n}\n\nexport interface CurrencyGroupToken {\n  chainId: number\n  tokenAddress: string\n}\n\nexport interface OffchainInventory {\n  id: number\n  projectId: number\n  chainId: number\n  externalProductId: string\n  paymentTokenAddress: string\n  paymentTokenType: TokenType\n  paymentTokenId: number\n  paymentAmount: number\n  paymentRecipient: string\n  chainedCallAddress?: string\n  chainedCallData?: string\n  allowCrossChainPayments?: boolean\n  callbackURL?: string\n  createdAt: string\n  deletedAt?: string\n}\n\nexport interface OffchainPayment {\n  id: number\n  offchainInventoryId: number\n  productRecipient: string\n  paymentChainId: number\n  paymentTokenAddress: string\n  expiration: string\n  createdAt: string\n  completedAt?: string\n  processedAt?: string\n}\n\nexport interface PaymentResponse {\n  paymentId: number\n  offchainInventoryId: number\n  chainId: number\n  externalProductId: string\n  paymentTokenAddress: string\n  paymentTokenType: TokenType\n  paymentTokenId: number\n  paymentTotal: number\n  expiration: string\n  signature: string\n  txTo: string\n  txData: string\n}\n\nexport interface API {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>\n  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>\n  clock(headers?: object, signal?: AbortSignal): Promise<ClockReturn>\n  getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn>\n  getAuthToken(args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenReturn>\n  getAuthToken2(args: GetAuthToken2Args, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Return>\n  sendPasswordlessLink(\n    args: SendPasswordlessLinkArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SendPasswordlessLinkReturn>\n  friendList(args: FriendListArgs, headers?: object, signal?: AbortSignal): Promise<FriendListReturn>\n  getFriendByAddress(args: GetFriendByAddressArgs, headers?: object, signal?: AbortSignal): Promise<GetFriendByAddressReturn>\n  searchFriends(args: SearchFriendsArgs, headers?: object, signal?: AbortSignal): Promise<SearchFriendsReturn>\n  addFriend(args: AddFriendArgs, headers?: object, signal?: AbortSignal): Promise<AddFriendReturn>\n  updateFriendNickname(\n    args: UpdateFriendNicknameArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateFriendNicknameReturn>\n  removeFriend(args: RemoveFriendArgs, headers?: object, signal?: AbortSignal): Promise<RemoveFriendReturn>\n  contractCall(args: ContractCallArgs, headers?: object, signal?: AbortSignal): Promise<ContractCallReturn>\n  decodeContractCall(args: DecodeContractCallArgs, headers?: object, signal?: AbortSignal): Promise<DecodeContractCallReturn>\n  lookupContractCallSelectors(\n    args: LookupContractCallSelectorsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<LookupContractCallSelectorsReturn>\n  userStorageFetch(args: UserStorageFetchArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchReturn>\n  userStorageSave(args: UserStorageSaveArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveReturn>\n  userStorageDelete(args: UserStorageDeleteArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageDeleteReturn>\n  userStorageFetchAll(args: UserStorageFetchAllArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchAllReturn>\n  getMoonpayLink(args: GetMoonpayLinkArgs, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkReturn>\n  resolveENSAddress(args: ResolveENSAddressArgs, headers?: object, signal?: AbortSignal): Promise<ResolveENSAddressReturn>\n  isValidSignature(args: IsValidSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidSignatureReturn>\n  isValidMessageSignature(\n    args: IsValidMessageSignatureArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<IsValidMessageSignatureReturn>\n  isValidTypedDataSignature(\n    args: IsValidTypedDataSignatureArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<IsValidTypedDataSignatureReturn>\n  isValidETHAuthProof(args: IsValidETHAuthProofArgs, headers?: object, signal?: AbortSignal): Promise<IsValidETHAuthProofReturn>\n  sardineGetClientToken(headers?: object, signal?: AbortSignal): Promise<SardineGetClientTokenReturn>\n  sardineGetNFTCheckoutToken(\n    args: SardineGetNFTCheckoutTokenArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SardineGetNFTCheckoutTokenReturn>\n  sardineGetNFTCheckoutOrderStatus(\n    args: SardineGetNFTCheckoutOrderStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SardineGetNFTCheckoutOrderStatusReturn>\n  sardineGetSupportedRegions(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedRegionsReturn>\n  sardineGetSupportedFiatCurrencies(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedFiatCurrenciesReturn>\n  sardineGetSupportedTokens(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedTokensReturn>\n  sardineGetEnabledTokens(headers?: object, signal?: AbortSignal): Promise<SardineGetEnabledTokensReturn>\n  sardineGetQuote(args: SardineGetQuoteArgs, headers?: object, signal?: AbortSignal): Promise<SardineGetQuoteReturn>\n  getSardineClientToken(headers?: object, signal?: AbortSignal): Promise<GetSardineClientTokenReturn>\n  getSardineNFTCheckoutToken(\n    args: GetSardineNFTCheckoutTokenArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetSardineNFTCheckoutTokenReturn>\n  getSardineNFTCheckoutOrderStatus(\n    args: GetSardineNFTCheckoutOrderStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetSardineNFTCheckoutOrderStatusReturn>\n  getCoinPrices(args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesReturn>\n  getCollectiblePrices(\n    args: GetCollectiblePricesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetCollectiblePricesReturn>\n  getExchangeRate(args: GetExchangeRateArgs, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateReturn>\n  memoryStore(args: MemoryStoreArgs, headers?: object, signal?: AbortSignal): Promise<MemoryStoreReturn>\n  memoryLoad(args: MemoryLoadArgs, headers?: object, signal?: AbortSignal): Promise<MemoryLoadReturn>\n  getInviteInfo(headers?: object, signal?: AbortSignal): Promise<GetInviteInfoReturn>\n  isValidAccessCode(args: IsValidAccessCodeArgs, headers?: object, signal?: AbortSignal): Promise<IsValidAccessCodeReturn>\n  internalClaimAccessCode(\n    args: InternalClaimAccessCodeArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<InternalClaimAccessCodeReturn>\n  blockNumberAtTime(args: BlockNumberAtTimeArgs, headers?: object, signal?: AbortSignal): Promise<BlockNumberAtTimeReturn>\n  paperSessionSecret(args: PaperSessionSecretArgs, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecretReturn>\n  paperSessionSecret2(args: PaperSessionSecret2Args, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecret2Return>\n  linkWallet(args: LinkWalletArgs, headers?: object, signal?: AbortSignal): Promise<LinkWalletReturn>\n  getLinkedWallets(args: GetLinkedWalletsArgs, headers?: object, signal?: AbortSignal): Promise<GetLinkedWalletsReturn>\n  removeLinkedWallet(args: RemoveLinkedWalletArgs, headers?: object, signal?: AbortSignal): Promise<RemoveLinkedWalletReturn>\n  generateWaaSVerificationURL(\n    args: GenerateWaaSVerificationURLArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GenerateWaaSVerificationURLReturn>\n  validateWaaSVerificationNonce(\n    args: ValidateWaaSVerificationNonceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ValidateWaaSVerificationNonceReturn>\n  getSwapPrices(args: GetSwapPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapPricesReturn>\n  getSwapQuote(args: GetSwapQuoteArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapQuoteReturn>\n  listCurrencyGroups(headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsReturn>\n  addOffchainInventory(\n    args: AddOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddOffchainInventoryReturn>\n  getOffchainInventory(\n    args: GetOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetOffchainInventoryReturn>\n  listOffchainInventories(\n    args: ListOffchainInventoriesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListOffchainInventoriesReturn>\n  updateOffchainInventory(\n    args: UpdateOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateOffchainInventoryReturn>\n  deleteOffchainInventory(\n    args: DeleteOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DeleteOffchainInventoryReturn>\n  requestOffchainPayment(\n    args: RequestOffchainPaymentArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RequestOffchainPaymentReturn>\n  listOffchainPayments(\n    args: ListOffchainPaymentsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListOffchainPaymentsReturn>\n}\n\nexport interface PingArgs {}\n\nexport interface PingReturn {\n  status: boolean\n}\nexport interface VersionArgs {}\n\nexport interface VersionReturn {\n  version: Version\n}\nexport interface RuntimeStatusArgs {}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus\n}\nexport interface ClockArgs {}\n\nexport interface ClockReturn {\n  serverTime: string\n}\nexport interface GetSequenceContextArgs {}\n\nexport interface GetSequenceContextReturn {\n  data: SequenceContext\n}\nexport interface GetAuthTokenArgs {\n  ewtString: string\n  testnetMode?: boolean\n}\n\nexport interface GetAuthTokenReturn {\n  status: boolean\n  jwtToken: string\n  address: string\n  user?: User\n}\nexport interface GetAuthToken2Args {\n  ewtString: string\n  chainID: string\n}\n\nexport interface GetAuthToken2Return {\n  status: boolean\n  jwtToken: string\n  address: string\n  user?: User\n}\nexport interface SendPasswordlessLinkArgs {\n  email: string\n  redirectUri: string\n  intent: string\n}\n\nexport interface SendPasswordlessLinkReturn {\n  status: boolean\n}\nexport interface FriendListArgs {\n  nickname?: string\n  page?: Page\n}\n\nexport interface FriendListReturn {\n  page: Page\n  friends: Array<Friend>\n}\nexport interface GetFriendByAddressArgs {\n  friendAddress: string\n}\n\nexport interface GetFriendByAddressReturn {\n  status: boolean\n  friend: Friend\n}\nexport interface SearchFriendsArgs {\n  filterUsername: string\n  page?: Page\n}\n\nexport interface SearchFriendsReturn {\n  friends: Array<Friend>\n}\nexport interface AddFriendArgs {\n  friendAddress: string\n  optionalNickname?: string\n}\n\nexport interface AddFriendReturn {\n  status: boolean\n  friend?: Friend\n}\nexport interface UpdateFriendNicknameArgs {\n  friendAddress: string\n  nickname: string\n}\n\nexport interface UpdateFriendNicknameReturn {\n  status: boolean\n  friend?: Friend\n}\nexport interface RemoveFriendArgs {\n  friendAddress: string\n}\n\nexport interface RemoveFriendReturn {\n  status: boolean\n}\nexport interface ContractCallArgs {\n  chainID: string\n  contract: string\n  inputExpr: string\n  outputExpr: string\n  args: Array<string>\n}\n\nexport interface ContractCallReturn {\n  returns: Array<string>\n}\nexport interface DecodeContractCallArgs {\n  callData: string\n}\n\nexport interface DecodeContractCallReturn {\n  call: ContractCall\n}\nexport interface LookupContractCallSelectorsArgs {\n  selectors: Array<string>\n}\n\nexport interface LookupContractCallSelectorsReturn {\n  signatures: Array<Array<string>>\n}\nexport interface UserStorageFetchArgs {\n  key: string\n}\n\nexport interface UserStorageFetchReturn {\n  object: any\n}\nexport interface UserStorageSaveArgs {\n  key: string\n  object: any\n}\n\nexport interface UserStorageSaveReturn {\n  ok: boolean\n}\nexport interface UserStorageDeleteArgs {\n  key: string\n}\n\nexport interface UserStorageDeleteReturn {\n  ok: boolean\n}\nexport interface UserStorageFetchAllArgs {\n  keys?: Array<string>\n}\n\nexport interface UserStorageFetchAllReturn {\n  objects: { [key: string]: any }\n}\nexport interface GetMoonpayLinkArgs {\n  url: string\n}\n\nexport interface GetMoonpayLinkReturn {\n  signedUrl: string\n}\nexport interface ResolveENSAddressArgs {\n  ens: string\n}\n\nexport interface ResolveENSAddressReturn {\n  address: string\n  ok: boolean\n}\nexport interface IsValidSignatureArgs {\n  chainId: string\n  walletAddress: string\n  digest: string\n  signature: string\n}\n\nexport interface IsValidSignatureReturn {\n  isValid: boolean\n}\nexport interface IsValidMessageSignatureArgs {\n  chainId: string\n  walletAddress: string\n  message: string\n  signature: string\n}\n\nexport interface IsValidMessageSignatureReturn {\n  isValid: boolean\n}\nexport interface IsValidTypedDataSignatureArgs {\n  chainId: string\n  walletAddress: string\n  typedData: any\n  signature: string\n}\n\nexport interface IsValidTypedDataSignatureReturn {\n  isValid: boolean\n}\nexport interface IsValidETHAuthProofArgs {\n  chainId: string\n  walletAddress: string\n  ethAuthProofString: string\n}\n\nexport interface IsValidETHAuthProofReturn {\n  isValid: boolean\n}\nexport interface SardineGetClientTokenArgs {}\n\nexport interface SardineGetClientTokenReturn {\n  token: string\n}\nexport interface SardineGetNFTCheckoutTokenArgs {\n  params: SardineNFTCheckoutParams\n}\n\nexport interface SardineGetNFTCheckoutTokenReturn {\n  resp: SardineNFTCheckout\n}\nexport interface SardineGetNFTCheckoutOrderStatusArgs {\n  orderId: string\n}\n\nexport interface SardineGetNFTCheckoutOrderStatusReturn {\n  resp: SardineOrder\n}\nexport interface SardineGetSupportedRegionsArgs {}\n\nexport interface SardineGetSupportedRegionsReturn {\n  regions: Array<SardineRegion>\n}\nexport interface SardineGetSupportedFiatCurrenciesArgs {}\n\nexport interface SardineGetSupportedFiatCurrenciesReturn {\n  tokens: Array<SardineFiatCurrency>\n}\nexport interface SardineGetSupportedTokensArgs {}\n\nexport interface SardineGetSupportedTokensReturn {\n  tokens: Array<SardineSupportedToken>\n}\nexport interface SardineGetEnabledTokensArgs {}\n\nexport interface SardineGetEnabledTokensReturn {\n  tokens: Array<SardineEnabledToken>\n}\nexport interface SardineGetQuoteArgs {\n  params: SardineGetQuoteParams\n}\n\nexport interface SardineGetQuoteReturn {\n  quote: SardineQuote\n}\nexport interface GetSardineClientTokenArgs {}\n\nexport interface GetSardineClientTokenReturn {\n  token: string\n}\nexport interface GetSardineNFTCheckoutTokenArgs {\n  params: SardineNFTCheckoutParams\n}\n\nexport interface GetSardineNFTCheckoutTokenReturn {\n  resp: SardineNFTCheckout\n}\nexport interface GetSardineNFTCheckoutOrderStatusArgs {\n  orderId: string\n}\n\nexport interface GetSardineNFTCheckoutOrderStatusReturn {\n  resp: SardineOrder\n}\nexport interface GetCoinPricesArgs {\n  tokens: Array<Token>\n}\n\nexport interface GetCoinPricesReturn {\n  tokenPrices: Array<TokenPrice>\n}\nexport interface GetCollectiblePricesArgs {\n  tokens: Array<Token>\n}\n\nexport interface GetCollectiblePricesReturn {\n  tokenPrices: Array<TokenPrice>\n}\nexport interface GetExchangeRateArgs {\n  toCurrency: string\n}\n\nexport interface GetExchangeRateReturn {\n  exchangeRate: ExchangeRate\n}\nexport interface MemoryStoreArgs {\n  key: string\n  value: string\n}\n\nexport interface MemoryStoreReturn {\n  ok: boolean\n}\nexport interface MemoryLoadArgs {\n  key: string\n}\n\nexport interface MemoryLoadReturn {\n  value: string\n}\nexport interface GetInviteInfoArgs {}\n\nexport interface GetInviteInfoReturn {\n  inviteInfo: InviteInfo\n}\nexport interface IsValidAccessCodeArgs {\n  accessCode: string\n}\n\nexport interface IsValidAccessCodeReturn {\n  status: boolean\n}\nexport interface InternalClaimAccessCodeArgs {\n  address: string\n  accessCode: string\n}\n\nexport interface InternalClaimAccessCodeReturn {\n  status: boolean\n}\nexport interface BlockNumberAtTimeArgs {\n  chainId: number\n  timestamps: Array<number>\n}\n\nexport interface BlockNumberAtTimeReturn {\n  blocks: Array<number>\n}\nexport interface PaperSessionSecretArgs {\n  chainName: string\n  contractAddress: string\n  paramsJson: string\n  contractType: string\n}\n\nexport interface PaperSessionSecretReturn {\n  secret: string\n}\nexport interface PaperSessionSecret2Args {\n  chainName: string\n  contractAddress: string\n  paramsJson: string\n  abi: string\n}\n\nexport interface PaperSessionSecret2Return {\n  secret: string\n}\nexport interface LinkWalletArgs {\n  parentWalletAddress: string\n  parentWalletMessage: string\n  parentWalletSignature: string\n  linkedWalletAddress: string\n  linkedWalletMessage: string\n  linkedWalletSignature: string\n  signatureChainId: string\n  linkedWalletType?: string\n}\n\nexport interface LinkWalletReturn {\n  status: boolean\n}\nexport interface GetLinkedWalletsArgs {\n  parentWalletAddress: string\n  parentWalletMessage: string\n  parentWalletSignature: string\n  signatureChainId: string\n}\n\nexport interface GetLinkedWalletsReturn {\n  linkedWallets: Array<LinkedWallet>\n}\nexport interface RemoveLinkedWalletArgs {\n  parentWalletAddress: string\n  parentWalletMessage: string\n  parentWalletSignature: string\n  linkedWalletAddress: string\n  linkedWalletMessage: string\n  linkedWalletSignature: string\n  signatureChainId: string\n}\n\nexport interface RemoveLinkedWalletReturn {\n  status: boolean\n}\nexport interface GenerateWaaSVerificationURLArgs {\n  walletAddress: string\n}\n\nexport interface GenerateWaaSVerificationURLReturn {\n  nonce: string\n  verificationURL: string\n}\nexport interface ValidateWaaSVerificationNonceArgs {\n  nonce: string\n  signature: string\n  sessionId: string\n  chainId: string\n}\n\nexport interface ValidateWaaSVerificationNonceReturn {\n  walletAddress: string\n}\nexport interface GetSwapPricesArgs {\n  userAddress: string\n  buyCurrencyAddress: string\n  buyAmount: string\n  chainId: number\n}\n\nexport interface GetSwapPricesReturn {\n  swapPrices: Array<SwapPrice>\n}\nexport interface GetSwapQuoteArgs {\n  userAddress: string\n  buyCurrencyAddress: string\n  sellCurrencyAddress: string\n  buyAmount: string\n  chainId: number\n  includeApprove: boolean\n}\n\nexport interface GetSwapQuoteReturn {\n  swapQuote: SwapQuote\n}\nexport interface ListCurrencyGroupsArgs {}\n\nexport interface ListCurrencyGroupsReturn {\n  currencyGroups: Array<CurrencyGroup>\n}\nexport interface AddOffchainInventoryArgs {\n  inventory: OffchainInventory\n}\n\nexport interface AddOffchainInventoryReturn {\n  inventoryId: number\n}\nexport interface GetOffchainInventoryArgs {\n  inventoryId: number\n}\n\nexport interface GetOffchainInventoryReturn {\n  inventory: OffchainInventory\n}\nexport interface ListOffchainInventoriesArgs {\n  projectId: number\n}\n\nexport interface ListOffchainInventoriesReturn {\n  inventory: Array<OffchainInventory>\n}\nexport interface UpdateOffchainInventoryArgs {\n  inventory: OffchainInventory\n}\n\nexport interface UpdateOffchainInventoryReturn {}\nexport interface DeleteOffchainInventoryArgs {\n  inventoryId: number\n}\n\nexport interface DeleteOffchainInventoryReturn {\n  ok: boolean\n}\nexport interface RequestOffchainPaymentArgs {\n  inventoryId: number\n  recipient: string\n  chainId?: number\n  tokenAddress?: string\n}\n\nexport interface RequestOffchainPaymentReturn {\n  payment: PaymentResponse\n}\nexport interface ListOffchainPaymentsArgs {\n  inventoryId: number\n  page?: Page\n}\n\nexport interface ListOffchainPaymentsReturn {\n  page: Page\n  payments: Array<OffchainPayment>\n}\n\n//\n// Client\n//\nexport class API implements API {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/API/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {\n    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: <Version>_data.version\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {\n    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <RuntimeStatus>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  clock = (headers?: object, signal?: AbortSignal): Promise<ClockReturn> => {\n    return this.fetch(this.url('Clock'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            serverTime: <string>_data.serverTime\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSequenceContext = (headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn> => {\n    return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            data: <SequenceContext>_data.data\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getAuthToken = (args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenReturn> => {\n    return this.fetch(this.url('GetAuthToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            jwtToken: <string>_data.jwtToken,\n            address: <string>_data.address,\n            user: <User>_data.user\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getAuthToken2 = (args: GetAuthToken2Args, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Return> => {\n    return this.fetch(this.url('GetAuthToken2'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            jwtToken: <string>_data.jwtToken,\n            address: <string>_data.address,\n            user: <User>_data.user\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sendPasswordlessLink = (\n    args: SendPasswordlessLinkArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SendPasswordlessLinkReturn> => {\n    return this.fetch(this.url('SendPasswordlessLink'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  friendList = (args: FriendListArgs, headers?: object, signal?: AbortSignal): Promise<FriendListReturn> => {\n    return this.fetch(this.url('FriendList'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            friends: <Array<Friend>>_data.friends\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getFriendByAddress = (\n    args: GetFriendByAddressArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetFriendByAddressReturn> => {\n    return this.fetch(this.url('GetFriendByAddress'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            friend: <Friend>_data.friend\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchFriends = (args: SearchFriendsArgs, headers?: object, signal?: AbortSignal): Promise<SearchFriendsReturn> => {\n    return this.fetch(this.url('SearchFriends'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            friends: <Array<Friend>>_data.friends\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addFriend = (args: AddFriendArgs, headers?: object, signal?: AbortSignal): Promise<AddFriendReturn> => {\n    return this.fetch(this.url('AddFriend'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            friend: <Friend>_data.friend\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateFriendNickname = (\n    args: UpdateFriendNicknameArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateFriendNicknameReturn> => {\n    return this.fetch(this.url('UpdateFriendNickname'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            friend: <Friend>_data.friend\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  removeFriend = (args: RemoveFriendArgs, headers?: object, signal?: AbortSignal): Promise<RemoveFriendReturn> => {\n    return this.fetch(this.url('RemoveFriend'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  contractCall = (args: ContractCallArgs, headers?: object, signal?: AbortSignal): Promise<ContractCallReturn> => {\n    return this.fetch(this.url('ContractCall'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            returns: <Array<string>>_data.returns\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  decodeContractCall = (\n    args: DecodeContractCallArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DecodeContractCallReturn> => {\n    return this.fetch(this.url('DecodeContractCall'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            call: <ContractCall>_data.call\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  lookupContractCallSelectors = (\n    args: LookupContractCallSelectorsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<LookupContractCallSelectorsReturn> => {\n    return this.fetch(this.url('LookupContractCallSelectors'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            signatures: <Array<Array<string>>>_data.signatures\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  userStorageFetch = (args: UserStorageFetchArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchReturn> => {\n    return this.fetch(this.url('UserStorageFetch'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            object: <any>_data.object\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  userStorageSave = (args: UserStorageSaveArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveReturn> => {\n    return this.fetch(this.url('UserStorageSave'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  userStorageDelete = (args: UserStorageDeleteArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageDeleteReturn> => {\n    return this.fetch(this.url('UserStorageDelete'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  userStorageFetchAll = (\n    args: UserStorageFetchAllArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UserStorageFetchAllReturn> => {\n    return this.fetch(this.url('UserStorageFetchAll'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            objects: <{ [key: string]: any }>_data.objects\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getMoonpayLink = (args: GetMoonpayLinkArgs, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkReturn> => {\n    return this.fetch(this.url('GetMoonpayLink'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            signedUrl: <string>_data.signedUrl\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  resolveENSAddress = (args: ResolveENSAddressArgs, headers?: object, signal?: AbortSignal): Promise<ResolveENSAddressReturn> => {\n    return this.fetch(this.url('ResolveENSAddress'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            address: <string>_data.address,\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  isValidSignature = (args: IsValidSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidSignatureReturn> => {\n    return this.fetch(this.url('IsValidSignature'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: <boolean>_data.isValid\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  isValidMessageSignature = (\n    args: IsValidMessageSignatureArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<IsValidMessageSignatureReturn> => {\n    return this.fetch(this.url('IsValidMessageSignature'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: <boolean>_data.isValid\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  isValidTypedDataSignature = (\n    args: IsValidTypedDataSignatureArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<IsValidTypedDataSignatureReturn> => {\n    return this.fetch(this.url('IsValidTypedDataSignature'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: <boolean>_data.isValid\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  isValidETHAuthProof = (\n    args: IsValidETHAuthProofArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<IsValidETHAuthProofReturn> => {\n    return this.fetch(this.url('IsValidETHAuthProof'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: <boolean>_data.isValid\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetClientToken = (headers?: object, signal?: AbortSignal): Promise<SardineGetClientTokenReturn> => {\n    return this.fetch(this.url('SardineGetClientToken'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            token: <string>_data.token\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetNFTCheckoutToken = (\n    args: SardineGetNFTCheckoutTokenArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SardineGetNFTCheckoutTokenReturn> => {\n    return this.fetch(this.url('SardineGetNFTCheckoutToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            resp: <SardineNFTCheckout>_data.resp\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetNFTCheckoutOrderStatus = (\n    args: SardineGetNFTCheckoutOrderStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SardineGetNFTCheckoutOrderStatusReturn> => {\n    return this.fetch(this.url('SardineGetNFTCheckoutOrderStatus'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            resp: <SardineOrder>_data.resp\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetSupportedRegions = (headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedRegionsReturn> => {\n    return this.fetch(this.url('SardineGetSupportedRegions'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            regions: <Array<SardineRegion>>_data.regions\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetSupportedFiatCurrencies = (\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SardineGetSupportedFiatCurrenciesReturn> => {\n    return this.fetch(this.url('SardineGetSupportedFiatCurrencies'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokens: <Array<SardineFiatCurrency>>_data.tokens\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetSupportedTokens = (headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedTokensReturn> => {\n    return this.fetch(this.url('SardineGetSupportedTokens'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokens: <Array<SardineSupportedToken>>_data.tokens\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetEnabledTokens = (headers?: object, signal?: AbortSignal): Promise<SardineGetEnabledTokensReturn> => {\n    return this.fetch(this.url('SardineGetEnabledTokens'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokens: <Array<SardineEnabledToken>>_data.tokens\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sardineGetQuote = (args: SardineGetQuoteArgs, headers?: object, signal?: AbortSignal): Promise<SardineGetQuoteReturn> => {\n    return this.fetch(this.url('SardineGetQuote'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            quote: <SardineQuote>_data.quote\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSardineClientToken = (headers?: object, signal?: AbortSignal): Promise<GetSardineClientTokenReturn> => {\n    return this.fetch(this.url('GetSardineClientToken'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            token: <string>_data.token\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSardineNFTCheckoutToken = (\n    args: GetSardineNFTCheckoutTokenArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetSardineNFTCheckoutTokenReturn> => {\n    return this.fetch(this.url('GetSardineNFTCheckoutToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            resp: <SardineNFTCheckout>_data.resp\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSardineNFTCheckoutOrderStatus = (\n    args: GetSardineNFTCheckoutOrderStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetSardineNFTCheckoutOrderStatusReturn> => {\n    return this.fetch(this.url('GetSardineNFTCheckoutOrderStatus'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            resp: <SardineOrder>_data.resp\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getCoinPrices = (args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesReturn> => {\n    return this.fetch(this.url('GetCoinPrices'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenPrices: <Array<TokenPrice>>_data.tokenPrices\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getCollectiblePrices = (\n    args: GetCollectiblePricesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetCollectiblePricesReturn> => {\n    return this.fetch(this.url('GetCollectiblePrices'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenPrices: <Array<TokenPrice>>_data.tokenPrices\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getExchangeRate = (args: GetExchangeRateArgs, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateReturn> => {\n    return this.fetch(this.url('GetExchangeRate'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            exchangeRate: <ExchangeRate>_data.exchangeRate\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  memoryStore = (args: MemoryStoreArgs, headers?: object, signal?: AbortSignal): Promise<MemoryStoreReturn> => {\n    return this.fetch(this.url('MemoryStore'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  memoryLoad = (args: MemoryLoadArgs, headers?: object, signal?: AbortSignal): Promise<MemoryLoadReturn> => {\n    return this.fetch(this.url('MemoryLoad'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            value: <string>_data.value\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getInviteInfo = (headers?: object, signal?: AbortSignal): Promise<GetInviteInfoReturn> => {\n    return this.fetch(this.url('GetInviteInfo'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            inviteInfo: <InviteInfo>_data.inviteInfo\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  isValidAccessCode = (args: IsValidAccessCodeArgs, headers?: object, signal?: AbortSignal): Promise<IsValidAccessCodeReturn> => {\n    return this.fetch(this.url('IsValidAccessCode'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  internalClaimAccessCode = (\n    args: InternalClaimAccessCodeArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<InternalClaimAccessCodeReturn> => {\n    return this.fetch(this.url('InternalClaimAccessCode'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  blockNumberAtTime = (args: BlockNumberAtTimeArgs, headers?: object, signal?: AbortSignal): Promise<BlockNumberAtTimeReturn> => {\n    return this.fetch(this.url('BlockNumberAtTime'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            blocks: <Array<number>>_data.blocks\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  paperSessionSecret = (\n    args: PaperSessionSecretArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<PaperSessionSecretReturn> => {\n    return this.fetch(this.url('PaperSessionSecret'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            secret: <string>_data.secret\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  paperSessionSecret2 = (\n    args: PaperSessionSecret2Args,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<PaperSessionSecret2Return> => {\n    return this.fetch(this.url('PaperSessionSecret2'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            secret: <string>_data.secret\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  linkWallet = (args: LinkWalletArgs, headers?: object, signal?: AbortSignal): Promise<LinkWalletReturn> => {\n    return this.fetch(this.url('LinkWallet'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getLinkedWallets = (args: GetLinkedWalletsArgs, headers?: object, signal?: AbortSignal): Promise<GetLinkedWalletsReturn> => {\n    return this.fetch(this.url('GetLinkedWallets'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            linkedWallets: <Array<LinkedWallet>>_data.linkedWallets\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  removeLinkedWallet = (\n    args: RemoveLinkedWalletArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveLinkedWalletReturn> => {\n    return this.fetch(this.url('RemoveLinkedWallet'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  generateWaaSVerificationURL = (\n    args: GenerateWaaSVerificationURLArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GenerateWaaSVerificationURLReturn> => {\n    return this.fetch(this.url('GenerateWaaSVerificationURL'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            nonce: <string>_data.nonce,\n            verificationURL: <string>_data.verificationURL\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  validateWaaSVerificationNonce = (\n    args: ValidateWaaSVerificationNonceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ValidateWaaSVerificationNonceReturn> => {\n    return this.fetch(this.url('ValidateWaaSVerificationNonce'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            walletAddress: <string>_data.walletAddress\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSwapPrices = (args: GetSwapPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapPricesReturn> => {\n    return this.fetch(this.url('GetSwapPrices'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            swapPrices: <Array<SwapPrice>>_data.swapPrices\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSwapQuote = (args: GetSwapQuoteArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapQuoteReturn> => {\n    return this.fetch(this.url('GetSwapQuote'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            swapQuote: <SwapQuote>_data.swapQuote\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listCurrencyGroups = (headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsReturn> => {\n    return this.fetch(this.url('ListCurrencyGroups'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            currencyGroups: <Array<CurrencyGroup>>_data.currencyGroups\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addOffchainInventory = (\n    args: AddOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddOffchainInventoryReturn> => {\n    return this.fetch(this.url('AddOffchainInventory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            inventoryId: <number>_data.inventoryId\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getOffchainInventory = (\n    args: GetOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetOffchainInventoryReturn> => {\n    return this.fetch(this.url('GetOffchainInventory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            inventory: <OffchainInventory>_data.inventory\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listOffchainInventories = (\n    args: ListOffchainInventoriesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListOffchainInventoriesReturn> => {\n    return this.fetch(this.url('ListOffchainInventories'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            inventory: <Array<OffchainInventory>>_data.inventory\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateOffchainInventory = (\n    args: UpdateOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateOffchainInventoryReturn> => {\n    return this.fetch(this.url('UpdateOffchainInventory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  deleteOffchainInventory = (\n    args: DeleteOffchainInventoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DeleteOffchainInventoryReturn> => {\n    return this.fetch(this.url('DeleteOffchainInventory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  requestOffchainPayment = (\n    args: RequestOffchainPaymentArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RequestOffchainPaymentReturn> => {\n    return this.fetch(this.url('RequestOffchainPayment'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            payment: <PaymentResponse>_data.payment\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listOffchainPayments = (\n    args: ListOffchainPaymentsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListOffchainPaymentsReturn> => {\n    return this.fetch(this.url('ListOffchainPayments'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            payments: <Array<OffchainPayment>>_data.payments\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`\n      })\n    }\n    if (!res.ok) {\n      const code: number = typeof data.code === 'number' ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n// Schema errors\n\nexport class UnauthorizedError extends WebrpcError {\n  constructor(\n    name: string = 'Unauthorized',\n    code: number = 1000,\n    message: string = 'Unauthorized access',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnauthorizedError.prototype)\n  }\n}\n\nexport class PermissionDeniedError extends WebrpcError {\n  constructor(\n    name: string = 'PermissionDenied',\n    code: number = 1001,\n    message: string = 'Permission denied',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, PermissionDeniedError.prototype)\n  }\n}\n\nexport class SessionExpiredError extends WebrpcError {\n  constructor(\n    name: string = 'SessionExpired',\n    code: number = 1002,\n    message: string = 'Session expired',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, SessionExpiredError.prototype)\n  }\n}\n\nexport class AbortedError extends WebrpcError {\n  constructor(\n    name: string = 'Aborted',\n    code: number = 1005,\n    message: string = 'Request aborted',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, AbortedError.prototype)\n  }\n}\n\nexport class GeoblockedError extends WebrpcError {\n  constructor(\n    name: string = 'Geoblocked',\n    code: number = 1006,\n    message: string = 'Geoblocked region',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, GeoblockedError.prototype)\n  }\n}\n\nexport class InvalidArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidArgument',\n    code: number = 2000,\n    message: string = 'Invalid argument',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidArgumentError.prototype)\n  }\n}\n\nexport class UnavailableError extends WebrpcError {\n  constructor(\n    name: string = 'Unavailable',\n    code: number = 2002,\n    message: string = 'Unavailable resource',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnavailableError.prototype)\n  }\n}\n\nexport class QueryFailedError extends WebrpcError {\n  constructor(\n    name: string = 'QueryFailed',\n    code: number = 2003,\n    message: string = 'Query failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, QueryFailedError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'NotFound',\n    code: number = 3000,\n    message: string = 'Resource not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  Unauthorized = 'Unauthorized',\n  PermissionDenied = 'PermissionDenied',\n  SessionExpired = 'SessionExpired',\n  Aborted = 'Aborted',\n  Geoblocked = 'Geoblocked',\n  InvalidArgument = 'InvalidArgument',\n  Unavailable = 'Unavailable',\n  QueryFailed = 'QueryFailed',\n  NotFound = 'NotFound'\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1000]: UnauthorizedError,\n  [1001]: PermissionDeniedError,\n  [1002]: SessionExpiredError,\n  [1005]: AbortedError,\n  [1006]: GeoblockedError,\n  [2000]: InvalidArgumentError,\n  [2002]: UnavailableError,\n  [2003]: QueryFailedError,\n  [3000]: NotFoundError\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","export * from './api.gen'\n\nimport { API as ApiRpc } from './api.gen'\n\nconst fetch = globalThis.fetch\n\nexport class SequenceAPIClient extends ApiRpc {\n  constructor(\n    hostname: string,\n    public projectAccessKey?: string,\n    public jwtAuth?: string\n  ) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt and access key auth header to requests\n    // if its been set on the api client\n    const headers: { [key: string]: any } = {}\n\n    const jwtAuth = this.jwtAuth\n    const projectAccessKey = this.projectAccessKey\n\n    if (jwtAuth && jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${jwtAuth}`\n    }\n\n    if (projectAccessKey && projectAccessKey.length > 0) {\n      headers['X-Access-Key'] = projectAccessKey\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n}\n","/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.7';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n","import { ethers } from 'ethers';\nimport { Base64 } from 'js-base64';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar encodeTypedDataHash = function (typedData) {\r\n    return ethers.TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message);\r\n};\r\nvar encodeTypedDataDigest = function (typedData) {\r\n    var hash = encodeTypedDataHash(typedData);\r\n    var digest = ethers.getBytes(ethers.keccak256(hash));\r\n    return digest;\r\n};\n\nvar ETHAuthVersion = '1';\r\nvar ETHAuthPrefix = 'eth';\r\nvar ETHAuthEIP712Domain = {\r\n    name: 'ETHAuth',\r\n    version: ETHAuthVersion\r\n};\r\nvar Proof = /** @class */ (function () {\r\n    function Proof(args) {\r\n        this.prefix = ETHAuthPrefix;\r\n        this.address = (args === null || args === void 0 ? void 0 : args.address) ? args.address.toLowerCase() : '';\r\n        this.claims = (args === null || args === void 0 ? void 0 : args.claims) ? args.claims : { app: '', iat: 0, exp: 0, v: ETHAuthVersion };\r\n        this.signature = (args === null || args === void 0 ? void 0 : args.signature) ? args.signature : '';\r\n        this.extra = (args === null || args === void 0 ? void 0 : args.extra) ? args.extra : '';\r\n    }\r\n    Proof.prototype.setIssuedAtNow = function () {\r\n        this.claims.iat = Math.round(new Date().getTime() / 1000);\r\n    };\r\n    Proof.prototype.setExpiryIn = function (seconds) {\r\n        this.claims.exp = Math.round(new Date().getTime() / 1000) + seconds;\r\n    };\r\n    Proof.prototype.validateClaims = function () {\r\n        return validateClaims(this.claims);\r\n    };\r\n    Proof.prototype.messageDigest = function () {\r\n        var isValid = this.validateClaims();\r\n        if (isValid.err) {\r\n            throw isValid.err;\r\n        }\r\n        return ethers.getBytes(encodeTypedDataHash(this.messageTypedData()));\r\n    };\r\n    Proof.prototype.messageTypedData = function () {\r\n        var domain = __assign({}, ETHAuthEIP712Domain);\r\n        var types = {\r\n            Claims: []\r\n        };\r\n        var message = {};\r\n        var typedData = { domain: domain, types: types, message: message };\r\n        if (this.claims.app && this.claims.app.length > 0) {\r\n            typedData.types.Claims.push({ name: 'app', type: 'string' });\r\n            typedData.message['app'] = this.claims.app;\r\n        }\r\n        if (this.claims.iat && this.claims.iat > 0) {\r\n            typedData.types.Claims.push({ name: 'iat', type: 'int64' });\r\n            typedData.message['iat'] = this.claims.iat;\r\n        }\r\n        if (this.claims.exp && this.claims.exp > 0) {\r\n            typedData.types.Claims.push({ name: 'exp', type: 'int64' });\r\n            typedData.message['exp'] = this.claims.exp;\r\n        }\r\n        if (this.claims.n && this.claims.n > 0) {\r\n            typedData.types.Claims.push({ name: 'n', type: 'uint64' });\r\n            typedData.message['n'] = this.claims.n;\r\n        }\r\n        if (this.claims.typ && this.claims.typ.length > 0) {\r\n            typedData.types.Claims.push({ name: 'typ', type: 'string' });\r\n            typedData.message['typ'] = this.claims.typ;\r\n        }\r\n        if (this.claims.ogn && this.claims.ogn.length > 0) {\r\n            typedData.types.Claims.push({ name: 'ogn', type: 'string' });\r\n            typedData.message['ogn'] = this.claims.ogn;\r\n        }\r\n        if (this.claims.v && this.claims.v.length > 0) {\r\n            typedData.types.Claims.push({ name: 'v', type: 'string' });\r\n            typedData.message['v'] = this.claims.v;\r\n        }\r\n        return typedData;\r\n    };\r\n    return Proof;\r\n}());\r\nvar validateClaims = function (claims) {\r\n    if (claims.app === '') {\r\n        return { ok: false, err: new Error('claims: app is empty') };\r\n    }\r\n    var now = Math.round(new Date().getTime() / 1000);\r\n    var drift = 5 * 60; // 5 minutes\r\n    var max = 60 * 60 * 24 * 365 + drift; // 1 year\r\n    if (claims.v === '') {\r\n        return { ok: false, err: new Error('claims: ethauth version is empty') };\r\n    }\r\n    if (claims.iat && claims.iat !== 0 && (claims.iat > now + drift || claims.iat < now - max)) {\r\n        return { ok: false, err: new Error('claims: iat is invalid') };\r\n    }\r\n    if (claims.exp < now - drift || claims.exp > now + max) {\r\n        return { ok: false, err: new Error('claims: token has expired') };\r\n    }\r\n    return { ok: true };\r\n};\n\n// ValidateEOAProof verifies the account proof, testing if the proof claims have been signed with an\r\n// EOA (externally owned account) and will return success/failture, the account address as a string, and any errors.\r\nvar ValidateEOAProof = function (provider, chainId, proof) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var messageDigest, address;\r\n    return __generator(this, function (_a) {\r\n        messageDigest = proof.messageDigest();\r\n        address = ethers.verifyMessage(messageDigest, proof.signature);\r\n        if (address.slice(0, 2) === '0x' && address.length === 42 && address.toLowerCase() === proof.address.toLowerCase()) {\r\n            return [2 /*return*/, { isValid: true, address: proof.address }];\r\n        }\r\n        else {\r\n            return [2 /*return*/, { isValid: false }];\r\n        }\r\n    });\r\n}); };\r\n// ValidateContractAccountProof verifies the account proof, testing if the\r\n// proof claims have been signed with a smart-contract based account by calling the EIP-1271\r\n// method of the remote contract. This method will return success/failure, the\r\n// account address as a string, and any errors. The wallet contract must be deployed in\r\n// order for this call to be successful. In order test an undeployed smart-wallet, you\r\n// will have to implement your own custom validator method.\r\nvar ValidateContractAccountProof = function (provider, chainId, proof) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var messageDigest, walletCode, abi, contract, isValidSignature;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!provider || provider === undefined) {\r\n                    return [2 /*return*/, { isValid: false }];\r\n                }\r\n                messageDigest = proof.messageDigest();\r\n                return [4 /*yield*/, provider.getCode(proof.address)];\r\n            case 1:\r\n                walletCode = _a.sent();\r\n                if (walletCode === '0x' || walletCode.length <= 2) {\r\n                    throw new Error('ValidateContractAccountProof failed. unable to fetch wallet contract code');\r\n                }\r\n                abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];\r\n                contract = new ethers.Contract(proof.address, abi, provider);\r\n                return [4 /*yield*/, contract.isValidSignature(messageDigest, ethers.getBytes(proof.signature))];\r\n            case 2:\r\n                isValidSignature = _a.sent();\r\n                if (isValidSignature === IsValidSignatureBytes32MagicValue) {\r\n                    return [2 /*return*/, { isValid: true, address: proof.address }];\r\n                }\r\n                else {\r\n                    return [2 /*return*/, { isValid: false }];\r\n                }\r\n        }\r\n    });\r\n}); };\r\n// IsValidSignatureBytes32 is the EIP-1271 magic value we test\r\nvar IsValidSignatureBytes32MagicValue = '0x1626ba7e';\n\nvar ETHAuth = /** @class */ (function () {\r\n    function ETHAuth() {\r\n        var validators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            validators[_i] = arguments[_i];\r\n        }\r\n        var _this = this;\r\n        this.configJsonRpcProvider = function (ethereumJsonRpcURL) { return __awaiter(_this, void 0, void 0, function () {\r\n            var netVersion;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.provider = new ethers.JsonRpcProvider(ethereumJsonRpcURL);\r\n                        return [4 /*yield*/, this.provider.send('net_version', [])];\r\n                    case 1:\r\n                        netVersion = _a.sent();\r\n                        this.chainId = parseInt(netVersion);\r\n                        if (!this.chainId) {\r\n                            throw new Error('ethauth: unable to get chainId');\r\n                        }\r\n                        this.ethereumJsonRpcURL = ethereumJsonRpcURL;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this.configValidators = function () {\r\n            var validators = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                validators[_i] = arguments[_i];\r\n            }\r\n            if (validators.length == 0) {\r\n                throw new Error('validators list is empty');\r\n            }\r\n            _this.validators = validators;\r\n        };\r\n        this.encodeProof = function (proof, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var isValid, claimsJSON, proofString;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            if (proof.address.length !== 42 || proof.address.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid address');\r\n                            }\r\n                            if (proof.signature === '' || proof.signature.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid signature');\r\n                            }\r\n                            if (proof.extra && proof.extra.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid extra encoding, expecting hex data');\r\n                            }\r\n                            return [4 /*yield*/, this.validateProof(proof, skipSignatureValidation)];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid) {\r\n                                throw new Error(\"ethauth: proof is invalid\");\r\n                            }\r\n                            claimsJSON = JSON.stringify(proof.claims);\r\n                            proofString = ETHAuthPrefix + '.' + proof.address.toLowerCase() + '.' + Base64.encode(claimsJSON, true) + '.' + proof.signature;\r\n                            if (proof.extra && proof.extra.length > 0) {\r\n                                proofString += '.' + proof.extra;\r\n                            }\r\n                            return [2 /*return*/, proofString];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.decodeProof = function (proofString, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var parts, prefix, address, messageBase64, signature, extra, message, claims, proof, isValid;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            parts = proofString.split('.');\r\n                            if (parts.length < 4 || parts.length > 5) {\r\n                                throw new Error('ethauth: invalid proof string');\r\n                            }\r\n                            prefix = parts[0], address = parts[1], messageBase64 = parts[2], signature = parts[3], extra = parts[4];\r\n                            // check prefix\r\n                            if (prefix !== ETHAuthPrefix) {\r\n                                throw new Error('ethauth: not an ethauth proof');\r\n                            }\r\n                            message = Base64.decode(messageBase64);\r\n                            claims = JSON.parse(message);\r\n                            proof = new Proof({ address: address, claims: claims, signature: signature, extra: extra });\r\n                            return [4 /*yield*/, this.validateProof(proof, skipSignatureValidation)];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid) {\r\n                                throw new Error(\"ethauth: proof is invalid\");\r\n                            }\r\n                            return [2 /*return*/, proof];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.validateProof = function (proof, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var isValidClaims, isValidSig;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            isValidClaims = this.validateProofClaims(proof);\r\n                            if (isValidClaims.err) {\r\n                                throw new Error(\"ethauth: proof claims are invalid \".concat(isValidClaims.err));\r\n                            }\r\n                            if (!(skipSignatureValidation !== true)) return [3 /*break*/, 2];\r\n                            return [4 /*yield*/, this.validateProofSignature(proof)];\r\n                        case 1:\r\n                            isValidSig = _a.sent();\r\n                            if (isValidSig !== true) {\r\n                                throw new Error('ethauth: proof signature is invalid');\r\n                            }\r\n                            _a.label = 2;\r\n                        case 2: return [2 /*return*/, true];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.validateProofSignature = function (proof) { return __awaiter(_this, void 0, void 0, function () {\r\n            var retIsValid, i, validator, isValid, i;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        retIsValid = [];\r\n                        i = 0;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(i < this.validators.length)) return [3 /*break*/, 6];\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        validator = this.validators[i];\r\n                        return [4 /*yield*/, validator(this.provider, this.chainId, proof)];\r\n                    case 3:\r\n                        isValid = (_a.sent()).isValid;\r\n                        if (isValid === true) {\r\n                            // preemptively return true if we've determined it to be valid\r\n                            return [2 /*return*/, true];\r\n                        }\r\n                        retIsValid.push(isValid);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        _a.sent();\r\n                        retIsValid.push(false);\r\n                        return [3 /*break*/, 5];\r\n                    case 5:\r\n                        i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 6:\r\n                        for (i = 0; i < retIsValid.length; i++) {\r\n                            if (retIsValid[i]) {\r\n                                return [2 /*return*/, true];\r\n                            }\r\n                        }\r\n                        return [2 /*return*/, false];\r\n                }\r\n            });\r\n        }); };\r\n        this.validateProofClaims = function (proof) {\r\n            return proof.validateClaims();\r\n        };\r\n        if (validators.length == 0) {\r\n            this.validators = [ValidateEOAProof, ValidateContractAccountProof];\r\n        }\r\n        else {\r\n            this.validators = validators;\r\n        }\r\n    }\r\n    return ETHAuth;\r\n}());\n\nexport { ETHAuth, ETHAuthEIP712Domain, ETHAuthPrefix, ETHAuthVersion, IsValidSignatureBytes32MagicValue, Proof, ValidateContractAccountProof, ValidateEOAProof, encodeTypedDataDigest, encodeTypedDataHash, validateClaims };\n","export enum ChainId {\n  // Ethereum\n  MAINNET = 1,\n  ROPSTEN = 3, // network is deprecated\n  RINKEBY = 4, // network is deprecated\n  GOERLI = 5, // network is deprecated\n  KOVAN = 42, // network is deprecated\n  SEPOLIA = 11155111,\n\n  // Polygon\n  POLYGON = 137,\n  POLYGON_MUMBAI = 80001, // network is deprecated\n  POLYGON_ZKEVM = 1101,\n  POLYGON_AMOY = 80002,\n\n  // BSC\n  BSC = 56,\n  BSC_TESTNET = 97,\n\n  // Optimism\n  OPTIMISM = 10,\n  OPTIMISM_KOVAN = 69, // network is deprecated\n  OPTIMISM_GOERLI = 420, // network is deprecated\n  OPTIMISM_SEPOLIA = 11155420,\n\n  // Arbitrum One\n  ARBITRUM = 42161,\n  ARBITRUM_GOERLI = 421613, // network is deprecated\n  ARBITRUM_SEPOLIA = 421614,\n\n  // Arbitrum Nova\n  ARBITRUM_NOVA = 42170,\n\n  // Avalanche\n  AVALANCHE = 43114,\n  AVALANCHE_TESTNET = 43113,\n\n  // Gnosis Chain (XDAI)\n  GNOSIS = 100,\n\n  // BASE\n  BASE = 8453,\n  BASE_GOERLI = 84531, // network is deprecated\n  BASE_SEPOLIA = 84532,\n\n  // HOMEVERSE\n  HOMEVERSE_TESTNET = 40875,\n  HOMEVERSE = 19011,\n\n  // Xai\n  XAI = 660279,\n  XAI_SEPOLIA = 37714555429,\n\n  // XR\n  XR_SEPOLIA = 2730,\n\n  // TELOS\n  TELOS = 40,\n\n  // B3 Sepolia\n  B3 = 8333,\n  B3_SEPOLIA = 1993,\n\n  // APE Chain\n  APECHAIN = 33139,\n  APECHAIN_TESTNET = 33111,\n\n  // Blast\n  BLAST = 81457,\n  BLAST_SEPOLIA = 168587773,\n\n  // Borne\n  BORNE_TESTNET = 94984,\n\n  // SKALE Nebula\n  SKALE_NEBULA = 1482601649,\n  SKALE_NEBULA_TESTNET = 37084624,\n\n  // Soneium Minato\n  SONEIUM_MINATO = 1946,\n\n  // TOY Testnet\n  TOY_TESTNET = 21000000,\n\n  // Immutable zkEVM\n  IMMUTABLE_ZKEVM = 13371,\n  IMMUTABLE_ZKEVM_TESTNET = 13473,\n\n  // The Root Network\n  ROOT_NETWORK = 7668,\n  ROOT_NETWORK_PORCINI = 7672,\n\n  // HARDHAT TESTNETS\n  HARDHAT = 31337,\n  HARDHAT_2 = 31338\n}\n\nexport enum NetworkType {\n  MAINNET = 'mainnet',\n  TESTNET = 'testnet'\n}\n\nexport type BlockExplorerConfig = {\n  name?: string\n  rootUrl: string\n  addressUrl?: string\n  txnHashUrl?: string\n}\n\nexport interface NetworkMetadata {\n  chainId: ChainId\n  type?: NetworkType\n  name: string\n  title?: string\n  logoURI?: string\n  blockExplorer?: BlockExplorerConfig\n  ensAddress?: string\n  testnet?: boolean // Deprecated field, use type instead\n  deprecated?: boolean // The actual network is deprecated\n  nativeToken: {\n    symbol: string\n    name: string\n    decimals: number\n  }\n}\n\nexport const networks: Record<ChainId, NetworkMetadata> = {\n  [ChainId.MAINNET]: {\n    chainId: ChainId.MAINNET,\n    type: NetworkType.MAINNET,\n    name: 'mainnet',\n    title: 'Ethereum',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.MAINNET}.webp`,\n    blockExplorer: {\n      name: 'Etherscan',\n      rootUrl: 'https://etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  [ChainId.ROPSTEN]: {\n    chainId: ChainId.ROPSTEN,\n    type: NetworkType.TESTNET,\n    name: 'ropsten',\n    title: 'Ropsten',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ROPSTEN}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Ropsten)',\n      rootUrl: 'https://ropsten.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'roETH',\n      name: 'Ropsten Ether',\n      decimals: 18\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    deprecated: true\n  },\n  [ChainId.RINKEBY]: {\n    chainId: ChainId.RINKEBY,\n    type: NetworkType.TESTNET,\n    name: 'rinkeby',\n    title: 'Rinkeby',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.RINKEBY}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Rinkeby)',\n      rootUrl: 'https://rinkeby.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'rETH',\n      name: 'Rinkeby Ether',\n      decimals: 18\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    deprecated: true\n  },\n  [ChainId.GOERLI]: {\n    chainId: ChainId.GOERLI,\n    type: NetworkType.TESTNET,\n    name: 'goerli',\n    title: 'Goerli',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.GOERLI}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Goerli)',\n      rootUrl: 'https://goerli.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'gETH',\n      name: 'Goerli Ether',\n      decimals: 18\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    deprecated: true\n  },\n  [ChainId.KOVAN]: {\n    chainId: ChainId.KOVAN,\n    type: NetworkType.TESTNET,\n    name: 'kovan',\n    title: 'Kovan',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.KOVAN}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Kovan)',\n      rootUrl: 'https://kovan.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'kETH',\n      name: 'Kovan Ether',\n      decimals: 18\n    },\n    deprecated: true\n  },\n  [ChainId.SEPOLIA]: {\n    chainId: ChainId.SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'sepolia',\n    title: 'Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Sepolia)',\n      rootUrl: 'https://sepolia.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'sETH',\n      name: 'Sepolia Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.POLYGON]: {\n    chainId: ChainId.POLYGON,\n    type: NetworkType.MAINNET,\n    name: 'polygon',\n    title: 'Polygon',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON}.webp`,\n    blockExplorer: {\n      name: 'Polygonscan',\n      rootUrl: 'https://polygonscan.com/'\n    },\n    nativeToken: {\n      symbol: 'POL',\n      name: 'POL',\n      decimals: 18\n    }\n  },\n  [ChainId.POLYGON_MUMBAI]: {\n    chainId: ChainId.POLYGON_MUMBAI,\n    type: NetworkType.TESTNET,\n    name: 'mumbai',\n    title: 'Polygon Mumbai',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_MUMBAI}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Polygonscan (Mumbai)',\n      rootUrl: 'https://mumbai.polygonscan.com/'\n    },\n    nativeToken: {\n      symbol: 'mMATIC',\n      name: 'Mumbai Polygon',\n      decimals: 18\n    },\n    deprecated: true\n  },\n  [ChainId.POLYGON_AMOY]: {\n    chainId: ChainId.POLYGON_AMOY,\n    type: NetworkType.TESTNET,\n    name: 'amoy',\n    title: 'Polygon Amoy',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_AMOY}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'OKLink (Amoy)',\n      rootUrl: 'https://www.oklink.com/amoy/'\n    },\n    nativeToken: {\n      symbol: 'aPOL',\n      name: 'Amoy POL',\n      decimals: 18\n    }\n  },\n  [ChainId.POLYGON_ZKEVM]: {\n    chainId: ChainId.POLYGON_ZKEVM,\n    type: NetworkType.MAINNET,\n    name: 'polygon-zkevm',\n    title: 'Polygon zkEVM',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.POLYGON_ZKEVM}.webp`,\n    blockExplorer: {\n      name: 'Polygonscan (zkEVM)',\n      rootUrl: 'https://zkevm.polygonscan.com/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.BSC]: {\n    chainId: ChainId.BSC,\n    type: NetworkType.MAINNET,\n    name: 'bsc',\n    title: 'BNB Smart Chain',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BSC}.webp`,\n    blockExplorer: {\n      name: 'BSCScan',\n      rootUrl: 'https://bscscan.com/'\n    },\n    nativeToken: {\n      symbol: 'BNB',\n      name: 'BNB',\n      decimals: 18\n    }\n  },\n  [ChainId.BSC_TESTNET]: {\n    chainId: ChainId.BSC_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'bsc-testnet',\n    title: 'BNB Smart Chain Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BSC_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'BSCScan (Testnet)',\n      rootUrl: 'https://testnet.bscscan.com/'\n    },\n    nativeToken: {\n      symbol: 'tBNB',\n      name: 'Testnet BNB',\n      decimals: 18\n    }\n  },\n  [ChainId.OPTIMISM]: {\n    chainId: ChainId.OPTIMISM,\n    type: NetworkType.MAINNET,\n    name: 'optimism',\n    title: 'Optimism',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM}.webp`,\n    blockExplorer: {\n      name: 'Etherscan (Optimism)',\n      rootUrl: 'https://optimistic.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.OPTIMISM_KOVAN]: {\n    chainId: ChainId.OPTIMISM_KOVAN,\n    type: NetworkType.TESTNET,\n    name: 'optimism-kovan',\n    title: 'Optimism Kovan',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_KOVAN}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Optimism Kovan)',\n      rootUrl: 'https://kovan-optimistic.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'kETH',\n      name: 'Kovan Ether',\n      decimals: 18\n    },\n    deprecated: true\n  },\n  [ChainId.OPTIMISM_GOERLI]: {\n    chainId: ChainId.OPTIMISM_GOERLI,\n    type: NetworkType.TESTNET,\n    name: 'optimism-goerli',\n    title: 'Optimism Goerli',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_GOERLI}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Optimism Goerli)',\n      rootUrl: 'https://goerli-optimistic.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'gETH',\n      name: 'Goerli Ether',\n      decimals: 18\n    },\n    deprecated: true\n  },\n  [ChainId.OPTIMISM_SEPOLIA]: {\n    chainId: ChainId.OPTIMISM_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'optimism-sepolia',\n    title: 'Optimism Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.OPTIMISM_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Optimism Sepolia)',\n      rootUrl: 'https://sepolia-optimistic.etherscan.io/'\n    },\n    nativeToken: {\n      symbol: 'sETH',\n      name: 'Sepolia Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.ARBITRUM]: {\n    chainId: ChainId.ARBITRUM,\n    type: NetworkType.MAINNET,\n    name: 'arbitrum',\n    title: 'Arbitrum One',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM}.webp`,\n    blockExplorer: {\n      name: 'Arbiscan',\n      rootUrl: 'https://arbiscan.io/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.ARBITRUM_GOERLI]: {\n    chainId: ChainId.ARBITRUM_GOERLI,\n    type: NetworkType.TESTNET,\n    name: 'arbitrum-goerli',\n    title: 'Arbitrum Goerli',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_GOERLI}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Arbiscan (Goerli Testnet)',\n      rootUrl: 'https://testnet.arbiscan.io/'\n    },\n    nativeToken: {\n      symbol: 'gETH',\n      name: 'Goerli Ether',\n      decimals: 18\n    },\n    deprecated: true\n  },\n  [ChainId.ARBITRUM_SEPOLIA]: {\n    chainId: ChainId.ARBITRUM_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'arbitrum-sepolia',\n    title: 'Arbitrum Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Arbiscan (Sepolia Testnet)',\n      rootUrl: 'https://sepolia.arbiscan.io/'\n    },\n    nativeToken: {\n      symbol: 'sETH',\n      name: 'Sepolia Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.ARBITRUM_NOVA]: {\n    chainId: ChainId.ARBITRUM_NOVA,\n    type: NetworkType.MAINNET,\n    name: 'arbitrum-nova',\n    title: 'Arbitrum Nova',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ARBITRUM_NOVA}.webp`,\n    blockExplorer: {\n      name: 'Arbiscan Nova',\n      rootUrl: 'https://nova.arbiscan.io/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.AVALANCHE]: {\n    chainId: ChainId.AVALANCHE,\n    type: NetworkType.MAINNET,\n    name: 'avalanche',\n    title: 'Avalanche',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.AVALANCHE}.webp`,\n    blockExplorer: {\n      name: 'Snowtrace',\n      rootUrl: 'https://subnets.avax.network/c-chain/'\n    },\n    nativeToken: {\n      symbol: 'AVAX',\n      name: 'AVAX',\n      decimals: 18\n    }\n  },\n  [ChainId.AVALANCHE_TESTNET]: {\n    chainId: ChainId.AVALANCHE_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'avalanche-testnet',\n    title: 'Avalanche Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.AVALANCHE_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Snowtrace (Testnet)',\n      rootUrl: 'https://subnets-test.avax.network/c-chain/'\n    },\n    nativeToken: {\n      symbol: 'tAVAX',\n      name: 'Testnet AVAX',\n      decimals: 18\n    }\n  },\n  [ChainId.GNOSIS]: {\n    chainId: ChainId.GNOSIS,\n    type: NetworkType.MAINNET,\n    name: 'gnosis',\n    title: 'Gnosis Chain',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.GNOSIS}.webp`,\n    blockExplorer: {\n      name: 'Gnosis Chain Explorer',\n      rootUrl: 'https://blockscout.com/xdai/mainnet/'\n    },\n    nativeToken: {\n      symbol: 'XDAI',\n      name: 'XDAI',\n      decimals: 18\n    }\n  },\n  [ChainId.BASE]: {\n    chainId: ChainId.BASE,\n    type: NetworkType.MAINNET,\n    name: 'base',\n    title: 'Base (Coinbase)',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE}.webp`,\n    blockExplorer: {\n      name: 'Base Explorer',\n      rootUrl: 'https://basescan.org/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.BASE_GOERLI]: {\n    chainId: ChainId.BASE_GOERLI,\n    type: NetworkType.TESTNET,\n    name: 'base-goerli',\n    title: 'Base Goerli',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE_GOERLI}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Base Goerli Explorer',\n      rootUrl: 'https://goerli.basescan.org/'\n    },\n    nativeToken: {\n      symbol: 'gETH',\n      name: 'Goerli Ether',\n      decimals: 18\n    },\n    deprecated: true\n  },\n  [ChainId.BASE_SEPOLIA]: {\n    chainId: ChainId.BASE_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'base-sepolia',\n    title: 'Base Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BASE_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Base Sepolia Explorer',\n      rootUrl: 'https://base-sepolia.blockscout.com/'\n    },\n    nativeToken: {\n      symbol: 'sETH',\n      name: 'Sepolia Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.HOMEVERSE]: {\n    chainId: ChainId.HOMEVERSE,\n    type: NetworkType.MAINNET,\n    name: 'homeverse',\n    title: 'Oasys Homeverse',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.HOMEVERSE}.webp`,\n    blockExplorer: {\n      name: 'Oasys Homeverse Explorer',\n      rootUrl: 'https://explorer.oasys.homeverse.games/'\n    },\n    nativeToken: {\n      symbol: 'OAS',\n      name: 'OAS',\n      decimals: 18\n    }\n  },\n  [ChainId.HOMEVERSE_TESTNET]: {\n    chainId: ChainId.HOMEVERSE_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'homeverse-testnet',\n    title: 'Oasys Homeverse Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.HOMEVERSE_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Oasys Homeverse Explorer (Testnet)',\n      rootUrl: 'https://explorer.testnet.oasys.homeverse.games/'\n    },\n    nativeToken: {\n      symbol: 'tOAS',\n      name: 'Testnet OAS',\n      decimals: 18\n    }\n  },\n  [ChainId.XAI]: {\n    chainId: ChainId.XAI,\n    type: NetworkType.MAINNET,\n    name: 'xai',\n    title: 'Xai',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XAI}.webp`,\n    blockExplorer: {\n      name: 'Xai Explorer',\n      rootUrl: 'https://explorer.xai-chain.net/'\n    },\n    nativeToken: {\n      symbol: 'XAI',\n      name: 'XAI',\n      decimals: 18\n    }\n  },\n  [ChainId.XAI_SEPOLIA]: {\n    chainId: ChainId.XAI_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'xai-sepolia',\n    title: 'Xai Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XAI_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Xai Sepolia Explorer',\n      rootUrl: 'https://testnet-explorer-v2.xai-chain.net/'\n    },\n    nativeToken: {\n      symbol: 'sXAI',\n      name: 'Sepolia XAI',\n      decimals: 18\n    }\n  },\n  [ChainId.XR_SEPOLIA]: {\n    chainId: ChainId.XR_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'xr-sepolia',\n    title: 'XR Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.XR_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'XR Sepolia Explorer',\n      rootUrl: 'https://xr-sepolia-testnet.explorer.caldera.xyz/'\n    },\n    nativeToken: {\n      symbol: 'tXR',\n      name: 'Sepolia XR',\n      decimals: 18\n    }\n  },\n  [ChainId.B3]: {\n    chainId: ChainId.B3,\n    type: NetworkType.MAINNET,\n    name: 'b3',\n    title: 'B3',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.B3}.webp`,\n    testnet: false,\n    blockExplorer: {\n      name: 'B3 Explorer',\n      rootUrl: 'https://explorer.b3.fun/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.B3_SEPOLIA]: {\n    chainId: ChainId.B3_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'b3-sepolia',\n    title: 'B3 Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.B3_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'B3 Sepolia Explorer',\n      rootUrl: 'https://sepolia.explorer.b3.fun/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.APECHAIN]: {\n    chainId: ChainId.APECHAIN,\n    type: NetworkType.MAINNET,\n    name: 'apechain',\n    title: 'APE Chain',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.APECHAIN}.webp`,\n    testnet: false,\n    blockExplorer: {\n      name: 'APE Chain Explorer',\n      rootUrl: 'https://apechain.calderaexplorer.xyz/'\n    },\n    nativeToken: {\n      symbol: 'APE',\n      name: 'ApeCoin',\n      decimals: 18\n    }\n  },\n  [ChainId.APECHAIN_TESTNET]: {\n    chainId: ChainId.APECHAIN_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'apechain-testnet',\n    title: 'APE Chain Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.APECHAIN_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'APE Chain Explorer',\n      rootUrl: 'https://curtis.explorer.caldera.xyz/'\n    },\n    nativeToken: {\n      symbol: 'APE',\n      name: 'ApeCoin',\n      decimals: 18\n    }\n  },\n  [ChainId.BLAST]: {\n    chainId: ChainId.BLAST,\n    type: NetworkType.MAINNET,\n    name: 'blast',\n    title: 'Blast',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BLAST}.webp`,\n    blockExplorer: {\n      name: 'Blast Explorer',\n      rootUrl: 'https://blastscan.io/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.BLAST_SEPOLIA]: {\n    chainId: ChainId.BLAST_SEPOLIA,\n    type: NetworkType.TESTNET,\n    name: 'blast-sepolia',\n    title: 'Blast Sepolia',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BLAST_SEPOLIA}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Blast Sepolia Explorer',\n      rootUrl: 'https://sepolia.blastexplorer.io/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.TELOS]: {\n    chainId: ChainId.TELOS,\n    type: NetworkType.MAINNET,\n    name: 'telos',\n    title: 'Telos',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.TELOS}.webp`,\n    blockExplorer: {\n      name: 'Telos Explorer',\n      rootUrl: 'https://explorer.telos.net/network/'\n    },\n    nativeToken: {\n      symbol: 'TLOS',\n      name: 'TLOS',\n      decimals: 18\n    }\n  },\n  [ChainId.BORNE_TESTNET]: {\n    chainId: ChainId.BORNE_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'borne-testnet',\n    title: 'Borne Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.BORNE_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Borne Testnet Explorer',\n      rootUrl: 'https://subnets-test.avax.network/bornegfdn'\n    },\n    nativeToken: {\n      symbol: 'BORNE',\n      name: 'BORNE',\n      decimals: 18\n    }\n  },\n  [ChainId.SKALE_NEBULA]: {\n    chainId: ChainId.SKALE_NEBULA,\n    type: NetworkType.MAINNET,\n    name: 'skale-nebula',\n    title: 'SKALE Nebula Gaming Hub',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SKALE_NEBULA}.webp`,\n    testnet: false,\n    blockExplorer: {\n      name: 'SKALE Nebula Gaming Hub Explorer',\n      rootUrl: 'https://green-giddy-denebola.explorer.mainnet.skalenodes.com/'\n    },\n    nativeToken: {\n      symbol: 'sFUEL',\n      name: 'SKALE Fuel',\n      decimals: 18\n    }\n  },\n  [ChainId.SKALE_NEBULA_TESTNET]: {\n    chainId: ChainId.SKALE_NEBULA_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'skale-nebula-testnet',\n    title: 'SKALE Nebula Gaming Hub Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SKALE_NEBULA_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'SKALE Nebula Gaming Hub Testnet Explorer',\n      rootUrl: 'https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com/'\n    },\n    nativeToken: {\n      symbol: 'sFUEL',\n      name: 'SKALE Fuel',\n      decimals: 18\n    }\n  },\n  [ChainId.SONEIUM_MINATO]: {\n    chainId: ChainId.SONEIUM_MINATO,\n    type: NetworkType.TESTNET,\n    name: 'soneium-minato',\n    title: 'Soneium Minato (Testnet)',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.SONEIUM_MINATO}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Soneium Minato Explorer',\n      rootUrl: 'https://explorer-testnet.soneium.org/'\n    },\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.TOY_TESTNET]: {\n    chainId: ChainId.TOY_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'toy-testnet',\n    title: 'TOY (Testnet)',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.TOY_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'TOY Testnet Explorer',\n      rootUrl: 'https://toy-chain-testnet.explorer.caldera.xyz/'\n    },\n    nativeToken: {\n      symbol: 'TOY',\n      name: 'TOY',\n      decimals: 18\n    }\n  },\n  [ChainId.IMMUTABLE_ZKEVM]: {\n    chainId: ChainId.IMMUTABLE_ZKEVM,\n    type: NetworkType.MAINNET,\n    name: 'immutable-zkevm',\n    title: 'Immutable zkEVM',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.IMMUTABLE_ZKEVM}.webp`,\n    testnet: false,\n    blockExplorer: {\n      name: 'Immutable zkEVM Explorer',\n      rootUrl: 'https://explorer.immutable.com/'\n    },\n    nativeToken: {\n      symbol: 'IMX',\n      name: 'IMX',\n      decimals: 18\n    }\n  },\n  [ChainId.IMMUTABLE_ZKEVM_TESTNET]: {\n    chainId: ChainId.IMMUTABLE_ZKEVM_TESTNET,\n    type: NetworkType.TESTNET,\n    name: 'immutable-zkevm-testnet',\n    title: 'Immutable zkEVM Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.IMMUTABLE_ZKEVM_TESTNET}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'Immutable zkEVM Testnet Explorer',\n      rootUrl: 'https://explorer.testnet.immutable.com/'\n    },\n    nativeToken: {\n      symbol: 'IMX',\n      name: 'IMX',\n      decimals: 18\n    }\n  },\n  [ChainId.ROOT_NETWORK]: {\n    chainId: ChainId.ROOT_NETWORK,\n    type: NetworkType.MAINNET,\n    name: 'rootnet',\n    title: 'The Root Network',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ROOT_NETWORK}.webp`,\n    testnet: false,\n    blockExplorer: {\n      name: 'The Root Network Explorer',\n      rootUrl: 'https://rootscan.io/'\n    },\n    nativeToken: {\n      symbol: 'XRP',\n      name: 'XRP',\n      decimals: 18\n    }\n  },\n  [ChainId.ROOT_NETWORK_PORCINI]: {\n    chainId: ChainId.ROOT_NETWORK_PORCINI,\n    type: NetworkType.TESTNET,\n    name: 'rootnet-porcini',\n    title: 'The Root Network Porcini Testnet',\n    logoURI: `https://assets.sequence.info/images/networks/medium/${ChainId.ROOT_NETWORK_PORCINI}.webp`,\n    testnet: true,\n    blockExplorer: {\n      name: 'The Root Network Porcini Testnet Explorer',\n      rootUrl: 'https://porcini.rootscan.io/'\n    },\n    nativeToken: {\n      symbol: 'XRP',\n      name: 'XRP',\n      decimals: 18\n    }\n  },\n  [ChainId.HARDHAT]: {\n    chainId: ChainId.HARDHAT,\n    name: 'hardhat',\n    title: 'Hardhat (local testnet)',\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  },\n  [ChainId.HARDHAT_2]: {\n    chainId: ChainId.HARDHAT_2,\n    name: 'hardhat2',\n    title: 'Hardhat (local testnet)',\n    nativeToken: {\n      symbol: 'ETH',\n      name: 'Ether',\n      decimals: 18\n    }\n  }\n}\n","import { ethers } from 'ethers'\nimport { ChainIdLike } from '.'\nimport { NetworkConfig } from './config'\n\nexport function isNetworkConfig(cand: any): cand is NetworkConfig {\n  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined\n}\n\nexport const getChainId = (chainId: ChainIdLike): number => {\n  if (typeof chainId === 'number') {\n    return chainId\n  }\n  if ((<NetworkConfig>chainId).chainId) {\n    return (<NetworkConfig>chainId).chainId\n  }\n  return Number(chainId as ethers.BigNumberish)\n}\n\nexport const maybeChainId = (chainId?: ChainIdLike): number | undefined => {\n  if (!chainId) return undefined\n  return getChainId(chainId)\n}\n\nexport const isValidNetworkConfig = (\n  networkConfig: NetworkConfig | NetworkConfig[],\n  raise: boolean = false,\n  skipRelayerCheck: boolean = false\n): boolean => {\n  if (!networkConfig) throw new Error(`invalid network config: empty config`)\n\n  const configs: NetworkConfig[] = []\n  if (Array.isArray(networkConfig)) {\n    configs.push(...networkConfig)\n  } else {\n    configs.push(networkConfig)\n  }\n\n  if (configs.length === 0) {\n    if (raise) throw new Error(`invalid network config: empty config`)\n    return false\n  }\n\n  // Ensure distinct chainId configs\n  const chainIds = configs.map(c => c.chainId).sort()\n  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i)\n  if (dupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`)\n    return false\n  }\n\n  // Downcase all network names\n  configs.forEach(c => (c.name = c.name.toLowerCase()))\n\n  // Ensure distinct network names\n  const names = configs.map(c => c.name).sort()\n  const nameDupes = names.filter((c, i) => names.indexOf(c) !== i)\n  if (nameDupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`)\n    return false\n  }\n\n  // Ensure rpcUrl or provider is specified\n  // Ensure relayerUrl or relayer is specified\n  // Ensure one default chain\n  // Ensure one auth chain\n  let defaultChain = false\n  for (let i = 0; i < configs.length; i++) {\n    const c = configs[i]\n    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {\n      if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`)\n      return false\n    }\n    if (!skipRelayerCheck) {\n      if (!c.relayer) {\n        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`)\n        return false\n      }\n    }\n    if (c.isDefaultChain) {\n      if (defaultChain) {\n        if (raise)\n          throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`)\n        return false\n      }\n      defaultChain = true\n    }\n  }\n\n  if (!defaultChain) {\n    if (raise) throw new Error(`invalid network config: DefaultChain must be set`)\n    return false\n  }\n\n  return true\n}\n\nexport const ensureValidNetworks = (networks: NetworkConfig[], skipRelayerCheck: boolean = false): NetworkConfig[] => {\n  isValidNetworkConfig(networks, true, skipRelayerCheck)\n  return networks\n}\n\nexport const ensureUniqueNetworks = (networks: NetworkConfig[], raise: boolean = true): boolean => {\n  const chainIds = networks.map(c => c.chainId).sort()\n  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i)\n  if (dupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`)\n    return false\n  }\n  return true\n}\n\nexport const updateNetworkConfig = (src: Partial<NetworkConfig>, dest: NetworkConfig) => {\n  if (!src || !dest) return\n\n  if (!src.chainId && !src.name) {\n    throw new Error('failed to update network config: source config is missing chainId or name')\n  }\n  if (src.chainId !== dest.chainId && src.name !== dest.name) {\n    throw new Error('failed to update network config: one of chainId or name must match')\n  }\n\n  if (src.rpcUrl) {\n    dest.rpcUrl = src.rpcUrl\n    dest.provider = undefined\n  }\n  if (src.provider) {\n    dest.provider = src.provider\n  }\n  if (src.relayer) {\n    dest.relayer = src.relayer\n  }\n}\n\nexport const validateAndSortNetworks = (networks: NetworkConfig[]) => {\n  return ensureValidNetworks(sortNetworks(networks))\n}\n\nexport const findNetworkConfig = (networks: NetworkConfig[], chainId: ChainIdLike): NetworkConfig | undefined => {\n  if (typeof chainId === 'string') {\n    if (chainId.startsWith('0x')) {\n      const id = Number(chainId)\n      return networks.find(n => n.chainId === id)\n    } else {\n      return networks.find(n => n.name === chainId || `${n.chainId}` === chainId)\n    }\n  } else if (typeof chainId === 'number') {\n    return networks.find(n => n.chainId === chainId)\n  } else if ((<NetworkConfig>chainId).chainId) {\n    return networks.find(n => n.chainId === (<NetworkConfig>chainId).chainId)\n  } else if (typeof chainId === 'bigint') {\n    const id = Number(chainId)\n    return networks.find(n => n.chainId === id)\n  } else {\n    return undefined\n  }\n}\n\nexport const checkNetworkConfig = (network: NetworkConfig, chainId: string | number): boolean => {\n  if (!network) return false\n  if (network.name === chainId) return true\n  if (network.chainId === chainId) return true\n  return false\n}\n\nexport const networksIndex = (networks: NetworkConfig[]): { [key: string]: NetworkConfig } => {\n  const index: { [key: string]: NetworkConfig } = {}\n  for (let i = 0; i < networks.length; i++) {\n    index[networks[i].name] = networks[i]\n  }\n  return index\n}\n\n// TODO: we should remove sortNetworks in the future but this is a breaking change for dapp integrations on older versions <-> wallet\n// sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers\nexport const sortNetworks = (networks: NetworkConfig[]): NetworkConfig[] => {\n  if (!networks) {\n    return []\n  }\n\n  const config = networks.sort((a, b) => {\n    if (a.chainId === b.chainId) return 0\n    return a.chainId < b.chainId ? -1 : 1\n  })\n\n  // DefaultChain goes first\n  const defaultConfigIdx = config.findIndex(c => c.isDefaultChain)\n  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0])\n\n  return config\n}\n\nexport const stringTemplate = (sTemplate: string, mData: any) => {\n  if (typeof sTemplate === 'string') {\n    mData = mData ? mData : {}\n    return sTemplate.replace(/\\$\\{\\s*([$#@\\-\\d\\w]+)\\s*\\}/gim, function (fullMath, grp) {\n      let val = mData[grp]\n      if (typeof val === 'function') {\n        val = val()\n      } else if (val === null || val === undefined) {\n        val = ''\n      } else if (typeof val === 'object' || typeof val === 'symbol') {\n        val = val.toString()\n      } else {\n        val = val.valueOf()\n      }\n      return val\n    })\n  }\n  return ''\n}\n","import { ethers } from 'ethers'\n\nexport const MAX_UINT_256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n\n// ethers implement this method but doesn't exports it\nexport const isBigNumberish = (value: any): value is ethers.BigNumberish => {\n  return (\n    value != null &&\n    ((typeof value === 'number' && value % 1 === 0) ||\n      (typeof value === 'string' && !!value.match(/^-?[0-9]+$/)) ||\n      ethers.isHexString(value) ||\n      typeof value === 'bigint')\n  )\n}\n\n// Even length zero-padded hex string with 0x prefix\nexport const toHexString = (value: bigint): string => {\n  const result = value.toString(16)\n\n  return `${result.length % 2 === 0 ? '0x' : '0x0'}${result}`\n}\n\nexport const parseUnits = (value: string, decimals: number = 18): bigint => {\n  let [integer, fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) {\n    integer = integer.slice(1)\n  }\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    integer = `${Math.round(Number(`${integer}.${fraction}`))}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals)\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9) {\n      fraction = `${BigInt(left) + 1n}0`.padStart(left.length + 1, '0')\n    } else {\n      fraction = `${left}${rounded}`\n    }\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n\nexport const parseEther = (value: string): bigint => parseUnits(value, 18)\n\nexport const formatUnits = (value: bigint, decimals: number = 18): string => {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) {\n    display = display.slice(1)\n  }\n\n  display = display.padStart(decimals, '0')\n\n  const integer = display.slice(0, display.length - decimals)\n  let fraction = display.slice(display.length - decimals)\n\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`\n}\n\nexport const formatEther = (value: bigint): string => formatUnits(value, 18)\n\n// JSON.stringify doesn't handle BigInts, so we need to replace them with objects\nexport const bigintReplacer = (key: string, value: any): any => {\n  if (typeof value === 'bigint') {\n    return { $bigint: value.toString() }\n  }\n\n  return value\n}\n\n// JSON.parse will need to convert our serialized bigints back into BigInt\nexport const bigintReviver = (key: string, value: any): any => {\n  if (value !== null && typeof value === 'object' && '$bigint' in value && typeof value.$bigint === 'string') {\n    return BigInt(value.$bigint)\n  }\n\n  // BigNumber compatibility with older versions of sequence.js with ethers v5\n  if (value !== null && typeof value === 'object' && value.type === 'BigNumber' && ethers.isHexString(value.hex)) {\n    return BigInt(value.hex)\n  }\n\n  return value\n}\n","import { Base64 } from 'js-base64'\nimport { bigintReplacer, bigintReviver } from './bigint'\n\nexport const base64Encode = (val: string): string => {\n  return Base64.encode(val, true)\n}\n\nexport const base64EncodeObject = (obj: any): string => {\n  return Base64.encode(JSON.stringify(obj, bigintReplacer), true)\n}\n\nexport const base64Decode = (encodedString: string): string | undefined => {\n  if (encodedString === null || encodedString === undefined) {\n    return undefined\n  }\n  return Base64.decode(encodedString)\n}\n\nexport const base64DecodeObject = <T = any>(encodedObject: string | null): T | undefined => {\n  if (encodedObject === null || encodedObject === undefined) {\n    return undefined\n  }\n  return JSON.parse(Base64.decode(encodedObject), bigintReviver) as T\n}\n","import { ethers } from 'ethers'\n\nexport const encodeMessageDigest = (message: string | ethers.BytesLike) => {\n  if (typeof message === 'string') {\n    return ethers.getBytes(ethers.id(message))\n  } else {\n    return ethers.getBytes(ethers.keccak256(message))\n  }\n}\n\n// packMessageData encodes the specified data ready for the Sequence Wallet contracts.\nexport const packMessageData = (walletAddress: string, chainId: ethers.BigNumberish, digest: ethers.BytesLike): string => {\n  return ethers.solidityPacked(['string', 'uint256', 'address', 'bytes32'], ['\\x19\\x01', chainId, walletAddress, digest])\n}\n\nexport const subDigestOf = (address: string, chainId: ethers.BigNumberish, digest: ethers.BytesLike): string => {\n  return ethers.keccak256(packMessageData(address, chainId, digest))\n}\n","export const isNode = () => {\n  if (typeof window === 'undefined' && typeof process === 'object') {\n    return true\n  } else {\n    return false\n  }\n}\n\nexport const isBrowser = () => !isNode()\n","import { Base64 } from 'js-base64'\n\nexport const jwtDecodeClaims = <T = any>(jwt: string) => {\n  const parts = jwt.split('.')\n  if (parts.length !== 3) {\n    throw new Error('invalid jwt')\n  }\n  const claims = JSON.parse(Base64.decode(parts[1])) as T\n  return claims\n}\n","export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'DISABLED'\n\nenum logLevel {\n  DEBUG = 1,\n  INFO = 2,\n  WARN = 3,\n  ERROR = 4,\n  DISABLED = 5\n}\n\nexport interface LoggerConfig {\n  logLevel: LogLevel\n  silence?: boolean\n\n  onwarn?: (message: any, ...optionalParams: any[]) => void\n  onerror?: (message: any, ...optionalParams: any[]) => void\n}\n\nexport class Logger {\n  logLevel: logLevel\n\n  constructor(private config: LoggerConfig) {\n    this.configure(config)\n  }\n\n  configure(config: Partial<LoggerConfig>) {\n    this.config = { ...this.config, ...config }\n    switch (this.config.logLevel) {\n      case 'DEBUG':\n        this.logLevel = logLevel.DEBUG\n        break\n      case 'INFO':\n        this.logLevel = logLevel.INFO\n        break\n      case 'WARN':\n        this.logLevel = logLevel.WARN\n        break\n      case 'ERROR':\n        this.logLevel = logLevel.ERROR\n        break\n      case 'DISABLED':\n        this.logLevel = logLevel.DISABLED\n        break\n      default:\n        this.logLevel = logLevel.INFO\n        break\n    }\n\n    // undefined silence value will disable the default silence flag\n    if (this.config.silence === undefined) {\n      this.config.silence = false\n    }\n  }\n\n  debug(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel === logLevel.DEBUG) {\n      console.log(message, ...optionalParams)\n    }\n  }\n\n  info(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel <= logLevel.INFO) {\n      console.log(message, ...optionalParams)\n    }\n  }\n\n  warn(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel <= logLevel.WARN) {\n      console.warn(message, ...optionalParams)\n      if (this.config.onwarn) {\n        this.config.onwarn(message, optionalParams)\n      }\n    }\n  }\n\n  error(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel <= logLevel.ERROR) {\n      console.error(message, ...optionalParams)\n      if (this.config.onerror) {\n        this.config.onerror(message, optionalParams)\n      }\n    }\n  }\n}\n\nexport const logger = new Logger({\n  logLevel: 'INFO',\n\n  // By default we silence the logger. In tests we should call `configureLogger`\n  // below to set silence: false.\n  silence: true\n})\n\nexport const configureLogger = (config: Partial<LoggerConfig>) => logger.configure(config)\n","import { ethers } from 'ethers'\n\nexport class Base {\n  static bufferIndexOf(array: Uint8Array[], element: Uint8Array, isSorted: boolean = false): number {\n    if (isSorted) {\n      return Base.binarySearch(array, element, Base.compare)\n    }\n\n    const eqChecker = (buffer1: Uint8Array, buffer2: Uint8Array): boolean => {\n      if (buffer1 === buffer2) {\n        return true\n      }\n      if (buffer1.length !== buffer2.length) {\n        return false\n      }\n      for (let i = 0; i < buffer1.length; i++) {\n        if (buffer1[i] !== buffer2[i]) {\n          return false\n        }\n      }\n      return true\n    }\n\n    return Base.linearSearch(array, element, eqChecker)\n  }\n\n  static binarySearch(\n    array: Uint8Array[],\n    element: Uint8Array,\n    compareFunction: (a: Uint8Array, b: Uint8Array) => number\n  ): number {\n    let start = 0\n    let end = array.length - 1\n\n    // Iterate while start not meets end\n    while (start <= end) {\n      // Find the mid index\n      const mid = Math.floor((start + end) / 2)\n\n      // Check if the mid value is greater than, equal to, or less than search element.\n      const ordering = compareFunction(array[mid], element)\n\n      // If element is present at mid, start iterating for searching first appearance.\n      if (ordering === 0) {\n        // Linear reverse iteration until the first matching item index is found.\n        for (let i = mid - 1; i >= 0; i--) {\n          if (compareFunction(array[i], element) === 0) continue\n          return i + 1\n        }\n        return 0\n      } /* Else look in left or right half accordingly */ else if (ordering < 0) {\n        start = mid + 1\n      } else {\n        end = mid - 1\n      }\n    }\n\n    return -1\n  }\n\n  static compare(a: Uint8Array, b: Uint8Array): number {\n    // Determine the minimum length to compare\n    const len = Math.min(a.length, b.length)\n\n    // Compare byte by byte\n    for (let i = 0; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return a[i] - b[i]\n      }\n    }\n\n    // If all compared bytes are equal, compare lengths\n    return a.length - b.length\n  }\n\n  static linearSearch(array: Uint8Array[], element: Uint8Array, eqChecker: (a: Uint8Array, b: Uint8Array) => boolean): number {\n    for (let i = 0; i < array.length; i++) {\n      if (eqChecker(array[i], element)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  static bufferify(value: Uint8Array | string): Uint8Array {\n    if (typeof value === 'string') {\n      return ethers.getBytes(value)\n    }\n    return value\n  }\n\n  static isHexString(v: string): boolean {\n    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v)\n  }\n\n  static bufferToHex(value: Uint8Array, withPrefix: boolean = true): string {\n    const prefixed = ethers.hexlify(value)\n    return withPrefix ? prefixed : prefixed.substring(2)\n  }\n\n  static bufferifyFn(f: any): any {\n    return (value: any): Uint8Array => {\n      return Base.bufferify(f(value))\n    }\n  }\n}\n","import { ethers } from 'ethers'\nimport { Base } from './Base'\n\ntype TValue = string\ntype TLeaf = Uint8Array\ntype TLayer = TLeaf[]\ntype THashFn = (value: TValue | TLeaf) => TLeaf\n\nexport interface Options {\n  sortLeaves?: boolean\n  sortPairs?: boolean\n}\n\nexport type Proof = { position: 'left' | 'right'; data: Uint8Array }[]\n\nexport class MerkleTree extends Base {\n  private hashFn: THashFn\n  private leaves: TLeaf[] = []\n  private layers: TLayer[] = []\n  private sortLeaves: boolean = false\n  private sortPairs: boolean = false\n\n  constructor(leaves: any[], options: Options = {}) {\n    super()\n\n    this.sortLeaves = !!options.sortLeaves\n    this.sortPairs = !!options.sortPairs\n\n    this.hashFn = Base.bufferifyFn(ethers.keccak256)\n    this.processLeaves(leaves)\n  }\n\n  public getOptions() {\n    return {\n      sortLeaves: this.sortLeaves,\n      sortPairs: this.sortPairs\n    }\n  }\n\n  private processLeaves(leaves: TLeaf[]) {\n    this.leaves = leaves.map(Base.bufferify)\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(Base.compare)\n    }\n\n    this.createHashes(this.leaves)\n  }\n\n  private createHashes(nodes: Uint8Array[]) {\n    this.layers = [nodes]\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length\n\n      this.layers.push([])\n\n      const layerLimit = nodes.length\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          this.layers[layerIndex].push(...nodes.slice(layerLimit))\n          break\n        } else if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            this.layers[layerIndex].push(nodes[i])\n            continue\n          }\n        }\n\n        const left = nodes[i]\n        const right = i + 1 === nodes.length ? left : nodes[i + 1]\n        const combined = [left, right]\n\n        if (this.sortPairs) {\n          combined.sort(Base.compare)\n        }\n\n        const hash = this.hashFn(ethers.concat(combined))\n        this.layers[layerIndex].push(hash)\n      }\n\n      nodes = this.layers[layerIndex]\n    }\n  }\n\n  getRoot(): Uint8Array {\n    if (this.layers.length === 0) {\n      return Uint8Array.from([])\n    }\n\n    return this.layers[this.layers.length - 1][0] || Uint8Array.from([])\n  }\n\n  getHexRoot(): string {\n    return Base.bufferToHex(this.getRoot())\n  }\n\n  getProof(leaf: Uint8Array | string, index?: number): Proof {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required')\n    }\n    leaf = Base.bufferify(leaf)\n    const proof: Proof = []\n\n    if (!Number.isInteger(index)) {\n      index = -1\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (Base.compare(leaf, this.leaves[i]) === 0) {\n          index = i\n        }\n      }\n    }\n\n    // Type fix\n    index = index as number\n\n    if (index <= -1) {\n      return []\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i]\n      const isRightNode = index % 2\n      const pairIndex = isRightNode ? index - 1 : index + 1\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        })\n      }\n\n      // set index to parent index\n      index = (index / 2) | 0\n    }\n\n    return proof\n  }\n\n  getHexProof(leaf: Uint8Array | string, index?: number): string[] {\n    return this.getProof(leaf, index).map(item => Base.bufferToHex(item.data))\n  }\n\n  verify(proof: Proof | string[], targetNode: Uint8Array | string, root: Uint8Array | string): boolean {\n    let hash = Base.bufferify(targetNode)\n    root = Base.bufferify(root)\n\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false\n    }\n\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i]\n      let data: Uint8Array\n      let isLeftNode: boolean\n\n      if (typeof node === 'string') {\n        data = Base.bufferify(node)\n        isLeftNode = true\n      } else if (node instanceof Object) {\n        data = node.data\n        isLeftNode = node.position === 'left'\n      } else {\n        throw new Error('Expected node to be of type string or object')\n      }\n\n      const buffers: Uint8Array[] = []\n\n      if (this.sortPairs) {\n        if (Base.compare(hash, data) < 0) {\n          buffers.push(hash, data)\n        } else {\n          buffers.push(data, hash)\n        }\n        hash = this.hashFn(ethers.concat(buffers))\n      } else {\n        buffers.push(hash)\n        buffers[isLeftNode ? 'unshift' : 'push'](data)\n        hash = this.hashFn(ethers.concat(buffers))\n      }\n    }\n\n    return Base.compare(hash, root) === 0\n  }\n}\n","import { ethers } from 'ethers'\nimport { MerkleTree } from './merkletree'\n\nexport type ToLeaf<T> = (element: T) => string\nexport type Proof = string[]\n\nexport class MerkleTreeGenerator<T> {\n  private elements: T[]\n  private toLeaf: ToLeaf<T>\n  private tree: MerkleTree\n\n  constructor(elements: T[], toLeaf: ToLeaf<T>) {\n    this.elements = elements\n    this.toLeaf = toLeaf\n  }\n\n  generateTree(): MerkleTree {\n    const hashed = this.elements.map(e => this.toLeaf(e))\n    return new MerkleTree(hashed, {\n      sortPairs: true,\n      sortLeaves: true\n    })\n  }\n\n  generateRoot(): string {\n    if (!this.tree) this.tree = this.generateTree()\n    return this.tree.getHexRoot()\n  }\n\n  generateProof(element: T): Proof {\n    if (!this.elements.includes(element)) throw new Error('Element not found')\n    if (!this.tree) this.tree = this.generateTree()\n    return this.tree.getHexProof(this.toLeaf(element))\n  }\n\n  verifyProof(element: T, proof: Proof): boolean {\n    if (!this.elements.includes(element)) throw new Error('Element not found')\n    if (!this.tree) this.tree = this.generateTree()\n    return this.tree.verify(proof, this.toLeaf(element), this.generateRoot())\n  }\n}\n\nexport type SaleItemsElement = {\n  address: string\n  tokenId: ethers.BigNumberish\n}\n\nexport const getSaleItemsLeaf: ToLeaf<SaleItemsElement> = element =>\n  ethers.solidityPackedKeccak256(['address', 'uint256'], [element.address.toLowerCase(), element.tokenId])\n","import { ethers } from 'ethers'\n\n// export const getEthersConnectionInfo = (url: string, projectAccessKey?: string, jwt?: string): ConnectionInfo => {\n//   const headers: {\n//     [key: string]: string | number\n//   } = {}\n\n//   if (jwt && jwt.length > 0) {\n//     headers['Authorization'] = `BEARER ${jwt}`\n//   }\n//   if (projectAccessKey && projectAccessKey.length > 0) {\n//     headers['X-Access-Key'] = projectAccessKey\n//   }\n\n//   return {\n//     url,\n//     headers,\n//     skipFetchSetup: true,\n//     fetchOptions: {\n//       mode: 'cors',\n//       cache: 'force-cache',\n//       credentials: 'same-origin',\n//       redirect: 'follow',\n//       referrer: 'client'\n//     }\n//   }\n// }\n\nexport const getFetchRequest = (url: string, projectAccessKey?: string, jwt?: string): ethers.FetchRequest => {\n  const req = new ethers.FetchRequest(url)\n\n  if (jwt) {\n    req.setHeader('Authorization', `BEARER ${jwt}`)\n  }\n\n  if (projectAccessKey) {\n    req.setHeader('X-Access-Key', projectAccessKey)\n  }\n\n  return req\n}\n","import { ethers } from 'ethers'\n\nexport class PromiseCache {\n  private readonly cache: Map<string, Entry>\n\n  constructor() {\n    this.cache = new Map()\n  }\n\n  do<S extends Array<unknown>, T>(\n    key: string,\n    validMilliseconds: number | undefined,\n    task: (...args: S) => Promise<T>,\n    ...args: S\n  ): Promise<T> {\n    key = `${key}:${ethers.id(JSON.stringify(args, deterministically))}`\n\n    let entry = this.cache.get(key)\n\n    if (entry) {\n      if (entry.expiration) {\n        if (new Date() >= entry.expiration) {\n          entry = undefined\n          this.cache.delete(key)\n        }\n      }\n    }\n\n    if (!entry) {\n      const entry_: Entry = { promise: task(...args) }\n\n      if (validMilliseconds !== undefined) {\n        entry_.promise = entry_.promise.then(result => {\n          entry_.expiration = new Date(Date.now() + validMilliseconds)\n          return result\n        })\n      }\n\n      entry = entry_\n      this.cache.set(key, entry)\n    }\n\n    return entry.promise as Promise<T>\n  }\n}\n\ntype Entry = {\n  promise: Promise<unknown>\n  expiration?: Date\n}\n\nfunction deterministically(_key: string, value: any): any {\n  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n    return Object.fromEntries(Object.entries(value).sort())\n  }\n\n  return value\n}\n","export const getRandomInt = (min: number = 0, max: number = Number.MAX_SAFE_INTEGER): number => {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n","// sanitizeNumberString accepts a number string and returns back a clean number string.\n// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'\nexport const sanitizeNumberString = (numString: string | null): string => {\n  if (!numString || typeof numString !== 'string') {\n    return ''\n  }\n  const v = numString.match(/[\\d.]+/)\n  return v && v.length > 0 ? v[0].trim() : ''\n}\n\n// sanitizeAlphanumeric accepts any string and returns alphanumeric contents only\nexport const sanitizeAlphanumeric = (alphanum: string): string => {\n  if (!alphanum || typeof alphanum !== 'string') {\n    return ''\n  }\n  const v = alphanum.match(/[\\w\\s\\d]+/)\n  return v && v.length > 0 ? v[0].trim() : ''\n}\n\n// sanitizeHost accepts any string and returns valid host string\nexport const sanitizeHost = (host: string): string => {\n  if (!host || typeof host !== 'string') {\n    return ''\n  }\n  const v = host.match(/[\\w\\d.\\-:\\/]+/)\n  return v && v.length > 0 ? v[0].trim() : ''\n}\n","import { ethers, TypedDataDomain, TypedDataField } from 'ethers'\n\nexport interface TypedData {\n  domain: TypedDataDomain\n  types: Record<string, Array<TypedDataField>>\n  message: Record<string, any>\n  primaryType?: string\n}\n\nexport type { TypedDataDomain, TypedDataField }\n\nexport const encodeTypedDataHash = (typedData: TypedData): string => {\n  const types = { ...typedData.types }\n\n  // remove EIP712Domain key from types as ethers will auto-gen it in\n  // the hash encoder below\n  delete types['EIP712Domain']\n\n  return ethers.TypedDataEncoder.hash(typedData.domain, types, typedData.message)\n}\n\nexport const encodeTypedDataDigest = (typedData: TypedData): Uint8Array => {\n  return ethers.getBytes(encodeTypedDataHash(typedData))\n}\n","import { ethers } from 'ethers'\n\nconst { defineProperties, resolveProperties } = ethers\n\nexport { defineProperties, resolveProperties }\n\nexport type Optionals<T extends object> = Omit<\n  T,\n  Exclude<\n    {\n      [K in keyof T]: T extends Record<K, T[K]> ? K : never\n    }[keyof T],\n    undefined\n  >\n>\n\nexport type Mask<T, K> = Omit<T, keyof K>\n\nexport type Forbid<T, K extends keyof any> = T & {\n  [P in K]?: never\n}\n","import { ethers } from 'ethers'\nimport { Indexer } from '@0xsequence/indexer'\nimport { Relayer, RpcRelayerOptions } from '@0xsequence/relayer'\nimport { findNetworkConfig, stringTemplate, validateAndSortNetworks } from './utils'\nimport { isBigNumberish } from '@0xsequence/utils'\nimport { ChainId, NetworkMetadata, networks } from './constants'\n\nexport type NetworkConfig = NetworkMetadata & {\n  rpcUrl: string\n  provider?: ethers.Provider\n  indexerUrl?: string\n  indexer?: Indexer\n  relayer?: Relayer | RpcRelayerOptions\n\n  // isDefaultChain identifies the default network. For example, a dapp may run on the Polygon\n  // network and may configure the wallet to use it as its main/default chain.\n  isDefaultChain?: boolean\n\n  // Disabled / deprecated chain\n  disabled?: boolean\n}\n\ntype LegacyNetworkConfig = NetworkConfig & { isAuthChain?: boolean }\n\nexport const indexerURL = (network: string) => stringTemplate('https://${network}-indexer.sequence.app', { network })\nexport const relayerURL = (network: string) => stringTemplate('https://${network}-relayer.sequence.app', { network })\nexport const nodesURL = (network: string) => stringTemplate('https://nodes.sequence.app/${network}', { network })\n\nexport function findSupportedNetwork(chainIdOrName: string | ChainIdLike): NetworkConfig | undefined {\n  return findNetworkConfig(allNetworks, chainIdOrName)\n}\n\nexport type ChainIdLike = NetworkConfig | ethers.BigNumberish\n\nexport function toChainIdNumber(chainIdLike: ChainIdLike): bigint {\n  if (typeof chainIdLike === 'bigint') {\n    return chainIdLike\n  }\n\n  if (isBigNumberish(chainIdLike)) {\n    return BigInt(chainIdLike)\n  }\n\n  return BigInt(chainIdLike.chainId)\n}\n\nconst createNetworkConfig = (chainId: ChainId, options?: { disabled?: boolean }): NetworkConfig => {\n  const network = networks[chainId]\n\n  if (!network) {\n    throw new Error(`Network with chainId ${chainId} not found`)\n  }\n\n  const rpcUrl = nodesURL(network.name)\n\n  return {\n    ...network,\n    rpcUrl,\n    indexerUrl: indexerURL(network.name),\n    relayer: {\n      url: relayerURL(network.name),\n      provider: {\n        url: rpcUrl\n      }\n    },\n    ...options\n  }\n}\n\nexport const hardhatNetworks = [\n  {\n    ...networks[ChainId.HARDHAT],\n    rpcUrl: 'http://localhost:8545',\n    relayer: {\n      url: 'http://localhost:3000',\n      provider: {\n        url: 'http://localhost:8545'\n      }\n    }\n  },\n  {\n    ...networks[ChainId.HARDHAT_2],\n    rpcUrl: 'http://localhost:9545',\n    relayer: {\n      url: 'http://localhost:3000',\n      provider: {\n        url: 'http://localhost:9545'\n      }\n    }\n  }\n]\n\nexport const allNetworks = validateAndSortNetworks([\n  { ...createNetworkConfig(ChainId.POLYGON), isDefaultChain: true, isAuthChain: true } as LegacyNetworkConfig,\n  createNetworkConfig(ChainId.MAINNET),\n  createNetworkConfig(ChainId.BSC),\n  createNetworkConfig(ChainId.AVALANCHE),\n  createNetworkConfig(ChainId.ARBITRUM),\n  createNetworkConfig(ChainId.ARBITRUM_NOVA),\n  createNetworkConfig(ChainId.OPTIMISM),\n  createNetworkConfig(ChainId.OPTIMISM_SEPOLIA),\n  createNetworkConfig(ChainId.POLYGON_ZKEVM),\n  createNetworkConfig(ChainId.GNOSIS),\n  createNetworkConfig(ChainId.RINKEBY, { disabled: true }),\n  createNetworkConfig(ChainId.GOERLI, { disabled: true }),\n  createNetworkConfig(ChainId.SEPOLIA),\n  createNetworkConfig(ChainId.POLYGON_MUMBAI, { disabled: true }),\n  createNetworkConfig(ChainId.POLYGON_AMOY),\n  createNetworkConfig(ChainId.BSC_TESTNET),\n  createNetworkConfig(ChainId.ARBITRUM_SEPOLIA),\n  createNetworkConfig(ChainId.BASE),\n  createNetworkConfig(ChainId.BASE_SEPOLIA),\n  createNetworkConfig(ChainId.HOMEVERSE),\n  createNetworkConfig(ChainId.HOMEVERSE_TESTNET),\n  createNetworkConfig(ChainId.XAI),\n  createNetworkConfig(ChainId.XAI_SEPOLIA),\n  createNetworkConfig(ChainId.AVALANCHE_TESTNET),\n  createNetworkConfig(ChainId.XR_SEPOLIA),\n  createNetworkConfig(ChainId.B3),\n  createNetworkConfig(ChainId.B3_SEPOLIA),\n  createNetworkConfig(ChainId.APECHAIN),\n  createNetworkConfig(ChainId.APECHAIN_TESTNET),\n  createNetworkConfig(ChainId.BLAST),\n  createNetworkConfig(ChainId.BLAST_SEPOLIA),\n  createNetworkConfig(ChainId.TELOS),\n  createNetworkConfig(ChainId.BORNE_TESTNET),\n  createNetworkConfig(ChainId.SKALE_NEBULA),\n  createNetworkConfig(ChainId.SKALE_NEBULA_TESTNET),\n  createNetworkConfig(ChainId.SONEIUM_MINATO),\n  createNetworkConfig(ChainId.TOY_TESTNET),\n  createNetworkConfig(ChainId.IMMUTABLE_ZKEVM),\n  createNetworkConfig(ChainId.IMMUTABLE_ZKEVM_TESTNET),\n  createNetworkConfig(ChainId.ROOT_NETWORK),\n  createNetworkConfig(ChainId.ROOT_NETWORK_PORCINI),\n  ...hardhatNetworks\n])\n","import { EIP1193Provider, EIP1193ProviderFunc, JsonRpcMiddleware, JsonRpcMiddlewareHandler } from './types'\n\nexport class JsonRpcRouter implements EIP1193Provider {\n  private sender: EIP1193Provider\n  private handler: EIP1193Provider\n\n  constructor(middlewares: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>, sender: EIP1193Provider) {\n    this.sender = sender\n    if (middlewares) {\n      this.setMiddleware(middlewares)\n    }\n  }\n\n  setMiddleware(middlewares: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>) {\n    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender)\n  }\n\n  request(request: { id?: number; method: string; params?: any[]; chainId?: number }): Promise<any> {\n    return this.handler.request(request)\n  }\n}\n\nexport const createJsonRpcMiddlewareStack = (\n  middlewares: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>,\n  handler: EIP1193Provider\n): EIP1193Provider => {\n  if (middlewares.length === 0) return handler\n\n  const toMiddleware = (v: any): JsonRpcMiddleware => {\n    if (v.requestHandler) {\n      return (v as JsonRpcMiddlewareHandler).requestHandler\n    } else {\n      return v\n    }\n  }\n\n  let chain: EIP1193ProviderFunc\n  chain = toMiddleware(middlewares[middlewares.length - 1])(handler.request)\n  for (let i = middlewares.length - 2; i >= 0; i--) {\n    chain = toMiddleware(middlewares[i])(chain)\n  }\n  return { request: chain }\n}\n","import { ethers } from 'ethers'\nimport { JsonRpcSender } from './types'\n\n// TODOXXX: review..\nexport function isJsonRpcProvider(cand: any): cand is ethers.JsonRpcProvider {\n  return (\n    cand !== undefined &&\n    cand.send !== undefined &&\n    cand.constructor.defaultUrl !== undefined &&\n    cand.detectNetwork !== undefined &&\n    cand.getSigner !== undefined &&\n    cand.perform !== undefined\n  )\n}\n\nexport function isJsonRpcSender(cand: any): cand is JsonRpcSender {\n  return cand !== undefined && cand.send !== undefined\n}\n","import { ethers } from 'ethers'\nimport { EIP1193Provider, EIP1193ProviderFunc, JsonRpcSender } from './types'\n\nimport { isJsonRpcSender, isJsonRpcProvider } from './utils'\n\nexport class JsonRpcHandler implements EIP1193Provider, JsonRpcSender {\n  private provider: EIP1193ProviderFunc\n  private defaultChainId?: number\n\n  constructor(provider: EIP1193ProviderFunc | JsonRpcSender | ethers.JsonRpcProvider, defaultChainId?: number) {\n    if (isJsonRpcSender(provider)) {\n      this.provider = (request: { method: string; params?: any[]; chainId?: number }): Promise<any> => {\n        return provider.send(request.method, request.params, request.chainId)\n      }\n    } else if (isJsonRpcProvider(provider)) {\n      this.provider = (request: { method: string; params?: any[]; chainId?: number }): Promise<any> => {\n        return provider.send(request.method, request.params || [])\n      }\n    } else {\n      this.provider = provider\n    }\n    this.defaultChainId = defaultChainId\n  }\n\n  request = (request: { method: string; params?: any[]; chainId?: number }): Promise<any> => {\n    if (!request.chainId) {\n      request.chainId = this.defaultChainId\n    }\n    return this.provider(request)\n  }\n\n  send(method: string, params?: any[], chainId?: number): Promise<any> {\n    const request = {\n      method,\n      params,\n      chainId\n    }\n    return this.request(request)\n  }\n}\n","import { JsonRpcRequest, EIP1193ProviderFunc, JsonRpcMiddleware, JsonRpcMiddlewareHandler } from '../types'\n\nexport class AllowProvider implements JsonRpcMiddlewareHandler {\n  requestHandler: JsonRpcMiddleware\n\n  private isAllowedFunc: (request: JsonRpcRequest) => boolean\n\n  constructor(isAllowedFunc?: (request: JsonRpcRequest) => boolean) {\n    if (isAllowedFunc) {\n      this.isAllowedFunc = isAllowedFunc\n    } else {\n      this.isAllowedFunc = (request: JsonRpcRequest): boolean => true\n    }\n\n    this.requestHandler = allowProviderMiddleware(this.isAllowedFunc)\n  }\n\n  setIsAllowedFunc(fn: (request: JsonRpcRequest) => boolean) {\n    this.isAllowedFunc = fn\n    this.requestHandler = allowProviderMiddleware(this.isAllowedFunc)\n  }\n}\n\nexport const allowProviderMiddleware =\n  (isAllowed: (request: JsonRpcRequest) => boolean): JsonRpcMiddleware =>\n  (next: EIP1193ProviderFunc) => {\n    return (request: JsonRpcRequest): Promise<any> => {\n      // ensure precondition is met or do not allow the request to continue\n      if (!isAllowed(request)) {\n        throw new Error('allowProvider middleware precondition is unmet.')\n      }\n\n      // request is allowed. keep going..\n      return next(request)\n    }\n  }\n","import { EIP1193ProviderFunc, JsonRpcRequest, JsonRpcMiddlewareHandler } from '../types'\n\nexport interface CachedProviderOptions {\n  // defaultChainId passes a chainId to provider handler if one isn't passed.\n  // This is used in multi-chain mode\n  defaultChainId?: number\n\n  // blockCache toggle, with option to pass specific set of methods to use with\n  // the block cache.\n  blockCache?: boolean | string[]\n}\n\nexport class CachedProvider implements JsonRpcMiddlewareHandler {\n  // cachableJsonRpcMethods which can be permanently cached for lifetime\n  // of the provider.\n  private cachableJsonRpcMethods = [\n    'net_version',\n    'eth_chainId',\n    'eth_accounts',\n    'sequence_getWalletContext',\n    'sequence_getNetworks'\n  ]\n\n  // cachableJsonRpcMethodsByBlock which can be temporarily cached for a short\n  // period of time, essentially by block time. As we support chains fast blocks,\n  // we keep the values here cachable only for 1.5 seconds. This is still useful to\n  // memoize the calls within app-code that calls out to fetch these values within\n  // a short period of time.\n  private cachableJsonRpcMethodsByBlock: string[] = ['eth_call', 'eth_getCode']\n\n  // cache for life-time of provider (unless explicitly cleared)\n  private cache: { [key: string]: any }\n\n  // cache by block, simulated by using a 1 second life-time\n  private cacheByBlock: { [key: string]: any }\n  private cacheByBlockResetLock: boolean = false\n\n  // onUpdateCallback callback to be notified when cache values are set.\n  private onUpdateCallback?: (key?: string, value?: any) => void\n\n  // defaultChainId is used for default chain select with used with multi-chain provider\n  readonly defaultChainId?: number\n\n  constructor(options?: CachedProviderOptions) {\n    this.cache = {}\n    this.cacheByBlock = {}\n    this.defaultChainId = options?.defaultChainId\n    if (!options?.blockCache) {\n      this.cachableJsonRpcMethodsByBlock = []\n    } else if (options?.blockCache !== true) {\n      this.cachableJsonRpcMethodsByBlock = options?.blockCache\n    }\n  }\n\n  requestHandler = (next: EIP1193ProviderFunc) => {\n    return async (request: JsonRpcRequest): Promise<any> => {\n      // Respond early with cached result\n      if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {\n        const key = this.cacheKey(request.method, request.params! as any[], request.chainId || this.defaultChainId)\n        const result = this.getCacheValue(key)\n        if (result && result !== '') {\n          return {\n            id: request.id!,\n            result\n          }\n        }\n      }\n\n      // Continue down the handler chain\n      const result = await next(request)\n\n      // Store result in cache and continue\n      if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {\n        if (result && this.shouldCacheResponse(request, result)) {\n          // cache the value\n          const key = this.cacheKey(request.method, request.params! as any[], request.chainId || this.defaultChainId)\n\n          if (this.cachableJsonRpcMethods.includes(request.method)) {\n            this.setCacheValue(key, result)\n          } else {\n            this.setCacheByBlockValue(key, result)\n          }\n        }\n      }\n\n      return result\n    }\n  }\n\n  cacheKey = (method: string, params: any[], chainId?: number) => {\n    let key = ''\n    if (chainId) {\n      key = `${chainId}:${method}:`\n    } else {\n      key = `:${method}:`\n    }\n    if (!params || params.length === 0) {\n      return key + '[]'\n    }\n    return key + JSON.stringify(params)\n  }\n\n  getCache = () => this.cache\n\n  setCache = (cache: { [key: string]: any }) => {\n    this.cache = cache\n    if (this.onUpdateCallback) {\n      this.onUpdateCallback()\n    }\n  }\n\n  getCacheValue = (key: string): any => {\n    if (this.cache[key]) {\n      return this.cache[key]\n    }\n    if (this.cacheByBlock[key]) {\n      return this.cacheByBlock[key]\n    }\n    return undefined\n  }\n\n  setCacheValue = (key: string, value: any) => {\n    this.cache[key] = value\n    if (this.onUpdateCallback) {\n      this.onUpdateCallback(key, value)\n    }\n  }\n\n  setCacheByBlockValue = (key: string, value: any) => {\n    this.cacheByBlock[key] = value\n\n    // clear the cacheByBlock once every X period of time\n    if (!this.cacheByBlockResetLock) {\n      this.cacheByBlockResetLock = true\n      setTimeout(() => {\n        this.cacheByBlockResetLock = false\n        this.cacheByBlock = {}\n      }, 1500) // 1.5 second cache lifetime\n    }\n  }\n\n  shouldCacheResponse = (request: JsonRpcRequest, result?: any): boolean => {\n    // skip if we do not have response result\n    if (!result) {\n      return false\n    }\n\n    // skip caching eth_getCode where resposne value is '0x' or empty\n    if (request.method === 'eth_getCode' && result.length <= 2) {\n      return false\n    }\n\n    // all good -- signal to cache the result\n    return true\n  }\n\n  onUpdate(callback: (key?: string, value?: any) => void) {\n    this.onUpdateCallback = callback\n  }\n\n  clearCache = () => {\n    this.cache = {}\n    this.cacheByBlock = {}\n  }\n}\n","import { commons } from '@0xsequence/core'\nimport { ethers } from 'ethers'\nimport { EIP1193ProviderFunc, JsonRpcMiddlewareHandler, JsonRpcRequest } from '../types'\n\n// EagerProvider will eagerly respond to a provider request from pre-initialized data values.\n//\n// This is useful for saving a few remote calls for responses we're already expecting when\n// communicating to a specific network provider.\n\nexport type EagerProviderOptions = {\n  accountAddress?: string\n  chainId?: number\n  walletContext?: commons.context.VersionedContext\n}\n\nexport class EagerProvider implements JsonRpcMiddlewareHandler {\n  readonly options: EagerProviderOptions\n\n  constructor(options: EagerProviderOptions) {\n    this.options = options\n  }\n\n  requestHandler = (next: EIP1193ProviderFunc) => {\n    return async (request: JsonRpcRequest): Promise<any> => {\n      switch (request.method) {\n        case 'net_version':\n          if (this.options.chainId) {\n            return `${this.options.chainId}`\n          }\n          break\n\n        case 'eth_chainId':\n          if (this.options.chainId) {\n            return ethers.toQuantity(this.options.chainId)\n          }\n          break\n\n        case 'eth_accounts':\n          if (this.options.accountAddress) {\n            return [ethers.getAddress(this.options.accountAddress)]\n          }\n          break\n\n        case 'sequence_getWalletContext':\n          if (this.options.walletContext) {\n            return this.options.walletContext\n          }\n          break\n\n        default:\n      }\n\n      return next(request)\n    }\n  }\n}\n","import { EIP1193ProviderFunc, JsonRpcMiddleware } from '../types'\n\nexport const exceptionProviderMiddleware: JsonRpcMiddleware = (next: EIP1193ProviderFunc) => {\n  return async (request: { method: string; params?: any[]; chainId?: number }): Promise<any> => {\n    try {\n      return await next(request)\n    } catch (error) {\n      if (typeof error === 'string') {\n        throw new Error(error)\n      } else {\n        throw new Error(error.message)\n      }\n    }\n  }\n}\n","import { EIP1193ProviderFunc, JsonRpcMiddleware, JsonRpcRequest } from '../types'\nimport { logger } from '@0xsequence/utils'\n\n// TODO: rename to loggerMiddleware\nexport const loggingProviderMiddleware: JsonRpcMiddleware = (next: EIP1193ProviderFunc) => {\n  return async (request: JsonRpcRequest): Promise<any> => {\n    const chainIdLabel = request.chainId ? ` chainId:${request.chainId}` : ''\n    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params)\n\n    try {\n      const result = await next(request)\n\n      logger.info(\n        `[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`,\n        request.params,\n        `result:`,\n        result\n      )\n\n      return result\n    } catch (error) {\n      logger.warn(\n        `[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`,\n        request.params,\n        `error:`,\n        error\n      )\n    }\n  }\n}\n","import { EIP1193Provider, EIP1193ProviderFunc, JsonRpcMiddlewareHandler, JsonRpcRequest } from '../types'\n\nexport const SignerJsonRpcMethods = [\n  'personal_sign',\n  'eth_sign',\n  'eth_signTypedData',\n  'eth_signTypedData_v4',\n  'eth_sendTransaction',\n  'eth_sendRawTransaction',\n  'sequence_sign', // sequence-aware personal_sign\n  'sequence_signTypedData_v4', // sequence-aware eth_signTypedData_v4\n\n  'sequence_getWalletContext',\n  'sequence_getWalletConfig',\n  'sequence_getWalletState',\n  'sequence_getNetworks',\n  'sequence_updateConfig',\n  'sequence_publishConfig',\n  'sequence_gasRefundOptions',\n  'sequence_getNonce',\n  'sequence_relay',\n\n  'eth_decrypt',\n  'eth_getEncryptionPublicKey',\n  'wallet_addEthereumChain',\n  'wallet_switchEthereumChain',\n  'wallet_registerOnboarding',\n  'wallet_watchAsset',\n  'wallet_scanQRCode'\n]\n\nexport class SigningProvider implements JsonRpcMiddlewareHandler {\n  private provider: EIP1193Provider\n\n  constructor(provider: EIP1193Provider) {\n    this.provider = provider\n  }\n\n  requestHandler = (next: EIP1193ProviderFunc) => {\n    return (request: JsonRpcRequest): Promise<any> => {\n      // Forward signing requests to the signing provider\n      if (SignerJsonRpcMethods.includes(request.method)) {\n        return this.provider.request(request)\n      }\n\n      // Continue to next handler\n      return next(request)\n    }\n  }\n}\n","import { EIP1193ProviderFunc, JsonRpcResponseCallback, JsonRpcMiddlewareHandler, JsonRpcRequest } from '../types'\n\nexport class SingleflightMiddleware implements JsonRpcMiddlewareHandler {\n  private singleflightJsonRpcMethods = [\n    'eth_chainId',\n    'net_version',\n    'eth_call',\n    'eth_getCode',\n    'eth_blockNumber',\n    'eth_getBalance',\n    'eth_getStorageAt',\n    'eth_getTransactionCount',\n    'eth_getBlockTransactionCountByHash',\n    'eth_getBlockTransactionCountByNumber',\n    'eth_getUncleCountByBlockHash',\n    'eth_getUncleCountByBlockNumber',\n    'eth_getBlockByHash',\n    'eth_getBlockByNumber',\n    'eth_getTransactionByHash',\n    'eth_getTransactionByBlockHashAndIndex',\n    'eth_getTransactionByBlockNumberAndIndex',\n    'eth_getTransactionReceipt',\n    'eth_getUncleByBlockHashAndIndex',\n    'eth_getUncleByBlockNumberAndIndex',\n    'eth_getLogs'\n  ]\n\n  inflight: { [key: string]: { id: number; callback: JsonRpcResponseCallback }[] }\n\n  constructor() {\n    this.inflight = {}\n  }\n\n  requestHandler = (next: EIP1193ProviderFunc) => {\n    return async (request: JsonRpcRequest): Promise<any> => {\n      // continue to next handler if method isn't part of methods list\n      if (!this.singleflightJsonRpcMethods.includes(request.method)) {\n        return next(request)\n      }\n\n      const key = this.requestKey(request.method, request.params || [], request.chainId)\n\n      if (!this.inflight[key]) {\n        // first request -- init the empty list\n        this.inflight[key] = []\n      } else {\n        // already in-flight, add the callback to the list and return\n        return new Promise<any>((resolve, reject) => {\n          this.inflight[key].push({\n            id: request.id!,\n            callback: (error: any, response: any) => {\n              if (error) {\n                reject(error)\n              } else {\n                resolve(response)\n              }\n            }\n          })\n        })\n      }\n\n      // Continue down the handler chain\n      try {\n        // Exec the handler, and on success resolve all other promises\n        const response = await next(request)\n        this.inflight[key].forEach(({ callback }) => callback(undefined, response))\n        return response\n      } catch (error) {\n        // If the request fails, reject all queued promises.\n        this.inflight[key].forEach(({ callback }) => callback(error, undefined))\n        throw error\n      } finally {\n        delete this.inflight[key]\n      }\n    }\n  }\n\n  requestKey = (method: string, params: any[], chainId?: number) => {\n    let key = ''\n    if (chainId) {\n      key = `${chainId}:${method}:`\n    } else {\n      key = `:${method}:`\n    }\n    if (!params || params.length === 0) {\n      return key + '[]'\n    }\n    return key + JSON.stringify(params)\n  }\n}\n","import { ethers } from 'ethers'\nimport {\n  JsonRpcRouter,\n  EagerProvider,\n  SingleflightMiddleware,\n  CachedProvider,\n  JsonRpcMiddleware,\n  JsonRpcMiddlewareHandler,\n  JsonRpcHandler,\n  EIP1193Provider,\n  JsonRpcSender,\n  JsonRpcRequest\n} from './json-rpc'\nimport { ChainId, networks } from './constants'\n\nexport interface JsonRpcProviderOptions {\n  // ..\n  chainId?: number\n\n  // ..\n  middlewares?: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>\n\n  // ..\n  blockCache?: boolean | string[]\n}\n\n// JsonRpcProvider with a middleware stack. By default it will use a simple caching middleware.\nexport class JsonRpcProvider extends ethers.JsonRpcProvider implements EIP1193Provider, JsonRpcSender {\n  #chainId?: number\n  #nextId: number = 1\n  #sender: EIP1193Provider\n\n  constructor(\n    public url: string | ethers.FetchRequest | undefined,\n    options?: JsonRpcProviderOptions,\n    jsonRpcApiProviderOptions?: ethers.JsonRpcApiProviderOptions\n  ) {\n    super(url, options?.chainId, jsonRpcApiProviderOptions)\n\n    const chainId = options?.chainId\n    const middlewares = options?.middlewares\n    const blockCache = options?.blockCache\n\n    this.#chainId = chainId\n\n    // NOTE: it will either use the middleware stack passed to the constructor\n    // or it will use the default caching middleware provider. It does not concat them,\n    // so if you set middlewares, make sure you set the caching middleware yourself if you'd\n    // like to keep using it.\n    const router = new JsonRpcRouter(\n      middlewares ?? [\n        // loggingProviderMiddleware,\n        new EagerProvider({ chainId }),\n        new SingleflightMiddleware(),\n        new CachedProvider({ defaultChainId: chainId, blockCache: blockCache })\n      ],\n      new JsonRpcHandler(this.fetch, chainId)\n    )\n\n    this.#sender = router\n  }\n\n  async request(request: { method: string; params?: any[]; chainId?: number }): Promise<any> {\n    return this.#sender.request(request)\n  }\n\n  async send(method: string, params?: any[] | Record<string, any>, chainId?: number): Promise<any> {\n    return this.request({ method, params: params as any, chainId })\n  }\n\n  async getNetwork(): Promise<ethers.Network> {\n    const chainId = this.#chainId\n    if (chainId) {\n      const network = networks[chainId as ChainId]\n      const name = network?.name || ''\n      const ensAddress = network?.ensAddress\n      return ethers.Network.from({\n        name,\n        chainId,\n        ensAddress\n      })\n    } else {\n      const chainIdHex = await this.send('eth_chainId', [])\n      this.#chainId = Number(chainIdHex)\n      return this.getNetwork()\n    }\n  }\n\n  private fetch = async (request: { method: string; params?: any[]; chainId?: number }): Promise<any> => {\n    if (this.url === undefined) {\n      throw new Error('missing provider URL')\n    }\n\n    const { method, params } = request\n\n    const jsonRpcRequest: JsonRpcRequest = {\n      method,\n      params,\n      id: this.#nextId++,\n      jsonrpc: '2.0'\n    }\n\n    // const result = ethers.fetchJson(this.connection, JSON.stringify(request), getResult).then(\n    //   result => {\n    //     return result\n    //   },\n    //   error => {\n    //     throw error\n    //   }\n    // )\n\n    const fetchRequest = typeof this.url === 'string' ? new ethers.FetchRequest(this.url) : this.url\n    fetchRequest.body = JSON.stringify(jsonRpcRequest)\n\n    // TODOXXX: what about headers, etc..?\n    // we probably need these in the options of the construtor, etc..\n\n    try {\n      const res = await fetchRequest.send()\n\n      if (res.body) {\n        try {\n          const result = JSON.parse(ethers.toUtf8String(res.body))\n\n          // TODO: Process result\n\n          return getResult(result)\n        } catch (err) {\n          throw new Error('invalid JSON response')\n        }\n      }\n\n      return null\n    } catch (err) {\n      // TODO - error handling\n      throw err\n    }\n  }\n}\n\nfunction getResult(payload: { error?: { code?: number; data?: any; message?: string }; result?: any }): any {\n  if (payload.error) {\n    // @TODO: not any\n    const error: any = new Error(payload.error.message)\n    error.code = payload.error.code\n    error.data = payload.error.data\n    throw error\n  }\n  return payload.result\n}\n","import { ethers } from 'ethers'\nimport * as config from './config'\n\nexport type SignaturePart = {\n  signature: string\n  isDynamic: boolean\n}\n\nexport type Signature<T extends config.Config> = {\n  version: number\n  config: T\n  subdigest: string\n  payload?: SignedPayload\n}\n\nexport type UnrecoveredSignature = {\n  version: number\n}\n\nexport type SignedPayload = {\n  message?: ethers.BytesLike\n  digest: string\n  chainId: ethers.BigNumberish\n  address: string\n}\n\nexport interface SignatureCoder<\n  Y extends config.Config = config.Config,\n  T extends Signature<Y> = Signature<Y>,\n  Z extends UnrecoveredSignature = UnrecoveredSignature\n> {\n  decode: (data: string) => Z\n  encode: (data: T | Z | ethers.BytesLike) => string\n\n  trim: (data: string) => Promise<string>\n\n  recover: (data: Z, payload: SignedPayload, provider: ethers.Provider) => Promise<T>\n\n  supportsNoChainId: boolean\n\n  encodeSigners: (\n    config: Y,\n    signatures: Map<string, SignaturePart>,\n    subdigests: string[],\n    chainId: ethers.BigNumberish\n  ) => {\n    encoded: string\n    weight: bigint\n  }\n\n  hasEnoughSigningPower: (config: Y, signatures: Map<string, SignaturePart>) => boolean\n\n  chainSignatures: (main: T | Z | ethers.BytesLike, suffixes: (T | Z | ethers.BytesLike)[]) => string\n\n  hashSetImageHash: (imageHash: string) => string\n\n  signaturesOf: (config: Y) => { address: string; signature: string }[]\n\n  signaturesOfDecoded: (decoded: Z) => string[]\n}\n\nexport function subdigestOf(payload: SignedPayload) {\n  return ethers.solidityPackedKeccak256(\n    ['bytes', 'uint256', 'address', 'bytes32'],\n    ['0x1901', payload.chainId, payload.address, payload.digest]\n  )\n}\n\nexport function isSignedPayload(payload: any): payload is SignedPayload {\n  return payload.digest !== undefined && payload.chainId !== undefined && payload.address !== undefined\n}\n","import { ethers } from 'ethers'\n\nconst EIP1271_MAGIC_VALUE = '0x1626ba7e'\n\nconst EIP1271_ABI = [\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        type: 'bytes32'\n      },\n      {\n        internalType: 'bytes',\n        type: 'bytes'\n      }\n    ],\n    name: 'isValidSignature',\n    outputs: [\n      {\n        internalType: 'bytes4',\n        type: 'bytes4'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  }\n]\n\nexport async function isValidEIP1271Signature(\n  address: string,\n  digest: string,\n  signature: ethers.BytesLike,\n  provider: ethers.Provider\n): Promise<boolean> {\n  const contract = new ethers.Contract(address, EIP1271_ABI, provider)\n  const result = await contract.isValidSignature(digest, signature)\n  return result === EIP1271_MAGIC_VALUE\n}\n","import { ethers } from 'ethers'\nimport { isValidEIP1271Signature } from './validateEIP1271'\n\nexport enum SigType {\n  EIP712 = 1,\n  ETH_SIGN = 2,\n  WALLET_BYTES32 = 3\n}\n\nexport function canRecover(signature: ethers.BytesLike) {\n  const bytes = ethers.getBytes(signature)\n  const type = bytes[bytes.length - 1]\n\n  return type === SigType.EIP712 || type === SigType.ETH_SIGN\n}\n\nexport function recoverSigner(digest: ethers.BytesLike, signature: ethers.BytesLike) {\n  const bytes = ethers.getBytes(signature)\n  const digestBytes = ethers.getBytes(digest)\n\n  // type is last byte\n  const type = bytes[bytes.length - 1]\n\n  // Split r:s:v\n  const r = ethers.hexlify(bytes.slice(0, 32))\n  const s = ethers.hexlify(bytes.slice(32, 64))\n  const v = Number(ethers.hexlify(bytes.slice(64, 65)))\n\n  const splitSignature = { r, s, v }\n\n  if (type === SigType.EIP712) {\n    return ethers.recoverAddress(digestBytes, splitSignature)\n  }\n\n  if (type === SigType.ETH_SIGN) {\n    return ethers.recoverAddress(ethers.hashMessage(digestBytes), splitSignature)\n  }\n\n  throw new Error(`Unsupported signature type: ${type}`)\n}\n\nexport function isValidSignature(\n  address: string,\n  digest: ethers.BytesLike,\n  signature: ethers.BytesLike,\n  provider: ethers.Provider\n) {\n  const bytes = ethers.getBytes(signature)\n\n  // type is last byte\n  const type = bytes[bytes.length - 1]\n\n  if (type === SigType.EIP712 || type === SigType.ETH_SIGN) {\n    return address === recoverSigner(digest, signature)\n  }\n\n  if (type === SigType.WALLET_BYTES32) {\n    return isValidEIP1271Signature(address, ethers.hexlify(digest), bytes.slice(0, -1), provider)\n  }\n\n  throw new Error(`Unsupported signature type: ${type}`)\n}\n\nexport function tryRecoverSigner(digest: ethers.BytesLike, signature: ethers.BytesLike): string | undefined {\n  const bytes = ethers.getBytes(signature)\n  if (bytes.length !== 66) return undefined\n\n  try {\n    return recoverSigner(digest, bytes)\n  } catch {}\n\n  return undefined\n}\n","import { ethers } from 'ethers'\nimport * as base from '../commons/signature'\nimport { AddressMember, WalletConfig } from './config'\nimport { isValidSignature, recoverSigner } from '../commons/signer'\n\nexport enum SignaturePartType {\n  EOASignature = 0,\n  Address = 1,\n  DynamicSignature = 2\n}\n\nexport type Signature = base.Signature<WalletConfig>\n\nexport type UnrecoveredSignatureMember = {\n  unrecovered: true\n  weight: ethers.BigNumberish\n  signature: string\n  address?: string\n  isDynamic: boolean\n}\n\nexport type UnrecoveredMember = AddressMember | UnrecoveredSignatureMember\n\nexport type UnrecoveredSignature = base.UnrecoveredSignature & {\n  threshold: ethers.BigNumberish\n  signers: UnrecoveredMember[]\n}\n\nexport function isAddressMember(member: any): member is AddressMember {\n  return (member as AddressMember).address !== undefined && !isUnrecoveredSignatureMember(member)\n}\n\nexport function isUnrecoveredSignatureMember(member: any): member is UnrecoveredSignatureMember {\n  return (\n    (member as UnrecoveredSignatureMember).signature !== undefined &&\n    (member as UnrecoveredSignatureMember).weight !== undefined &&\n    (member as UnrecoveredSignatureMember).isDynamic !== undefined\n  )\n}\n\nexport function isUnrecoveredSignature(signature: Signature | UnrecoveredSignature): signature is UnrecoveredSignature {\n  return (signature as UnrecoveredSignature).threshold !== undefined && (signature as UnrecoveredSignature).signers !== undefined\n}\n\nexport function decodeSignature(signature: ethers.BytesLike): UnrecoveredSignature {\n  const bytes = ethers.getBytes(signature)\n\n  const threshold = (bytes[0] << 8) | bytes[1]\n  const signers: UnrecoveredMember[] = []\n\n  for (let i = 2; i < bytes.length; ) {\n    const type = bytes[i++]\n    const weight = bytes[i++]\n\n    switch (type) {\n      case SignaturePartType.EOASignature:\n        signers.push({\n          unrecovered: true,\n          weight,\n          signature: ethers.hexlify(bytes.slice(i, i + 66)),\n          isDynamic: false\n        })\n        i += 66\n        break\n\n      case SignaturePartType.Address:\n        signers.push({\n          weight,\n          address: ethers.getAddress(ethers.hexlify(bytes.slice(i, i + 20)))\n        })\n        i += 20\n        break\n\n      case SignaturePartType.DynamicSignature:\n        const address = ethers.getAddress(ethers.hexlify(bytes.slice(i, i + 20)))\n        i += 20\n\n        const size = (bytes[i] << 8) | bytes[i + 1]\n        i += 2\n\n        signers.push({\n          unrecovered: true,\n          weight,\n          signature: ethers.hexlify(bytes.slice(i, i + size)),\n          address,\n          isDynamic: true\n        })\n        i += size\n        break\n\n      default:\n        throw new Error(`Unknown signature part type: ${type}`)\n    }\n  }\n\n  return { version: 1, threshold, signers }\n}\n\nexport function encodeSignature(signature: Signature | UnrecoveredSignature | ethers.BytesLike): string {\n  if (ethers.isBytesLike(signature)) {\n    return ethers.hexlify(signature)\n  }\n\n  const { signers, threshold } = isUnrecoveredSignature(signature) ? signature : signature.config\n\n  const encodedSigners = signers.map(s => {\n    if (isAddressMember(s)) {\n      return ethers.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, s.weight, s.address])\n    }\n\n    if (s.isDynamic) {\n      const bytes = ethers.getBytes(s.signature)\n      return ethers.solidityPacked(\n        ['uint8', 'uint8', 'address', 'uint16', 'bytes'],\n        [SignaturePartType.DynamicSignature, s.weight, s.address, bytes.length, bytes]\n      )\n    }\n\n    return ethers.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.EOASignature, s.weight, s.signature])\n  })\n\n  return ethers.solidityPacked(['uint16', ...new Array(encodedSigners.length).fill('bytes')], [threshold, ...encodedSigners])\n}\n\nexport async function recoverSignature(\n  data: UnrecoveredSignature,\n  payload: base.SignedPayload,\n  provider: ethers.Provider\n): Promise<Signature> {\n  const subdigest = base.subdigestOf(payload)\n  const signers = await Promise.all(\n    data.signers.map(async s => {\n      if (isAddressMember(s)) {\n        return s\n      }\n\n      if (s.isDynamic) {\n        if (!s.address) throw new Error('Dynamic signature part must have address')\n        if (!isValidSignature(s.address, subdigest, s.signature, provider)) {\n          throw new Error(`Invalid dynamic signature part ${s.address}`)\n        }\n\n        return { address: s.address, weight: s.weight, signature: s.signature }\n      } else {\n        const address = recoverSigner(subdigest, s.signature)\n        return { address, weight: s.weight, signature: s.signature }\n      }\n    })\n  )\n\n  return {\n    version: 1,\n    payload,\n    subdigest,\n    config: {\n      version: 1,\n      threshold: data.threshold,\n      signers\n    }\n  }\n}\n\nexport function encodeSigners(\n  config: WalletConfig,\n  signatures: Map<string, base.SignaturePart>,\n  subdigests: string[],\n  _: ethers.BigNumberish\n): { encoded: string; weight: bigint } {\n  if (subdigests.length !== 0) {\n    throw new Error('Explicit subdigests not supported on v1')\n  }\n\n  let weight = 0n\n  const parts = config.signers.map(s => {\n    if (!signatures.has(s.address)) {\n      return s\n    }\n\n    const signature = signatures.get(s.address)!\n    const bytes = ethers.getBytes(signature.signature)\n\n    weight += BigInt(s.weight)\n\n    if (signature.isDynamic || bytes.length !== 66) {\n      return {\n        ...s,\n        isDynamic: true,\n        signature: signature.signature,\n        address: s.address\n      }\n    }\n\n    return {\n      ...s,\n      isDynamic: false,\n      signature: signature.signature\n    }\n  })\n\n  const encoded = encodeSignature({ version: 1, threshold: config.threshold, signers: parts })\n  return { encoded, weight }\n}\n\nexport const SignatureCoder: base.SignatureCoder<WalletConfig, Signature, UnrecoveredSignature> = {\n  decode: (data: string): UnrecoveredSignature => {\n    return decodeSignature(data)\n  },\n\n  encode: (data: Signature | UnrecoveredSignature | ethers.BytesLike): string => {\n    return encodeSignature(data)\n  },\n\n  trim: async (data: string): Promise<string> => {\n    return data\n  },\n\n  supportsNoChainId: true,\n\n  recover: (data: UnrecoveredSignature, payload: base.SignedPayload, provider: ethers.Provider): Promise<Signature> => {\n    return recoverSignature(data, payload, provider)\n  },\n\n  encodeSigners: (\n    config: WalletConfig,\n    signatures: Map<string, base.SignaturePart>,\n    subdigests: string[],\n    chainId: ethers.BigNumberish\n  ): {\n    encoded: string\n    weight: bigint\n  } => {\n    return encodeSigners(config, signatures, subdigests, chainId)\n  },\n\n  hasEnoughSigningPower: (config: WalletConfig, signatures: Map<string, base.SignaturePart>): boolean => {\n    const { weight } = SignatureCoder.encodeSigners(config, signatures, [], 0)\n    return weight >= BigInt(config.threshold)\n  },\n\n  chainSignatures: (\n    _main: Signature | UnrecoveredSignature | ethers.BytesLike,\n    _suffix: (Signature | UnrecoveredSignature | ethers.BytesLike)[]\n  ): string => {\n    throw new Error('Signature chaining not supported on v1')\n  },\n\n  hashSetImageHash: function (_imageHash: string): string {\n    throw new Error('Image hash not supported on v1')\n  },\n\n  signaturesOf(config: WalletConfig): { address: string; signature: string }[] {\n    return config.signers.filter(s => s.signature !== undefined).map(s => ({ address: s.address, signature: s.signature! }))\n  },\n\n  signaturesOfDecoded: function (data: UnrecoveredSignature): string[] {\n    return data.signers.map(s => s.signature).filter(s => s !== undefined) as string[]\n  }\n}\n","import { ethers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { commons } from '..'\nimport { encodeSigners } from './signature'\nimport { SimpleConfig } from '../commons/config'\n\nexport type AddressMember = {\n  weight: ethers.BigNumberish\n  address: string\n  signature?: string\n}\n\nexport type WalletConfig = commons.config.Config & {\n  threshold: ethers.BigNumberish\n  signers: AddressMember[]\n}\n\nexport const ConfigCoder: commons.config.ConfigCoder<WalletConfig> = {\n  isWalletConfig: (config: commons.config.Config): config is WalletConfig => {\n    return (\n      config.version === 1 && (config as WalletConfig).threshold !== undefined && (config as WalletConfig).signers !== undefined\n    )\n  },\n\n  imageHashOf: (config: WalletConfig): string => {\n    return config.signers.reduce(\n      (imageHash, signer) =>\n        ethers.keccak256(\n          ethers.AbiCoder.defaultAbiCoder().encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])\n        ),\n      ethers.solidityPacked(['uint256'], [config.threshold])\n    )\n  },\n\n  hasSubdigest: (_walletConfig: WalletConfig, _subdigest: string): boolean => {\n    // v1 does not support explicit subdigests\n    return false\n  },\n\n  isComplete: (_config: WalletConfig): boolean => {\n    // v1 does not support incomplete configs\n    return true\n  },\n\n  checkpointOf: (_config: WalletConfig): bigint => {\n    return 0n\n  },\n\n  signersOf: (config: WalletConfig): { address: string; weight: number }[] => {\n    return config.signers.map(s => ({ address: s.address, weight: Number(s.weight) }))\n  },\n\n  fromSimple: (config: SimpleConfig): WalletConfig => {\n    if (BigInt(config.checkpoint) !== 0n) {\n      throw new Error('v1 wallet config does not support checkpoint')\n    }\n\n    if (config.subdigests && config.subdigests.length > 0) {\n      throw new Error('v1 wallet config does not support subdigests')\n    }\n\n    return {\n      version: 1,\n      threshold: config.threshold,\n      signers: config.signers\n    }\n  },\n\n  update: {\n    isKindUsed: true,\n\n    buildTransaction: (\n      wallet: string,\n      config: WalletConfig,\n      context: commons.context.WalletContext,\n      kind?: 'first' | 'later' | undefined\n    ): commons.transaction.TransactionBundle => {\n      const module = new ethers.Interface([...walletContracts.mainModule.abi, ...walletContracts.mainModuleUpgradable.abi])\n\n      const transactions: commons.transaction.Transaction[] = []\n\n      if (!kind || kind === 'first') {\n        transactions.push({\n          to: wallet,\n          data: module.encodeFunctionData(module.getFunction('updateImplementation')!, [context.mainModuleUpgradable]),\n          gasLimit: 0,\n          delegateCall: false,\n          revertOnError: true,\n          value: 0\n        })\n      }\n\n      transactions.push({\n        to: wallet,\n        data: module.encodeFunctionData(module.getFunction('updateImageHash')!, [ConfigCoder.imageHashOf(config)]),\n        gasLimit: 0,\n        delegateCall: false,\n        revertOnError: true,\n        value: 0\n      })\n\n      return {\n        entrypoint: wallet,\n        transactions\n      }\n    },\n    decodeTransaction: function (tx: commons.transaction.TransactionBundle): {\n      address: string\n      newImageHash: string\n      kind: 'first' | 'later' | undefined\n    } {\n      throw new Error('Function not implemented.')\n    }\n  },\n\n  toJSON: function (config: WalletConfig): string {\n    const plainMembers = config.signers.map(signer => {\n      return {\n        weight: BigInt(signer.weight).toString(),\n        address: signer.address\n      }\n    })\n\n    return JSON.stringify({\n      version: config.version,\n      threshold: BigInt(config.threshold).toString(),\n      signers: plainMembers\n    })\n  },\n\n  fromJSON: function (json: string): WalletConfig {\n    const parsed = JSON.parse(json)\n\n    const signers = parsed.signers.map((signer: any) => {\n      return {\n        weight: BigInt(signer.weight),\n        address: signer.address\n      }\n    })\n\n    return {\n      version: parsed.version,\n      threshold: BigInt(parsed.threshold),\n      signers\n    }\n  },\n\n  editConfig: function (\n    config: WalletConfig,\n    action: {\n      add?: commons.config.SimpleSigner[]\n      remove?: string[]\n      threshold?: ethers.BigNumberish\n      checkpoint?: ethers.BigNumberish\n    }\n  ): WalletConfig {\n    const newSigners = config.signers.slice()\n\n    if (action.checkpoint && BigInt(action.checkpoint) !== 0n) {\n      throw new Error('v1 wallet config does not support checkpoint')\n    }\n\n    if (action.add) {\n      for (const signer of action.add) {\n        if (newSigners.find(s => s.address === signer.address)) {\n          continue\n        }\n\n        newSigners.push({\n          weight: signer.weight,\n          address: signer.address\n        })\n      }\n    }\n\n    if (action.remove) {\n      for (const address of action.remove) {\n        const index = newSigners.findIndex(signer => signer.address === address)\n        if (index >= 0) {\n          newSigners.splice(index, 1)\n        }\n      }\n    }\n\n    return {\n      version: config.version,\n      threshold: action.threshold ?? config.threshold,\n      signers: newSigners\n    }\n  },\n\n  buildStubSignature: function (config: WalletConfig, overrides: Map<string, string>) {\n    const parts = new Map<string, commons.signature.SignaturePart>()\n\n    for (const [signer, signature] of overrides.entries()) {\n      parts.set(signer, { signature, isDynamic: true })\n\n      const { encoded, weight } = encodeSigners(config, parts, [], 0)\n\n      if (weight >= BigInt(config.threshold)) {\n        return encoded\n      }\n    }\n\n    const signers = config.signers\n\n    for (const { address } of signers.sort(({ weight: a }, { weight: b }) => Number(a) - Number(b))) {\n      const signature =\n        '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02'\n      parts.set(address, { signature, isDynamic: false })\n\n      const { encoded, weight } = encodeSigners(config, parts, [], 0)\n\n      if (weight >= BigInt(config.threshold)) {\n        return encoded\n      }\n    }\n\n    return encodeSigners(config, parts, [], 0).encoded\n  }\n}\n","import { WalletContext } from '../commons/context'\n\nexport * as config from './config'\nexport * as context from './context'\nexport * as signature from './signature'\n\nexport const version = 1\n\nexport const DeployedWalletContext: WalletContext = {\n  version: version,\n  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',\n  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',\n  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',\n  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',\n  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'\n}\n","import { ethers } from 'ethers'\n\n//                              = keccak256(\"SetImageHash(bytes32 imageHash)\")\nexport const SetImageHashPrefix = '0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1'\n\nexport function hashSetImageHash(imageHash: string): string {\n  return ethers.keccak256(messageSetImageHash(imageHash))\n}\n\nexport function messageSetImageHash(imageHash: string) {\n  return ethers.solidityPacked(['bytes32', 'bytes32'], [SetImageHashPrefix, imageHash])\n}\n\nexport function decodeMessageSetImageHash(message: ethers.BytesLike): string | undefined {\n  const arr = ethers.getBytes(message)\n\n  if (arr.length !== 64) {\n    return undefined\n  }\n\n  if (ethers.hexlify(arr.slice(0, 32)) !== SetImageHashPrefix) {\n    return undefined\n  }\n\n  return ethers.hexlify(arr.slice(32, 64))\n}\n\nexport function isMessageSetImageHash(message: ethers.BytesLike): boolean {\n  return decodeMessageSetImageHash(message) !== undefined\n}\n","import { ethers } from 'ethers'\nimport { MAX_UINT_256 } from '@0xsequence/utils'\nimport { isValidSignature, recoverSigner } from '../commons/signer'\nimport {\n  hashNode,\n  isNestedLeaf,\n  isNode,\n  isNodeLeaf,\n  isSignerLeaf,\n  isSubdigestLeaf,\n  Leaf,\n  WalletConfig,\n  SignerLeaf,\n  Topology,\n  imageHash,\n  NodeLeaf,\n  decodeSignerLeaf,\n  isEncodedSignerLeaf\n} from './config'\nimport * as base from '../commons/signature'\nimport { hashSetImageHash } from './chained'\n\nexport enum SignatureType {\n  Legacy = 0,\n  Dynamic = 1,\n  NoChainIdDynamic = 2,\n  Chained = 3\n}\n\nexport enum SignaturePartType {\n  Signature = 0,\n  Address = 1,\n  DynamicSignature = 2,\n  Node = 3,\n  Branch = 4,\n  Subdigest = 5,\n  Nested = 6\n}\n\nexport const SignaturePartTypeLength = 66\n\nexport type SignatureLeaf = SignerLeaf & {\n  signature: string\n  isDynamic: boolean\n}\n\nexport type UnrecoveredSignatureLeaf = Omit<SignatureLeaf, 'address'> &\n  Pick<Partial<SignatureLeaf>, 'address'> & {\n    unrecovered: true\n  }\n\nexport type UnrecoveredNestedLeaf = {\n  tree: UnrecoveredTopology\n  weight: ethers.BigNumberish\n  threshold: ethers.BigNumberish\n}\n\nexport type UnrecoveredLeaf = UnrecoveredNestedLeaf | UnrecoveredSignatureLeaf | Leaf\n\nexport type UnrecoveredNode = {\n  left: UnrecoveredNode | UnrecoveredLeaf\n  right: UnrecoveredNode | UnrecoveredLeaf\n}\n\nexport type UnrecoveredTopology = UnrecoveredNode | UnrecoveredLeaf\n\nexport function isUnrecoveredNode(node: UnrecoveredTopology): node is UnrecoveredNode {\n  return (node as UnrecoveredNode).left !== undefined && (node as UnrecoveredNode).right !== undefined\n}\n\nexport function isUnrecoveredNestedLeaf(leaf: UnrecoveredTopology): leaf is UnrecoveredNestedLeaf {\n  return (leaf as UnrecoveredNestedLeaf).tree !== undefined\n}\n\nexport function isUnrecoveredSignatureLeaf(leaf: UnrecoveredTopology): leaf is UnrecoveredSignatureLeaf {\n  return (\n    (leaf as UnrecoveredSignatureLeaf).unrecovered &&\n    (leaf as UnrecoveredSignatureLeaf).signature !== undefined &&\n    (leaf as UnrecoveredSignatureLeaf).isDynamic !== undefined\n  )\n}\n\nexport function decodeSignatureTree(body: ethers.BytesLike): UnrecoveredTopology {\n  let arr = ethers.getBytes(body)\n\n  let pointer: undefined | (Omit<UnrecoveredNode, 'right'> & Pick<Partial<UnrecoveredNode>, 'right'>)\n\n  const append = (prevPointer: typeof pointer, node: UnrecoveredNode | UnrecoveredLeaf): typeof pointer => {\n    if (!prevPointer) {\n      return {\n        left: node\n      }\n    }\n\n    if (!prevPointer.right) {\n      return {\n        left: prevPointer.left,\n        right: node\n      }\n    }\n\n    return {\n      left: prevPointer as Required<typeof prevPointer>,\n      right: node\n    }\n  }\n\n  while (arr.length > 0) {\n    const type = arr[0] as SignaturePartType\n    arr = arr.slice(1)\n\n    switch (type) {\n      case SignaturePartType.Signature:\n        {\n          const weight = arr[0]\n          const signature = ethers.hexlify(arr.slice(1, SignaturePartTypeLength + 1))\n\n          pointer = append(pointer, {\n            signature,\n            weight,\n            unrecovered: true,\n            isDynamic: false\n          })\n          arr = arr.slice(SignaturePartTypeLength + 1)\n        }\n        break\n\n      case SignaturePartType.Address:\n        {\n          const weight = arr[0]\n          const address = ethers.getAddress(ethers.hexlify(arr.slice(1, 21)))\n\n          pointer = append(pointer, {\n            address,\n            weight\n          })\n          arr = arr.slice(21)\n        }\n        break\n\n      case SignaturePartType.DynamicSignature:\n        {\n          const weight = arr[0]\n          const address = ethers.getAddress(ethers.hexlify(arr.slice(1, 21)))\n          const size = (arr[21] << 16) | (arr[22] << 8) | arr[23]\n          const signature = ethers.hexlify(arr.slice(24, 24 + size))\n\n          pointer = append(pointer, {\n            address,\n            signature,\n            weight,\n            unrecovered: true,\n            isDynamic: true\n          })\n          arr = arr.slice(24 + size)\n        }\n        break\n\n      case SignaturePartType.Node:\n        {\n          const nodeHash = ethers.hexlify(arr.slice(0, 32))\n\n          pointer = append(pointer, { nodeHash })\n          arr = arr.slice(32)\n        }\n        break\n\n      case SignaturePartType.Branch:\n        {\n          const size = (arr[0] << 16) | (arr[1] << 8) | arr[2]\n          const branch = decodeSignatureTree(arr.slice(3, 3 + size))\n\n          pointer = append(pointer, branch)\n          arr = arr.slice(3 + size)\n        }\n        break\n\n      case SignaturePartType.Subdigest:\n        {\n          const subdigest = ethers.hexlify(arr.slice(0, 32))\n\n          pointer = append(pointer, { subdigest })\n          arr = arr.slice(32)\n        }\n        break\n\n      case SignaturePartType.Nested:\n        {\n          const weight = arr[0]\n          const threshold = (arr[1] << 8) | arr[2]\n          const size = (arr[3] << 16) | (arr[4] << 8) | arr[5]\n\n          const tree = decodeSignatureTree(arr.slice(6, 6 + size))\n\n          pointer = append(pointer, {\n            weight,\n            threshold,\n            tree\n          })\n          arr = arr.slice(6 + size)\n        }\n        break\n\n      default:\n        throw new Error(`Unknown signature part type: ${type}: ${ethers.hexlify(arr)}`)\n    }\n  }\n\n  if (!pointer) {\n    throw new Error('Empty signature tree')\n  }\n\n  if (pointer.right) {\n    return pointer as Required<typeof pointer>\n  }\n\n  return pointer.left\n}\n\nexport class InvalidSignatureLeafError extends Error {\n  constructor(public leaf: UnrecoveredLeaf) {\n    super(`Invalid signature leaf: ${JSON.stringify(leaf)}`)\n  }\n}\n\nexport async function recoverTopology(\n  unrecovered: UnrecoveredTopology,\n  subdigest: string,\n  provider: ethers.Provider\n): Promise<Topology> {\n  if (isUnrecoveredNode(unrecovered)) {\n    const [left, right] = await Promise.all([\n      recoverTopology(unrecovered.left, subdigest, provider),\n      recoverTopology(unrecovered.right, subdigest, provider)\n    ])\n\n    return { left, right }\n  }\n\n  if (isUnrecoveredNestedLeaf(unrecovered)) {\n    return {\n      weight: unrecovered.weight,\n      threshold: unrecovered.threshold,\n      tree: await recoverTopology(unrecovered.tree, subdigest, provider)\n    }\n  }\n\n  if (isUnrecoveredSignatureLeaf(unrecovered)) {\n    if (unrecovered.isDynamic) {\n      if (!unrecovered.address) {\n        throw new Error('Dynamic signature leaf without address')\n      }\n\n      const isValid = await isValidSignature(unrecovered.address, subdigest, unrecovered.signature, provider)\n      if (!isValid) {\n        throw new InvalidSignatureLeafError(unrecovered)\n      }\n\n      return {\n        weight: unrecovered.weight,\n        address: unrecovered.address!,\n        signature: unrecovered.signature,\n        subdigest\n      }\n    } else {\n      return {\n        weight: unrecovered.weight,\n        address: recoverSigner(subdigest, unrecovered.signature),\n        signature: unrecovered.signature,\n        subdigest\n      }\n    }\n  }\n\n  return unrecovered\n}\n\n// TODO: It should be possible to re-use encodeSignatureTree\n// and avoid duplicating this logic\nexport const partEncoder = {\n  concat: (a: ethers.BytesLike, b: ethers.BytesLike) => {\n    return ethers.solidityPacked(['bytes', 'bytes'], [a, b])\n  },\n  node: (nodeHash: ethers.BytesLike): string => {\n    return ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, nodeHash])\n  },\n  branch: (tree: ethers.BytesLike): string => {\n    const arr = ethers.getBytes(tree)\n    return ethers.solidityPacked(['uint8', 'uint24', 'bytes'], [SignaturePartType.Branch, arr.length, arr])\n  },\n  nested: (weight: ethers.BigNumberish, threshold: ethers.BigNumberish, tree: ethers.BytesLike): string => {\n    const arr = ethers.getBytes(tree)\n    return ethers.solidityPacked(\n      ['uint8', 'uint8', 'uint16', 'uint24', 'bytes'],\n      [SignaturePartType.Nested, weight, threshold, arr.length, arr]\n    )\n  },\n  subdigest: (subdigest: ethers.BytesLike): string => {\n    return ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, subdigest])\n  },\n  signature: (weight: ethers.BigNumberish, signature: ethers.BytesLike): string => {\n    return ethers.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, weight, signature])\n  },\n  dynamicSignature: (weight: ethers.BigNumberish, address: ethers.BytesLike, signature: ethers.BytesLike): string => {\n    const arrSignature = ethers.getBytes(signature)\n    return ethers.solidityPacked(\n      ['uint8', 'uint8', 'address', 'uint24', 'bytes'],\n      [SignaturePartType.DynamicSignature, weight, address, arrSignature.length, arrSignature]\n    )\n  },\n  address: (weight: ethers.BigNumberish, address: ethers.BytesLike): string => {\n    return ethers.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, weight, address])\n  }\n}\n\nexport type EncodingOptions = {\n  forceDynamicEncoding?: boolean\n  disableTrim?: boolean\n}\n\nexport function encodeSigners(\n  config: WalletConfig,\n  parts: Map<string, base.SignaturePart>,\n  subdigests: string[],\n  chainId: ethers.BigNumberish,\n  options: EncodingOptions = {}\n): {\n  encoded: string\n  weight: bigint\n} {\n  const tree = encodeTree(config.tree, parts, subdigests, options)\n\n  if (BigInt(chainId) === 0n) {\n    return {\n      encoded: ethers.solidityPacked(\n        ['uint8', 'uint16', 'uint32', 'bytes'],\n        [SignatureType.NoChainIdDynamic, config.threshold, config.checkpoint, tree.encoded]\n      ),\n      weight: tree.weight\n    }\n  }\n\n  if (BigInt(config.threshold) > 255n) {\n    return {\n      encoded: ethers.solidityPacked(\n        ['uint8', 'uint16', 'uint32', 'bytes'],\n        [SignatureType.Dynamic, config.threshold, config.checkpoint, tree.encoded]\n      ),\n      weight: tree.weight\n    }\n  }\n\n  return {\n    encoded: ethers.solidityPacked(\n      ['uint8', 'uint8', 'uint32', 'bytes'],\n      [SignatureType.Legacy, config.threshold, config.checkpoint, tree.encoded]\n    ),\n    weight: tree.weight\n  }\n}\n\nexport function encodeTree(\n  topology: Topology,\n  parts: Map<string, base.SignaturePart>,\n  subdigests: string[],\n  options: EncodingOptions = {}\n): {\n  encoded: string\n  weight: bigint\n} {\n  const trim = !options.disableTrim\n\n  if (isNode(topology)) {\n    const left = encodeTree(topology.left, parts, subdigests)\n    const right = encodeTree(topology.right, parts, subdigests)\n\n    const isLeftSigner = isSignerLeaf(topology.left)\n    const isRightSigner = isSignerLeaf(topology.right)\n\n    if (trim && left.weight === 0n && right.weight === 0n && !isLeftSigner && !isRightSigner) {\n      return {\n        // We don't need to include anything for this node\n        // just the hash will be enough\n        encoded: partEncoder.node(hashNode(topology)),\n        weight: 0n\n      }\n    }\n\n    if (trim && right.weight === 0n && !isRightSigner) {\n      return {\n        // The right node doesn't have any weight\n        // but we still need to include the left node encoded\n        encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),\n        weight: left.weight\n      }\n    }\n\n    if (trim && left.weight === 0n && !isLeftSigner) {\n      return {\n        // The left node doesn't have any weight\n        // we can just append its hash, but for the right node\n        // we need to create a new \"branch\"\n        encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),\n        weight: right.weight\n      }\n    }\n\n    return {\n      // Both nodes have weight, we need to include both\n      // the right one must be a branch\n      encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),\n      weight: left.weight + right.weight\n    }\n  }\n\n  if (isNestedLeaf(topology)) {\n    const tree = encodeTree(topology.tree, parts, subdigests)\n\n    if (trim && tree.weight === 0n) {\n      return {\n        encoded: partEncoder.node(hashNode(topology)),\n        weight: 0n\n      }\n    }\n\n    return {\n      encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),\n      weight: tree.weight\n    }\n  }\n\n  if (isNodeLeaf(topology)) {\n    return {\n      encoded: partEncoder.node(hashNode(topology)),\n      weight: 0n\n    }\n  }\n\n  if (isSubdigestLeaf(topology)) {\n    const include = subdigests.includes(topology.subdigest)\n    return {\n      encoded: partEncoder.subdigest(topology.subdigest),\n      weight: include ? MAX_UINT_256 : 0n\n    }\n  }\n\n  if (isSignerLeaf(topology)) {\n    const include = parts.has(topology.address)\n\n    if (include) {\n      const part = parts.get(topology.address)!\n      const signature = part.signature\n\n      if (options.forceDynamicEncoding || part.isDynamic) {\n        return {\n          encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature),\n          weight: BigInt(topology.weight)\n        }\n      } else {\n        return {\n          encoded: partEncoder.signature(topology.weight, signature),\n          weight: BigInt(topology.weight)\n        }\n      }\n    } else {\n      return {\n        encoded: partEncoder.address(topology.weight, topology.address),\n        weight: 0n\n      }\n    }\n  }\n\n  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`)\n}\n\nexport type UnrecoveredConfig = {\n  tree: UnrecoveredTopology\n  threshold: ethers.BigNumberish\n  checkpoint: ethers.BigNumberish\n}\n\nexport type UnrecoveredSignature = base.UnrecoveredSignature & {\n  type: SignatureType\n  decoded: UnrecoveredConfig\n}\n\nexport type Signature = base.Signature<WalletConfig> & {\n  type: SignatureType\n}\n\nexport type UnrecoveredChainedSignature = UnrecoveredSignature & {\n  suffix: (UnrecoveredSignature | UnrecoveredChainedSignature)[]\n}\n\nexport type ChainedSignature = Signature & {\n  suffix: (Signature | ChainedSignature)[]\n}\n\nexport function deepestConfigOfSignature(signature: Signature | ChainedSignature): WalletConfig {\n  return isChainedSignature(signature)\n    ? deepestConfigOfSignature(signature.suffix[signature.suffix.length - 1])\n    : signature.config\n}\n\nexport function isUnrecoveredSignature(sig: any): sig is UnrecoveredSignature {\n  return sig.type !== undefined && sig.decoded !== undefined && sig.version !== undefined && sig.version === 2\n}\n\nexport function isUnrecoveredChainedSignature(sig: any): sig is UnrecoveredChainedSignature {\n  return sig.suffix !== undefined && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature)\n}\n\nexport function isSignature(sig: any): sig is Signature {\n  return (\n    sig.type !== undefined &&\n    sig.config !== undefined &&\n    sig.digest !== undefined &&\n    sig.version !== undefined &&\n    sig.version === 2\n  )\n}\n\nexport function isChainedSignature(sig: any): sig is ChainedSignature {\n  return sig.chain !== undefined && Array.isArray(sig.chain) && sig.chain.every(isSignature)\n}\n\nexport function decodeSignature(signature: ethers.BytesLike): UnrecoveredSignature | UnrecoveredChainedSignature {\n  const bytes = ethers.getBytes(signature)\n  const type = bytes[0]\n\n  switch (type) {\n    case SignatureType.Legacy:\n      return { version: 2, type: SignatureType.Legacy, decoded: decodeSignatureBody(bytes) }\n\n    case SignatureType.Dynamic:\n      return { version: 2, type: SignatureType.Dynamic, decoded: decodeSignatureBody(bytes.slice(1)) }\n\n    case SignatureType.NoChainIdDynamic:\n      return { version: 2, type: SignatureType.NoChainIdDynamic, decoded: decodeSignatureBody(bytes.slice(1)) }\n\n    case SignatureType.Chained:\n      return decodeChainedSignature(bytes)\n\n    default:\n      throw new Error(`Invalid signature type: ${type}`)\n  }\n}\n\nexport function decodeSignatureBody(signature: ethers.BytesLike): UnrecoveredConfig {\n  const bytes = ethers.getBytes(signature)\n\n  const threshold = (bytes[0] << 8) | bytes[1]\n  const checkpoint = (bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]\n\n  const tree = decodeSignatureTree(bytes.slice(6))\n\n  return { threshold, checkpoint, tree }\n}\n\nexport function decodeChainedSignature(signature: ethers.BytesLike): UnrecoveredChainedSignature {\n  const arr = ethers.getBytes(signature)\n  const type = arr[0]\n\n  if (type !== SignatureType.Chained) {\n    throw new Error(`Expected chained signature type: ${type}`)\n  }\n\n  const chain: (UnrecoveredSignature | UnrecoveredChainedSignature)[] = []\n  let index = 1\n\n  while (index < arr.length) {\n    const size = (arr[index] << 16) | (arr[index + 1] << 8) | arr[index + 2]\n    index += 3\n\n    const sig = decodeSignature(arr.slice(index, index + size))\n    chain.push(sig)\n\n    index += size\n  }\n\n  const main = chain[0]\n  if (isUnrecoveredChainedSignature(main)) {\n    throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`)\n  }\n\n  const suffix = chain.slice(1)\n\n  return { ...main, suffix }\n}\n\nexport function setImageHashStruct(imageHash: string) {\n  return ethers.solidityPacked(\n    ['bytes32', 'bytes32'],\n    [ethers.solidityPackedKeccak256(['string'], ['SetImageHash(bytes32 imageHash)']), imageHash]\n  )\n}\n\nexport async function recoverSignature(\n  signature: UnrecoveredSignature | UnrecoveredChainedSignature,\n  payload: base.SignedPayload | { subdigest: string },\n  provider: ethers.Provider\n): Promise<Signature | ChainedSignature> {\n  const signedPayload = (payload as { subdigest: string }).subdigest === undefined ? (payload as base.SignedPayload) : undefined\n\n  const isNoChainId = signature.type === SignatureType.NoChainIdDynamic\n  if (isNoChainId && signedPayload) {\n    signedPayload.chainId = 0\n  }\n\n  const subdigest = signedPayload ? base.subdigestOf(signedPayload) : (payload as { subdigest: string }).subdigest\n\n  if (!isUnrecoveredChainedSignature(signature)) {\n    const tree = await recoverTopology(signature.decoded.tree, subdigest, provider)\n    return { version: 2, type: signature.type, subdigest, config: { version: 2, ...signature.decoded, tree } }\n  }\n\n  if (!base.isSignedPayload(signedPayload)) {\n    throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`)\n  }\n\n  const result: (Signature | ChainedSignature)[] = []\n  let mutatedPayload = signedPayload\n\n  // Recover the chain of signatures\n  // NOTICE: Remove the suffix from the \"first\" siganture\n  // otherwise we recurse infinitely\n  for (const sig of [{ ...signature, suffix: undefined }, ...signature.suffix]) {\n    const recovered = await recoverSignature(sig, mutatedPayload, provider)\n    result.unshift(recovered)\n\n    const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)))\n\n    mutatedPayload = {\n      ...mutatedPayload,\n      message: nextMessage,\n      digest: ethers.keccak256(nextMessage)\n    }\n  }\n\n  const main = result[0]\n  const suffix = result.slice(1)\n\n  return { ...main, suffix }\n}\n\nexport function encodeChain(main: ethers.BytesLike, suffix: ethers.BytesLike[]): string {\n  const allSignatures = [main, ...(suffix || [])]\n  const encodedMap = allSignatures.map(s => ethers.getBytes(encodeSignature(s)))\n\n  const body = ethers.solidityPacked(encodedMap.map(() => ['uint24', 'bytes']).flat(), encodedMap.map(s => [s.length, s]).flat())\n\n  return ethers.solidityPacked(['uint8', 'bytes'], [SignatureType.Chained, body])\n}\n\nexport function encodeSignature(\n  decoded: UnrecoveredChainedSignature | ChainedSignature | UnrecoveredSignature | Signature | ethers.BytesLike\n): string {\n  if (ethers.isBytesLike(decoded)) return ethers.hexlify(decoded)\n\n  if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) {\n    return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature))\n  }\n\n  const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config\n\n  switch (decoded.type) {\n    case SignatureType.Legacy:\n      if (BigInt(body.threshold) > 255n) {\n        throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`)\n      }\n\n      return encodeSignatureBody(body)\n\n    case SignatureType.NoChainIdDynamic:\n    case SignatureType.Dynamic:\n      return ethers.solidityPacked(['uint8', 'bytes'], [decoded.type, encodeSignatureBody(body)])\n\n    case SignatureType.Chained:\n      throw new Error(`Unreachable code: Chained signature should be handled above`)\n\n    default:\n      throw new Error(`Invalid signature type: ${decoded.type}`)\n  }\n}\n\nexport function encodeSignatureBody(decoded: WalletConfig | UnrecoveredConfig): string {\n  return ethers.solidityPacked(\n    ['uint16', 'uint32', 'bytes'],\n    [decoded.threshold, decoded.checkpoint, encodeSignatureTree(decoded.tree)]\n  )\n}\n\nexport function encodeSignatureTree(tree: UnrecoveredTopology | Topology): string {\n  if (isNode(tree) || isUnrecoveredNode(tree)) {\n    const encodedRight = ethers.getBytes(encodeSignatureTree(tree.right))\n    const encodedLeft = ethers.getBytes(encodeSignatureTree(tree.left))\n    const isBranching = isNode(tree.right) || isUnrecoveredNode(tree.right)\n\n    if (isBranching) {\n      return ethers.solidityPacked(\n        ['bytes', 'uint8', 'uint24', 'bytes'],\n        [encodedLeft, SignaturePartType.Branch, encodedRight.length, encodedRight]\n      )\n    } else {\n      return ethers.solidityPacked(['bytes', 'bytes'], [encodedLeft, encodedRight])\n    }\n  }\n\n  if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {\n    const nested = ethers.getBytes(encodeSignatureTree(tree.tree))\n\n    return ethers.solidityPacked(\n      ['uint8', 'uint8', 'uint16', 'uint24', 'bytes'],\n      [SignaturePartType.Nested, tree.weight, tree.threshold, nested.length, nested]\n    )\n  }\n\n  if (isUnrecoveredSignatureLeaf(tree) || (isSignerLeaf(tree) && tree.signature !== undefined)) {\n    const signature = ethers.getBytes(tree.signature!)\n\n    if ((tree as { isDynamic?: boolean }).isDynamic || signature.length !== SignaturePartTypeLength) {\n      if (!tree.address) throw new Error(`Dynamic signature leaf must have address`)\n      return ethers.solidityPacked(\n        ['uint8', 'uint8', 'address', 'uint24', 'bytes'],\n        [SignaturePartType.DynamicSignature, tree.weight, tree.address, signature.length, signature]\n      )\n    } else {\n      return ethers.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, tree.weight, signature])\n    }\n  }\n\n  if (isSignerLeaf(tree)) {\n    return ethers.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, tree.weight, tree.address])\n  }\n\n  if (isNodeLeaf(tree)) {\n    return ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, tree.nodeHash])\n  }\n\n  if (isSubdigestLeaf(tree)) {\n    return ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, tree.subdigest])\n  }\n\n  throw new Error(`Unknown signature tree type: ${tree}`)\n}\n\nexport function signaturesOf(topology: Topology): { address: string; signature: string }[] {\n  if (isNode(topology)) {\n    return [...signaturesOf(topology.left), ...signaturesOf(topology.right)]\n  }\n\n  if (isNestedLeaf(topology)) {\n    return signaturesOf(topology.tree)\n  }\n\n  if (isSignerLeaf(topology) && topology.signature) {\n    return [{ address: topology.address, signature: topology.signature }]\n  }\n\n  return []\n}\n\nexport function signaturesOfDecoded(utopology: UnrecoveredTopology): string[] {\n  if (isUnrecoveredNode(utopology)) {\n    return [...signaturesOfDecoded(utopology.left), ...signaturesOfDecoded(utopology.right)]\n  }\n\n  if (isUnrecoveredNestedLeaf(utopology)) {\n    return signaturesOfDecoded(utopology.tree)\n  }\n\n  if (isUnrecoveredSignatureLeaf(utopology)) {\n    return [utopology.signature]\n  }\n\n  return []\n}\n\nexport function subdigestsOfDecoded(utopology: UnrecoveredTopology): string[] {\n  if (isUnrecoveredNode(utopology)) {\n    return [...subdigestsOfDecoded(utopology.left), ...subdigestsOfDecoded(utopology.right)]\n  }\n\n  if (isUnrecoveredNestedLeaf(utopology)) {\n    return subdigestsOfDecoded(utopology.tree)\n  }\n\n  if (isSubdigestLeaf(utopology)) {\n    return [utopology.subdigest]\n  }\n\n  return []\n}\n\nexport async function trimSignature(signature: string | UnrecoveredSignature): Promise<string> {\n  const decoded = typeof signature === 'string' ? decodeSignature(signature) : signature\n\n  if (isUnrecoveredChainedSignature(decoded)) {\n    // We need to trim every suffix AND the main signature\n    const trimmed = await Promise.all([\n      trimSignature({ ...decoded, suffix: undefined } as UnrecoveredSignature),\n      ...decoded.suffix.map(s => trimSignature(s))\n    ])\n\n    return encodeChain(trimmed[0], trimmed.slice(1))\n  }\n\n  const { trimmed } = await trimUnrecoveredTree(decoded.decoded.tree)\n  return encodeSignature({ ...decoded, decoded: { ...decoded.decoded, tree: trimmed } })\n}\n\nexport async function trimUnrecoveredTree(\n  tree: UnrecoveredTopology,\n  trimStaticDigest: boolean = true\n): Promise<{\n  weight: number\n  trimmed: UnrecoveredTopology\n}> {\n  if (isUnrecoveredNode(tree)) {\n    const [left, right] = await Promise.all([trimUnrecoveredTree(tree.left), trimUnrecoveredTree(tree.right)])\n\n    if (left.weight === 0 && right.weight === 0) {\n      try {\n        // If both weights are 0 then it means we don't have any signatures yet\n        // because of that, we should be able to \"recover\" the tree with any subdigest\n        // and still get the valid node hash (there shouldn't be any signatures to verify)\n        const recovered = await recoverTopology(tree, ethers.ZeroHash, undefined as any)\n\n        return {\n          weight: 0,\n          trimmed: {\n            nodeHash: hashNode(recovered)\n          } as NodeLeaf\n        }\n      } catch {\n        // If something fails it's more likely because some signatures have sneaked in\n        // in that case we should keep this node\n      }\n    } else {\n      return {\n        weight: left.weight + right.weight,\n        trimmed: {\n          left: left.trimmed,\n          right: right.trimmed\n        } as UnrecoveredNode\n      }\n    }\n  }\n\n  if (isUnrecoveredNestedLeaf(tree)) {\n    const trimmed = await trimUnrecoveredTree(tree.tree)\n\n    if (trimmed.weight === 0) {\n      try {\n        // If the nested leaf is empty, we can recover it with any subdigest\n        // and still get the valid node hash (there shouldn't be any signatures to verify)\n        const recovered = await recoverTopology(tree, ethers.ZeroHash, undefined as any)\n\n        return {\n          weight: 0,\n          trimmed: {\n            nodeHash: hashNode(recovered)\n          } as NodeLeaf\n        }\n      } catch {\n        // If something fails it's more likely because some signatures have sneaked in\n        // in that case we should keep this node\n      }\n    }\n\n    return {\n      weight: trimmed.weight,\n      trimmed: {\n        weight: tree.weight,\n        threshold: tree.threshold,\n        tree: trimmed.trimmed\n      } as UnrecoveredNestedLeaf\n    }\n  }\n\n  // Hash nodes can be encoded as signer leaves if they have a weight below\n  // 256, most likely the are signer leaves wrongly encoded\n  if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) {\n    return {\n      weight: 0,\n      trimmed: {\n        ...decodeSignerLeaf(tree.nodeHash)\n      } as SignerLeaf\n    }\n  }\n\n  if (isUnrecoveredSignatureLeaf(tree) || (isSignerLeaf(tree) && tree.signature !== undefined)) {\n    return {\n      weight: Number(tree.weight),\n      trimmed: tree\n    }\n  }\n\n  if (!trimStaticDigest && isSubdigestLeaf(tree)) {\n    return {\n      weight: +Infinity,\n      trimmed: tree\n    }\n  }\n\n  return {\n    weight: 0,\n    trimmed: tree\n  }\n}\n\nexport const SignatureCoder: base.SignatureCoder<WalletConfig, Signature, UnrecoveredChainedSignature | UnrecoveredSignature> = {\n  decode: (data: string): UnrecoveredSignature => {\n    return decodeSignature(data)\n  },\n\n  encode: (data: Signature | UnrecoveredSignature): string => {\n    return encodeSignature(data)\n  },\n\n  trim: (data: string): Promise<string> => {\n    return trimSignature(data)\n  },\n\n  supportsNoChainId: true,\n\n  recover: (\n    data: UnrecoveredSignature | UnrecoveredChainedSignature,\n    payload: base.SignedPayload,\n    provider: ethers.Provider\n  ): Promise<Signature> => {\n    return recoverSignature(data, payload, provider)\n  },\n\n  encodeSigners: (\n    config: WalletConfig,\n    signatures: Map<string, base.SignaturePart>,\n    subdigests: string[],\n    chainId: ethers.BigNumberish\n  ): {\n    encoded: string\n    weight: bigint\n  } => {\n    return encodeSigners(config, signatures, subdigests, chainId)\n  },\n\n  hasEnoughSigningPower: (config: WalletConfig, signatures: Map<string, base.SignaturePart>): boolean => {\n    const { weight } = SignatureCoder.encodeSigners(config, signatures, [], 0)\n    return weight >= BigInt(config.threshold)\n  },\n\n  chainSignatures: (\n    main: Signature | UnrecoveredSignature | UnrecoveredChainedSignature | ethers.BytesLike,\n    suffix: (Signature | UnrecoveredSignature | UnrecoveredChainedSignature | ethers.BytesLike)[]\n  ): string => {\n    // Notice: v2 expects suffix to be reversed\n    // that being: from signed to current imageHash\n    const reversed = suffix.reverse()\n    const mraw = ethers.isBytesLike(main) ? main : encodeSignature(main)\n    const sraw = reversed.map(s => (ethers.isBytesLike(s) ? s : encodeSignature(s)))\n    return encodeChain(mraw, sraw)\n  },\n\n  hashSetImageHash: function (imageHash: string): string {\n    return hashSetImageHash(imageHash)\n  },\n\n  signaturesOf(config: WalletConfig): { address: string; signature: string }[] {\n    return signaturesOf(config.tree)\n  },\n\n  signaturesOfDecoded: function (data: UnrecoveredSignature): string[] {\n    return signaturesOfDecoded(data.decoded.tree)\n  }\n}\n","import { ethers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { commons } from '..'\nimport { encodeSigners } from './signature'\nimport { SimpleConfig } from '../commons/config'\n\n//\n// Tree typings - leaves\n//\n\nexport type SignerLeaf = {\n  address: string\n  weight: ethers.BigNumberish\n  signature?: string\n}\n\nexport type SubdigestLeaf = {\n  subdigest: string\n}\n\nexport type NestedLeaf = {\n  tree: Topology\n  weight: ethers.BigNumberish\n  threshold: ethers.BigNumberish\n}\n\n// This is an unknown node\n// it means the tree has a branch\n// but we don't know what the content\nexport type NodeLeaf = {\n  nodeHash: string\n}\n\nexport type Leaf = SignerLeaf | SubdigestLeaf | NestedLeaf | NodeLeaf\n\nexport function isSignerLeaf(leaf: any): leaf is SignerLeaf {\n  return (leaf as SignerLeaf).address !== undefined && (leaf as SignerLeaf).weight !== undefined\n}\n\nexport function isSubdigestLeaf(leaf: any): leaf is SubdigestLeaf {\n  return (leaf as SubdigestLeaf).subdigest !== undefined && (leaf as SignerLeaf).address === undefined\n}\n\nexport function topologyToJSON(tree: Topology): string {\n  if (isNode(tree)) {\n    return JSON.stringify({\n      left: topologyToJSON(tree.left),\n      right: topologyToJSON(tree.right)\n    })\n  }\n\n  if (isNestedLeaf(tree)) {\n    return JSON.stringify({\n      weight: BigInt(tree.weight).toString(),\n      threshold: BigInt(tree.threshold).toString(),\n      tree: topologyToJSON(tree.tree)\n    })\n  }\n\n  if (isSignerLeaf(tree)) {\n    return JSON.stringify({\n      address: tree.address,\n      weight: BigInt(tree.weight).toString()\n    })\n  }\n\n  return JSON.stringify(tree)\n}\n\nexport function topologyFromJSON(json: string | object): Topology {\n  const parsed = typeof json === 'string' ? JSON.parse(json) : json\n\n  if (parsed.left !== undefined && parsed.right !== undefined) {\n    return {\n      left: topologyFromJSON(parsed.left),\n      right: topologyFromJSON(parsed.right)\n    }\n  }\n\n  if (parsed.weight !== undefined && parsed.threshold !== undefined && parsed.tree !== undefined) {\n    return {\n      weight: BigInt(parsed.weight),\n      threshold: BigInt(parsed.threshold),\n      tree: topologyFromJSON(parsed.tree)\n    }\n  }\n\n  if (parsed.address !== undefined && parsed.weight !== undefined) {\n    return {\n      address: parsed.address,\n      weight: BigInt(parsed.weight)\n    }\n  }\n\n  return parsed\n}\n\nexport function isNestedLeaf(leaf: any): leaf is NestedLeaf {\n  return (\n    (leaf as NestedLeaf).tree !== undefined &&\n    (leaf as NestedLeaf).weight !== undefined &&\n    (leaf as NestedLeaf).threshold !== undefined\n  )\n}\n\nexport function isNodeLeaf(leaf: any): leaf is NodeLeaf {\n  return (leaf as NodeLeaf).nodeHash !== undefined\n}\n\nexport function isLeaf(leaf: any): leaf is Leaf {\n  return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf)\n}\n\n//\n// Tree typings - nodes\n//\n\nexport type Node = {\n  left: Node | Leaf\n  right: Node | Leaf\n}\n\nexport type Topology = Node | Leaf\n\nexport function isNode(node: any): node is Node {\n  return (node as Node).left !== undefined && (node as Node).right !== undefined\n}\n\nexport function isTopology(topology: any): topology is Topology {\n  return isNode(topology) || isLeaf(topology)\n}\n\nexport function encodeSignerLeaf(leaf: SignerLeaf): string {\n  return ethers.solidityPacked(['uint96', 'address'], [leaf.weight, leaf.address])\n}\n\nexport function decodeSignerLeaf(encoded: string): SignerLeaf {\n  const bytes = ethers.getBytes(encoded)\n\n  if (bytes.length !== 32) {\n    throw new Error('Invalid encoded string length')\n  }\n\n  const weight = BigInt(ethers.hexlify(bytes.slice(0, 12)))\n  const address = ethers.getAddress(ethers.hexlify(bytes.slice(12)))\n\n  return { weight, address }\n}\n\nexport function isEncodedSignerLeaf(encoded: string): boolean {\n  const bytes = ethers.getBytes(encoded)\n\n  if (bytes.length !== 32) {\n    return false\n  }\n\n  const prefix = bytes.slice(0, 11)\n  return prefix.every(byte => byte === 0)\n}\n\nexport function hashNode(node: Node | Leaf): string {\n  if (isSignerLeaf(node)) {\n    return encodeSignerLeaf(node)\n  }\n\n  if (isSubdigestLeaf(node)) {\n    return ethers.solidityPackedKeccak256(['string', 'bytes32'], ['Sequence static digest:\\n', node.subdigest])\n  }\n\n  if (isNestedLeaf(node)) {\n    const nested = hashNode(node.tree)\n    return ethers.solidityPackedKeccak256(\n      ['string', 'bytes32', 'uint256', 'uint256'],\n      ['Sequence nested config:\\n', nested, node.threshold, node.weight]\n    )\n  }\n\n  if (isNodeLeaf(node)) {\n    return node.nodeHash\n  }\n\n  return ethers.solidityPackedKeccak256(['bytes32', 'bytes32'], [hashNode(node.left), hashNode(node.right)])\n}\n\nexport function leftFace(topology: Topology): Topology[] {\n  const stack: Topology[] = []\n\n  let prev = topology\n  while (!isLeaf(prev)) {\n    stack.unshift(prev.right)\n    prev = prev.left\n  }\n\n  stack.unshift(prev)\n\n  return stack\n}\n\n//\n// Wallet config types\n//\n\nexport type WalletConfig = commons.config.Config & {\n  threshold: ethers.BigNumberish\n  checkpoint: ethers.BigNumberish\n  tree: Topology\n}\n\nexport function isWalletConfig(config: any): config is WalletConfig {\n  return (\n    (config as WalletConfig).threshold !== undefined &&\n    (config as WalletConfig).checkpoint !== undefined &&\n    (config as WalletConfig).tree !== undefined &&\n    (config as WalletConfig).version !== undefined &&\n    (config as WalletConfig).version === 2\n  )\n}\n\nexport function imageHash(config: WalletConfig): string {\n  return ethers.solidityPackedKeccak256(\n    ['bytes32', 'uint256'],\n    [ethers.solidityPackedKeccak256(['bytes32', 'uint256'], [hashNode(config.tree), config.threshold]), config.checkpoint]\n  )\n}\n\n//\n// Simple wallet config types\n// (used for building and reading merkle configs)\n//\n// dev: `members` is a flat representation of the tree\n//      it keeps relevant structure like 'nested trees' but\n//      it ignores the tree structure\n//\n//\n\nexport type SimpleNestedMember = {\n  threshold: ethers.BigNumberish\n  weight: ethers.BigNumberish\n  members: SimpleConfigMember[]\n}\n\nexport type SimpleConfigMember = SubdigestLeaf | SignerLeaf | SimpleNestedMember\n\nexport type SimpleWalletConfig = {\n  threshold: ethers.BigNumberish\n  checkpoint: ethers.BigNumberish\n  members: SimpleConfigMember[]\n}\n\nexport function isSimpleNestedMember(member: any): member is SimpleNestedMember {\n  return (\n    (member as SimpleNestedMember).threshold !== undefined &&\n    (member as SimpleNestedMember).weight !== undefined &&\n    (member as SimpleNestedMember).members !== undefined\n  )\n}\n\nexport function topologyToMembers(tree: Topology): SimpleConfigMember[] {\n  if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) {\n    return [tree]\n  }\n\n  if (isNestedLeaf(tree)) {\n    return [\n      {\n        threshold: tree.threshold,\n        weight: tree.weight,\n        members: topologyToMembers(tree.tree)\n      }\n    ]\n  }\n\n  if (isNodeLeaf(tree)) {\n    // we don't know the content of this node\n    // so we omit it\n    return []\n  }\n\n  return [...topologyToMembers(tree.left), ...topologyToMembers(tree.right)]\n}\n\nexport function hasUnknownNodes(tree: Topology): boolean {\n  if (isNodeLeaf(tree)) {\n    return true\n  }\n\n  if (isNode(tree)) {\n    return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right)\n  }\n\n  return false\n}\n\nexport function toSimpleWalletConfig(config: WalletConfig): SimpleWalletConfig {\n  return {\n    threshold: config.threshold,\n    checkpoint: config.checkpoint,\n    members: topologyToMembers(config.tree)\n  }\n}\n\nexport type TopologyBuilder = (members: SimpleConfigMember[]) => Topology\n\nconst membersAsTopologies = (members: SimpleConfigMember[], builder: TopologyBuilder): Topology[] => {\n  return members.map(member => {\n    if (isSimpleNestedMember(member)) {\n      return {\n        tree: builder(member.members),\n        threshold: member.threshold,\n        weight: member.weight\n      }\n    }\n\n    return member\n  })\n}\n\nexport function legacyTopologyBuilder(members: SimpleConfigMember[]): Topology {\n  if (members.length === 0) {\n    throw new Error('Empty members array')\n  }\n\n  const asTopologies = membersAsTopologies(members, legacyTopologyBuilder)\n  return asTopologies.reduce((acc, member) => {\n    return {\n      left: acc,\n      right: member\n    }\n  })\n}\n\nexport function merkleTopologyBuilder(members: SimpleConfigMember[]): Topology {\n  if (members.length === 0) {\n    throw new Error('Empty members array')\n  }\n\n  const leaves = membersAsTopologies(members, merkleTopologyBuilder)\n  for (let s = leaves.length; s > 1; s = s / 2) {\n    for (let i = 0; i < s / 2; i++) {\n      const j1 = i * 2\n      const j2 = j1 + 1\n\n      if (j2 >= s) {\n        leaves[i] = leaves[j1]\n      } else {\n        leaves[i] = {\n          left: leaves[j1],\n          right: leaves[j2]\n        }\n      }\n    }\n  }\n\n  return leaves[0]\n}\n\nexport function optimized2SignersTopologyBuilder(members: SimpleConfigMember[]): Topology {\n  if (members.length > 8) {\n    return merkleTopologyBuilder(members)\n  }\n\n  return legacyTopologyBuilder(members)\n}\n\nexport function toWalletConfig(\n  simpleWalletConfig: SimpleWalletConfig,\n  builder: TopologyBuilder = optimized2SignersTopologyBuilder\n): WalletConfig {\n  return {\n    version: 2,\n    threshold: simpleWalletConfig.threshold,\n    checkpoint: simpleWalletConfig.checkpoint,\n    tree: builder(simpleWalletConfig.members)\n  }\n}\n\nexport function hasSubdigest(tree: Topology, subdigest: string): boolean {\n  if (isSubdigestLeaf(tree)) {\n    return tree.subdigest === subdigest\n  }\n\n  if (isNode(tree)) {\n    return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest)\n  }\n\n  return false\n}\n\nexport function signersOf(tree: Topology): { address: string; weight: number }[] {\n  const stack: Topology[] = [tree]\n  const signers = new Set<{ address: string; weight: number }>()\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n\n    if (isNestedLeaf(node)) {\n      stack.push(node.tree)\n    } else if (isNode(node)) {\n      stack.push(node.left)\n      stack.push(node.right)\n    } else if (isSignerLeaf(node)) {\n      signers.add({ address: node.address, weight: Number(node.weight) })\n    }\n  }\n\n  return Array.from(signers)\n}\n\nexport function isComplete(tree: Topology): boolean {\n  if (isNode(tree)) {\n    return isComplete(tree.left) && isComplete(tree.right)\n  }\n\n  return !isNodeLeaf(tree)\n}\n\nexport const ConfigCoder: commons.config.ConfigCoder<WalletConfig> = {\n  isWalletConfig: (config: commons.config.Config): config is WalletConfig => {\n    return config.version === 2 && (config as WalletConfig).threshold !== undefined && (config as WalletConfig).tree !== undefined\n  },\n\n  imageHashOf: (config: WalletConfig): string => {\n    return imageHash(config)\n  },\n\n  hasSubdigest: (config: WalletConfig, subdigest: string): boolean => {\n    return hasSubdigest(config.tree, subdigest)\n  },\n\n  checkpointOf: (config: WalletConfig): bigint => {\n    return BigInt(config.checkpoint)\n  },\n\n  signersOf: (config: WalletConfig): { address: string; weight: number }[] => {\n    return signersOf(config.tree)\n  },\n\n  fromSimple: (config: SimpleConfig): WalletConfig => {\n    return toWalletConfig({\n      ...config,\n      members: [...config.signers, ...(config.subdigests ?? []).map(subdigest => ({ subdigest }))]\n    })\n  },\n\n  isComplete: (config: WalletConfig): boolean => {\n    return isComplete(config.tree)\n  },\n\n  // isValid = (config: WalletConfig): boolean {}\n  /**\n   *\n   * Notice: context and kind are ignored because v2\n   * doesn't need to manually update the implementation before\n   * a configuration update, it's automatically done by the contract.\n   *\n   */\n  update: {\n    isKindUsed: true,\n\n    buildTransaction: (\n      wallet: string,\n      config: WalletConfig,\n      _context: commons.context.WalletContext,\n      _kind?: 'first' | 'later' | undefined\n    ): commons.transaction.TransactionBundle => {\n      const module = new ethers.Interface(walletContracts.mainModuleUpgradable.abi)\n\n      return {\n        entrypoint: wallet,\n        transactions: [\n          {\n            to: wallet,\n            data: module.encodeFunctionData(module.getFunction('updateImageHash')!, [ConfigCoder.imageHashOf(config)]),\n            gasLimit: 0,\n            delegateCall: false,\n            revertOnError: true,\n            value: 0\n          }\n        ]\n      }\n    },\n    decodeTransaction: function (tx: commons.transaction.TransactionBundle): {\n      address: string\n      newImageHash: string\n      kind: 'first' | 'later' | undefined\n    } {\n      const module = new ethers.Interface(walletContracts.mainModuleUpgradable.abi)\n\n      if (tx.transactions.length !== 1) {\n        throw new Error('Invalid transaction bundle, expected 1 transaction')\n      }\n\n      const data = tx.transactions[0].data\n      if (!data) {\n        throw new Error('Invalid transaction bundle, expected data')\n      }\n\n      const decoded = module.decodeFunctionData(module.getFunction('updateImageHash')!, data)\n      if (!decoded) {\n        throw new Error('Invalid transaction bundle, expected valid data')\n      }\n\n      if (tx.transactions[0].to !== tx.entrypoint) {\n        throw new Error('Invalid transaction bundle, expected to be sent to entrypoint')\n      }\n\n      if (tx.transactions[0].delegateCall) {\n        throw new Error('Invalid transaction bundle, expected not to be a delegateCall')\n      }\n\n      if (!tx.transactions[0].revertOnError) {\n        throw new Error('Invalid transaction bundle, expected revertOnError')\n      }\n\n      if (BigInt(tx.transactions[0]?.value ?? 0) !== 0n) {\n        throw new Error('Invalid transaction bundle, expected value to be 0')\n      }\n\n      if (BigInt(tx.transactions[0]?.gasLimit ?? 0) !== 0n) {\n        throw new Error('Invalid transaction bundle, expected value to be 0')\n      }\n\n      return {\n        address: tx.entrypoint,\n        newImageHash: decoded[0],\n        kind: undefined\n      }\n    }\n  },\n\n  toJSON: function (config: WalletConfig): string {\n    return JSON.stringify({\n      version: config.version,\n      threshold: BigInt(config.threshold).toString(),\n      checkpoint: BigInt(config.checkpoint).toString(),\n      tree: topologyToJSON(config.tree)\n    })\n  },\n\n  fromJSON: function (json: string): WalletConfig {\n    const config = JSON.parse(json)\n    return {\n      version: config.version,\n      threshold: BigInt(config.threshold),\n      checkpoint: BigInt(config.checkpoint),\n      tree: topologyFromJSON(config.tree)\n    }\n  },\n\n  editConfig: function (\n    config: WalletConfig,\n    action: {\n      add?: commons.config.SimpleSigner[]\n      remove?: string[]\n      threshold?: ethers.BigNumberish\n      checkpoint?: ethers.BigNumberish\n    }\n  ): WalletConfig {\n    const members = topologyToMembers(config.tree)\n\n    if (action.add) {\n      for (const signer of action.add) {\n        if (members.find(s => isSignerLeaf(s) && s.address === signer.address)) {\n          continue\n        }\n\n        members.push({\n          address: signer.address,\n          weight: signer.weight\n        })\n      }\n    }\n\n    if (action.remove) {\n      for (const address of action.remove) {\n        const index = members.findIndex(s => isSignerLeaf(s) && s.address === address)\n        if (index >= 0) {\n          members.splice(index, 1)\n        }\n      }\n    }\n\n    return {\n      version: config.version,\n      threshold: action.threshold ?? config.threshold,\n      checkpoint: action.checkpoint ?? config.checkpoint,\n      tree: optimized2SignersTopologyBuilder(members)\n    }\n  },\n\n  buildStubSignature: function (config: WalletConfig, overrides: Map<string, string>) {\n    const parts = new Map<string, commons.signature.SignaturePart>()\n\n    for (const [signer, signature] of overrides.entries()) {\n      parts.set(signer, { signature, isDynamic: true })\n\n      const { encoded, weight } = encodeSigners(config, parts, [], 0)\n\n      if (weight >= BigInt(config.threshold)) {\n        return encoded\n      }\n    }\n\n    const signers = signersOf(config.tree)\n\n    for (const { address } of signers.sort(({ weight: a }, { weight: b }) => a - b)) {\n      const signature =\n        '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02'\n      parts.set(address, { signature, isDynamic: false })\n\n      const { encoded, weight } = encodeSigners(config, parts, [], 0)\n\n      if (weight >= BigInt(config.threshold)) {\n        return encoded\n      }\n    }\n\n    return encodeSigners(config, parts, [], 0).encoded\n  }\n}\n","import { WalletContext } from '../commons/context'\n\nexport * as config from './config'\nexport * as signature from './signature'\nexport * as context from './context'\nexport * as chained from './chained'\n\nimport { ConfigCoder } from './config'\nimport { SignatureCoder } from './signature'\n\nexport const coders = {\n  config: ConfigCoder,\n  signature: SignatureCoder\n}\n\nexport const version = 2\n\nexport const DeployedWalletContext: WalletContext = {\n  version: version,\n  factory: '0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A',\n  guestModule: '0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE',\n  mainModule: '0xfBf8f1A5E00034762D928f46d438B947f5d4065d',\n  mainModuleUpgradable: '0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911',\n  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'\n}\n","import { ethers } from 'ethers'\nimport { allVersions } from '..'\n\nimport { DeployedWalletContext as context1 } from '../v1'\nimport { DeployedWalletContext as context2 } from '../v2'\n\nexport type WalletContext = {\n  version: number\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n\n  walletCreationCode: string\n}\n\nexport function addressOf(context: WalletContext, imageHash: ethers.BytesLike) {\n  const codeHash = ethers.keccak256(\n    ethers.solidityPacked(['bytes', 'bytes32'], [context.walletCreationCode, ethers.zeroPadValue(context.mainModule, 32)])\n  )\n\n  const hash = ethers.keccak256(\n    ethers.solidityPacked(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, imageHash, codeHash])\n  )\n\n  return ethers.getAddress(ethers.dataSlice(hash, 12))\n}\n\nexport async function isValidCounterfactual(\n  wallet: string,\n  digest: ethers.BytesLike,\n  signature: ethers.BytesLike,\n  chainId: ethers.BigNumberish,\n  provider: ethers.Provider,\n  contexts: { [key: number]: WalletContext }\n) {\n  // We don't know the version of the signature\n  // so we need to try all of them\n  const res = await Promise.all(\n    allVersions.map(async version => {\n      try {\n        const decoded = version.signature.SignatureCoder.decode(ethers.hexlify(signature))\n\n        const recovered1 = await version.signature.SignatureCoder.recover(\n          decoded as any,\n          {\n            address: wallet,\n            digest: ethers.hexlify(digest),\n            chainId\n          },\n          provider\n        )\n\n        const imageHash = version.config.ConfigCoder.imageHashOf(recovered1.config as any)\n        const counterfactualAddress = addressOf(contexts[version.version], imageHash)\n\n        if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) {\n          return true\n        }\n\n        // chainId=0 means no chainId, so the signature is valid for all chains\n        // we need to check that case too\n        const recovered2 = await version.signature.SignatureCoder.recover(\n          decoded as any,\n          {\n            address: wallet,\n            digest: ethers.hexlify(digest),\n            chainId\n          },\n          provider\n        )\n\n        const imageHash2 = version.config.ConfigCoder.imageHashOf(recovered2.config as any)\n        const counterfactualAddress2 = addressOf(contexts[version.version], imageHash2)\n\n        return counterfactualAddress2.toLowerCase() === wallet.toLowerCase()\n      } catch {}\n\n      // We most likely failed to decode the signature\n      return false\n    })\n  )\n\n  return res.some(r => r)\n}\n\nexport type VersionedContext = { [key: number]: WalletContext }\n\nexport function isValidVersionedContext(contexts: VersionedContext): boolean {\n  // number of keys is the number of versions\n  const versions = Object.keys(contexts).length\n\n  // check that all versions exist and are valid\n  for (let i = 1; i <= versions; i++) {\n    const context = contexts[i]\n    if (!context || context.version !== i) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function latestContext(contexts: VersionedContext): WalletContext {\n  const versions = Object.keys(contexts).length\n  return contexts[versions]\n}\n\nexport const defaultContexts: VersionedContext = {\n  1: context1,\n  2: context2\n}\n","import { ethers } from 'ethers'\n\nimport { subdigestOf } from './signature'\nimport { walletContracts } from '@0xsequence/abi'\n\nexport interface Transaction {\n  to: string\n  value?: ethers.BigNumberish\n  data?: string\n  gasLimit?: ethers.BigNumberish\n  delegateCall?: boolean\n  revertOnError?: boolean\n}\n\nexport interface SimulatedTransaction extends Transaction {\n  succeeded: boolean\n  executed: boolean\n  gasUsed: number\n  gasLimit: number\n  result?: string\n  reason?: string\n}\n\nexport interface TransactionEncoded {\n  delegateCall: boolean\n  revertOnError: boolean\n  gasLimit: ethers.BigNumberish\n  target: string\n  value: ethers.BigNumberish\n  data: string\n}\n\nexport type Transactionish = ethers.TransactionRequest | ethers.TransactionRequest[] | Transaction | Transaction[]\n\nexport interface TransactionResponse<R = any> extends ethers.TransactionResponse {\n  receipt?: R\n}\n\nexport type TransactionBundle = {\n  entrypoint: string\n  transactions: Transaction[]\n  nonce?: ethers.BigNumberish\n}\n\nexport type IntendedTransactionBundle = TransactionBundle & {\n  chainId: ethers.BigNumberish\n  intent: {\n    id: string\n    wallet: string\n  }\n}\n\nexport type SignedTransactionBundle = IntendedTransactionBundle & {\n  signature: string\n  nonce: ethers.BigNumberish\n}\n\nexport type RelayReadyTransactionBundle = SignedTransactionBundle | IntendedTransactionBundle\n\nexport const MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`\n\nexport function intendTransactionBundle(\n  bundle: TransactionBundle,\n  wallet: string,\n  chainId: ethers.BigNumberish,\n  id: string\n): IntendedTransactionBundle {\n  return {\n    ...bundle,\n    chainId,\n    intent: { id: id, wallet }\n  }\n}\n\nexport function intendedTransactionID(bundle: IntendedTransactionBundle) {\n  return ethers.keccak256(\n    ethers.AbiCoder.defaultAbiCoder().encode(\n      ['address', 'uint256', 'bytes32'],\n      [bundle.intent.wallet, bundle.chainId, bundle.intent.id]\n    )\n  )\n}\n\nexport function unpackMetaTransactionsData(data: ethers.BytesLike): [bigint, TransactionEncoded[]] {\n  const res = ethers.AbiCoder.defaultAbiCoder().decode(['uint256', MetaTransactionsType], data)\n  if (res.length !== 2 || !res[0] || !res[1]) throw new Error('Invalid meta transaction data')\n  return [res[0], res[1]]\n}\n\nexport function packMetaTransactionsData(nonce: ethers.BigNumberish, txs: Transaction[]): string {\n  return ethers.AbiCoder.defaultAbiCoder().encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)])\n}\n\nexport function digestOfTransactions(nonce: ethers.BigNumberish, txs: Transaction[]) {\n  return ethers.keccak256(packMetaTransactionsData(nonce, txs))\n}\n\nexport function subdigestOfTransactions(\n  address: string,\n  chainId: ethers.BigNumberish,\n  nonce: ethers.BigNumberish,\n  txs: Transaction[]\n): string {\n  return subdigestOf({ address, chainId, digest: digestOfTransactions(nonce, txs) })\n}\n\nexport function subdigestOfGuestModuleTransactions(\n  guestModule: string,\n  chainId: ethers.BigNumberish,\n  txs: Transaction[]\n): string {\n  return subdigestOf({\n    address: guestModule,\n    chainId,\n    digest: ethers.keccak256(\n      ethers.AbiCoder.defaultAbiCoder().encode(['string', MetaTransactionsType], ['guest:', sequenceTxAbiEncode(txs)])\n    )\n  })\n}\n\nexport function toSequenceTransactions(\n  wallet: string,\n  txs: ethers.TransactionRequest[]\n): { nonce?: ethers.BigNumberish; transaction: Transaction }[] {\n  return txs.map(tx => toSequenceTransaction(wallet, tx))\n}\n\nexport function toSequenceTransaction(\n  wallet: string,\n  tx: ethers.TransactionRequest\n): { nonce?: ethers.BigNumberish; transaction: Transaction } {\n  if (tx.to && tx.to !== ethers.ZeroAddress) {\n    return {\n      nonce: !isNullish(tx.nonce) ? BigInt(tx.nonce) : undefined,\n      transaction: {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,\n        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise\n        // Keeping this as is for now so we don't have to change everything to async\n        to: tx.to as string,\n        value: BigInt(tx.value || 0),\n        data: tx.data || '0x'\n      }\n    }\n  } else {\n    const walletInterface = new ethers.Interface(walletContracts.mainModule.abi)\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract')!, [tx.data])\n\n    return {\n      nonce: typeof tx.nonce === 'number' ? BigInt(tx.nonce) : undefined,\n      transaction: {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,\n        to: wallet,\n        value: BigInt(tx.value || 0),\n        data\n      }\n    }\n  }\n}\n\nexport function isSequenceTransaction(tx: any): tx is Transaction {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined\n}\n\nexport function hasSequenceTransactions(txs: any[]): txs is Transaction[] {\n  return txs.every(isSequenceTransaction)\n}\n\n// TODO: We may be able to remove this if we make Transaction === TransactionEncoded\nexport function sequenceTxAbiEncode(txs: Transaction[]): TransactionEncoded[] {\n  return txs.map(tx => ({\n    delegateCall: tx.delegateCall === true,\n    revertOnError: tx.revertOnError === true,\n    gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : 0n,\n    target: tx.to ?? ethers.ZeroAddress,\n    value: !isNullish(tx.value) ? tx.value : 0n,\n    data: tx.data || '0x'\n  }))\n}\n\nexport function fromTxAbiEncode(txs: TransactionEncoded[]): Transaction[] {\n  return txs.map(tx => ({\n    delegateCall: tx.delegateCall,\n    revertOnError: tx.revertOnError,\n    gasLimit: tx.gasLimit,\n    to: tx.target,\n    value: tx.value,\n    data: tx.data\n  }))\n}\n\n// export function appendNonce(txs: Transaction[], nonce: ethers.BigNumberish): Transaction[] {\n//   return txs.map((t: Transaction) => ({ ...t, nonce }))\n// }\n\nexport function encodeNonce(space: ethers.BigNumberish, nonce: ethers.BigNumberish): bigint {\n  const bspace = BigInt(space)\n  const bnonce = BigInt(nonce)\n\n  const shl = 2n ** 96n\n\n  if (bnonce / shl !== 0n) {\n    throw new Error('Space already encoded')\n  }\n\n  return bnonce + bspace * shl\n}\n\nexport function decodeNonce(nonce: ethers.BigNumberish): [bigint, bigint] {\n  const bnonce = BigInt(nonce)\n  const shr = 2n ** 96n\n\n  return [bnonce / shr, bnonce % shr]\n}\n\nexport function fromTransactionish(wallet: string, transaction: Transactionish): Transaction[] {\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      return transaction\n    } else {\n      const stx = toSequenceTransactions(wallet, transaction)\n      return stx.map(t => t.transaction)\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    return [transaction]\n  } else {\n    return [toSequenceTransaction(wallet, transaction).transaction]\n  }\n}\n\nexport function isTransactionBundle(cand: any): cand is TransactionBundle {\n  return (\n    cand !== undefined &&\n    cand.entrypoint !== undefined &&\n    cand.chainId !== undefined &&\n    cand.transactions !== undefined &&\n    cand.nonce !== undefined &&\n    cand.intent !== undefined &&\n    cand.intent.id !== undefined &&\n    cand.intent.wallet !== undefined &&\n    Array.isArray(cand.transactions) &&\n    (<TransactionBundle>cand).transactions.reduce((p, c) => p && isSequenceTransaction(c), true)\n  )\n}\n\nexport function isSignedTransactionBundle(cand: any): cand is SignedTransactionBundle {\n  return cand !== undefined && cand.signature !== undefined && cand.signature !== '' && isTransactionBundle(cand)\n}\n\nexport function encodeBundleExecData(bundle: TransactionBundle): string {\n  const walletInterface = new ethers.Interface(walletContracts.mainModule.abi)\n  return walletInterface.encodeFunctionData(\n    walletInterface.getFunction('execute')!,\n    isSignedTransactionBundle(bundle)\n      ? [\n          // Signed transaction bundle has all 3 parameters\n          sequenceTxAbiEncode(bundle.transactions),\n          bundle.nonce,\n          bundle.signature\n        ]\n      : [\n          // Unsigned bundle may be a GuestModule call, so signature and nonce are missing\n          sequenceTxAbiEncode(bundle.transactions),\n          0,\n          new Uint8Array([])\n        ]\n  )\n}\n\n// TODO: Use Sequence ABI package\nexport const selfExecuteSelector = '0x61c2926c'\nexport const selfExecuteAbi = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`\n\n// Splits Sequence batch transactions into individual parts\nexport const unwind = (wallet: string, transactions: Transaction[]): Transaction[] => {\n  const unwound: Transaction[] = []\n\n  const walletInterface = new ethers.Interface(walletContracts.mainModule.abi)\n\n  for (const tx of transactions) {\n    const txData = ethers.getBytes(tx.data || '0x')\n\n    if (tx.to === wallet && ethers.hexlify(txData.slice(0, 4)) === selfExecuteSelector) {\n      // Decode as selfExecute call\n      const data = txData.slice(4)\n      const decoded = ethers.AbiCoder.defaultAbiCoder().decode([selfExecuteAbi], data)[0]\n      unwound.push(\n        ...unwind(\n          tx.to,\n          decoded.map((d: TransactionEncoded) => ({ ...d, to: d.target }))\n        )\n      )\n    } else {\n      try {\n        const innerTransactions = walletInterface.decodeFunctionData('execute', txData)[0] as ethers.Result\n        const unwoundTransactions = unwind(\n          wallet,\n          innerTransactions.map((tx: ethers.Result) => ({ ...tx.toObject(), to: tx.target }))\n        )\n        unwound.push(...unwoundTransactions)\n      } catch {\n        unwound.push(tx)\n      }\n    }\n  }\n\n  return unwound\n}\n\nconst isNullish = <T>(value: T | null | undefined): value is null | undefined => value === null || value === void 0\n","import { ethers } from 'ethers'\n\n/* Source of Offchain EIP-6492 validation:\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\n\n// As per ERC-1271\ninterface IERC1271Wallet {\n  function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\n}\n\nerror ERC1271Revert(bytes error);\nerror ERC6492DeployFailed(bytes error);\n\ncontract UniversalSigValidator {\n  bytes32 private constant ERC6492_DETECTION_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;\n  bytes4 private constant ERC1271_SUCCESS = 0x1626ba7e;\n\n  function isValidSigImpl(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature,\n    bool allowSideEffects,\n    bool deployAlreadyDeployed\n  ) public returns (bool) {\n    uint contractCodeLen = address(_signer).code.length;\n    bytes memory sigToValidate;\n    // The order here is striclty defined in https://eips.ethereum.org/EIPS/eip-6492\n    // - ERC-6492 suffix check and verification first, while being permissive in case the contract is already deployed; if the contract is deployed we will check the sig against the deployed version, this allows 6492 signatures to still be validated while taking into account potential key rotation\n    // - ERC-1271 verification if there's contract code\n    // - finally, ecrecover\n    bool isCounterfactual = bytes32(_signature[_signature.length-32:_signature.length]) == ERC6492_DETECTION_SUFFIX;\n    if (isCounterfactual) {\n      address create2Factory;\n      bytes memory factoryCalldata;\n      (create2Factory, factoryCalldata, sigToValidate) = abi.decode(_signature[0:_signature.length-32], (address, bytes, bytes));\n\n      if (contractCodeLen == 0 || deployAlreadyDeployed) {\n        (bool success, bytes memory err) = create2Factory.call(factoryCalldata);\n        if (!success) revert ERC6492DeployFailed(err);\n      }\n    } else {\n      sigToValidate = _signature;\n    }\n\n    // Try ERC-1271 verification\n    if (isCounterfactual || contractCodeLen > 0) {\n      try IERC1271Wallet(_signer).isValidSignature(_hash, sigToValidate) returns (bytes4 magicValue) {\n        bool isValid = magicValue == ERC1271_SUCCESS;\n\n        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*\n        // but it may be useful to retry the call making the factory call\n        // even if the wallet is already deployed, in case the wallet\n        // needs to perform some sort of migration or onchain key rotation\n        if (!isValid && !deployAlreadyDeployed && contractCodeLen > 0) {\n          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);\n        }\n\n        if (contractCodeLen == 0 && isCounterfactual && !allowSideEffects) {\n          // if the call had side effects we need to return the\n          // result using a `revert` (to undo the state changes)\n          assembly {\n            mstore(0, isValid)\n            revert(31, 1)\n          }\n        }\n\n        return isValid;\n      } catch (bytes memory err) {\n        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*\n        // but it may be useful to retry the call making the factory call\n        // even if the wallet is already deployed, in case the wallet\n        // needs to perform some sort of migration or onchain key rotation\n        if (!deployAlreadyDeployed && contractCodeLen > 0) {\n          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);\n        }\n\n        revert ERC1271Revert(err);\n      }\n    }\n\n    // ecrecover verification\n    require(_signature.length == 65, 'SignatureValidator#recoverSigner: invalid signature length');\n    bytes32 r = bytes32(_signature[0:32]);\n    bytes32 s = bytes32(_signature[32:64]);\n    uint8 v = uint8(_signature[64]);\n\n    if (v != 27 && v != 28) {\n      revert('SignatureValidator: invalid signature v value');\n    }\n\n    return ecrecover(_hash, v, r, s) == _signer;\n  }\n\n  function isValidSigWithSideEffects(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    return this.isValidSigImpl(_signer, _hash, _signature, true, false);\n  }\n\n  function isValidSig(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n      uint len = error.length;\n      if (len == 1) {\n        return error[0] == 0x01;\n        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n      } else {\n        assembly { revert(error, len) }\n      }\n    }\n  }\n\n  // NOTICE: These functions aren't part of the standard\n  // they are helpers that behave like the above functions\n  // but they don't revert on failure, instead they return false\n\n  function isValidSigNoThrow(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n      uint len = error.length;\n      if (len == 1) {\n        return error[0] == 0x01;\n        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n      } else {\n        // Ignore all other errors and return false\n        return false;\n      }\n    }\n  }\n\n  function isValidSigWithSideEffectsNoThrow(\n    address _signer,\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external returns (bool) {\n    try this.isValidSigImpl(_signer, _hash, _signature, true, false) returns (bool isValid) {\n      return isValid;\n    } catch (bytes memory error) {\n      // Ignore all errors and return false\n      return false;\n    }\n  }\n}\n\n// this is a helper so we can perform validation in a single eth_call without pre-deploying a singleton\ncontract ValidateSigOffchain {\n  constructor (address _signer, bytes32 _hash, bytes memory _signature) {\n    UniversalSigValidator validator = new UniversalSigValidator();\n    bool isValidSig = validator.isValidSigWithSideEffects(_signer, _hash, _signature);\n    assembly {\n      mstore(0, isValidSig)\n      return(31, 1)\n    }\n  }\n}\n*/\n\nexport const EIP_6492_OFFCHAIN_DEPLOY_CODE =\n  '0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033'\nexport const EIP_6492_SUFFIX = '0x6492649264926492649264926492649264926492649264926492649264926492'\n\n// TODO: This is a length payload, we can lower the load by deploying\n// the contract on some of the popular chains, and calling the contract\n// if the provider is one of those chains\nexport async function validateEIP6492Offchain(\n  provider: ethers.Provider,\n  signer: string,\n  hash: ethers.BytesLike,\n  signature: ethers.BytesLike\n): Promise<boolean> {\n  try {\n    const result = await provider.call({\n      data: ethers.concat([\n        EIP_6492_OFFCHAIN_DEPLOY_CODE,\n        ethers.AbiCoder.defaultAbiCoder().encode(['address', 'bytes32', 'bytes'], [signer, hash, signature])\n      ])\n    })\n\n    return result === '0x01'\n  } catch (err) {\n    return false\n  }\n}\n","import { walletContracts } from '@0xsequence/abi'\nimport { ethers } from 'ethers'\nimport { validateEIP6492Offchain } from './validateEIP6492'\n\n/**\n * Provides stateful information about the wallet.\n */\nexport interface Reader {\n  isDeployed(wallet: string): Promise<boolean>\n  implementation(wallet: string): Promise<string | undefined>\n  imageHash(wallet: string): Promise<string | undefined>\n  nonce(wallet: string, space: ethers.BigNumberish): Promise<ethers.BigNumberish>\n  isValidSignature(wallet: string, digest: ethers.BytesLike, signature: ethers.BytesLike): Promise<boolean>\n}\n\n/**\n * The OnChainReader class fetches on-chain data from a wallet.\n * It is used to understand the \"real\" state of the wallet contract on-chain.\n */\nexport class OnChainReader implements Reader {\n  // Simple cache to avoid re-fetching the same data\n  private isDeployedCache: Set<string> = new Set()\n\n  constructor(public readonly provider: ethers.Provider) {}\n\n  private module(address: string) {\n    return new ethers.Contract(\n      address,\n      [...walletContracts.mainModuleUpgradable.abi, ...walletContracts.mainModule.abi, ...walletContracts.erc1271.abi],\n      this.provider\n    )\n  }\n\n  async isDeployed(wallet: string): Promise<boolean> {\n    // This is safe to cache because the wallet cannot be undeployed once deployed\n    if (this.isDeployedCache.has(wallet)) {\n      return true\n    }\n\n    const code = await this.provider.getCode(wallet).then(c => ethers.getBytes(c))\n    const isDeployed = code.length !== 0\n    if (isDeployed) {\n      this.isDeployedCache.add(wallet)\n    }\n\n    return isDeployed\n  }\n\n  async implementation(wallet: string): Promise<string | undefined> {\n    const position = ethers.AbiCoder.defaultAbiCoder().encode(['address'], [wallet])\n    const val = await this.provider.getStorage(wallet, position).then(c => ethers.getBytes(c))\n\n    if (val.length === 20) {\n      return ethers.getAddress(ethers.hexlify(val))\n    }\n\n    if (val.length === 32) {\n      return ethers.AbiCoder.defaultAbiCoder().decode(['address'], val)[0]\n    }\n\n    return undefined\n  }\n\n  async imageHash(wallet: string): Promise<string | undefined> {\n    try {\n      const imageHash = await this.module(wallet).imageHash()\n      return imageHash\n    } catch {}\n\n    return undefined\n  }\n\n  async nonce(wallet: string, space: ethers.BigNumberish = 0): Promise<ethers.BigNumberish> {\n    try {\n      const nonce = await this.module(wallet).readNonce(space)\n      return nonce\n    } catch (e) {\n      if (!(await this.isDeployed(wallet))) {\n        return 0\n      }\n\n      throw e\n    }\n  }\n\n  // We use the EIP-6492 validator contract to check the signature\n  // this means that if the wallet is not deployed, then the signature\n  // must be prefixed with a transaction that deploys the wallet\n  async isValidSignature(wallet: string, digest: ethers.BytesLike, signature: ethers.BytesLike): Promise<boolean> {\n    return validateEIP6492Offchain(this.provider, wallet, digest, signature)\n  }\n}\n","import { ethers } from 'ethers'\nimport { commons } from '..'\nimport { Config } from './config'\n\n/**\n * Request metadata, used by the wallet to pass additional information through the orchestrator.\n */\nexport type WalletSignRequestMetadata = {\n  address: string\n  digest: ethers.BytesLike\n  chainId: ethers.BigNumberish\n\n  config: Config\n\n  parts?: Map<string, commons.signature.SignaturePart>\n\n  // TODO: We can add a \"percentage\" field to the orchestrator to indicate\n  //       how close are we to the threshold. This can be used to display\n  //       a progress bar or something similar.\n\n  message?: ethers.BytesLike\n  transactions?: commons.transaction.Transaction[]\n\n  // This is used only when a Sequence wallet is nested in another Sequence wallet\n  // it contains the original metadata of the parent wallet.\n  parent?: WalletSignRequestMetadata\n\n  decorate?: boolean\n  cantValidateBehavior?: 'ignore' | 'eip6492' | 'throw'\n}\n\nexport function isWalletSignRequestMetadata(obj: any): obj is WalletSignRequestMetadata {\n  return obj && obj.address && obj.digest && obj.chainId !== undefined && obj.config\n}\n\n/**\n * Request metadata, used by the wallet to pass additional information through the orchestrator.\n */\nexport type WalletDeployMetadata = {\n  includeChildren?: boolean // Whether to include children in deployment, default false\n  ignoreDeployed?: boolean // Whether to ignore already deployed wallets, default false\n}\n","import { commons, v1, v2 } from '..'\n\nexport const ALL_CODERS = [\n  { config: v1.config.ConfigCoder, signature: v1.signature.SignatureCoder },\n  { config: v2.config.ConfigCoder, signature: v2.signature.SignatureCoder }\n]\n\nexport function coderFor(version: number) {\n  const index = version - 1\n  if (index < 0 || index >= ALL_CODERS.length) {\n    throw new Error(`No coder for version: ${version}`)\n  }\n\n  return ALL_CODERS[index]\n}\n\n/**\n *  Same as `coderFor` but returns `generic` coders without versioned types.\n */\nexport function genericCoderFor(version: number): {\n  config: commons.config.ConfigCoder\n  signature: commons.signature.SignatureCoder\n} {\n  return coderFor(version)\n}\n","export const VERSION = '2.0.25'\n","export * as v1 from './v1'\nexport * as v2 from './v2'\nexport * as commons from './commons'\nexport * as universal from './universal'\n\nimport * as v1 from './v1'\nimport * as v2 from './v2'\n\nexport { VERSION } from './version'\n\nexport const allVersions = [v1, v2]\n","import { commons } from '@0xsequence/core'\n\nexport function counterfactualVersion(\n  address: string,\n  firstImageHash: string,\n  versions: commons.context.WalletContext[]\n): number {\n  for (let i = 0; i < versions.length; i++) {\n    if (commons.context.addressOf(versions[i], firstImageHash) === address) {\n      return versions[i].version\n    }\n  }\n\n  // if we can't find the version then either the address is invalid,\n  // the version is not in VersionedContext, or the firstImageHash is not correct\n  throw new Error('Could not find version for counterfactual address')\n}\n\nexport interface Version<\n  C extends commons.config.Config,\n  S extends commons.signature.Signature<C>,\n  U extends commons.signature.UnrecoveredSignature\n> {\n  version: number\n  coders: {\n    config: commons.config.ConfigCoder<C>\n    signature: commons.signature.SignatureCoder<C, S, U>\n  }\n}\n","import { commons } from '@0xsequence/core'\nimport { UnsignedMigration } from '../migrator'\nimport { Migration_v1v2 } from './migration_01_02'\n\n//                                 = uint160(keccak256(\"org.sequence.sdk.migration.space.nonce\"))\nexport const MIGRATION_NONCE_SPACE = '0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb'\n\nexport interface Migration<P extends commons.config.Config, C extends commons.config.Config> {\n  version: number\n\n  buildTransaction: (address: string, contexts: commons.context.VersionedContext, newConfig: P | C) => UnsignedMigration\n\n  decodeTransaction: (\n    tx: commons.transaction.TransactionBundle,\n    contexts: commons.context.VersionedContext\n  ) => {\n    address: string\n    newImageHash: string\n  }\n\n  configCoder: commons.config.ConfigCoder<C>\n  signatureCoder: commons.signature.SignatureCoder<C, commons.signature.Signature<C>, commons.signature.UnrecoveredSignature>\n}\n\nexport const v1v2 = new Migration_v1v2()\n","import { commons, v1, v2 } from '@0xsequence/core'\nimport { ethers } from 'ethers'\n\nimport { Migration, MIGRATION_NONCE_SPACE } from '.'\nimport { walletContracts } from '@0xsequence/abi'\nimport { UnsignedMigration } from '../migrator'\n\nexport class Migration_v1v2 implements Migration<v1.config.WalletConfig, v2.config.WalletConfig> {\n  version = 2\n\n  configCoder = v2.config.ConfigCoder\n  signatureCoder = v2.signature.SignatureCoder\n\n  buildTransaction(\n    address: string,\n    contexts: commons.context.VersionedContext,\n    newConfig: v1.config.WalletConfig | v2.config.WalletConfig\n  ): UnsignedMigration {\n    // If new config is not v2, then we need to convert it to v2\n    if (!v2.config.ConfigCoder.isWalletConfig(newConfig)) {\n      const v2Config = v2.config.toWalletConfig({\n        threshold: newConfig.threshold,\n        members: newConfig.signers,\n        checkpoint: 0\n      })\n\n      return this.buildTransaction(address, contexts, v2Config)\n    }\n\n    const context = contexts[2]\n    const contract = new ethers.Interface(walletContracts.mainModule.abi)\n\n    // WARNING: v1 wallets CAN NOT use v2 configurations so we ALWAYS need to update\n    // both the implementation and the configuration at the same time\n\n    const updateBundle = v2.config.ConfigCoder.update.buildTransaction(address, newConfig, context, 'first')\n\n    const tx = {\n      entrypoint: address,\n      nonce: commons.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0),\n      transactions: [\n        {\n          to: address,\n          value: 0,\n          gasLimit: 0,\n          revertOnError: true,\n          delegateCall: false,\n          data: contract.encodeFunctionData(contract.getFunction('updateImplementation')!, [context.mainModuleUpgradable])\n        },\n        ...updateBundle.transactions\n      ]\n    }\n\n    return {\n      tx,\n      fromVersion: this.version - 1,\n      toVersion: this.version,\n      toConfig: newConfig\n    }\n  }\n\n  decodeTransaction(\n    tx: commons.transaction.TransactionBundle,\n    contexts: commons.context.VersionedContext\n  ): {\n    address: string\n    newImageHash: string\n  } {\n    const address = tx.entrypoint\n\n    if (tx.transactions.length < 2) {\n      throw new Error('Invalid transaction bundle size')\n    }\n\n    if (!tx.nonce || commons.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0) !== BigInt(tx.nonce)) {\n      throw new Error('Invalid transaction bundle nonce')\n    }\n\n    if (\n      tx.transactions[0].to !== address ||\n      tx.transactions[1].to !== address ||\n      tx.transactions[0].delegateCall ||\n      tx.transactions[1].delegateCall ||\n      !tx.transactions[0].revertOnError ||\n      !tx.transactions[1].revertOnError ||\n      (tx.transactions[0].value && BigInt(tx.transactions[0].value) !== 0n) ||\n      (tx.transactions[1].value && BigInt(tx.transactions[1].value) !== 0n) ||\n      (tx.transactions[0].gasLimit && BigInt(tx.transactions[0].gasLimit) !== 0n) ||\n      (tx.transactions[1].gasLimit && BigInt(tx.transactions[1].gasLimit) !== 0n)\n    ) {\n      throw new Error('Invalid transaction bundle format')\n    }\n\n    const context = contexts[2]\n    const contract = new ethers.Interface(walletContracts.mainModule.abi)\n\n    const data1 = ethers.hexlify(tx.transactions[0].data || new Uint8Array())\n    const expectData1 = ethers.hexlify(\n      contract.encodeFunctionData(contract.getFunction('updateImplementation')!, [context.mainModuleUpgradable])\n    )\n\n    if (data1 !== expectData1) {\n      throw new Error('Invalid new implementation on transaction')\n    }\n\n    const decoded2 = v2.config.ConfigCoder.update.decodeTransaction({ entrypoint: address, transactions: [tx.transactions[1]] })\n    if (decoded2.address !== address) {\n      throw new Error('Invalid transaction bundle address')\n    }\n\n    return decoded2\n  }\n}\n","import { commons } from '@0xsequence/core'\nimport { Wallet } from '@0xsequence/wallet'\n\nimport { Migration } from './migrations'\nimport { ethers } from 'ethers'\n\nexport type UnsignedMigration = {\n  tx: commons.transaction.TransactionBundle\n  fromVersion: number\n  toVersion: number\n  toConfig: commons.config.Config\n}\n\nexport type SignedMigration = Omit<UnsignedMigration, 'tx'> & {\n  tx: commons.transaction.SignedTransactionBundle\n}\n\nexport interface PresignedMigrationTracker {\n  getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<SignedMigration | undefined>\n\n  saveMigration(address: string, signed: SignedMigration, contexts: commons.context.VersionedContext): Promise<void>\n}\n\nexport type Migrations = { [version: number]: Migration<commons.config.Config, commons.config.Config> }\n\nfunction validateMigrations(migrations: Migrations) {\n  for (const [version, migration] of Object.entries(migrations)) {\n    if (version !== String(migration.version - 1)) {\n      throw new Error(`Migration with key ${version} has version ${migration.version}, expected version to be key + 1`)\n    }\n  }\n}\n\nexport class Migrator {\n  constructor(\n    public readonly tracker: PresignedMigrationTracker,\n    public readonly migrations: Migrations,\n    public readonly contexts: commons.context.VersionedContext\n  ) {\n    validateMigrations(migrations)\n  }\n\n  lastMigration(): Migration<commons.config.Config, commons.config.Config> {\n    let last: Migration<commons.config.Config, commons.config.Config> | undefined\n    for (const migration of Object.values(this.migrations)) {\n      if (last === undefined || migration.version > last.version) {\n        last = migration\n      }\n    }\n    if (last === undefined) {\n      throw new Error('No migrations')\n    }\n    return last\n  }\n\n  async getAllMigratePresignedTransaction(args: {\n    address: string\n    fromImageHash: string\n    fromVersion: number\n    chainId: ethers.BigNumberish\n  }): Promise<{\n    lastVersion: number\n    lastImageHash: string\n    signedMigrations: SignedMigration[]\n    missing: boolean\n  }> {\n    const { address, fromImageHash, fromVersion, chainId } = args\n\n    let fih = fromImageHash\n    let fversion = fromVersion\n\n    const versions = Object.values(this.contexts)\n    const migs: SignedMigration[] = []\n\n    for (let i = 1; i < versions.length; i++) {\n      const mig = await this.tracker.getMigration(address, fih, fversion, chainId)\n      if (!mig) return { signedMigrations: migs, missing: true, lastImageHash: fih, lastVersion: fversion }\n\n      migs.push(mig)\n\n      const migration = this.migrations[fversion]\n      if (!migration) {\n        throw new Error(`No migration found for version ${fversion}`)\n      }\n\n      const decoded = migration.decodeTransaction(mig.tx, this.contexts)\n      if (decoded.address !== address) {\n        throw new Error(`Migration transaction address does not match expected address`)\n      }\n\n      fih = decoded.newImageHash\n      fversion += 1\n    }\n\n    return { signedMigrations: migs, missing: false, lastImageHash: fih, lastVersion: fversion }\n  }\n\n  async signNextMigration(\n    address: string,\n    fromVersion: number,\n    wallet: Wallet,\n    nextConfig: commons.config.Config\n  ): Promise<SignedMigration | undefined> {\n    const migration = this.migrations[fromVersion]\n\n    if (!migration) {\n      return undefined\n    }\n\n    const unsignedMigration = migration.buildTransaction(address, this.contexts, nextConfig)\n    const signedBundle = await wallet.signTransactionBundle(unsignedMigration.tx)\n\n    return {\n      ...unsignedMigration,\n      tx: signedBundle\n    }\n  }\n}\n","import { v1v2 } from './migrations'\nimport { Migrations } from './migrator'\n\nexport const DefaultMigrations: Migrations = {\n  1: v1v2\n}\n","import { ethers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { FeeOption, FeeQuote, Relayer, SimulateResult } from '.'\nimport { logger, Optionals } from '@0xsequence/utils'\nimport { commons } from '@0xsequence/core'\n\nconst DEFAULT_GAS_LIMIT = 800000n\n\nexport interface ProviderRelayerOptions {\n  provider: ethers.Provider\n  waitPollRate?: number\n  deltaBlocksLog?: number\n  fromBlockLog?: number\n}\n\nexport const ProviderRelayerDefaults: Required<Optionals<ProviderRelayerOptions>> = {\n  waitPollRate: 1000,\n  deltaBlocksLog: 12,\n  fromBlockLog: -1024\n}\n\nexport function isProviderRelayerOptions(obj: any): obj is ProviderRelayerOptions {\n  return typeof obj === 'object' && isAbstractProvider(obj.provider)\n}\n\nexport abstract class ProviderRelayer implements Relayer {\n  public provider: ethers.Provider\n  public waitPollRate: number\n  public deltaBlocksLog: number\n  public fromBlockLog: number\n\n  constructor(options: ProviderRelayerOptions) {\n    const opts = { ...ProviderRelayerDefaults, ...options }\n\n    this.provider = opts.provider\n    this.waitPollRate = opts.waitPollRate\n    this.deltaBlocksLog = opts.deltaBlocksLog\n    this.fromBlockLog = opts.fromBlockLog\n  }\n\n  abstract getFeeOptions(\n    address: string,\n    ...transactions: commons.transaction.Transaction[]\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }>\n\n  abstract getFeeOptionsRaw(\n    entrypoint: string,\n    data: ethers.BytesLike,\n    options?: {\n      simulate?: boolean\n    }\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }>\n\n  abstract gasRefundOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<FeeOption[]>\n\n  abstract relay(\n    signedTxs: commons.transaction.IntendedTransactionBundle,\n    quote?: FeeQuote,\n    waitForReceipt?: boolean\n  ): Promise<commons.transaction.TransactionResponse>\n\n  async simulate(wallet: string, ...transactions: commons.transaction.Transaction[]): Promise<SimulateResult[]> {\n    return (\n      await Promise.all(\n        transactions.map(async tx => {\n          // Respect gasLimit request of the transaction (as long as its not 0)\n          if (tx.gasLimit && BigInt(tx.gasLimit || 0) !== 0n) {\n            return tx.gasLimit\n          }\n\n          // Fee can't be estimated locally for delegateCalls\n          if (tx.delegateCall) {\n            return DEFAULT_GAS_LIMIT\n          }\n\n          // Fee can't be estimated for self-called if wallet hasn't been deployed\n          if (tx.to === wallet && (await this.provider.getCode(wallet).then(code => ethers.getBytes(code).length === 0))) {\n            return DEFAULT_GAS_LIMIT\n          }\n\n          if (!this.provider) {\n            throw new Error('signer.provider is not set, but is required')\n          }\n\n          // TODO: If the wallet address has been deployed, gas limits can be\n          // estimated with more accurately by using self-calls with the batch transactions one by one\n          return this.provider.estimateGas({\n            from: wallet,\n            to: tx.to,\n            data: tx.data,\n            value: tx.value\n          })\n        })\n      )\n    ).map(gasLimit => ({\n      executed: true,\n      succeeded: true,\n      gasUsed: Number(gasLimit),\n      gasLimit: Number(gasLimit)\n    }))\n  }\n\n  async getNonce(address: string, space?: ethers.BigNumberish, blockTag?: ethers.BlockTag): Promise<ethers.BigNumberish> {\n    if (!this.provider) {\n      throw new Error('provider is not set')\n    }\n\n    if ((await this.provider.getCode(address)) === '0x') {\n      return 0\n    }\n\n    if (space === undefined) {\n      space = 0\n    }\n\n    const module = new ethers.Contract(address, walletContracts.mainModule.abi, this.provider)\n    const nonce = await module.readNonce(space, { blockTag: blockTag })\n    return commons.transaction.encodeNonce(space, nonce)\n  }\n\n  async wait(\n    metaTxnId: string | commons.transaction.SignedTransactionBundle,\n    timeoutDuration?: number,\n    delay: number = this.waitPollRate,\n    maxFails: number = 5\n  ): Promise<ethers.TransactionResponse & { receipt: ethers.TransactionReceipt }> {\n    if (typeof metaTxnId !== 'string') {\n      metaTxnId = commons.transaction.intendedTransactionID(metaTxnId)\n    }\n\n    let timedOut = false\n\n    const retry = async <T>(f: () => Promise<T>, errorMessage: string): Promise<T> => {\n      let fails = 0\n\n      while (!timedOut) {\n        try {\n          return await f()\n        } catch (error) {\n          fails++\n\n          if (maxFails !== undefined && fails >= maxFails) {\n            logger.error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`, error)\n            throw error\n          } else {\n            logger.warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ''}`, error)\n          }\n        }\n\n        if (delay > 0) {\n          await new Promise(resolve => setTimeout(resolve, delay))\n        }\n      }\n\n      throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`)\n    }\n\n    const waitReceipt = async (): Promise<ethers.TransactionResponse & { receipt: ethers.TransactionReceipt }> => {\n      // Transactions can only get executed on nonce change\n      // get all nonce changes and look for metaTxnIds in between logs\n      let lastBlock: number = this.fromBlockLog\n\n      if (lastBlock < 0) {\n        const block = await retry(() => this.provider.getBlockNumber(), 'unable to get latest block number')\n        lastBlock = block + lastBlock\n      }\n\n      if (typeof metaTxnId !== 'string') {\n        throw new Error('impossible')\n      }\n\n      const normalMetaTxnId = metaTxnId.replace('0x', '')\n\n      while (!timedOut) {\n        const block = await retry(() => this.provider.getBlockNumber(), 'unable to get latest block number')\n\n        const logs = await retry(\n          () =>\n            this.provider.getLogs({\n              fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),\n              toBlock: block,\n              // Nonce change event topic\n              topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']\n            }),\n          `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - this.deltaBlocksLog)} to ${block}`\n        )\n\n        lastBlock = block\n\n        // Get receipts of all transactions\n        const txs = await Promise.all(\n          logs.map(l =>\n            retry(\n              () => this.provider.getTransactionReceipt(l.transactionHash),\n              `unable to get receipt for transaction ${l.transactionHash}`\n            )\n          )\n        )\n\n        // Find a transaction with a TxExecuted log\n        const found = txs.find(tx =>\n          tx?.logs.find(\n            l =>\n              (l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId) ||\n              (l.topics.length === 1 &&\n                // TxFailed event topic\n                l.topics[0] === '0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7' &&\n                l.data.length >= 64 &&\n                l.data.replace('0x', '').startsWith(normalMetaTxnId))\n          )\n        )\n\n        // If found return that\n        if (found) {\n          const response = await retry(() => this.provider.getTransaction(found.hash), `unable to get transaction ${found.hash}`)\n          if (!response) {\n            throw new Error(`Transaction response not found for  ${metaTxnId}`)\n          }\n\n          // NOTE: we have to do this, because ethers-v6 uses private fields\n          // and we can't just extend the class and override the method, so\n          // we just modify the response object directly by adding the receipt to it.\n          const out: any = response\n          out.receipt = found\n          return out\n        }\n\n        // Otherwise wait and try again\n        if (!timedOut) {\n          await new Promise(r => setTimeout(r, delay))\n        }\n      }\n\n      throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`)\n    }\n\n    if (timeoutDuration !== undefined) {\n      return Promise.race([\n        waitReceipt(),\n        new Promise<ethers.TransactionResponse & { receipt: ethers.TransactionReceipt }>((_, reject) =>\n          setTimeout(() => {\n            timedOut = true\n            reject(`Timeout waiting for transaction receipt ${metaTxnId}`)\n          }, timeoutDuration)\n        )\n      ])\n    } else {\n      return waitReceipt()\n    }\n  }\n}\n\nfunction isAbstractProvider(provider: any): provider is ethers.AbstractProvider {\n  return (\n    provider &&\n    typeof provider === 'object' &&\n    typeof provider.getNetwork === 'function' &&\n    typeof provider.getBlockNumber === 'function'\n  )\n}\n","import { ethers } from 'ethers'\nimport { logger } from '@0xsequence/utils'\nimport { FeeOption, FeeQuote, Relayer } from '.'\nimport { ProviderRelayer, ProviderRelayerOptions } from './provider-relayer'\nimport { commons } from '@0xsequence/core'\n\nexport type LocalRelayerOptions = Omit<ProviderRelayerOptions, 'provider'> & {\n  signer: ethers.Signer\n}\n\nexport function isLocalRelayerOptions(obj: any): obj is LocalRelayerOptions {\n  return typeof obj === 'object' && isAbstractSigner(obj.signer)\n}\n\nexport class LocalRelayer extends ProviderRelayer implements Relayer {\n  private signer: ethers.Signer\n  private txnOptions: ethers.TransactionRequest\n\n  constructor(options: LocalRelayerOptions | ethers.AbstractSigner) {\n    super(isAbstractSigner(options) ? { provider: options.provider! } : { ...options, provider: options.signer.provider! })\n    this.signer = isAbstractSigner(options) ? options : options.signer\n    if (!this.signer.provider) throw new Error('Signer must have a provider')\n  }\n\n  async getFeeOptions(_address: string, ..._transactions: commons.transaction.Transaction[]): Promise<{ options: FeeOption[] }> {\n    return { options: [] }\n  }\n\n  async getFeeOptionsRaw(\n    _entrypoint: string,\n    _data: ethers.BytesLike,\n    _options?: {\n      simulate?: boolean\n    }\n  ): Promise<{ options: FeeOption[] }> {\n    return { options: [] }\n  }\n\n  async gasRefundOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<FeeOption[]> {\n    const { options } = await this.getFeeOptions(address, ...transactions)\n    return options\n  }\n\n  setTransactionOptions(transactionRequest: ethers.TransactionRequest) {\n    this.txnOptions = transactionRequest\n  }\n\n  async relay(\n    signedTxs: commons.transaction.IntendedTransactionBundle,\n    quote?: FeeQuote,\n    waitForReceipt: boolean = true\n  ): Promise<commons.transaction.TransactionResponse<ethers.TransactionReceipt>> {\n    if (quote !== undefined) {\n      logger.warn(`LocalRelayer doesn't accept fee quotes`)\n    }\n\n    const data = commons.transaction.encodeBundleExecData(signedTxs)\n\n    // TODO: think about computing gas limit individually, summing together and passing across\n    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation\n    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum + tx.gasLimit, 0n)\n    // txRequest.gasLimit = gasLimit\n\n    const responsePromise = this.signer.sendTransaction({\n      to: signedTxs.entrypoint,\n      data,\n      ...this.txnOptions,\n      gasLimit: 9000000\n    })\n\n    if (waitForReceipt) {\n      const response: commons.transaction.TransactionResponse = await responsePromise\n      response.receipt = await response.wait()\n      return response\n    } else {\n      return responsePromise\n    }\n  }\n}\n\nfunction isAbstractSigner(signer: any): signer is ethers.AbstractSigner {\n  return (\n    signer &&\n    typeof signer === 'object' &&\n    typeof signer.provider === 'object' &&\n    typeof signer.getAddress === 'function' &&\n    typeof signer.connect === 'function'\n  )\n}\n","/* eslint-disable */\n// sequence-relayer v0.4.1 1e27d0fd295aa5897878939595ef0c6adc54b1a3\n// --\n// Code generated by webrpc-gen@v0.18.6 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=relayer.ridl -target=typescript -client -out=./clients/relayer.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = 'v1'\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = 'v0.4.1'\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = '1e27d0fd295aa5897878939595ef0c6adc54b1a3'\n\n//\n// Types\n//\n\nexport enum ETHTxnStatus {\n  UNKNOWN = 'UNKNOWN',\n  DROPPED = 'DROPPED',\n  QUEUED = 'QUEUED',\n  SENT = 'SENT',\n  SUCCEEDED = 'SUCCEEDED',\n  PARTIALLY_FAILED = 'PARTIALLY_FAILED',\n  FAILED = 'FAILED'\n}\n\nexport enum TransferType {\n  SEND = 'SEND',\n  RECEIVE = 'RECEIVE',\n  BRIDGE_DEPOSIT = 'BRIDGE_DEPOSIT',\n  BRIDGE_WITHDRAW = 'BRIDGE_WITHDRAW',\n  BURN = 'BURN',\n  UNKNOWN = 'UNKNOWN'\n}\n\nexport enum FeeTokenType {\n  UNKNOWN = 'UNKNOWN',\n  ERC20_TOKEN = 'ERC20_TOKEN',\n  ERC1155_TOKEN = 'ERC1155_TOKEN'\n}\n\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  useEIP1559: boolean\n  senders: Array<SenderStatus>\n  checks: RuntimeChecks\n  numTxnsRelayed: NumTxnsRelayed\n}\n\nexport interface SenderStatus {\n  index: number\n  address: string\n  etherBalance: number\n  active: boolean\n}\n\nexport interface RuntimeChecks {}\n\nexport interface NumTxnsRelayed {\n  prev: number\n  current: number\n  period: number\n}\n\nexport interface SequenceContext {\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n  utils: string\n}\n\nexport interface GasTank {\n  id: number\n  name: string\n  currentBalance: number\n  unlimited: boolean\n  feeMarkupFactor: number\n  updatedAt: string\n  createdAt: string\n}\n\nexport interface GasTankBalanceAdjustment {\n  gasTankId: number\n  nonce: number\n  amount: number\n  totalBalance: number\n  balanceTimestamp: string\n  createdAt: string\n}\n\nexport interface GasSponsor {\n  id: number\n  gasTankId: number\n  projectId: number\n  address: string\n  name: string\n  active: boolean\n  updatedAt: string\n  createdAt: string\n  deletedAt: string\n}\n\nexport interface GasSponsorUsage {\n  name: string\n  id: number\n  totalGasUsed: number\n  totalTxnFees: number\n  totalTxnFeesUsd: number\n  avgGasPrice: number\n  totalTxns: number\n  startTime: string\n  endTime: string\n}\n\nexport interface MetaTxn {\n  walletAddress: string\n  contract: string\n  input: string\n}\n\nexport interface MetaTxnLog {\n  id: number\n  projectId: number\n  txnHash: string\n  txnNonce: string\n  metaTxnID?: string\n  txnStatus: ETHTxnStatus\n  txnRevertReason: string\n  requeues: number\n  queuedAt: string\n  sentAt: string\n  minedAt: string\n  target: string\n  input: string\n  txnArgs: { [key: string]: any }\n  txnReceipt?: { [key: string]: any }\n  walletAddress: string\n  metaTxnNonce: string\n  gasLimit: number\n  gasPrice: string\n  gasUsed: number\n  gasEstimated: number\n  gasFeeMarkup?: number\n  usdRate: string\n  creditsUsed: number\n  isWhitelisted: boolean\n  gasSponsor?: number\n  gasTank?: number\n  updatedAt: string\n  createdAt: string\n}\n\nexport interface MetaTxnEntry {\n  id: number\n  metaTxnID: string\n  txnStatus: ETHTxnStatus\n  txnRevertReason: string\n  index: number\n  logs?: Array<any>\n  updatedAt: string\n  createdAt: string\n}\n\nexport interface MetaTxnReceipt {\n  id: string\n  status: string\n  revertReason?: string\n  index: number\n  logs: Array<MetaTxnReceiptLog>\n  receipts: Array<MetaTxnReceipt>\n  txnReceipt: string\n}\n\nexport interface MetaTxnReceiptLog {\n  address: string\n  topics: Array<string>\n  data: string\n}\n\nexport interface Transaction {\n  txnHash?: string\n  blockNumber: number\n  chainId: number\n  metaTxnID?: string\n  transfers?: Array<TxnLogTransfer>\n  users?: { [key: string]: TxnLogUser }\n  timestamp: string\n}\n\nexport interface TxnLogUser {\n  username: string\n}\n\nexport interface TxnLogTransfer {\n  transferType: TransferType\n  contractAddress: string\n  from: string\n  to: string\n  ids: Array<string>\n  amounts: Array<string>\n}\n\nexport interface SentTransactionsFilter {\n  pending?: boolean\n  failed?: boolean\n}\n\nexport interface SimulateResult {\n  executed: boolean\n  succeeded: boolean\n  result?: string\n  reason?: string\n  gasUsed: number\n  gasLimit: number\n}\n\nexport interface FeeOption {\n  token: FeeToken\n  to: string\n  value: string\n  gasLimit: number\n}\n\nexport interface FeeToken {\n  chainId: number\n  name: string\n  symbol: string\n  type: FeeTokenType\n  decimals?: number\n  logoURL: string\n  contractAddress?: string\n  tokenID?: string\n}\n\nexport interface Page {\n  pageSize?: number\n  page?: number\n  more?: boolean\n  totalRecords?: number\n  column?: string\n  before?: any\n  after?: any\n  sort?: Array<SortBy>\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface Relayer {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>\n  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>\n  getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn>\n  getChainID(headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn>\n  sendMetaTxn(args: SendMetaTxnArgs, headers?: object, signal?: AbortSignal): Promise<SendMetaTxnReturn>\n  getMetaTxnNonce(args: GetMetaTxnNonceArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnNonceReturn>\n  getMetaTxnReceipt(args: GetMetaTxnReceiptArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnReceiptReturn>\n  simulate(args: SimulateArgs, headers?: object, signal?: AbortSignal): Promise<SimulateReturn>\n  updateMetaTxnGasLimits(\n    args: UpdateMetaTxnGasLimitsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateMetaTxnGasLimitsReturn>\n  feeTokens(headers?: object, signal?: AbortSignal): Promise<FeeTokensReturn>\n  feeOptions(args: FeeOptionsArgs, headers?: object, signal?: AbortSignal): Promise<FeeOptionsReturn>\n  getMetaTxnNetworkFeeOptions(\n    args: GetMetaTxnNetworkFeeOptionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetMetaTxnNetworkFeeOptionsReturn>\n  getMetaTransactions(args: GetMetaTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTransactionsReturn>\n  sentTransactions(args: SentTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<SentTransactionsReturn>\n  pendingTransactions(args: PendingTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<PendingTransactionsReturn>\n  getGasTank(args: GetGasTankArgs, headers?: object, signal?: AbortSignal): Promise<GetGasTankReturn>\n  addGasTank(args: AddGasTankArgs, headers?: object, signal?: AbortSignal): Promise<AddGasTankReturn>\n  updateGasTank(args: UpdateGasTankArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasTankReturn>\n  getGasSponsor(args: GetGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<GetGasSponsorReturn>\n  addressGasSponsors(args: AddressGasSponsorsArgs, headers?: object, signal?: AbortSignal): Promise<AddressGasSponsorsReturn>\n  listGasSponsors(args: ListGasSponsorsArgs, headers?: object, signal?: AbortSignal): Promise<ListGasSponsorsReturn>\n  addGasSponsor(args: AddGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<AddGasSponsorReturn>\n  updateGasSponsor(args: UpdateGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasSponsorReturn>\n  removeGasSponsor(args: RemoveGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<RemoveGasSponsorReturn>\n  reportGasSponsorUsage(\n    args: ReportGasSponsorUsageArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ReportGasSponsorUsageReturn>\n  nextGasTankBalanceAdjustmentNonce(\n    args: NextGasTankBalanceAdjustmentNonceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<NextGasTankBalanceAdjustmentNonceReturn>\n  adjustGasTankBalance(\n    args: AdjustGasTankBalanceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AdjustGasTankBalanceReturn>\n  getGasTankBalanceAdjustment(\n    args: GetGasTankBalanceAdjustmentArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetGasTankBalanceAdjustmentReturn>\n  listGasTankBalanceAdjustments(\n    args: ListGasTankBalanceAdjustmentsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListGasTankBalanceAdjustmentsReturn>\n}\n\nexport interface PingArgs {}\n\nexport interface PingReturn {\n  status: boolean\n}\nexport interface VersionArgs {}\n\nexport interface VersionReturn {\n  version: Version\n}\nexport interface RuntimeStatusArgs {}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus\n}\nexport interface GetSequenceContextArgs {}\n\nexport interface GetSequenceContextReturn {\n  data: SequenceContext\n}\nexport interface GetChainIDArgs {}\n\nexport interface GetChainIDReturn {\n  chainID: number\n}\nexport interface SendMetaTxnArgs {\n  call: MetaTxn\n  quote?: string\n}\n\nexport interface SendMetaTxnReturn {\n  status: boolean\n  txnHash: string\n}\nexport interface GetMetaTxnNonceArgs {\n  walletContractAddress: string\n  space?: string\n}\n\nexport interface GetMetaTxnNonceReturn {\n  nonce: string\n}\nexport interface GetMetaTxnReceiptArgs {\n  metaTxID: string\n}\n\nexport interface GetMetaTxnReceiptReturn {\n  receipt: MetaTxnReceipt\n}\nexport interface SimulateArgs {\n  wallet: string\n  transactions: string\n}\n\nexport interface SimulateReturn {\n  results: Array<SimulateResult>\n}\nexport interface UpdateMetaTxnGasLimitsArgs {\n  walletAddress: string\n  walletConfig: any\n  payload: string\n}\n\nexport interface UpdateMetaTxnGasLimitsReturn {\n  payload: string\n}\nexport interface FeeTokensArgs {}\n\nexport interface FeeTokensReturn {\n  isFeeRequired: boolean\n  tokens: Array<FeeToken>\n}\nexport interface FeeOptionsArgs {\n  wallet: string\n  to: string\n  data: string\n  simulate?: boolean\n}\n\nexport interface FeeOptionsReturn {\n  options: Array<FeeOption>\n  sponsored: boolean\n  quote?: string\n}\nexport interface GetMetaTxnNetworkFeeOptionsArgs {\n  walletConfig: any\n  payload: string\n}\n\nexport interface GetMetaTxnNetworkFeeOptionsReturn {\n  options: Array<FeeOption>\n}\nexport interface GetMetaTransactionsArgs {\n  projectId: number\n  gasTankId: number\n  page?: Page\n}\n\nexport interface GetMetaTransactionsReturn {\n  page: Page\n  transactions: Array<MetaTxnLog>\n}\nexport interface SentTransactionsArgs {\n  filter?: SentTransactionsFilter\n  page?: Page\n}\n\nexport interface SentTransactionsReturn {\n  page: Page\n  transactions: Array<Transaction>\n}\nexport interface PendingTransactionsArgs {\n  page?: Page\n}\n\nexport interface PendingTransactionsReturn {\n  page: Page\n  transactions: Array<Transaction>\n}\nexport interface GetGasTankArgs {\n  id: number\n}\n\nexport interface GetGasTankReturn {\n  gasTank: GasTank\n}\nexport interface AddGasTankArgs {\n  name: string\n  feeMarkupFactor: number\n  unlimited?: boolean\n}\n\nexport interface AddGasTankReturn {\n  status: boolean\n  gasTank: GasTank\n}\nexport interface UpdateGasTankArgs {\n  id: number\n  name?: string\n  feeMarkupFactor?: number\n  unlimited?: boolean\n}\n\nexport interface UpdateGasTankReturn {\n  status: boolean\n  gasTank: GasTank\n}\nexport interface GetGasSponsorArgs {\n  id: number\n}\n\nexport interface GetGasSponsorReturn {\n  gasSponsor: GasSponsor\n}\nexport interface AddressGasSponsorsArgs {\n  address: string\n  page?: Page\n}\n\nexport interface AddressGasSponsorsReturn {\n  page: Page\n  gasSponsors: Array<GasSponsor>\n}\nexport interface ListGasSponsorsArgs {\n  projectId: number\n  gasTankId: number\n  page?: Page\n}\n\nexport interface ListGasSponsorsReturn {\n  page: Page\n  gasSponsors: Array<GasSponsor>\n}\nexport interface AddGasSponsorArgs {\n  projectId: number\n  gasTankId: number\n  address: string\n  name?: string\n  active?: boolean\n}\n\nexport interface AddGasSponsorReturn {\n  status: boolean\n  gasSponsor: GasSponsor\n}\nexport interface UpdateGasSponsorArgs {\n  id: number\n  name?: string\n  active?: boolean\n}\n\nexport interface UpdateGasSponsorReturn {\n  status: boolean\n  gasSponsor: GasSponsor\n}\nexport interface RemoveGasSponsorArgs {\n  id: number\n}\n\nexport interface RemoveGasSponsorReturn {\n  status: boolean\n}\nexport interface ReportGasSponsorUsageArgs {\n  projectId: number\n  gasTankId: number\n  startTime?: string\n  endTime?: string\n}\n\nexport interface ReportGasSponsorUsageReturn {\n  gasSponsorUsage: Array<GasSponsorUsage>\n}\nexport interface NextGasTankBalanceAdjustmentNonceArgs {\n  id: number\n}\n\nexport interface NextGasTankBalanceAdjustmentNonceReturn {\n  nonce: number\n}\nexport interface AdjustGasTankBalanceArgs {\n  id: number\n  nonce: number\n  amount: number\n}\n\nexport interface AdjustGasTankBalanceReturn {\n  status: boolean\n  adjustment: GasTankBalanceAdjustment\n}\nexport interface GetGasTankBalanceAdjustmentArgs {\n  id: number\n  nonce: number\n}\n\nexport interface GetGasTankBalanceAdjustmentReturn {\n  adjustment: GasTankBalanceAdjustment\n}\nexport interface ListGasTankBalanceAdjustmentsArgs {\n  id: number\n  page?: Page\n}\n\nexport interface ListGasTankBalanceAdjustmentsReturn {\n  page: Page\n  adjustments: Array<GasTankBalanceAdjustment>\n}\n\n//\n// Client\n//\nexport class Relayer implements Relayer {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Relayer/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {\n    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: <Version>_data.version\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {\n    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <RuntimeStatus>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSequenceContext = (headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn> => {\n    return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            data: <SequenceContext>_data.data\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getChainID = (headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn> => {\n    return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            chainID: <number>_data.chainID\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sendMetaTxn = (args: SendMetaTxnArgs, headers?: object, signal?: AbortSignal): Promise<SendMetaTxnReturn> => {\n    return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            txnHash: <string>_data.txnHash\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getMetaTxnNonce = (args: GetMetaTxnNonceArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnNonceReturn> => {\n    return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            nonce: <string>_data.nonce\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getMetaTxnReceipt = (args: GetMetaTxnReceiptArgs, headers?: object, signal?: AbortSignal): Promise<GetMetaTxnReceiptReturn> => {\n    return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            receipt: <MetaTxnReceipt>_data.receipt\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  simulate = (args: SimulateArgs, headers?: object, signal?: AbortSignal): Promise<SimulateReturn> => {\n    return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            results: <Array<SimulateResult>>_data.results\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateMetaTxnGasLimits = (\n    args: UpdateMetaTxnGasLimitsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateMetaTxnGasLimitsReturn> => {\n    return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            payload: <string>_data.payload\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  feeTokens = (headers?: object, signal?: AbortSignal): Promise<FeeTokensReturn> => {\n    return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isFeeRequired: <boolean>_data.isFeeRequired,\n            tokens: <Array<FeeToken>>_data.tokens\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  feeOptions = (args: FeeOptionsArgs, headers?: object, signal?: AbortSignal): Promise<FeeOptionsReturn> => {\n    return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: <Array<FeeOption>>_data.options,\n            sponsored: <boolean>_data.sponsored,\n            quote: <string>_data.quote\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getMetaTxnNetworkFeeOptions = (\n    args: GetMetaTxnNetworkFeeOptionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetMetaTxnNetworkFeeOptionsReturn> => {\n    return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: <Array<FeeOption>>_data.options\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getMetaTransactions = (\n    args: GetMetaTransactionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetMetaTransactionsReturn> => {\n    return this.fetch(this.url('GetMetaTransactions'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            transactions: <Array<MetaTxnLog>>_data.transactions\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sentTransactions = (args: SentTransactionsArgs, headers?: object, signal?: AbortSignal): Promise<SentTransactionsReturn> => {\n    return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            transactions: <Array<Transaction>>_data.transactions\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  pendingTransactions = (\n    args: PendingTransactionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<PendingTransactionsReturn> => {\n    return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            transactions: <Array<Transaction>>_data.transactions\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getGasTank = (args: GetGasTankArgs, headers?: object, signal?: AbortSignal): Promise<GetGasTankReturn> => {\n    return this.fetch(this.url('GetGasTank'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            gasTank: <GasTank>_data.gasTank\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addGasTank = (args: AddGasTankArgs, headers?: object, signal?: AbortSignal): Promise<AddGasTankReturn> => {\n    return this.fetch(this.url('AddGasTank'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            gasTank: <GasTank>_data.gasTank\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateGasTank = (args: UpdateGasTankArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasTankReturn> => {\n    return this.fetch(this.url('UpdateGasTank'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            gasTank: <GasTank>_data.gasTank\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getGasSponsor = (args: GetGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<GetGasSponsorReturn> => {\n    return this.fetch(this.url('GetGasSponsor'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            gasSponsor: <GasSponsor>_data.gasSponsor\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addressGasSponsors = (\n    args: AddressGasSponsorsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddressGasSponsorsReturn> => {\n    return this.fetch(this.url('AddressGasSponsors'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            gasSponsors: <Array<GasSponsor>>_data.gasSponsors\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listGasSponsors = (args: ListGasSponsorsArgs, headers?: object, signal?: AbortSignal): Promise<ListGasSponsorsReturn> => {\n    return this.fetch(this.url('ListGasSponsors'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            gasSponsors: <Array<GasSponsor>>_data.gasSponsors\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addGasSponsor = (args: AddGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<AddGasSponsorReturn> => {\n    return this.fetch(this.url('AddGasSponsor'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            gasSponsor: <GasSponsor>_data.gasSponsor\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateGasSponsor = (args: UpdateGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<UpdateGasSponsorReturn> => {\n    return this.fetch(this.url('UpdateGasSponsor'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            gasSponsor: <GasSponsor>_data.gasSponsor\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  removeGasSponsor = (args: RemoveGasSponsorArgs, headers?: object, signal?: AbortSignal): Promise<RemoveGasSponsorReturn> => {\n    return this.fetch(this.url('RemoveGasSponsor'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  reportGasSponsorUsage = (\n    args: ReportGasSponsorUsageArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ReportGasSponsorUsageReturn> => {\n    return this.fetch(this.url('ReportGasSponsorUsage'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            gasSponsorUsage: <Array<GasSponsorUsage>>_data.gasSponsorUsage\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  nextGasTankBalanceAdjustmentNonce = (\n    args: NextGasTankBalanceAdjustmentNonceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<NextGasTankBalanceAdjustmentNonceReturn> => {\n    return this.fetch(this.url('NextGasTankBalanceAdjustmentNonce'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            nonce: <number>_data.nonce\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  adjustGasTankBalance = (\n    args: AdjustGasTankBalanceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AdjustGasTankBalanceReturn> => {\n    return this.fetch(this.url('AdjustGasTankBalance'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            adjustment: <GasTankBalanceAdjustment>_data.adjustment\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getGasTankBalanceAdjustment = (\n    args: GetGasTankBalanceAdjustmentArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetGasTankBalanceAdjustmentReturn> => {\n    return this.fetch(this.url('GetGasTankBalanceAdjustment'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            adjustment: <GasTankBalanceAdjustment>_data.adjustment\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listGasTankBalanceAdjustments = (\n    args: ListGasTankBalanceAdjustmentsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListGasTankBalanceAdjustmentsReturn> => {\n    return this.fetch(this.url('ListGasTankBalanceAdjustments'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            adjustments: <Array<GasTankBalanceAdjustment>>_data.adjustments\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`\n      })\n    }\n    if (!res.ok) {\n      const code: number = typeof data.code === 'number' ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n// Schema errors\n\nexport class UnauthorizedError extends WebrpcError {\n  constructor(\n    name: string = 'Unauthorized',\n    code: number = 1000,\n    message: string = 'Unauthorized access',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnauthorizedError.prototype)\n  }\n}\n\nexport class PermissionDeniedError extends WebrpcError {\n  constructor(\n    name: string = 'PermissionDenied',\n    code: number = 1001,\n    message: string = 'Permission denied',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, PermissionDeniedError.prototype)\n  }\n}\n\nexport class MethodNotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'MethodNotFound',\n    code: number = 1003,\n    message: string = 'Method not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, MethodNotFoundError.prototype)\n  }\n}\n\nexport class AbortedError extends WebrpcError {\n  constructor(\n    name: string = 'Aborted',\n    code: number = 1005,\n    message: string = 'Request aborted',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, AbortedError.prototype)\n  }\n}\n\nexport class InvalidArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidArgument',\n    code: number = 2001,\n    message: string = 'Invalid argument',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidArgumentError.prototype)\n  }\n}\n\nexport class UnavailableError extends WebrpcError {\n  constructor(\n    name: string = 'Unavailable',\n    code: number = 2002,\n    message: string = 'Unavailable resource',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnavailableError.prototype)\n  }\n}\n\nexport class QueryFailedError extends WebrpcError {\n  constructor(\n    name: string = 'QueryFailed',\n    code: number = 2003,\n    message: string = 'Query failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, QueryFailedError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'NotFound',\n    code: number = 3000,\n    message: string = 'Resource not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  Unauthorized = 'Unauthorized',\n  PermissionDenied = 'PermissionDenied',\n  MethodNotFound = 'MethodNotFound',\n  Aborted = 'Aborted',\n  InvalidArgument = 'InvalidArgument',\n  Unavailable = 'Unavailable',\n  QueryFailed = 'QueryFailed',\n  NotFound = 'NotFound'\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1000]: UnauthorizedError,\n  [1001]: PermissionDeniedError,\n  [1003]: MethodNotFoundError,\n  [1005]: AbortedError,\n  [2001]: InvalidArgumentError,\n  [2002]: UnavailableError,\n  [2003]: QueryFailedError,\n  [3000]: NotFoundError\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","import { ethers } from 'ethers'\nimport { FeeOption, FeeQuote, Relayer, SimulateResult } from '..'\nimport * as proto from './relayer.gen'\nimport { commons } from '@0xsequence/core'\nimport { bigintReplacer, getFetchRequest, logger, toHexString } from '@0xsequence/utils'\n\nexport { proto }\n\nconst FINAL_STATUSES = [\n  proto.ETHTxnStatus.DROPPED,\n  proto.ETHTxnStatus.SUCCEEDED,\n  proto.ETHTxnStatus.PARTIALLY_FAILED,\n  proto.ETHTxnStatus.FAILED\n]\n\nconst FAILED_STATUSES = [proto.ETHTxnStatus.DROPPED, proto.ETHTxnStatus.PARTIALLY_FAILED, proto.ETHTxnStatus.FAILED]\n\nexport interface RpcRelayerOptions {\n  provider: ethers.AbstractProvider | { url: string }\n  url: string\n  projectAccessKey?: string\n  jwtAuth?: string\n}\n\nexport function isRpcRelayerOptions(obj: any): obj is RpcRelayerOptions {\n  return obj.url !== undefined && typeof obj.url === 'string' && obj.provider !== undefined && isAbstractProvider(obj.provider)\n}\n\nconst fetch = globalThis.fetch\n\n// TODO: rename to SequenceRelayer\nexport class RpcRelayer implements Relayer {\n  private readonly service: proto.Relayer\n  public readonly provider: ethers.Provider\n\n  constructor(public options: RpcRelayerOptions) {\n    this.service = new proto.Relayer(options.url, this._fetch)\n\n    if (isAbstractProvider(options.provider)) {\n      this.provider = options.provider\n    } else {\n      const { jwtAuth, projectAccessKey } = this.options\n      const fetchRequest = getFetchRequest(options.provider.url, projectAccessKey, jwtAuth)\n      this.provider = new ethers.JsonRpcProvider(fetchRequest, undefined, { staticNetwork: true })\n    }\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt and access key auth header to requests\n    // if its been set on the api client\n    const headers: { [key: string]: any } = {}\n\n    const { jwtAuth, projectAccessKey } = this.options\n\n    if (jwtAuth && jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${jwtAuth}`\n    }\n\n    if (projectAccessKey && projectAccessKey.length > 0) {\n      headers['X-Access-Key'] = projectAccessKey\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n\n  async waitReceipt(\n    metaTxnId: string | commons.transaction.SignedTransactionBundle,\n    delay: number = 1000,\n    maxFails: number = 5,\n    isCancelled?: () => boolean\n  ): Promise<proto.GetMetaTxnReceiptReturn> {\n    if (typeof metaTxnId !== 'string') {\n      metaTxnId = commons.transaction.intendedTransactionID(metaTxnId)\n    }\n\n    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`)\n\n    let fails = 0\n\n    while (isCancelled === undefined || !isCancelled()) {\n      try {\n        const { receipt } = await this.service.getMetaTxnReceipt({ metaTxID: metaTxnId })\n\n        if (\n          receipt &&\n          receipt.txnReceipt &&\n          receipt.txnReceipt !== 'null' &&\n          FINAL_STATUSES.includes(receipt.status as proto.ETHTxnStatus)\n        ) {\n          return { receipt }\n        }\n      } catch (e) {\n        fails++\n\n        if (fails === maxFails) {\n          throw e\n        }\n      }\n\n      if (isCancelled === undefined || !isCancelled()) {\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n\n    throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`)\n  }\n\n  async simulate(wallet: string, ...transactions: commons.transaction.Transaction[]): Promise<SimulateResult[]> {\n    const coder = ethers.AbiCoder.defaultAbiCoder()\n    const encoded = coder.encode(\n      [commons.transaction.MetaTransactionsType],\n      [commons.transaction.sequenceTxAbiEncode(transactions)]\n    )\n    return (await this.service.simulate({ wallet, transactions: encoded })).results\n  }\n\n  async getFeeOptions(\n    address: string,\n    ...transactions: commons.transaction.Transaction[]\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }> {\n    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value\n    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically\n    // with http cache response for this endpoint and service-worker.. lots of approaches\n    const feeTokens = await this.service.feeTokens()\n\n    if (feeTokens.isFeeRequired) {\n      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ')\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`)\n\n      const nonce = await this.getNonce(address)\n\n      if (!this.provider) {\n        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`)\n        throw new Error('provider is not set')\n      }\n\n      const { options, quote } = await this.service.feeOptions({\n        wallet: address,\n        to: address,\n        data: commons.transaction.encodeBundleExecData({\n          entrypoint: address,\n          transactions,\n          nonce\n        })\n      })\n\n      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options, bigintReplacer)}`)\n      return { options, quote: { _tag: 'FeeQuote', _quote: quote } }\n    } else {\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`)\n      return { options: [] }\n    }\n  }\n\n  async getFeeOptionsRaw(\n    entrypoint: string,\n    data: ethers.BytesLike,\n    options?: {\n      simulate?: boolean\n    }\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }> {\n    const { options: feeOptions, quote } = await this.service.feeOptions({\n      wallet: entrypoint,\n      to: entrypoint,\n      data: ethers.hexlify(data),\n      simulate: options?.simulate\n    })\n\n    return { options: feeOptions, quote: { _tag: 'FeeQuote', _quote: quote } }\n  }\n\n  async gasRefundOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<FeeOption[]> {\n    const { options } = await this.getFeeOptions(address, ...transactions)\n    return options\n  }\n\n  async getNonce(address: string, space?: ethers.BigNumberish): Promise<ethers.BigNumberish> {\n    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${address} space: ${space}`)\n    const encodedNonce = space !== undefined ? toHexString(BigInt(space)) : undefined\n    const resp = await this.service.getMetaTxnNonce({ walletContractAddress: address, space: encodedNonce })\n    const nonce = BigInt(resp.nonce)\n    const [decodedSpace, decodedNonce] = commons.transaction.decodeNonce(nonce)\n    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${address} ${decodedNonce} space: ${decodedSpace}`)\n    return nonce\n  }\n\n  async relay(\n    signedTxs: commons.transaction.IntendedTransactionBundle,\n    quote?: FeeQuote,\n    waitForReceipt: boolean = true\n  ): Promise<commons.transaction.TransactionResponse<RelayerTxReceipt>> {\n    logger.info(\n      `[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs, bigintReplacer)} with quote ${JSON.stringify(quote, bigintReplacer)}`\n    )\n\n    let typecheckedQuote: string | undefined\n    if (quote !== undefined) {\n      if (typeof quote._quote === 'string') {\n        typecheckedQuote = quote._quote\n      } else {\n        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote')\n      }\n    }\n\n    if (!this.provider) {\n      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`)\n      throw new Error('provider is not set')\n    }\n\n    const data = commons.transaction.encodeBundleExecData(signedTxs)\n    const metaTxn = await this.service.sendMetaTxn({\n      call: {\n        walletAddress: signedTxs.intent.wallet,\n        contract: signedTxs.entrypoint,\n        input: data\n      },\n      quote: typecheckedQuote\n    })\n\n    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn, bigintReplacer)}`)\n\n    if (waitForReceipt) {\n      return this.wait(signedTxs.intent.id)\n    } else {\n      const response = {\n        hash: signedTxs.intent.id,\n        confirmations: 0,\n        from: signedTxs.intent.wallet,\n        wait: (_confirmations?: number): Promise<ethers.TransactionReceipt | null> => Promise.reject(new Error('impossible'))\n      }\n\n      const wait = async (confirmations?: number): Promise<ethers.TransactionReceipt | null> => {\n        if (!this.provider) {\n          throw new Error('cannot wait for receipt, relayer has no provider set')\n        }\n\n        const waitResponse = await this.wait(signedTxs.intent.id)\n        const transactionHash = waitResponse.receipt?.transactionHash\n\n        if (!transactionHash) {\n          throw new Error('cannot wait for receipt, unknown native transaction hash')\n        }\n\n        Object.assign(response, waitResponse)\n\n        return this.provider.waitForTransaction(transactionHash, confirmations)\n      }\n\n      response.wait = wait\n\n      // NOTE: we just ignore these errors which come from the private fields\n      // of ethers-v6 .. but, we should probably rework this instead..\n      // @ts-ignore\n      return response as commons.transaction.TransactionResponse\n    }\n  }\n\n  async wait(\n    metaTxnId: string | commons.transaction.SignedTransactionBundle,\n    timeout?: number,\n    delay: number = 1000,\n    maxFails: number = 5\n  ): Promise<commons.transaction.TransactionResponse<RelayerTxReceipt>> {\n    let timedOut = false\n\n    const { receipt } = await (timeout !== undefined\n      ? Promise.race([\n          this.waitReceipt(metaTxnId, delay, maxFails, () => timedOut),\n          new Promise<proto.GetMetaTxnReceiptReturn>((_, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(`Timeout waiting for transaction receipt ${metaTxnId}`)\n            }, timeout)\n          )\n        ])\n      : this.waitReceipt(metaTxnId, delay, maxFails))\n\n    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status as proto.ETHTxnStatus)) {\n      throw new MetaTransactionResponseException(receipt)\n    }\n\n    const txReceipt = JSON.parse(receipt.txnReceipt) as RelayerTxReceipt\n\n    // NOTE: we just ignore these errors which come from the private fields\n    // of ethers-v6 .. but, we should probably rework this instead..\n    // @ts-ignore\n    return {\n      blockHash: txReceipt.blockHash,\n      blockNumber: Number(txReceipt.blockNumber),\n      confirmations: 1,\n      from: typeof metaTxnId === 'string' ? undefined : metaTxnId.intent.wallet,\n      hash: txReceipt.transactionHash,\n      raw: receipt.txnReceipt,\n      receipt: txReceipt, // extended type which is Sequence-specific. Contains the decoded metaTxReceipt\n      wait: async (confirmations?: number) => this.provider!.waitForTransaction(txReceipt.transactionHash, confirmations)\n    } as commons.transaction.TransactionResponse\n  }\n}\n\nclass MetaTransactionResponseException {\n  constructor(public receipt: proto.MetaTxnReceipt) {}\n}\n\nexport type RelayerTxReceipt = {\n  blockHash: string\n  blockNumber: string\n  contractAddress: string\n  cumulativeGasUsed: string\n  gasUsed: string\n  logs: {\n    address: string\n    blockHash: string\n    blockNumber: string\n    data: string\n    logIndex: string\n    removed: boolean\n    topics: string[]\n    transactionHash: string\n    transactionIndex: string\n  }[]\n  logsBloom: string\n  root: string\n  status: string\n  transactionHash: string\n  transactionIndex: string\n}\n\nfunction isAbstractProvider(provider: any): provider is ethers.AbstractProvider {\n  return (\n    provider &&\n    typeof provider === 'object' &&\n    typeof provider.getNetwork === 'function' &&\n    typeof provider.getBlockNumber === 'function'\n  )\n}\n","import { ethers } from 'ethers'\nimport { proto } from './rpc-relayer'\n\nimport { commons } from '@0xsequence/core'\n\nexport interface Relayer {\n  // simulate returns the execution results for a list of transactions.\n  simulate(wallet: string, ...transactions: commons.transaction.Transaction[]): Promise<SimulateResult[]>\n\n  // getFeeOptions returns the fee options that the relayer will accept as payment.\n  // If a quote is returned, it may be passed back to the relayer for dispatch.\n  getFeeOptions(\n    address: string,\n    ...transactions: commons.transaction.Transaction[]\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }>\n\n  // getFeeOptionsRaw returns the fee options that the relayer will accept as payment.\n  // If a quote is returned, it may be passed back to the relayer for dispatch.\n  // It doesn't make any assumptions about the transaction format.\n  getFeeOptionsRaw(\n    entrypoint: string,\n    data: ethers.BytesLike,\n    options?: {\n      simulate?: boolean\n    }\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }>\n\n  // gasRefundOptions returns the transactions which can be included to refund a\n  // relayer for submitting your transaction to a network.\n  gasRefundOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<FeeOption[]>\n\n  // getNonce returns the transaction count/nonce for a wallet, encoded with nonce space.\n  // If space is undefined, the relayer can choose a nonce space to encode the result with.\n  // Otherwise, the relayer must return a nonce encoded for the given nonce space.\n  getNonce(address: string, space?: ethers.BigNumberish, blockTag?: ethers.BlockTag): Promise<ethers.BigNumberish>\n\n  // relayer will submit the transaction(s) to the network and return the transaction response.\n  // The quote should be the one returned from getFeeOptions, if any.\n  // waitForReceipt must default to true.\n  relay(\n    signedTxs: commons.transaction.IntendedTransactionBundle,\n    quote?: FeeQuote,\n    waitForReceipt?: boolean\n  ): Promise<commons.transaction.TransactionResponse>\n\n  // wait for transaction confirmation\n  // timeout is the maximum time to wait for the transaction response\n  // delay is the polling interval, i.e. the time to wait between requests\n  // maxFails is the maximum number of hard failures to tolerate before giving up\n  wait(\n    metaTxnId: string | commons.transaction.SignedTransactionBundle,\n    timeout?: number,\n    delay?: number,\n    maxFails?: number\n  ): Promise<commons.transaction.TransactionResponse>\n}\n\nexport * from './local-relayer'\nexport * from './provider-relayer'\nexport * from './rpc-relayer'\nexport { proto as RpcRelayerProto } from './rpc-relayer'\nexport type SimulateResult = proto.SimulateResult\nexport type FeeOption = proto.FeeOption\n\n// A fee quote is simply an opaque value that can be obtained via Relayer.getFeeOptions(), and\n// returned back to the same relayer via Relayer.relay(). Fee quotes should be treated as an\n// implementation detail of the relayer that produces them.\n//\n// This interface exists for type-safety purposes to protect against passing non-FeeQuotes to\n// Relayer.relay(), or any other functions that call it indirectly (e.g. Account.sendTransaction).\nexport interface FeeQuote {\n  _tag: 'FeeQuote'\n  _quote: unknown\n}\n\nexport function isRelayer(cand: any): cand is Relayer {\n  return (\n    typeof cand === 'object' &&\n    typeof cand.simulate === 'function' &&\n    typeof cand.getFeeOptions === 'function' &&\n    typeof cand.gasRefundOptions === 'function' &&\n    typeof cand.getNonce === 'function' &&\n    typeof cand.relay === 'function' &&\n    typeof cand.wait === 'function'\n  )\n}\n","import { ethers } from 'ethers'\nimport { NetworkConfig, ChainIdLike } from '@0xsequence/network'\nimport { FeeQuote, Relayer } from '@0xsequence/relayer'\nimport { commons } from '@0xsequence/core'\n\n// TODO: Move to account ?\nexport abstract class Signer extends ethers.AbstractSigner {\n  static isSequenceSigner(cand: any): cand is Signer {\n    return isSequenceSigner(cand)\n  }\n\n  abstract getProvider(chainId?: number): Promise<ethers.JsonRpcProvider | undefined>\n  abstract getRelayer(chainId?: number): Promise<Relayer | undefined>\n\n  // abstract getWalletContext(): Promise<WalletContext>\n  abstract getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>\n  // abstract getWalletState(chainId?: ChainIdLike): Promise<WalletState[]>\n\n  abstract getNetworks(): Promise<NetworkConfig[]>\n\n  // getSigners returns a list of available / attached signers to the interface. Note: you need\n  // enough signers in order to meet the signing threshold that satisfies a wallet config.\n  abstract getSigners(): Promise<string[]>\n\n  // signMessage .....\n  abstract signMessage(\n    message: ethers.BytesLike,\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    isDigest?: boolean\n  ): Promise<string>\n\n  // signTypedData ..\n  abstract signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, Array<ethers.TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string>\n\n  // sendTransaction takes an unsigned transaction, or list of unsigned transactions, and then has it signed by\n  // the signer, and finally sends it to the relayer for submission to an Ethereum network.\n  abstract sendTransaction(\n    transaction: commons.transaction.Transactionish,\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    quote?: FeeQuote\n  ): Promise<commons.transaction.TransactionResponse>\n\n  // sendTransactionBatch provides the ability to send an array/batch of transactions as a single native on-chain transaction.\n  // This method works identically to sendTransaction but offers a different syntax for convience, readability and type clarity.\n  abstract sendTransactionBatch(\n    transactions: ethers.TransactionRequest[] | commons.transaction.Transaction[],\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    quote?: FeeQuote\n  ): Promise<commons.transaction.TransactionResponse>\n\n  // Low-level methods to sign and send/relayer signed transactions separately. The combination of these methods\n  // is like calling just sendTransaction(..) above. Also note that sendSignedTransactions is identical\n  // to calling getRelayer().relay(signedTxs), but included in this interface for convenience.\n  abstract signTransactions(\n    txs: commons.transaction.Transactionish,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<commons.transaction.SignedTransactionBundle>\n  abstract sendSignedTransactions(\n    signedTxs: commons.transaction.SignedTransactionBundle,\n    chainId?: ChainIdLike,\n    quote?: FeeQuote\n  ): Promise<commons.transaction.TransactionResponse>\n\n  // updateConfig will update the wallet image hash on-chain, aka deploying a smart wallet config to chain. If\n  // newConfig argument is undefined, then it will use the existing config. Config contents will also be\n  // automatically published to the authChain when updating the config image hash.\n  abstract updateConfig(\n    newConfig?: commons.config.Config\n  ): Promise<[commons.config.Config, commons.transaction.TransactionResponse | undefined]>\n\n  // publishConfig will store the raw WalletConfig object on-chain, note: this may be expensive,\n  // and is only necessary for config data-availability, in case of Account the contents are published\n  // to the authChain.\n  abstract publishConfig(): Promise<commons.transaction.TransactionResponse | undefined>\n\n  // isDeployed ..\n  abstract isDeployed(chainId?: ChainIdLike): Promise<boolean>\n}\n\nexport type SignedTransactionsCallback = (signedTxs: commons.transaction.SignedTransactionBundle, metaTxnHash: string) => void\n\nexport function isSequenceSigner(signer: any): signer is Signer {\n  const cand = signer as Signer\n  return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletConfig !== undefined\n}\n\n// TODO: move to error.ts, along with others..\nexport class InvalidSigner extends Error {}\n\nexport class NotEnoughSigners extends Error {}\n","import { ethers } from 'ethers'\n\nexport async function resolveArrayProperties<T>(object: Readonly<T> | Readonly<T>[]): Promise<T> {\n  if (Array.isArray(object)) {\n    // T must include array type\n    return Promise.all(object.map(o => ethers.resolveProperties(o))) as any\n  }\n\n  return ethers.resolveProperties(object)\n}\n\nexport async function findLatestLog(provider: ethers.Provider, filter: ethers.Filter): Promise<ethers.Log | undefined> {\n  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : (filter.toBlock as number)\n  const fromBlock = filter.fromBlock as number\n\n  try {\n    const logs = await provider.getLogs({ ...filter, toBlock: toBlock })\n    return logs.length === 0 ? undefined : logs[logs.length - 1]\n  } catch (e) {\n    // TODO Don't assume all errors are bad\n    const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock)\n    const nhalf = await findLatestLog(provider, { ...filter, fromBlock: pivot, toBlock: toBlock })\n    if (nhalf !== undefined) return nhalf\n    return findLatestLog(provider, { ...filter, fromBlock: fromBlock, toBlock: pivot })\n  }\n}\n","import { ethers } from 'ethers'\nimport { commons } from '@0xsequence/core'\nimport { Status } from '../orchestrator'\n\nexport interface SapientSigner {\n  getAddress(): Promise<string>\n\n  buildDeployTransaction(metadata: object): Promise<commons.transaction.TransactionBundle | undefined>\n\n  /**\n   * Get signed transactions to be included in the next request.\n   */\n  predecorateSignedTransactions(metadata: object): Promise<commons.transaction.SignedTransactionBundle[]>\n\n  /**\n   * Modify the transaction bundle before it is sent.\n   */\n  decorateTransactions(\n    bundle: commons.transaction.IntendedTransactionBundle,\n    metadata: object\n  ): Promise<commons.transaction.IntendedTransactionBundle>\n\n  /**\n   * Request a signature from the signer.\n   */\n  sign(message: ethers.BytesLike, metadata: object): Promise<ethers.BytesLike>\n\n  /**\n   * Notify the signer of a status change.\n   */\n  notifyStatusChange(id: string, status: Status, metadata: object): void\n\n  suffix(): ethers.BytesLike\n}\n\nexport function isSapientSigner(signer: ethers.Signer | SapientSigner): signer is SapientSigner {\n  return (\n    (signer as SapientSigner).getAddress !== undefined &&\n    (signer as SapientSigner).buildDeployTransaction !== undefined &&\n    (signer as SapientSigner).predecorateSignedTransactions !== undefined &&\n    (signer as SapientSigner).decorateTransactions !== undefined &&\n    (signer as SapientSigner).sign !== undefined &&\n    (signer as SapientSigner).notifyStatusChange !== undefined\n  )\n}\n","import { ethers } from 'ethers'\nimport { commons } from '@0xsequence/core'\nimport { Status } from '../orchestrator'\nimport { SapientSigner } from './signer'\n\nexport class SignerWrapper implements SapientSigner {\n  constructor(\n    public signer: ethers.Signer,\n    public eoa: boolean = true\n  ) {}\n\n  getAddress(): Promise<string> {\n    return this.signer.getAddress()\n  }\n\n  async buildDeployTransaction(_metadata: object): Promise<commons.transaction.TransactionBundle | undefined> {\n    // Wrapped signers don't require deployment\n    return\n  }\n\n  async predecorateSignedTransactions(_metadata: object): Promise<commons.transaction.SignedTransactionBundle[]> {\n    return []\n  }\n\n  async decorateTransactions(\n    bundle: commons.transaction.IntendedTransactionBundle,\n    _metadata: object\n  ): Promise<commons.transaction.IntendedTransactionBundle> {\n    return bundle\n  }\n\n  sign(message: ethers.BytesLike): Promise<ethers.BytesLike> {\n    return this.signer.signMessage(message)\n  }\n\n  notifyStatusChange(_i: string, _s: Status, _m: object): void {}\n\n  suffix(): ethers.BytesLike {\n    return new Uint8Array([2])\n  }\n}\n","import { ethers } from 'ethers'\nimport { commons } from '@0xsequence/core'\nimport { isSapientSigner, SapientSigner } from './signers/signer'\nimport { SignerWrapper } from './signers/wrapper'\n\nexport type Status = {\n  ended: boolean\n  message: ethers.BytesLike\n  signers: { [signer: string]: SignerStatus }\n}\n\nexport enum SignerState {\n  INITIAL,\n  SIGNING,\n  SIGNED,\n  ERROR\n}\n\nexport type SignerStatus =\n  | { state: SignerState.INITIAL }\n  | { state: SignerState.SIGNING; request: Promise<ethers.BytesLike> }\n  | { state: SignerState.SIGNED; signature: ethers.BytesLike; suffix: ethers.BytesLike }\n  | { state: SignerState.ERROR; error: any }\n\nexport function isSignerStatusPending(\n  status?: SignerStatus\n): status is undefined | { state: SignerState.INITIAL } | { state: SignerState.SIGNING; request: Promise<ethers.BytesLike> } {\n  return status === undefined || status.state === SignerState.INITIAL || status.state === SignerState.SIGNING\n}\n\nexport interface SignatureOrchestrator {\n  getSigners(): Promise<string[]>\n\n  signMessage(args: {\n    candidates: string[]\n    message: ethers.BytesLike\n    metadata: object\n    callback: (status: Status, onNewMetadata: (metadata: object) => void) => boolean\n  }): Promise<Status>\n\n  buildDeployTransaction(metadata: object): Promise<commons.transaction.TransactionBundle | undefined>\n\n  predecorateSignedTransactions(metadata?: object): Promise<commons.transaction.SignedTransactionBundle[]>\n\n  decorateTransactions(\n    bundle: commons.transaction.IntendedTransactionBundle,\n    metadata?: object\n  ): Promise<commons.transaction.IntendedTransactionBundle>\n}\n\n/**\n * Orchestrates actions of collective signers.\n * This includes the signing of a single digests and transactions by multiple signers.\n * It can provide internal visibility of the signing process, and it also\n * provides the internal signers with additional information about the\n * message being signed. Transaction decoration can be used to ensure on-chain state\n * is correctly managed during the signing process.\n */\nexport class Orchestrator {\n  private observers: ((status: Status, metadata: object) => void)[] = []\n  private signers: SapientSigner[] = []\n\n  private count = 0\n\n  constructor(\n    signers: (ethers.Signer | SapientSigner)[],\n    public tag: string = Orchestrator.randomTag()\n  ) {\n    this.setSigners(signers)\n  }\n\n  private static randomTag(): string {\n    return `default-${ethers.hexlify(ethers.randomBytes(8)).slice(2)}`\n  }\n\n  private pullId(): string {\n    return `${this.tag}-${this.count++}`\n  }\n\n  setSigners(signers: (ethers.Signer | SapientSigner)[]) {\n    this.signers = signers.map(s => (isSapientSigner(s) ? s : new SignerWrapper(s)))\n  }\n\n  async getSigners(): Promise<string[]> {\n    return Promise.all(this.signers.map(async s => s.getAddress()))\n  }\n\n  subscribe(observer: (status: Status, metadata: object) => void): () => void {\n    this.observers.push(observer)\n    return () => {\n      this.observers = this.observers.filter(o => o !== observer)\n    }\n  }\n\n  private async notifyObservers(id: string, status: Status, metadata: object) {\n    await Promise.all([\n      ...this.signers.map(async signer => signer.notifyStatusChange(id, status, metadata)),\n      ...this.observers.map(async observer => observer(status, metadata))\n    ])\n  }\n\n  async buildDeployTransaction(metadata: object): Promise<commons.transaction.TransactionBundle | undefined> {\n    let bundle: commons.transaction.TransactionBundle | undefined\n    for (const signer of this.signers) {\n      const newBundle = await signer.buildDeployTransaction(metadata)\n      if (bundle === undefined) {\n        // Use first bundle as base\n        bundle = newBundle\n      } else if (newBundle?.transactions) {\n        // Combine deploy transactions\n        bundle.transactions = newBundle.transactions.concat(bundle.transactions)\n      }\n    }\n    return bundle\n  }\n\n  async predecorateSignedTransactions(metadata?: object): Promise<commons.transaction.SignedTransactionBundle[]> {\n    const output: commons.transaction.SignedTransactionBundle[] = []\n    for (const signer of this.signers) {\n      output.push(...(await signer.predecorateSignedTransactions(metadata ?? {})))\n    }\n    return output\n  }\n\n  async decorateTransactions(\n    bundle: commons.transaction.IntendedTransactionBundle,\n    metadata?: object\n  ): Promise<commons.transaction.IntendedTransactionBundle> {\n    for (const signer of this.signers) {\n      bundle = await signer.decorateTransactions(bundle, metadata ?? {})\n    }\n    return bundle\n  }\n\n  signMessage(args: {\n    candidates?: string[]\n    message: ethers.BytesLike\n    metadata?: object\n    callback?: (status: Status, onNewMetadata: (metadata: object) => void) => boolean\n  }): Promise<Status> {\n    const id = this.pullId()\n\n    return new Promise(async resolve => {\n      const { message, metadata, callback, candidates } = args\n      const status: Status = { ended: false, message, signers: {} }\n      let lastMetadata = metadata ?? {}\n\n      const onNewMetadata = (newMetadata: object) => {\n        lastMetadata = newMetadata\n        this.notifyObservers(id, status, lastMetadata)\n      }\n\n      const onStatusUpdate = () => {\n        try {\n          this.notifyObservers(id, status, lastMetadata)\n\n          const pending = Object.entries(status.signers).filter(([_, s]) => isSignerStatusPending(s))\n          if ((callback && callback(status, onNewMetadata)) || pending.length === 0) {\n            status.ended = true\n            resolve(status)\n            this.notifyObservers(id, status, lastMetadata)\n            return\n          }\n        } catch (e) {\n          console.error('Error while notifying observers', e)\n        }\n      }\n\n      // we only call signers that are found in `candidates`\n      // if `candidates` is undefined, we call all signers\n      let signers = this.signers\n      if (candidates) {\n        const addresses = await Promise.all(this.signers.map(async s => s.getAddress()))\n        signers = this.signers.filter((_, i) => candidates.includes(addresses[i]))\n      }\n\n      // build callbacks object\n      const accepted = await Promise.allSettled(\n        signers.map(async s => {\n          const saddr = await s.getAddress()\n\n          status.signers[saddr] = {\n            state: SignerState.SIGNING,\n            request: s\n              .sign(message, metadata ?? {})\n              .then(signature => {\n                const suffix = s.suffix()\n                status.signers[saddr] = { state: SignerState.SIGNED, signature, suffix }\n                onStatusUpdate()\n                return signature\n              })\n              .catch(error => {\n                status.signers[saddr] = { state: SignerState.ERROR, error }\n                onStatusUpdate()\n                throw error\n              })\n          }\n        })\n      )\n\n      for (let i = 0; i < accepted.length; i++) {\n        const signer = this.signers[i]\n        const promise = accepted[i]\n\n        if (promise.status === 'rejected') {\n          const address = await signer.getAddress()\n          console.warn(`signer ${address} rejected the request: ${promise.reason}`)\n          status.signers[address] = {\n            state: SignerState.ERROR,\n            error: new Error(`signer ${address} rejected the request: ${promise.reason}`)\n          }\n        }\n      }\n\n      onStatusUpdate()\n    })\n  }\n}\n","import { ethers } from 'ethers'\nimport { commons, v1, v2 } from '@0xsequence/core'\nimport { ChainId } from '@0xsequence/network'\nimport { SignatureOrchestrator, SignerState, Status } from '@0xsequence/signhub'\nimport { encodeTypedDataDigest, subDigestOf } from '@0xsequence/utils'\nimport { FeeQuote, Relayer } from '@0xsequence/relayer'\nimport { walletContracts } from '@0xsequence/abi'\n\nimport { resolveArrayProperties } from './utils'\n\nexport type WalletOptions<\n  T extends commons.signature.Signature<Y>,\n  Y extends commons.config.Config,\n  Z extends commons.signature.UnrecoveredSignature\n> = {\n  // Sequence version configurator\n  coders: {\n    config: commons.config.ConfigCoder<Y>\n    signature: commons.signature.SignatureCoder<Y, T, Z>\n  }\n\n  context: commons.context.WalletContext\n  config: Y\n\n  chainId: ethers.BigNumberish\n  address: string\n\n  orchestrator: SignatureOrchestrator\n  reader?: commons.reader.Reader\n\n  provider?: ethers.Provider\n  relayer?: Relayer\n}\n\nconst statusToSignatureParts = (status: Status) => {\n  const parts = new Map<string, commons.signature.SignaturePart>()\n\n  for (const signer of Object.keys(status.signers)) {\n    const value = status.signers[signer]\n    if (value.state === SignerState.SIGNED) {\n      const suffix = ethers.getBytes(value.suffix)\n      const suffixed = ethers.solidityPacked(['bytes', 'bytes'], [value.signature, suffix])\n\n      parts.set(signer, { signature: suffixed, isDynamic: suffix.length !== 1 || suffix[0] !== 2 })\n    }\n  }\n\n  return parts\n}\n\nexport type WalletV2 = Wallet<v2.config.WalletConfig, v2.signature.Signature, v2.signature.UnrecoveredSignature>\nexport type WalletV1 = Wallet<v1.config.WalletConfig, v1.signature.Signature, v1.signature.UnrecoveredSignature>\n\n/**\n * The wallet is the minimum interface to interact with a single Sequence wallet/contract.\n * it doesn't have any knowledge of any on-chain state, instead it relies solely on the information\n * provided by the user. This building block is used to create higher level abstractions.\n *\n * Wallet can also be used to create Sequence wallets, but it's not recommended to use it directly.\n */\nexport class Wallet<\n  Y extends commons.config.Config = commons.config.Config,\n  T extends commons.signature.Signature<Y> = commons.signature.Signature<Y>,\n  Z extends commons.signature.UnrecoveredSignature = commons.signature.UnrecoveredSignature\n> extends ethers.AbstractSigner {\n  public context: commons.context.WalletContext\n  public config: Y\n  public address: string\n  public chainId: bigint\n\n  public relayer?: Relayer\n\n  public coders: {\n    signature: commons.signature.SignatureCoder<Y, T, Z>\n    config: commons.config.ConfigCoder<Y>\n  }\n\n  private orchestrator: SignatureOrchestrator\n  private _reader?: commons.reader.Reader\n\n  constructor(options: WalletOptions<T, Y, Z>) {\n    const chainId = BigInt(options.chainId)\n\n    if (chainId === 0n && !options.coders.signature.supportsNoChainId) {\n      throw new Error(`Sequence version ${options.config.version} doesn't support chainId 0`)\n    }\n\n    super(options.provider ?? null)\n\n    this.context = options.context\n    this.config = options.config\n    this.orchestrator = options.orchestrator\n    this.coders = options.coders\n    this.address = options.address\n    this.chainId = chainId\n    this.relayer = options.relayer\n\n    this._reader = options.reader\n  }\n\n  static newWallet<\n    Y extends commons.config.Config = commons.config.Config,\n    T extends commons.signature.Signature<Y> = commons.signature.Signature<Y>,\n    Z extends commons.signature.UnrecoveredSignature = commons.signature.UnrecoveredSignature\n  >(options: Omit<WalletOptions<T, Y, Z>, 'address'>): Wallet<Y, T, Z> {\n    const address = commons.context.addressOf(options.context, options.coders.config.imageHashOf(options.config))\n    return new Wallet({ ...options, address })\n  }\n\n  reader(): commons.reader.Reader {\n    if (this._reader) return this._reader\n    if (!this.provider) throw new Error('Wallet status provider requires a provider')\n    return new commons.reader.OnChainReader(this.provider)\n  }\n\n  setConfig(config: Y) {\n    this.config = config\n  }\n\n  setOrchestrator(orchestrator: SignatureOrchestrator) {\n    this.orchestrator = orchestrator\n  }\n\n  setAddress(address: string) {\n    this.address = address\n  }\n\n  getSigners(): Promise<string[]> {\n    return this.orchestrator.getSigners()\n  }\n\n  async getAddress(): Promise<string> {\n    return this.address\n  }\n\n  async decorateTransactions(\n    bundle: commons.transaction.IntendedTransactionBundle\n  ): Promise<commons.transaction.IntendedTransactionBundle> {\n    // Allow children to decorate\n    const decorated = await this.orchestrator.decorateTransactions(bundle)\n\n    if (await this.reader().isDeployed(this.address)) {\n      // Deployed - No decorating at this level\n      return decorated\n    }\n\n    const transactions: commons.transaction.Transaction[] = [\n      {\n        to: decorated.entrypoint,\n        data: commons.transaction.encodeBundleExecData(decorated),\n        revertOnError: true\n      }\n    ]\n\n    // Add deployment tx\n    const deployTx = await this.buildDeployTransaction()\n    if (deployTx) {\n      transactions.unshift(...deployTx.transactions)\n    }\n\n    // TODO: If entrypoint is guestModule we can flatten the bundle\n    // and avoid calling guestModule twice\n\n    return {\n      entrypoint: this.context.guestModule,\n      chainId: this.chainId,\n      intent: decorated.intent,\n      transactions\n    }\n  }\n\n  async buildDeployTransaction(\n    metadata?: commons.WalletDeployMetadata\n  ): Promise<commons.transaction.TransactionBundle | undefined> {\n    if (metadata?.ignoreDeployed && (await this.reader().isDeployed(this.address))) {\n      return\n    }\n\n    const imageHash = this.coders.config.imageHashOf(this.config)\n\n    if (commons.context.addressOf(this.context, imageHash) !== this.address) {\n      throw new Error(`First address of config ${imageHash} doesn't match wallet address ${this.address}`)\n    }\n\n    let gasLimit: bigint | undefined\n    switch (this.chainId) {\n      case BigInt(ChainId.SKALE_NEBULA):\n        gasLimit = 10000000n\n        break\n    }\n\n    const bundle = Wallet.buildDeployTransaction(this.context, imageHash, gasLimit)\n    if (metadata?.includeChildren) {\n      const childBundle = await this.orchestrator.buildDeployTransaction(metadata)\n      if (childBundle) {\n        // Deploy children first\n        bundle.transactions = childBundle.transactions.concat(bundle.transactions)\n      }\n    }\n    return bundle\n  }\n\n  async deploy(metadata?: commons.WalletDeployMetadata): Promise<ethers.TransactionResponse | undefined> {\n    const deployTx = await this.buildDeployTransaction(metadata)\n    if (deployTx === undefined) {\n      // Already deployed\n      return\n    }\n    if (!this.relayer) throw new Error('Wallet deploy requires a relayer')\n    return this.relayer.relay({\n      ...deployTx,\n      chainId: this.chainId,\n      intent: {\n        id: ethers.hexlify(ethers.randomBytes(32)),\n        wallet: this.address\n      }\n    })\n  }\n\n  static buildDeployTransaction(\n    context: commons.context.WalletContext,\n    imageHash: string,\n    gasLimit: ethers.BigNumberish = 100000n\n  ): commons.transaction.TransactionBundle {\n    const factoryInterface = new ethers.Interface(walletContracts.factory.abi)\n\n    return {\n      entrypoint: context.guestModule,\n      transactions: [\n        {\n          to: context.factory,\n          data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy')!, [context.mainModule, imageHash]),\n          gasLimit,\n          delegateCall: false,\n          revertOnError: true,\n          value: 0\n        }\n      ]\n    }\n  }\n\n  async buildUpdateConfigurationTransaction(config: Y): Promise<commons.transaction.TransactionBundle> {\n    if (this.coders.config.update.isKindUsed) {\n      const implementation = await this.reader().implementation(this.address)\n      const isLaterUpdate = implementation && implementation === this.context.mainModuleUpgradable\n      return this.coders.config.update.buildTransaction(this.address, config, this.context, isLaterUpdate ? 'later' : 'first')\n    }\n\n    return this.coders.config.update.buildTransaction(this.address, config, this.context)\n  }\n\n  async getNonce(space: ethers.BigNumberish = 0): Promise<number> {\n    const nonce = await this.reader().nonce(this.address, space)\n    if (nonce === undefined) throw new Error('Unable to determine nonce')\n    return Number(nonce)\n  }\n\n  async signDigest(digest: ethers.BytesLike, metadata?: object): Promise<string> {\n    // The subdigest may be statically defined on the configuration\n    // in that case we just encode the proof, no need to sign anything\n    const subdigest = subDigestOf(this.address, this.chainId, digest)\n    if (this.coders.config.hasSubdigest(this.config, subdigest)) {\n      return this.coders.signature.encodeSigners(this.config, new Map(), [subdigest], this.chainId).encoded\n    }\n\n    // We build the metadata object, this contains additional information\n    // that may be needed to sign the digest (by the other signers, or by the guard)\n    const childMetadata: commons.WalletSignRequestMetadata = {\n      ...metadata, // Keep other metadata fields\n      digest,\n      chainId: this.chainId,\n      address: this.address,\n      config: this.config\n    }\n\n    // We ask the orchestrator to sign the digest, as soon as we have enough signature parts\n    // to reach the threshold we returns true, that means the orchestrator will stop asking\n    // and we can encode the final signature\n    const subdigestBytes = ethers.getBytes(subdigest)\n    const signature = await this.orchestrator.signMessage({\n      candidates: this.coders.config.signersOf(this.config).map(s => s.address),\n      message: subdigestBytes,\n      metadata: childMetadata,\n      callback: (status: Status, onNewMetadata: (_metadata: object) => void): boolean => {\n        const parts = statusToSignatureParts(status)\n\n        const newMetadata = { ...childMetadata, parts }\n        onNewMetadata(newMetadata)\n\n        return this.coders.signature.hasEnoughSigningPower(this.config, parts)\n      }\n    })\n\n    const parts = statusToSignatureParts(signature)\n    return this.coders.signature.encodeSigners(this.config, parts, [], this.chainId).encoded\n  }\n\n  signMessage(message: ethers.BytesLike): Promise<string> {\n    return this.signDigest(ethers.keccak256(message), { message })\n  }\n\n  // XXX This method is not implemented in the original code but required by the AbstractSigner interface\n  signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, ethers.TypedDataField[]>,\n    value: Record<string, any>\n  ): Promise<string> {\n    const digest = encodeTypedDataDigest({ domain, types, message: value })\n    return this.signDigest(digest)\n  }\n\n  signTransactionBundle(bundle: commons.transaction.TransactionBundle): Promise<commons.transaction.SignedTransactionBundle> {\n    if (bundle.entrypoint !== this.address) {\n      throw new Error(`Invalid entrypoint: ${bundle.entrypoint} !== ${this.address}`)\n    }\n\n    return this.signTransactions(bundle.transactions, bundle.nonce)\n  }\n\n  async fetchNonceOrSpace(\n    nonce?: ethers.BigNumberish | { space: ethers.BigNumberish } | { serial: boolean }\n  ): Promise<ethers.BigNumberish> {\n    let spaceValue\n\n    if (nonce && (nonce as any).space !== undefined) {\n      // specified nonce \"space\"\n      spaceValue = BigInt((nonce as any).space)\n    } else if (nonce === undefined) {\n      // default is random, aka parallel\n      return this.randomNonce()\n    } else if (nonce && (nonce as any).serial === true) {\n      // next nonce determined from the chain\n      spaceValue = 0\n    } else {\n      // specific nonce is used\n      return nonce as ethers.BigNumberish\n    }\n\n    const resultNonce = await this.reader().nonce(this.address, spaceValue)\n    if (resultNonce === undefined) throw new Error('Unable to determine nonce')\n    return commons.transaction.encodeNonce(spaceValue, resultNonce)\n  }\n\n  // Generate nonce with random space\n  randomNonce(): ethers.BigNumberish {\n    const randomNonceSpace = BigInt(ethers.hexlify(ethers.randomBytes(12)))\n    const randomNonce = commons.transaction.encodeNonce(randomNonceSpace, 0)\n    return randomNonce\n  }\n\n  async signTransactions(\n    txs: commons.transaction.Transactionish,\n    nonce?: ethers.BigNumberish | { space: ethers.BigNumberish } | { serial: boolean },\n    metadata?: object\n  ): Promise<commons.transaction.SignedTransactionBundle> {\n    const transaction = await resolveArrayProperties<commons.transaction.Transactionish>(txs)\n    const transactions = commons.transaction.fromTransactionish(this.address, transaction)\n\n    // NOTICE: If the `transactions` list is empty, then we add a dummy transaction\n    // otherwise the `TxExecuted` event will not be emitted, and we won't be able to\n    // find the transaction hash\n    if (transactions.length === 0) {\n      transactions.push({\n        to: this.address,\n        data: '0x',\n        value: 0,\n        gasLimit: 0,\n        delegateCall: false,\n        revertOnError: true\n      })\n    }\n\n    const defaultedNonce = await this.fetchNonceOrSpace(nonce)\n    const digest = commons.transaction.digestOfTransactions(defaultedNonce, transactions)\n    const meta = {\n      digest,\n      transactions,\n      ...metadata\n    }\n    const signature = await this.signDigest(digest, meta)\n\n    return {\n      intent: {\n        // Maybe is better if signDigest returns the subdigest directly\n        id: subDigestOf(this.address, this.chainId, digest),\n        wallet: this.address\n      },\n      chainId: this.chainId,\n      transactions,\n      entrypoint: this.address,\n      nonce: defaultedNonce,\n      signature\n    }\n  }\n\n  async sendSignedTransaction(\n    signedBundle: commons.transaction.IntendedTransactionBundle,\n    quote?: FeeQuote\n  ): Promise<ethers.TransactionResponse> {\n    if (!this.relayer) throw new Error('Wallet sendTransaction requires a relayer')\n    return this.relayer.relay(signedBundle, quote)\n  }\n\n  // sendTransaction will dispatch the transaction to the relayer for submission to the network.\n  // This method is able to send transactions in serial or parallel (default). You can specify\n  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).\n  //\n  // By default, nonces are generated randomly and assigned so transactioned can be executed\n  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.\n  async sendTransaction(\n    txs: commons.transaction.Transactionish,\n    options?: {\n      quote?: FeeQuote\n      nonce?: ethers.BigNumberish\n      serial?: boolean\n    }\n  ): Promise<ethers.TransactionResponse> {\n    let nonce: ethers.BigNumberish | { serial: boolean }\n    if (options?.nonce !== undefined) {\n      // specific nonce is used\n      nonce = options.nonce\n    } else if (options?.serial) {\n      // next nonce on wallet is used and detected on-chain\n      nonce = { serial: true }\n    } else {\n      // default is random, aka parallel\n      nonce = this.randomNonce()\n    }\n\n    const signed = await this.signTransactions(txs, nonce)\n    const decorated = await this.decorateTransactions(signed)\n    return this.sendSignedTransaction(decorated, options?.quote)\n  }\n\n  async fillGasLimits(txs: commons.transaction.Transactionish): Promise<commons.transaction.SimulatedTransaction[]> {\n    const transaction = await resolveArrayProperties<commons.transaction.Transactionish>(txs)\n    const transactions = commons.transaction.fromTransactionish(this.address, transaction)\n    const relayer = this.relayer\n    if (!relayer) throw new Error('Wallet fillGasLimits requires a relayer')\n\n    const simulations = await relayer.simulate(this.address, ...transactions)\n    return transactions.map((tx, i) => {\n      const gasLimit = tx.gasLimit ? Number(tx.gasLimit) : simulations[i].gasLimit\n      return { ...tx, ...simulations[i], gasLimit }\n    })\n  }\n\n  connect(provider: ethers.Provider, relayer?: Relayer): Wallet<Y, T, Z> {\n    return new Wallet({\n      // Sequence version configurator\n      coders: this.coders,\n\n      context: this.context,\n      config: this.config,\n\n      chainId: this.chainId,\n      address: this.address,\n\n      orchestrator: this.orchestrator,\n      reader: this._reader,\n\n      provider,\n      relayer: relayer ?? this.relayer\n    })\n  }\n\n  signTransaction(transaction: ethers.TransactionRequest): Promise<string> {\n    throw new Error('Method not implemented.')\n  }\n}\n","import { ChainId } from '@0xsequence/network'\nimport { Account } from './account'\nimport { ethers } from 'ethers'\nimport { commons } from '@0xsequence/core'\nimport { FeeOption, proto } from '@0xsequence/relayer'\nimport { toHexString } from '@0xsequence/utils'\n\nexport type AccountSignerOptions = {\n  nonceSpace?: ethers.BigNumberish\n  cantValidateBehavior?: 'ignore' | 'eip6492' | 'throw'\n  stubSignatureOverrides?: Map<string, string>\n  selectFee?: (\n    txs: ethers.TransactionRequest | commons.transaction.Transactionish,\n    options: FeeOption[]\n  ) => Promise<FeeOption | undefined>\n}\n\nfunction encodeGasRefundTransaction(option?: FeeOption) {\n  if (!option) return []\n\n  const value = BigInt(option.value)\n\n  switch (option.token.type) {\n    case proto.FeeTokenType.UNKNOWN:\n      return [\n        {\n          delegateCall: false,\n          revertOnError: true,\n          gasLimit: option.gasLimit,\n          to: option.to,\n          value: toHexString(value),\n          data: '0x'\n        }\n      ]\n\n    case proto.FeeTokenType.ERC20_TOKEN:\n      if (!option.token.contractAddress) {\n        throw new Error(`No contract address for ERC-20 fee option`)\n      }\n\n      return [\n        {\n          delegateCall: false,\n          revertOnError: true,\n          gasLimit: option.gasLimit,\n          to: option.token.contractAddress,\n          value: 0,\n          data: new ethers.Interface([\n            {\n              constant: false,\n              inputs: [{ type: 'address' }, { type: 'uint256' }],\n              name: 'transfer',\n              outputs: [],\n              type: 'function'\n            }\n          ]).encodeFunctionData('transfer', [option.to, toHexString(value)])\n        }\n      ]\n\n    default:\n      throw new Error(`Unhandled fee token type ${option.token.type}`)\n  }\n}\n\nexport class AccountSigner implements ethers.AbstractSigner<ethers.Provider> {\n  constructor(\n    public account: Account,\n    public chainId: ChainId,\n    public readonly options?: AccountSignerOptions\n  ) {}\n\n  get provider() {\n    return this.account.providerFor(this.chainId)\n  }\n\n  async getAddress(): Promise<string> {\n    return this.account.address\n  }\n\n  signMessage(message: string | ethers.BytesLike): Promise<string> {\n    return this.account.signMessage(message, this.chainId, this.options?.cantValidateBehavior ?? 'throw')\n  }\n\n  signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, Array<ethers.TypedDataField>>,\n    value: Record<string, any>\n  ): Promise<string> {\n    return this.account.signTypedData(domain, types, value, this.chainId, this.options?.cantValidateBehavior ?? 'throw')\n  }\n\n  private async defaultSelectFee(_txs: commons.transaction.Transactionish, options: FeeOption[]): Promise<FeeOption | undefined> {\n    // If no options, return undefined\n    if (options.length === 0) return undefined\n\n    // If there are multiple options, try them one by one\n    // until we find one that satisfies the balance requirement\n    const balanceOfAbi = [\n      {\n        constant: true,\n        inputs: [{ type: 'address' }],\n        name: 'balanceOf',\n        outputs: [{ type: 'uint256' }],\n        type: 'function'\n      }\n    ]\n\n    for (const option of options) {\n      if (option.token.type === proto.FeeTokenType.UNKNOWN) {\n        // Native token\n        const balance = await this.getBalance()\n        if (balance >= BigInt(option.value)) {\n          return option\n        }\n      } else if (option.token.contractAddress && option.token.type === proto.FeeTokenType.ERC20_TOKEN) {\n        // ERC20 token\n        const token = new ethers.Contract(option.token.contractAddress, balanceOfAbi, this.provider)\n        const balance = await token.balanceOf(this.account.address)\n        if (balance >= BigInt(option.value)) {\n          return option\n        }\n      } else {\n        // Unsupported token type\n      }\n    }\n\n    throw new Error('No fee option available - not enough balance')\n  }\n\n  async sendTransaction(\n    txs: commons.transaction.Transactionish,\n    options?: {\n      simulateForFeeOptions?: boolean\n    }\n  ): Promise<ethers.TransactionResponse> {\n    const prepare = await this.account.prepareTransactions({\n      txs,\n      chainId: this.chainId,\n      stubSignatureOverrides: this.options?.stubSignatureOverrides ?? new Map(),\n      simulateForFeeOptions: options?.simulateForFeeOptions\n    })\n\n    const selectMethod = this.options?.selectFee ?? this.defaultSelectFee.bind(this)\n    const feeOption = await selectMethod(txs, prepare.feeOptions)\n\n    const finalTransactions = [...prepare.transactions, ...encodeGasRefundTransaction(feeOption)]\n\n    return this.account.sendTransaction(\n      finalTransactions,\n      this.chainId,\n      prepare.feeQuote,\n      undefined,\n      undefined,\n      this.options?.nonceSpace !== undefined\n        ? {\n            nonceSpace: this.options.nonceSpace\n          }\n        : undefined\n    ) as Promise<ethers.TransactionResponse> // Will always have a transaction response\n  }\n\n  getBalance(blockTag?: ethers.BlockTag | undefined): Promise<bigint> {\n    return this.provider.getBalance(this.account.address, blockTag)\n  }\n\n  call(transaction: ethers.TransactionRequest, blockTag?: ethers.BlockTag): Promise<string> {\n    return this.provider.call({ ...transaction, blockTag })\n  }\n\n  async resolveName(name: string): Promise<string> {\n    const res = await this.provider.resolveName(name)\n    if (!res) throw new Error(`Could not resolve name ${name}`)\n    return res\n  }\n\n  connect(_provider: ethers.Provider): ethers.Signer {\n    throw new Error('Method not implemented.')\n  }\n\n  signTransaction(transaction: ethers.TransactionRequest): Promise<string> {\n    throw new Error('Method not implemented.')\n  }\n\n  getTransactionCount(blockTag?: ethers.BlockTag | undefined): Promise<number> {\n    throw new Error('Method not implemented.')\n  }\n\n  estimateGas(transaction: ethers.TransactionRequest): Promise<bigint> {\n    throw new Error('Method not implemented.')\n  }\n\n  getChainId(): Promise<number> {\n    return Promise.resolve(Number(this.chainId))\n  }\n\n  getGasPrice(): Promise<bigint> {\n    throw new Error('Method not implemented.')\n  }\n\n  getFeeData(): Promise<ethers.FeeData> {\n    throw new Error('Method not implemented.')\n  }\n\n  getNonce(blockTag?: ethers.BlockTag): Promise<number> {\n    throw new Error('Method not implemented.')\n  }\n\n  populateCall(tx: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>> {\n    throw new Error('Method not implemented.')\n  }\n\n  checkTransaction(transaction: ethers.TransactionRequest): ethers.TransactionRequest {\n    throw new Error('Method not implemented.')\n  }\n\n  async populateTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>> {\n    throw new Error('Method not implemented.')\n  }\n\n  _checkProvider(operation?: string | undefined): void {\n    throw new Error('Method not implemented.')\n  }\n}\n","import { walletContracts } from '@0xsequence/abi'\nimport { commons, universal } from '@0xsequence/core'\nimport { migrator, defaults, version } from '@0xsequence/migration'\nimport { ChainId, NetworkConfig } from '@0xsequence/network'\nimport { FeeOption, FeeQuote, isRelayer, Relayer, RpcRelayer } from '@0xsequence/relayer'\nimport { tracker } from '@0xsequence/sessions'\nimport { SignatureOrchestrator } from '@0xsequence/signhub'\nimport { encodeTypedDataDigest, getFetchRequest } from '@0xsequence/utils'\nimport { Wallet } from '@0xsequence/wallet'\nimport { ethers } from 'ethers'\nimport { AccountSigner, AccountSignerOptions } from './signer'\n\nexport type AccountStatus = {\n  original: {\n    version: number\n    imageHash: string\n    context: commons.context.WalletContext\n  }\n  onChain: {\n    imageHash: string\n    config: commons.config.Config\n    version: number\n    deployed: boolean\n  }\n  fullyMigrated: boolean\n  signedMigrations: migrator.SignedMigration[]\n  version: number\n  presignedConfigurations: tracker.PresignedConfigLink[]\n  imageHash: string\n  config: commons.config.Config\n  checkpoint: ethers.BigNumberish\n  canOnchainValidate: boolean\n}\n\nexport type AccountOptions = {\n  // The only unique identifier for a wallet is the address\n  address: string\n\n  // The config tracker keeps track of chained configs,\n  // counterfactual addresses and reverse lookups for configurations\n  // it must implement both the ConfigTracker and MigrationTracker\n  tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker\n\n  // Versioned contexts contains the context information for each Sequence version\n  contexts: commons.context.VersionedContext\n\n  // Optional list of migrations, if not provided, the default migrations will be used\n  // NOTICE: the last vestion is considered the \"current\" version for the account\n  migrations?: migrator.Migrations\n\n  // Orchestrator manages signing messages and transactions\n  orchestrator: SignatureOrchestrator\n\n  // Networks information and providers\n  networks: NetworkConfig[]\n\n  // Jwt\n  jwt?: string\n\n  // Project access key\n  projectAccessKey?: string\n}\n\nexport interface PreparedTransactions {\n  transactions: commons.transaction.SimulatedTransaction[]\n  flatDecorated: commons.transaction.Transaction[]\n  feeOptions: FeeOption[]\n  feeQuote?: FeeQuote\n}\n\nclass Chain0Reader implements commons.reader.Reader {\n  async isDeployed(_wallet: string): Promise<boolean> {\n    return false\n  }\n\n  async implementation(_wallet: string): Promise<string | undefined> {\n    return undefined\n  }\n\n  async imageHash(_wallet: string): Promise<string | undefined> {\n    return undefined\n  }\n\n  async nonce(_wallet: string, _space: ethers.BigNumberish): Promise<bigint> {\n    return 0n\n  }\n\n  async isValidSignature(_wallet: string, _digest: ethers.BytesLike, _signature: ethers.BytesLike): Promise<boolean> {\n    throw new Error('Method not supported.')\n  }\n}\n\nexport class Account {\n  public readonly address: string\n\n  public readonly networks: NetworkConfig[]\n  public readonly tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker\n  public readonly contexts: commons.context.VersionedContext\n\n  public readonly migrator: migrator.Migrator\n  public readonly migrations: migrator.Migrations\n\n  private orchestrator: SignatureOrchestrator\n\n  private jwt?: string\n\n  private projectAccessKey?: string\n\n  constructor(options: AccountOptions) {\n    this.address = ethers.getAddress(options.address)\n\n    this.contexts = options.contexts\n    this.tracker = options.tracker\n    this.networks = options.networks\n    this.orchestrator = options.orchestrator\n    this.jwt = options.jwt\n    this.projectAccessKey = options.projectAccessKey\n\n    this.migrations = options.migrations || defaults.DefaultMigrations\n    this.migrator = new migrator.Migrator(options.tracker, this.migrations, this.contexts)\n  }\n\n  getSigner(chainId: ChainId, options?: AccountSignerOptions): AccountSigner {\n    return new AccountSigner(this, chainId, options)\n  }\n\n  static async new(options: {\n    config: commons.config.SimpleConfig\n    tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker\n    contexts: commons.context.VersionedContext\n    orchestrator: SignatureOrchestrator\n    networks: NetworkConfig[]\n    migrations?: migrator.Migrations\n    projectAccessKey?: string\n  }): Promise<Account> {\n    const mig = new migrator.Migrator(options.tracker, options.migrations ?? defaults.DefaultMigrations, options.contexts)\n\n    const lastMigration = mig.lastMigration()\n    const lastCoder = lastMigration.configCoder\n\n    const config = lastCoder.fromSimple(options.config)\n    const imageHash = lastCoder.imageHashOf(config)\n    const context = options.contexts[lastMigration.version]\n    const address = commons.context.addressOf(context, imageHash)\n\n    await options.tracker.saveCounterfactualWallet({ config, context: Object.values(options.contexts) })\n\n    return new Account({\n      address,\n      tracker: options.tracker,\n      contexts: options.contexts,\n      networks: options.networks,\n      orchestrator: options.orchestrator,\n      migrations: options.migrations,\n      projectAccessKey: options.projectAccessKey\n    })\n  }\n\n  getAddress(): Promise<string> {\n    return Promise.resolve(this.address)\n  }\n\n  get version(): number {\n    return this.migrator.lastMigration().version\n  }\n\n  get coders(): {\n    signature: commons.signature.SignatureCoder\n    config: commons.config.ConfigCoder\n  } {\n    const lastMigration = this.migrator.lastMigration()\n\n    return {\n      signature: lastMigration.signatureCoder,\n      config: lastMigration.configCoder\n    }\n  }\n\n  network(chainId: ethers.BigNumberish): NetworkConfig {\n    const tcid = BigInt(chainId)\n    const found = this.networks.find(n => tcid === BigInt(n.chainId))\n    if (!found) throw new Error(`Network not found for chainId ${chainId}`)\n    return found\n  }\n\n  providerFor(chainId: ethers.BigNumberish): ethers.Provider {\n    const found = this.network(chainId)\n    if (!found.provider && !found.rpcUrl) {\n      throw new Error(`Provider not found for chainId ${chainId}`)\n    }\n\n    const network = new ethers.Network(found.name, found.chainId)\n\n    return (\n      found.provider ||\n      new ethers.JsonRpcProvider(getFetchRequest(found.rpcUrl, this.projectAccessKey, this.jwt), network, {\n        staticNetwork: network\n      })\n    )\n  }\n\n  reader(chainId: ethers.BigNumberish): commons.reader.Reader {\n    if (BigInt(chainId) === 0n) {\n      return new Chain0Reader()\n    }\n\n    // TODO: Networks should be able to provide a reader directly\n    // and we should default to the on-chain reader\n    return new commons.reader.OnChainReader(this.providerFor(chainId))\n  }\n\n  relayer(chainId: ethers.BigNumberish): Relayer {\n    const found = this.network(chainId)\n    if (!found.relayer) throw new Error(`Relayer not found for chainId ${chainId}`)\n    if (isRelayer(found.relayer)) return found.relayer\n    return new RpcRelayer({\n      ...found.relayer,\n      // If there's an access key, we don't pass the JWT, because browser-side usage of this code mandates an access key\n      // and passing a JWT causes a CORS error.\n      ...(this.projectAccessKey ? { projectAccessKey: this.projectAccessKey } : { jwtAuth: this.jwt })\n    })\n  }\n\n  setOrchestrator(orchestrator: SignatureOrchestrator) {\n    this.orchestrator = orchestrator\n  }\n\n  setJwt(jwt: string) {\n    this.jwt = jwt\n  }\n\n  contextFor(version: number): commons.context.WalletContext {\n    const ctx = this.contexts[version]\n    if (!ctx) throw new Error(`Context not found for version ${version}`)\n    return ctx\n  }\n\n  walletForStatus(chainId: ethers.BigNumberish, status: Pick<AccountStatus, 'version'> & Pick<AccountStatus, 'config'>): Wallet {\n    const coder = universal.coderFor(status.version)\n    return this.walletFor(chainId, this.contextFor(status.version), status.config, coder)\n  }\n\n  walletFor(\n    chainId: ethers.BigNumberish,\n    context: commons.context.WalletContext,\n    config: commons.config.Config,\n    coders: typeof this.coders\n  ): Wallet {\n    const isNetworkZero = BigInt(chainId) === 0n\n    return new Wallet({\n      config,\n      context,\n      chainId,\n      coders,\n      relayer: isNetworkZero ? undefined : this.relayer(chainId),\n      address: this.address,\n      orchestrator: this.orchestrator,\n      reader: this.reader(chainId)\n    })\n  }\n\n  // Get the status of the account on a given network\n  // this does the following process:\n  // 1. Get the current on-chain status of the wallet (version + imageHash)\n  // 2. Get any pending migrations that have been signed by the wallet\n  // 3. Get any pending configuration updates that have been signed by the wallet\n  // 4. Fetch reverse lookups for both on-chain and pending configurations\n  async status(chainId: ethers.BigNumberish, longestPath: boolean = false): Promise<AccountStatus> {\n    const isDeployedPromise = this.reader(chainId).isDeployed(this.address)\n\n    const counterfactualImageHashPromise = this.tracker\n      .imageHashOfCounterfactualWallet({\n        wallet: this.address\n      })\n      .then(r => {\n        if (!r) throw new Error(`Counterfactual imageHash not found for wallet ${this.address}`)\n        return r\n      })\n\n    const counterFactualVersionPromise = counterfactualImageHashPromise.then(r => {\n      return version.counterfactualVersion(this.address, r.imageHash, Object.values(this.contexts))\n    })\n\n    const onChainVersionPromise = (async () => {\n      const isDeployed = await isDeployedPromise\n      if (!isDeployed) return counterFactualVersionPromise\n\n      const implementation = await this.reader(chainId).implementation(this.address)\n      if (!implementation) throw new Error(`Implementation not found for wallet ${this.address}`)\n\n      const versions = Object.values(this.contexts)\n      for (let i = 0; i < versions.length; i++) {\n        if (versions[i].mainModule === implementation || versions[i].mainModuleUpgradable === implementation) {\n          return versions[i].version\n        }\n      }\n\n      throw new Error(`Version not found for implementation ${implementation}`)\n    })()\n\n    const onChainImageHashPromise = (async () => {\n      const deployedImageHash = await this.reader(chainId).imageHash(this.address)\n      if (deployedImageHash) return deployedImageHash\n      const counterfactualImageHash = await counterfactualImageHashPromise\n      if (counterfactualImageHash) return counterfactualImageHash.imageHash\n      throw new Error(`On-chain imageHash not found for wallet ${this.address}`)\n    })()\n\n    const onChainConfigPromise = (async () => {\n      const onChainImageHash = await onChainImageHashPromise\n      const onChainConfig = await this.tracker.configOfImageHash({ imageHash: onChainImageHash })\n      if (onChainConfig) return onChainConfig\n      throw new Error(`On-chain config not found for imageHash ${onChainImageHash}`)\n    })()\n\n    const onChainVersion = await onChainVersionPromise\n    const onChainImageHash = await onChainImageHashPromise\n\n    let fromImageHash = onChainImageHash\n    let lastVersion = onChainVersion\n    let signedMigrations: migrator.SignedMigration[] = []\n\n    if (onChainVersion !== this.version) {\n      // We either need to use the presigned configuration updates, or we haven't performed\n      // any updates yet, so we can only use the on-chain imageHash as-is\n      const presignedMigrate = await this.migrator.getAllMigratePresignedTransaction({\n        address: this.address,\n        fromImageHash: onChainImageHash,\n        fromVersion: onChainVersion,\n        chainId\n      })\n\n      // The migrator returns the original version and imageHash\n      // if no presigned migration is found, so no need to check here\n      fromImageHash = presignedMigrate.lastImageHash\n      lastVersion = presignedMigrate.lastVersion\n\n      signedMigrations = presignedMigrate.signedMigrations\n    }\n\n    const presigned = await this.tracker.loadPresignedConfiguration({\n      wallet: this.address,\n      fromImageHash: fromImageHash,\n      longestPath\n    })\n\n    const imageHash = presigned && presigned.length > 0 ? presigned[presigned.length - 1].nextImageHash : fromImageHash\n    const config = await this.tracker.configOfImageHash({ imageHash })\n    if (!config) {\n      throw new Error(`Config not found for imageHash ${imageHash}`)\n    }\n\n    const isDeployed = await isDeployedPromise\n    const counterfactualImageHash = await counterfactualImageHashPromise\n    const checkpoint = universal.coderFor(lastVersion).config.checkpointOf(config as any)\n\n    return {\n      original: {\n        ...counterfactualImageHash,\n        version: await counterFactualVersionPromise\n      },\n      onChain: {\n        imageHash: onChainImageHash,\n        config: await onChainConfigPromise,\n        version: onChainVersion,\n        deployed: isDeployed\n      },\n      fullyMigrated: lastVersion === this.version,\n      signedMigrations,\n      version: lastVersion,\n      presignedConfigurations: presigned,\n      imageHash,\n      config,\n      checkpoint,\n      canOnchainValidate: onChainVersion === this.version && isDeployed\n    }\n  }\n\n  private mustBeFullyMigrated(status: AccountStatus) {\n    if (!status.fullyMigrated) {\n      throw new Error(`Wallet ${this.address} is not fully migrated`)\n    }\n  }\n\n  async predecorateSignedTransactions(\n    status: AccountStatus,\n    chainId: ethers.BigNumberish\n  ): Promise<commons.transaction.SignedTransactionBundle[]> {\n    // Request signed predecorate transactions from child wallets\n    const bundles = await this.orchestrator.predecorateSignedTransactions({ chainId })\n    // Get signed predecorate transaction\n    const predecorated = await this.predecorateTransactions([], status, chainId)\n    if (commons.transaction.fromTransactionish(this.address, predecorated).length > 0) {\n      // Sign it\n      bundles.push(await this.signTransactions(predecorated, chainId))\n    }\n    return bundles\n  }\n\n  async predecorateTransactions(\n    txs: commons.transaction.Transactionish,\n    status: AccountStatus,\n    chainId: ethers.BigNumberish\n  ): Promise<commons.transaction.Transactionish> {\n    // if onchain wallet config is not up to date\n    // then we should append an extra transaction that updates it\n    // to the latest \"lazy\" state\n    if (status.onChain.imageHash !== status.imageHash) {\n      const wallet = this.walletForStatus(chainId, status)\n      const updateConfig = await wallet.buildUpdateConfigurationTransaction(status.config)\n      return [Array.isArray(txs) ? txs : [txs], updateConfig.transactions].flat()\n    }\n\n    return txs\n  }\n\n  async decorateTransactions(\n    bundles: commons.transaction.IntendedTransactionBundle | commons.transaction.IntendedTransactionBundle[],\n    status: AccountStatus,\n    chainId?: ethers.BigNumberish\n  ): Promise<commons.transaction.IntendedTransactionBundle> {\n    if (!Array.isArray(bundles)) {\n      // Recurse with array\n      return this.decorateTransactions([bundles], status, chainId)\n    }\n\n    // Default to chainId of first bundle when not supplied\n    chainId = chainId ?? bundles[0].chainId\n\n    const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId)\n    const hasBootstrapTxs = bootstrapBundle.transactions.length > 0\n\n    if (!hasBootstrapTxs && bundles.length === 1) {\n      return bundles[0]\n    }\n\n    // Intent defaults to first bundle when no bootstrap transaction\n    const { entrypoint } = hasBootstrapTxs ? bootstrapBundle : bundles[0]\n\n    const decoratedBundle = {\n      entrypoint,\n      chainId,\n      // Intent of the first bundle is used\n      intent: bundles[0]?.intent,\n      transactions: [\n        ...bootstrapBundle.transactions,\n        ...bundles.map(\n          (bundle): commons.transaction.Transaction => ({\n            to: bundle.entrypoint,\n            data: commons.transaction.encodeBundleExecData(bundle),\n            gasLimit: 0,\n            delegateCall: false,\n            revertOnError: true,\n            value: 0\n          })\n        )\n      ]\n    }\n\n    // Re-compute the meta-transaction id to use the guest module subdigest\n    if (!status.onChain.deployed) {\n      const id = commons.transaction.subdigestOfGuestModuleTransactions(\n        this.contexts[this.version].guestModule,\n        chainId,\n        decoratedBundle.transactions\n      )\n\n      if (decoratedBundle.intent === undefined) {\n        decoratedBundle.intent = { id, wallet: this.address }\n      } else {\n        decoratedBundle.intent.id = id\n      }\n    }\n\n    return decoratedBundle\n  }\n\n  async decorateSignature<T extends ethers.BytesLike>(\n    signature: T,\n    status: Partial<Pick<AccountStatus, 'presignedConfigurations'>>\n  ): Promise<T | string> {\n    if (!status.presignedConfigurations || status.presignedConfigurations.length === 0) {\n      return signature\n    }\n\n    const coder = this.coders.signature\n\n    const chain = status.presignedConfigurations.map(c => c.signature)\n    const chainedSignature = coder.chainSignatures(signature, chain)\n    return coder.trim(chainedSignature)\n  }\n\n  async publishWitnessFor(signers: string[], chainId: ethers.BigNumberish = 0): Promise<void> {\n    const digest = ethers.id(`This is a Sequence account woo! ${Date.now()}`)\n\n    const status = await this.status(chainId)\n    const allOfAll = this.coders.config.fromSimple({\n      threshold: signers.length,\n      checkpoint: 0,\n      signers: signers.map(s => ({\n        address: s,\n        weight: 1\n      }))\n    })\n\n    const wallet = this.walletFor(chainId, status.original.context, allOfAll, this.coders)\n    const signature = await wallet.signDigest(digest)\n\n    const decoded = this.coders.signature.decode(signature)\n    const signatures = this.coders.signature.signaturesOfDecoded(decoded)\n\n    if (signatures.length === 0) {\n      throw new Error('No signatures found')\n    }\n\n    return this.tracker.saveWitnesses({ wallet: this.address, digest, chainId, signatures })\n  }\n\n  async publishWitness(): Promise<void> {\n    const digest = ethers.id(`This is a Sequence account woo! ${Date.now()}`)\n    const signature = await this.signDigest(digest, 0, false)\n    const decoded = this.coders.signature.decode(signature)\n    const signatures = this.coders.signature.signaturesOfDecoded(decoded)\n    return this.tracker.saveWitnesses({ wallet: this.address, digest, chainId: 0, signatures })\n  }\n\n  async signDigest(\n    digest: ethers.BytesLike,\n    chainId: ethers.BigNumberish,\n    decorate: boolean = true,\n    cantValidateBehavior: 'ignore' | 'eip6492' | 'throw' = 'ignore',\n    metadata?: object\n  ): Promise<string> {\n    // If we are signing a digest for chainId zero then we can never be fully migrated\n    // because Sequence v1 doesn't allow for signing a message on \"all chains\"\n\n    // So we ignore the state on \"chain zero\" and instead use one of the states of the networks\n    // wallet-webapp should ensure the wallet is as migrated as possible, trying to mimic\n    // the behaviour of being migrated on all chains\n    const chainRef = BigInt(chainId) === 0n ? this.networks[0].chainId : chainId\n    const status = await this.status(chainRef)\n    this.mustBeFullyMigrated(status)\n\n    // Check if we can validate onchain and what to do if we can't\n    // revert early, since there is no point in signing a digest now\n    if (!status.canOnchainValidate && cantValidateBehavior === 'throw') {\n      throw new Error('Wallet cannot validate onchain')\n    }\n\n    const wallet = this.walletForStatus(chainId, status)\n    const signature = await wallet.signDigest(digest, metadata)\n\n    const decorated = decorate ? this.decorateSignature(signature, status) : signature\n\n    // If the wallet can't validate onchain then we\n    // need to prefix the decorated signature with all deployments and migrations\n    // aka doing a bootstrap using EIP-6492\n    if (!status.canOnchainValidate) {\n      switch (cantValidateBehavior) {\n        // NOTICE: We covered this case before signing the digest\n        // case 'throw':\n        //   throw new Error('Wallet cannot validate on-chain')\n        case 'ignore':\n          return decorated\n\n        case 'eip6492':\n          return this.buildEIP6492Signature(await decorated, status, chainId)\n      }\n    }\n\n    return decorated\n  }\n\n  buildOnChainSignature(digest: ethers.BytesLike): { bundle: commons.transaction.TransactionBundle; signature: string } {\n    const subdigest = commons.signature.subdigestOf({\n      digest: ethers.hexlify(digest),\n      chainId: 0,\n      address: this.address\n    })\n    const hexSubdigest = ethers.hexlify(subdigest)\n    const config = this.coders.config.fromSimple({\n      // Threshold *only* needs to be > 0, this is not a magic number\n      // we only use 2 ** 15 because it may lead to lower gas costs in some chains\n      threshold: 32768,\n      checkpoint: 0,\n      signers: [],\n      subdigests: [hexSubdigest]\n    })\n\n    const walletInterface = new ethers.Interface(walletContracts.mainModule.abi)\n    const bundle: commons.transaction.TransactionBundle = {\n      entrypoint: this.address,\n      transactions: [\n        {\n          to: this.address,\n          data: walletInterface.encodeFunctionData(\n            // *NEVER* use updateImageHash here, as it would effectively destroy the wallet\n            // setExtraImageHash sets an additional imageHash, without changing the current one\n            'setExtraImageHash',\n            [\n              this.coders.config.imageHashOf(config),\n              // 2 ** 255 instead of max uint256, to have more zeros in the calldata\n              '57896044618658097711785492504343953926634992332820282019728792003956564819968'\n            ]\n          ),\n          // Conservative gas limit, used because the current relayer\n          // has trouble estimating gas for this transaction\n          gasLimit: 250000\n        }\n      ]\n    }\n\n    // Fire and forget request to save the config\n    this.tracker.saveWalletConfig({ config })\n\n    // Encode a signature proof for the given subdigest\n    // use `chainId = 0` to make it simpler, as this signature is only a proof\n    const signature = this.coders.signature.encodeSigners(config, new Map(), [hexSubdigest], 0).encoded\n    return { bundle, signature }\n  }\n\n  private async buildEIP6492Signature(signature: string, status: AccountStatus, chainId: ethers.BigNumberish): Promise<string> {\n    const bootstrapBundle = await this.buildBootstrapTransactions(status, chainId)\n    if (bootstrapBundle.transactions.length === 0) {\n      throw new Error('Cannot build EIP-6492 signature without bootstrap transactions')\n    }\n\n    const encoded = ethers.AbiCoder.defaultAbiCoder().encode(\n      ['address', 'bytes', 'bytes'],\n      [bootstrapBundle.entrypoint, commons.transaction.encodeBundleExecData(bootstrapBundle), signature]\n    )\n\n    return ethers.solidityPacked(['bytes', 'bytes32'], [encoded, commons.EIP6492.EIP_6492_SUFFIX])\n  }\n\n  async editConfig(changes: {\n    add?: commons.config.SimpleSigner[]\n    remove?: string[]\n    threshold?: ethers.BigNumberish\n  }): Promise<void> {\n    const currentConfig = await this.status(0).then(s => s.config)\n    const newConfig = this.coders.config.editConfig(currentConfig, {\n      ...changes,\n      checkpoint: this.coders.config.checkpointOf(currentConfig) + 1n\n    })\n\n    return this.updateConfig(newConfig)\n  }\n\n  async updateConfig(config: commons.config.Config): Promise<void> {\n    // config should be for the current version of the wallet\n    if (!this.coders.config.isWalletConfig(config)) {\n      throw new Error(`Invalid config for wallet ${this.address}`)\n    }\n\n    const nextImageHash = this.coders.config.imageHashOf(config)\n\n    // sign an update config struct\n    const updateStruct = this.coders.signature.hashSetImageHash(nextImageHash)\n\n    // sign the update struct, using chain id 0\n    const signature = await this.signDigest(updateStruct, 0, false)\n\n    // save the presigned transaction to the sessions tracker\n    await this.tracker.savePresignedConfiguration({\n      wallet: this.address,\n      nextConfig: config,\n      signature\n    })\n\n    // safety check, tracker should have a reverse lookup for the imageHash\n    // outside of the local cache\n    const reverseConfig = await this.tracker.configOfImageHash({\n      imageHash: nextImageHash,\n      noCache: true\n    })\n\n    if (!reverseConfig || this.coders.config.imageHashOf(reverseConfig) !== nextImageHash) {\n      throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`)\n    }\n  }\n\n  /**\n   *  This method is used to bootstrap the wallet on a given chain.\n   *  this deploys the wallets and executes all the necessary transactions\n   *  for that wallet to start working with the given version.\n   *\n   *  This usually involves: (a) deploying the wallet, (b) executing migrations\n   *\n   *  Notice: It should NOT explicitly include chained signatures. Unless internally used\n   *  by any of the migrations.\n   *\n   */\n  async buildBootstrapTransactions(\n    status: AccountStatus,\n    chainId: ethers.BigNumberish\n  ): Promise<commons.transaction.IntendedTransactionBundle> {\n    const bundle = await this.orchestrator.buildDeployTransaction({ chainId })\n    const transactions: commons.transaction.Transaction[] = bundle?.transactions ?? []\n\n    // Add wallet deployment if needed\n    if (!status.onChain.deployed) {\n      let gasLimit: bigint | undefined\n      switch (chainId) {\n        case BigInt(ChainId.SKALE_NEBULA):\n          gasLimit = 10000000n\n          break\n      }\n\n      // Wallet deployment will vary depending on the version\n      // so we need to use the context to get the correct deployment\n      const deployTransaction = Wallet.buildDeployTransaction(status.original.context, status.original.imageHash, gasLimit)\n\n      transactions.push(...deployTransaction.transactions)\n    }\n\n    // Get pending migrations\n    transactions.push(\n      ...status.signedMigrations.map(m => ({\n        to: m.tx.entrypoint,\n        data: commons.transaction.encodeBundleExecData(m.tx),\n        value: 0,\n        gasLimit: 0,\n        revertOnError: true,\n        delegateCall: false\n      }))\n    )\n\n    // Build the transaction intent, if the transaction has migrations\n    // then we should use one of the intents of the migrations (anyone will do)\n    // if it doesn't, then the only intent we could use if the GuestModule one\n    // ... but this may fail if the relayer uses a different GuestModule\n    const id =\n      status.signedMigrations.length > 0\n        ? status.signedMigrations[0].tx.intent.id\n        : commons.transaction.subdigestOfGuestModuleTransactions(this.contexts[this.version].guestModule, chainId, transactions)\n\n    // Everything is encoded as a bundle\n    // using the GuestModule of the account version\n    const { guestModule } = this.contextFor(status.version)\n    return { entrypoint: guestModule, transactions, chainId, intent: { id, wallet: this.address } }\n  }\n\n  async bootstrapTransactions(\n    chainId: ethers.BigNumberish,\n    prestatus?: AccountStatus\n  ): Promise<Omit<commons.transaction.IntendedTransactionBundle, 'chainId'>> {\n    const status = prestatus || (await this.status(chainId))\n    return this.buildBootstrapTransactions(status, chainId)\n  }\n\n  async doBootstrap(chainId: ethers.BigNumberish, feeQuote?: FeeQuote, prestatus?: AccountStatus) {\n    const bootstrapTxs = await this.bootstrapTransactions(chainId, prestatus)\n    return this.relayer(chainId).relay({ ...bootstrapTxs, chainId }, feeQuote)\n  }\n\n  signMessage(\n    message: ethers.BytesLike,\n    chainId: ethers.BigNumberish,\n    cantValidateBehavior: 'ignore' | 'eip6492' | 'throw' = 'ignore'\n  ): Promise<string> {\n    return this.signDigest(ethers.keccak256(message), chainId, true, cantValidateBehavior)\n  }\n\n  async signTransactions(\n    txs: commons.transaction.Transactionish,\n    chainId: ethers.BigNumberish,\n    pstatus?: AccountStatus,\n    options?: {\n      nonceSpace?: ethers.BigNumberish\n      serial?: boolean\n    }\n  ): Promise<commons.transaction.SignedTransactionBundle> {\n    const status = pstatus || (await this.status(chainId))\n    this.mustBeFullyMigrated(status)\n\n    const wallet = this.walletForStatus(chainId, status)\n\n    const metadata: commons.WalletSignRequestMetadata = {\n      address: this.address,\n      digest: '', // Set in wallet.signTransactions\n      chainId,\n      config: { version: this.version },\n      decorate: true,\n      cantValidateBehavior: 'ignore'\n    }\n\n    const nonceOptions = options?.serial\n      ? { serial: true }\n      : options?.nonceSpace !== undefined\n        ? { space: options.nonceSpace }\n        : undefined\n\n    const signed = await wallet.signTransactions(txs, nonceOptions, metadata)\n\n    return {\n      ...signed,\n      signature: await this.decorateSignature(signed.signature, status)\n    }\n  }\n\n  async signMigrations(\n    chainId: ethers.BigNumberish,\n    editConfig: (prevConfig: commons.config.Config) => commons.config.Config\n  ): Promise<boolean> {\n    const status = await this.status(chainId)\n    if (status.fullyMigrated) return false\n\n    const wallet = this.walletForStatus(chainId, status)\n    const nextConfig = editConfig(wallet.config)\n    const signed = await this.migrator.signNextMigration(this.address, status.version, wallet, nextConfig)\n    if (!signed) return false\n\n    // Make sure the tracker has a copy of the config\n    // before attempting to save the migration\n    // otherwise if this second step fails the tracker could end up\n    // with a migration to an unknown config\n    await this.tracker.saveWalletConfig({ config: nextConfig })\n    const nextCoder = universal.coderFor(nextConfig.version).config\n    const nextImageHash = nextCoder.imageHashOf(nextConfig as any)\n    const reverseConfig = await this.tracker.configOfImageHash({ imageHash: nextImageHash, noCache: true })\n    if (!reverseConfig || nextCoder.imageHashOf(reverseConfig as any) !== nextImageHash) {\n      throw Error(`Reverse lookup failed for imageHash ${nextImageHash}`)\n    }\n\n    await this.tracker.saveMigration(this.address, signed, this.contexts)\n\n    return true\n  }\n\n  async signAllMigrations(\n    editConfig: (prevConfig: commons.config.Config) => commons.config.Config\n  ): Promise<{ signedMigrations: Array<any>; failedChains: number[] }> {\n    const failedChains: number[] = []\n    const signedMigrations = await Promise.all(\n      this.networks.map(async n => {\n        try {\n          // Signing migrations for each chain\n          return await this.signMigrations(n.chainId, editConfig)\n        } catch (error) {\n          console.warn(`Failed to sign migrations for chain ${n.chainId}`, error)\n\n          // Adding failed chainId to the failedChains array\n          failedChains.push(n.chainId)\n          // Using null as a placeholder for failed chains\n          return null\n        }\n      })\n    )\n\n    // Filter out null values to get only the successful signed migrations\n    const successfulSignedMigrations = signedMigrations.filter(migration => migration !== null)\n\n    return { signedMigrations: successfulSignedMigrations, failedChains }\n  }\n\n  async isMigratedAllChains(): Promise<{ migratedAllChains: boolean; failedChains: number[] }> {\n    const failedChains: number[] = []\n    const statuses = await Promise.all(\n      this.networks.map(async n => {\n        try {\n          return await this.status(n.chainId)\n        } catch (error) {\n          failedChains.push(n.chainId)\n\n          console.warn(`Failed to get status for chain ${n.chainId}`, error)\n\n          // default to true for failed chains\n          return { fullyMigrated: true }\n        }\n      })\n    )\n\n    const migratedAllChains = statuses.every(s => s.fullyMigrated)\n    return { migratedAllChains, failedChains }\n  }\n\n  async sendSignedTransactions(\n    signedBundle: commons.transaction.IntendedTransactionBundle | commons.transaction.IntendedTransactionBundle[],\n    chainId: ethers.BigNumberish,\n    quote?: FeeQuote,\n    pstatus?: AccountStatus,\n    callback?: (bundle: commons.transaction.IntendedTransactionBundle) => void\n  ): Promise<ethers.TransactionResponse> {\n    if (!Array.isArray(signedBundle)) {\n      return this.sendSignedTransactions([signedBundle], chainId, quote, pstatus, callback)\n    }\n    const status = pstatus || (await this.status(chainId))\n    this.mustBeFullyMigrated(status)\n\n    const decoratedBundle = await this.decorateTransactions(signedBundle, status, chainId)\n    callback?.(decoratedBundle)\n\n    return this.relayer(chainId).relay(decoratedBundle, quote)\n  }\n\n  async fillGasLimits(\n    txs: commons.transaction.Transactionish,\n    chainId: ethers.BigNumberish,\n    status?: AccountStatus\n  ): Promise<commons.transaction.SimulatedTransaction[]> {\n    const wallet = this.walletForStatus(chainId, status || (await this.status(chainId)))\n    return wallet.fillGasLimits(txs)\n  }\n\n  async gasRefundQuotes(\n    txs: commons.transaction.Transactionish,\n    chainId: ethers.BigNumberish,\n    stubSignatureOverrides: Map<string, string>,\n    status?: AccountStatus,\n    options?: {\n      simulate?: boolean\n    }\n  ): Promise<{\n    options: FeeOption[]\n    quote?: FeeQuote\n    decorated: commons.transaction.IntendedTransactionBundle\n  }> {\n    const wstatus = status || (await this.status(chainId))\n    const wallet = this.walletForStatus(chainId, wstatus)\n\n    const predecorated = await this.predecorateTransactions(txs, wstatus, chainId)\n    const transactions = commons.transaction.fromTransactionish(this.address, predecorated)\n\n    // We can't sign the transactions (because we don't want to bother the user)\n    // so we use the latest configuration to build a \"stub\" signature, the relayer\n    // knows to ignore the wallet signatures\n    const stubSignature = wallet.coders.config.buildStubSignature(wallet.config, stubSignatureOverrides)\n\n    // Now we can decorate the transactions as always, but we need to manually build the signed bundle\n    const intentId = ethers.hexlify(ethers.randomBytes(32))\n    const signedBundle: commons.transaction.SignedTransactionBundle = {\n      chainId,\n      intent: {\n        id: intentId,\n        wallet: this.address\n      },\n      signature: stubSignature,\n      transactions,\n      entrypoint: this.address,\n      nonce: 0 // The relayer also ignored the nonce\n    }\n\n    const decoratedBundle = await this.decorateTransactions(signedBundle, wstatus)\n    const data = commons.transaction.encodeBundleExecData(decoratedBundle)\n    const res = await this.relayer(chainId).getFeeOptionsRaw(decoratedBundle.entrypoint, data, options)\n    return { ...res, decorated: decoratedBundle }\n  }\n\n  async prepareTransactions(args: {\n    txs: commons.transaction.Transactionish\n    chainId: ethers.BigNumberish\n    stubSignatureOverrides: Map<string, string>\n    simulateForFeeOptions?: boolean\n  }): Promise<PreparedTransactions> {\n    const status = await this.status(args.chainId)\n\n    const transactions = await this.fillGasLimits(args.txs, args.chainId, status)\n    const gasRefundQuote = await this.gasRefundQuotes(transactions, args.chainId, args.stubSignatureOverrides, status, {\n      simulate: args.simulateForFeeOptions\n    })\n    const flatDecorated = commons.transaction.unwind(this.address, gasRefundQuote.decorated.transactions)\n\n    return {\n      transactions,\n      flatDecorated,\n      feeOptions: gasRefundQuote.options,\n      feeQuote: gasRefundQuote.quote\n    }\n  }\n\n  async sendTransaction(\n    txs: commons.transaction.Transactionish,\n    chainId: ethers.BigNumberish,\n    quote?: FeeQuote,\n    skipPreDecorate: boolean = false,\n    callback?: (bundle: commons.transaction.IntendedTransactionBundle) => void,\n    options?: {\n      nonceSpace?: ethers.BigNumberish\n      serial?: boolean\n    }\n  ): Promise<ethers.TransactionResponse | undefined> {\n    const status = await this.status(chainId)\n\n    const predecorated = skipPreDecorate ? txs : await this.predecorateTransactions(txs, status, chainId)\n    const hasTxs = commons.transaction.fromTransactionish(this.address, predecorated).length > 0\n    const signed = hasTxs ? await this.signTransactions(predecorated, chainId, undefined, options) : undefined\n\n    const childBundles = await this.orchestrator.predecorateSignedTransactions({ chainId })\n\n    const bundles: commons.transaction.SignedTransactionBundle[] = []\n    if (signed !== undefined && signed.transactions.length > 0) {\n      bundles.push(signed)\n    }\n    bundles.push(...childBundles.filter(b => b.transactions.length > 0))\n\n    return this.sendSignedTransactions(bundles, chainId, quote, undefined, callback)\n  }\n\n  async signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, Array<ethers.TypedDataField>>,\n    message: Record<string, any>,\n    chainId: ethers.BigNumberish,\n    cantValidateBehavior: 'ignore' | 'eip6492' | 'throw' = 'ignore'\n  ): Promise<string> {\n    const digest = encodeTypedDataDigest({ domain, types, message })\n    return this.signDigest(digest, chainId, true, cantValidateBehavior)\n  }\n\n  async getSigners(): Promise<Array<{ address: string; network: ChainId; weight: number }>> {\n    const last = <T>(ts: T[]): T | undefined => (ts.length ? ts[ts.length - 1] : undefined)\n\n    return (\n      await Promise.all(\n        this.networks.map(async ({ chainId, name }) => {\n          try {\n            const status = await this.status(chainId)\n\n            let latestImageHash = last(status.presignedConfigurations)?.nextImageHash\n            if (!latestImageHash) {\n              if (status.onChain.version !== status.version) {\n                const migration = last(status.signedMigrations)\n                if (migration) {\n                  const { toVersion, toConfig } = migration\n                  const coder = universal.genericCoderFor(toVersion)\n                  latestImageHash = coder.config.imageHashOf(toConfig)\n                }\n              }\n            }\n            if (!latestImageHash) {\n              latestImageHash = status.onChain.imageHash\n            }\n\n            const latestConfig = await this.tracker.configOfImageHash({ imageHash: latestImageHash })\n            if (!latestConfig) {\n              throw new Error(`unable to find config for image hash ${latestImageHash}`)\n            }\n\n            const coder = universal.genericCoderFor(latestConfig.version)\n            const signers = coder.config.signersOf(latestConfig)\n\n            return signers.map(signer => ({ ...signer, network: chainId }))\n          } catch (error) {\n            console.warn(`unable to get signers on network ${chainId} ${name}`, error)\n            return []\n          }\n        })\n      )\n    ).flat()\n  }\n\n  async getAllSigners(): Promise<\n    {\n      address: string\n      weight: number\n      network: number\n      flaggedForRemoval: boolean\n    }[]\n  > {\n    const allSigners: {\n      address: string\n      weight: number\n      network: number\n      flaggedForRemoval: boolean\n    }[] = []\n\n    // We need to get the signers for each status\n    await Promise.all(\n      this.networks.map(async network => {\n        const chainId = network.chainId\n\n        // Getting the status with `longestPath` set to true will give us all the possible configurations\n        // between the current onChain config and the latest config, including the ones \"flagged for removal\"\n        const status = await this.status(chainId, true)\n\n        const fullChain = [\n          status.onChain.imageHash,\n          ...(status.onChain.version !== status.version\n            ? status.signedMigrations.map(m => universal.coderFor(m.toVersion).config.imageHashOf(m.toConfig as any))\n            : []),\n          ...status.presignedConfigurations.map(update => update.nextImageHash)\n        ]\n\n        return Promise.all(\n          fullChain.map(async (nextImageHash, iconf) => {\n            const isLast = iconf === fullChain.length - 1\n            const config = await this.tracker.configOfImageHash({ imageHash: nextImageHash })\n\n            if (!config) {\n              console.warn(`AllSigners may be incomplete, config not found for imageHash ${nextImageHash}`)\n              return\n            }\n\n            const coder = universal.genericCoderFor(config.version)\n            const signers = coder.config.signersOf(config)\n\n            signers.forEach(signer => {\n              const exists = allSigners.find(s => s.address === signer.address && s.network === chainId)\n\n              if (exists && isLast && exists.flaggedForRemoval) {\n                exists.flaggedForRemoval = false\n                return\n              }\n\n              if (exists) return\n\n              allSigners.push({\n                address: signer.address,\n                weight: signer.weight,\n                network: chainId,\n                flaggedForRemoval: !isLast\n              })\n            })\n          })\n        )\n      })\n    )\n\n    return allSigners\n  }\n}\n\nexport function isAccount(value: any): value is Account {\n  return value instanceof Account\n}\n","/* eslint-disable */\n// sequence-indexer v0.4.0 cae735346d8e5c3dce48dce9f85116989b6beffd\n// --\n// Code generated by webrpc-gen@v0.20.3 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=indexer.ridl -target=typescript -client -out=./clients/indexer.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = 'v1'\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = 'v0.4.0'\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = 'cae735346d8e5c3dce48dce9f85116989b6beffd'\n\n//\n// Types\n//\n\nexport interface ContractInfo {\n  chainId: number\n  address: string\n  name: string\n  type: string\n  symbol: string\n  decimals?: number\n  logoURI: string\n  deployed: boolean\n  bytecodeHash: string\n  extensions: ContractInfoExtensions\n  updatedAt: string\n}\n\nexport interface ContractInfoExtensions {\n  link: string\n  description: string\n  ogImage: string\n  originChainId: number\n  originAddress: string\n  blacklist: boolean\n  verified: boolean\n  verifiedBy: string\n  featured: boolean\n}\n\nexport interface TokenMetadata {\n  tokenId: string\n  name: string\n  description?: string\n  image?: string\n  video?: string\n  audio?: string\n  properties?: { [key: string]: any }\n  attributes: Array<{ [key: string]: any }>\n  image_data?: string\n  external_url?: string\n  background_color?: string\n  animation_url?: string\n  decimals?: number\n  updatedAt?: string\n  assets?: Array<Asset>\n}\n\nexport interface Asset {\n  id: number\n  collectionId: number\n  tokenId?: string\n  url?: string\n  metadataField: string\n  name?: string\n  filesize?: number\n  mimeType?: string\n  width?: number\n  height?: number\n  updatedAt?: string\n}\n\nexport enum ContractType {\n  UNKNOWN = 'UNKNOWN',\n  NATIVE = 'NATIVE',\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  SEQUENCE_WALLET = 'SEQUENCE_WALLET',\n  ERC20_BRIDGE = 'ERC20_BRIDGE',\n  ERC721_BRIDGE = 'ERC721_BRIDGE',\n  ERC1155_BRIDGE = 'ERC1155_BRIDGE',\n  SEQ_MARKETPLACE = 'SEQ_MARKETPLACE'\n}\n\nexport enum EventLogType {\n  UNKNOWN = 'UNKNOWN',\n  BLOCK_ADDED = 'BLOCK_ADDED',\n  BLOCK_REMOVED = 'BLOCK_REMOVED'\n}\n\nexport enum EventLogDataType {\n  EVENT = 'EVENT',\n  TOKEN_TRANSFER = 'TOKEN_TRANSFER',\n  NATIVE_TOKEN_TRANSFER = 'NATIVE_TOKEN_TRANSFER',\n  SEQUENCE_TXN = 'SEQUENCE_TXN'\n}\n\nexport enum OrderStatus {\n  OPEN = 'OPEN',\n  CLOSED = 'CLOSED',\n  CANCELLED = 'CANCELLED'\n}\n\nexport enum TxnTransferType {\n  UNKNOWN = 'UNKNOWN',\n  SEND = 'SEND',\n  RECEIVE = 'RECEIVE'\n}\n\nexport enum TransactionStatus {\n  FAILED = 'FAILED',\n  SUCCESSFUL = 'SUCCESSFUL'\n}\n\nexport enum TransactionType {\n  LegacyTxnType = 'LegacyTxnType',\n  AccessListTxnType = 'AccessListTxnType',\n  DynamicFeeTxnType = 'DynamicFeeTxnType'\n}\n\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport enum ContractVerificationStatus {\n  VERIFIED = 'VERIFIED',\n  UNVERIFIED = 'UNVERIFIED',\n  ALL = 'ALL'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  indexerEnabled: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  chainID: number\n  checks: RuntimeChecks\n}\n\nexport interface WALWriterRuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  chainID: number\n  percentWALWritten: number\n}\n\nexport interface RuntimeChecks {\n  running: boolean\n  runnables: any\n  cgoEnabled: boolean\n  quotaControlEnabled: boolean\n  syncMode: string\n  percentIndexed: number\n  lastBlockNum: number\n  lastBlockNumWithState: number\n  bloomStatus: BloomStatus\n  bond: Bond\n  diskUsage: DiskUsage\n}\n\nexport interface DiskUsage {\n  humanReadable: string\n  used: number\n  size: number\n  percent: number\n  dirs: { [key: string]: string }\n}\n\nexport interface Bond {\n  pebble: PebbleMetrics\n  estimatedDiskUsagePerTable: any\n  estimatedDiskUsageTotal: string\n}\n\nexport interface PebbleMetrics {\n  compactionCount: number\n  compactionEstimatedDebt: number\n  compactionInProgressBytes: number\n  compactionNumInProgress: number\n  compactionMarkedFiles: number\n}\n\nexport interface BloomStatus {\n  enabled: boolean\n  initialized: boolean\n  bloomInitElapsedTime: string\n}\n\nexport interface EtherBalance {\n  accountAddress: string\n  balanceWei: string\n}\n\nexport interface NativeTokenBalance {\n  accountAddress: string\n  balance: string\n}\n\nexport interface IndexState {\n  chainId: string\n  lastBlockNum: number\n  lastBlockHash: string\n}\n\nexport interface IndexedBlock {\n  blockNumber: number\n  blockShortHash: string\n}\n\nexport interface TxnInfo {\n  from: string\n  to: string\n  value: string\n}\n\nexport interface EventLog {\n  id: number\n  uid: string\n  type: EventLogType\n  blockNumber: number\n  blockHash: string\n  parentBlockHash: string\n  contractAddress: string\n  contractType: ContractType\n  txnHash: string\n  txnIndex: number\n  txnLogIndex: number\n  logDataType: EventLogDataType\n  ts: string\n  txnInfo?: TxnInfo\n  rawLog?: { [key: string]: any }\n  event?: EventDecoded\n}\n\nexport interface EventDecoded {\n  topicHash: string\n  eventSig: string\n  types: Array<string>\n  names: Array<string>\n  values: Array<string>\n}\n\nexport interface TokenBalance {\n  contractType: ContractType\n  contractAddress: string\n  accountAddress: string\n  tokenID?: string\n  balance: string\n  blockHash: string\n  blockNumber: number\n  chainId: number\n  uniqueCollectibles: string\n  isSummary: boolean\n  contractInfo?: ContractInfo\n  tokenMetadata?: TokenMetadata\n}\n\nexport interface OrderbookOrder {\n  orderId: string\n  tokenContract: string\n  tokenId: string\n  isListing: boolean\n  quantity: string\n  quantityRemaining: string\n  currencyAddress: string\n  pricePerToken: string\n  expiry: string\n  orderStatus: OrderStatus\n  createdBy: string\n  blockNumber: number\n  orderbookContractAddress: string\n  createdAt: number\n}\n\nexport interface OrderbookOrderFilter {\n  isListing?: boolean\n  userAddresses?: Array<string>\n  tokenIds: Array<string>\n  excludeUserAddresses?: Array<string>\n  afterBlockNumber: number\n  afterCreatedAt: number\n  beforeExpiry: number\n  userAddress?: string\n  excludeUserAddress?: string\n}\n\nexport interface TokenHistory {\n  blockNumber: number\n  blockHash: string\n  accountAddress: string\n  contractAddress: string\n  contractType: ContractType\n  fromAddress: string\n  toAddress: string\n  txnHash: string\n  txnIndex: number\n  txnLogIndex: number\n  logData: string\n  tokenIDs: string\n  Amounts: string\n  ts: string\n}\n\nexport interface TokenSupply {\n  tokenID: string\n  supply: string\n  chainId: number\n  contractInfo?: ContractInfo\n  tokenMetadata?: TokenMetadata\n}\n\nexport interface Transaction {\n  txnHash: string\n  blockNumber: number\n  blockHash: string\n  chainId: number\n  metaTxnID?: string\n  transfers?: Array<TxnTransfer>\n  timestamp: string\n}\n\nexport interface TxnTransfer {\n  transferType: TxnTransferType\n  contractAddress: string\n  contractType: ContractType\n  from: string\n  to: string\n  tokenIds?: Array<string>\n  amounts: Array<string>\n  logIndex: number\n  contractInfo?: ContractInfo\n  tokenMetadata?: { [key: string]: TokenMetadata }\n}\n\nexport interface TransactionHistoryFilter {\n  accountAddress?: string\n  contractAddress?: string\n  accountAddresses?: Array<string>\n  contractAddresses?: Array<string>\n  transactionHashes?: Array<string>\n  metaTransactionIDs?: Array<string>\n  fromBlock?: number\n  toBlock?: number\n  tokenID?: string\n}\n\nexport interface TransactionFilter {\n  txnHash?: string\n  from?: string\n  to?: string\n  contractAddress?: string\n  event?: string\n}\n\nexport interface TransactionReceipt {\n  txnHash: string\n  txnStatus: TransactionStatus\n  txnIndex: number\n  txnType: TransactionType\n  blockHash: string\n  blockNumber: number\n  gasUsed: number\n  effectiveGasPrice: string\n  from: string\n  to: string\n  logs: Array<TransactionLog>\n  final: boolean\n  reorged: boolean\n}\n\nexport interface TransactionLog {\n  contractAddress: string\n  topics: Array<string>\n  data: string\n  index: number\n}\n\nexport interface Page {\n  page?: number\n  column?: string\n  before?: any\n  after?: any\n  sort?: Array<SortBy>\n  pageSize?: number\n  more?: boolean\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface WebhookListener {\n  id: number\n  projectID: number\n  url: string\n  filters: EventFilter\n  name: string\n  updatedAt: string\n  active: boolean\n}\n\nexport interface EventFilter {\n  events?: Array<string>\n  contractAddresses?: Array<string>\n  accounts?: Array<string>\n  tokenIDs?: Array<string>\n}\n\nexport interface TokenBalanceFilter {\n  contractAddress: string\n  sinceBlockNumber: number\n}\n\nexport interface MetadataOptions {\n  verifiedOnly?: boolean\n  unverifiedOnly?: boolean\n  includeContracts?: Array<string>\n}\n\nexport interface TokenBalancesFilter {\n  accountAddresses: Array<string>\n  contractStatus: ContractVerificationStatus\n  contractWhitelist: Array<string>\n  contractBlacklist: Array<string>\n}\n\nexport interface TokenBalancesByContractFilter {\n  contractAddresses: Array<string>\n  accountAddresses: Array<string>\n  contractStatus: ContractVerificationStatus\n}\n\nexport interface Indexer {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>\n  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>\n  getChainID(headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn>\n  getEtherBalance(args: GetEtherBalanceArgs, headers?: object, signal?: AbortSignal): Promise<GetEtherBalanceReturn>\n  getNativeTokenBalance(\n    args: GetNativeTokenBalanceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNativeTokenBalanceReturn>\n  getTokenBalancesSummary(\n    args: GetTokenBalancesSummaryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenBalancesSummaryReturn>\n  getTokenBalancesDetails(\n    args: GetTokenBalancesDetailsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenBalancesDetailsReturn>\n  getTokenBalancesByContract(\n    args: GetTokenBalancesByContractArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenBalancesByContractReturn>\n  getTokenBalances(args: GetTokenBalancesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenBalancesReturn>\n  getTokenSupplies(args: GetTokenSuppliesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenSuppliesReturn>\n  getTokenSuppliesMap(args: GetTokenSuppliesMapArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenSuppliesMapReturn>\n  getBalanceUpdates(args: GetBalanceUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<GetBalanceUpdatesReturn>\n  getTransactionHistory(\n    args: GetTransactionHistoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTransactionHistoryReturn>\n  syncBalance(args: SyncBalanceArgs, headers?: object, signal?: AbortSignal): Promise<SyncBalanceReturn>\n  fetchTransactionReceipt(\n    args: FetchTransactionReceiptArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<FetchTransactionReceiptReturn>\n  getOrderbookOrders(args: GetOrderbookOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetOrderbookOrdersReturn>\n  getTopOrders(args: GetTopOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetTopOrdersReturn>\n  fetchTransactionReceiptWithFilter(\n    args: FetchTransactionReceiptWithFilterArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<FetchTransactionReceiptWithFilterReturn>\n  getAllWebhookListeners(\n    args: GetAllWebhookListenersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetAllWebhookListenersReturn>\n  getWebhookListener(args: GetWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<GetWebhookListenerReturn>\n  addWebhookListener(args: AddWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<AddWebhookListenerReturn>\n  updateWebhookListener(\n    args: UpdateWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateWebhookListenerReturn>\n  removeWebhookListener(\n    args: RemoveWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveWebhookListenerReturn>\n  toggleWebhookListener(\n    args: ToggleWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ToggleWebhookListenerReturn>\n  pauseAllWebhookListeners(\n    args: PauseAllWebhookListenersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<PauseAllWebhookListenersReturn>\n  resumeAllWebhookListeners(\n    args: ResumeAllWebhookListenersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ResumeAllWebhookListenersReturn>\n  subscribeReceipts(args: SubscribeReceiptsArgs, options: WebrpcStreamOptions<SubscribeReceiptsReturn>): Promise<void>\n  subscribeEvents(args: SubscribeEventsArgs, options: WebrpcStreamOptions<SubscribeEventsReturn>): Promise<void>\n  subscribeBalanceUpdates(\n    args: SubscribeBalanceUpdatesArgs,\n    options: WebrpcStreamOptions<SubscribeBalanceUpdatesReturn>\n  ): Promise<void>\n}\n\nexport interface PingArgs {}\n\nexport interface PingReturn {\n  status: boolean\n}\nexport interface VersionArgs {}\n\nexport interface VersionReturn {\n  version: Version\n}\nexport interface RuntimeStatusArgs {}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus\n}\nexport interface GetChainIDArgs {}\n\nexport interface GetChainIDReturn {\n  chainID: number\n}\nexport interface GetEtherBalanceArgs {\n  accountAddress?: string\n}\n\nexport interface GetEtherBalanceReturn {\n  balance: EtherBalance\n}\nexport interface GetNativeTokenBalanceArgs {\n  accountAddress?: string\n}\n\nexport interface GetNativeTokenBalanceReturn {\n  balance: NativeTokenBalance\n}\nexport interface GetTokenBalancesSummaryArgs {\n  filter: TokenBalancesFilter\n  omitMetadata?: boolean\n  page?: Page\n}\n\nexport interface GetTokenBalancesSummaryReturn {\n  page: Page\n  balances: Array<TokenBalance>\n}\nexport interface GetTokenBalancesDetailsArgs {\n  filter: TokenBalancesFilter\n  omitMetadata?: boolean\n  page?: Page\n}\n\nexport interface GetTokenBalancesDetailsReturn {\n  page: Page\n  balances: Array<TokenBalance>\n}\nexport interface GetTokenBalancesByContractArgs {\n  filter: TokenBalancesByContractFilter\n  omitMetadata?: boolean\n  page?: Page\n}\n\nexport interface GetTokenBalancesByContractReturn {\n  page: Page\n  balances: Array<TokenBalance>\n}\nexport interface GetTokenBalancesArgs {\n  accountAddress?: string\n  contractAddress?: string\n  tokenID?: string\n  includeMetadata?: boolean\n  metadataOptions?: MetadataOptions\n  includeCollectionTokens?: boolean\n  page?: Page\n}\n\nexport interface GetTokenBalancesReturn {\n  page: Page\n  balances: Array<TokenBalance>\n}\nexport interface GetTokenSuppliesArgs {\n  contractAddress: string\n  includeMetadata?: boolean\n  metadataOptions?: MetadataOptions\n  page?: Page\n}\n\nexport interface GetTokenSuppliesReturn {\n  page: Page\n  contractType: ContractType\n  tokenIDs: Array<TokenSupply>\n}\nexport interface GetTokenSuppliesMapArgs {\n  tokenMap: { [key: string]: Array<string> }\n  includeMetadata?: boolean\n  metadataOptions?: MetadataOptions\n}\n\nexport interface GetTokenSuppliesMapReturn {\n  supplies: { [key: string]: Array<TokenSupply> }\n}\nexport interface GetBalanceUpdatesArgs {\n  contractAddress: string\n  lastBlockNumber: number\n  lastBlockHash?: string\n  page?: Page\n}\n\nexport interface GetBalanceUpdatesReturn {\n  page: Page\n  balances: Array<TokenBalance>\n}\nexport interface GetTransactionHistoryArgs {\n  filter: TransactionHistoryFilter\n  page?: Page\n  includeMetadata?: boolean\n  metadataOptions?: MetadataOptions\n}\n\nexport interface GetTransactionHistoryReturn {\n  page: Page\n  transactions: Array<Transaction>\n}\nexport interface SyncBalanceArgs {\n  accountAddress: string\n  contractAddress: string\n  tokenID?: string\n}\n\nexport interface SyncBalanceReturn {}\nexport interface FetchTransactionReceiptArgs {\n  txnHash: string\n  maxBlockWait?: number\n}\n\nexport interface FetchTransactionReceiptReturn {\n  receipt: TransactionReceipt\n}\nexport interface GetOrderbookOrdersArgs {\n  page?: Page\n  orderbookContractAddress: string\n  collectionAddress: string\n  currencyAddresses: Array<string>\n  filter: OrderbookOrderFilter\n  orderStatuses: Array<OrderStatus>\n  filters: Array<OrderbookOrderFilter>\n  beforeExpiryTimestamp: number\n  blockNumberAfter: number\n  createdAtAfter: number\n}\n\nexport interface GetOrderbookOrdersReturn {\n  page?: Page\n  orders: Array<OrderbookOrder>\n}\nexport interface GetTopOrdersArgs {\n  orderbookContractAddress: string\n  collectionAddress: string\n  currencyAddresses: Array<string>\n  tokenIDs: Array<string>\n  isListing: boolean\n  priceSort: SortOrder\n  excludeUser?: string\n}\n\nexport interface GetTopOrdersReturn {\n  orders: Array<OrderbookOrder>\n}\nexport interface FetchTransactionReceiptWithFilterArgs {\n  filter: TransactionFilter\n  maxBlockWait?: number\n}\n\nexport interface FetchTransactionReceiptWithFilterReturn {\n  receipt: TransactionReceipt\n}\nexport interface GetAllWebhookListenersArgs {\n  projectId?: number\n}\n\nexport interface GetAllWebhookListenersReturn {\n  listeners: Array<WebhookListener>\n}\nexport interface GetWebhookListenerArgs {\n  id: number\n  projectId?: number\n}\n\nexport interface GetWebhookListenerReturn {\n  listener: WebhookListener\n}\nexport interface AddWebhookListenerArgs {\n  url: string\n  filters: EventFilter\n  projectId?: number\n}\n\nexport interface AddWebhookListenerReturn {\n  status: boolean\n  listener: WebhookListener\n}\nexport interface UpdateWebhookListenerArgs {\n  listener: WebhookListener\n  projectId?: number\n}\n\nexport interface UpdateWebhookListenerReturn {\n  status: boolean\n}\nexport interface RemoveWebhookListenerArgs {\n  id: number\n  projectId?: number\n}\n\nexport interface RemoveWebhookListenerReturn {\n  status: boolean\n}\nexport interface ToggleWebhookListenerArgs {\n  id: number\n  projectId?: number\n}\n\nexport interface ToggleWebhookListenerReturn {\n  webhookListener: WebhookListener\n}\nexport interface PauseAllWebhookListenersArgs {\n  projectId?: number\n}\n\nexport interface PauseAllWebhookListenersReturn {\n  status: boolean\n}\nexport interface ResumeAllWebhookListenersArgs {\n  projectId?: number\n}\n\nexport interface ResumeAllWebhookListenersReturn {\n  status: boolean\n}\nexport interface SubscribeReceiptsArgs {\n  filter: TransactionFilter\n}\n\nexport interface SubscribeReceiptsReturn {\n  receipt: TransactionReceipt\n}\nexport interface SubscribeEventsArgs {\n  filter: EventFilter\n}\n\nexport interface SubscribeEventsReturn {\n  log: EventLog\n}\nexport interface SubscribeBalanceUpdatesArgs {\n  contractAddress: string\n}\n\nexport interface SubscribeBalanceUpdatesReturn {\n  balance: TokenBalance\n}\n\n//\n// Client\n//\nexport class Indexer implements Indexer {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Indexer/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname.replace(/\\/*$/, '')\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {\n    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: <Version>_data.version\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {\n    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <RuntimeStatus>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getChainID = (headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn> => {\n    return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            chainID: <number>_data.chainID\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getEtherBalance = (args: GetEtherBalanceArgs, headers?: object, signal?: AbortSignal): Promise<GetEtherBalanceReturn> => {\n    return this.fetch(this.url('GetEtherBalance'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            balance: <EtherBalance>_data.balance\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getNativeTokenBalance = (\n    args: GetNativeTokenBalanceArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNativeTokenBalanceReturn> => {\n    return this.fetch(this.url('GetNativeTokenBalance'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            balance: <NativeTokenBalance>_data.balance\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenBalancesSummary = (\n    args: GetTokenBalancesSummaryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenBalancesSummaryReturn> => {\n    return this.fetch(this.url('GetTokenBalancesSummary'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            balances: <Array<TokenBalance>>_data.balances\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenBalancesDetails = (\n    args: GetTokenBalancesDetailsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenBalancesDetailsReturn> => {\n    return this.fetch(this.url('GetTokenBalancesDetails'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            balances: <Array<TokenBalance>>_data.balances\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenBalancesByContract = (\n    args: GetTokenBalancesByContractArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenBalancesByContractReturn> => {\n    return this.fetch(this.url('GetTokenBalancesByContract'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            balances: <Array<TokenBalance>>_data.balances\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenBalances = (args: GetTokenBalancesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenBalancesReturn> => {\n    return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            balances: <Array<TokenBalance>>_data.balances\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenSupplies = (args: GetTokenSuppliesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenSuppliesReturn> => {\n    return this.fetch(this.url('GetTokenSupplies'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            contractType: <ContractType>_data.contractType,\n            tokenIDs: <Array<TokenSupply>>_data.tokenIDs\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenSuppliesMap = (\n    args: GetTokenSuppliesMapArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenSuppliesMapReturn> => {\n    return this.fetch(this.url('GetTokenSuppliesMap'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            supplies: <{ [key: string]: Array<TokenSupply> }>_data.supplies\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getBalanceUpdates = (args: GetBalanceUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<GetBalanceUpdatesReturn> => {\n    return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            balances: <Array<TokenBalance>>_data.balances\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTransactionHistory = (\n    args: GetTransactionHistoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTransactionHistoryReturn> => {\n    return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            transactions: <Array<Transaction>>_data.transactions\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  syncBalance = (args: SyncBalanceArgs, headers?: object, signal?: AbortSignal): Promise<SyncBalanceReturn> => {\n    return this.fetch(this.url('SyncBalance'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  fetchTransactionReceipt = (\n    args: FetchTransactionReceiptArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<FetchTransactionReceiptReturn> => {\n    return this.fetch(this.url('FetchTransactionReceipt'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            receipt: <TransactionReceipt>_data.receipt\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getOrderbookOrders = (\n    args: GetOrderbookOrdersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetOrderbookOrdersReturn> => {\n    return this.fetch(this.url('GetOrderbookOrders'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            orders: <Array<OrderbookOrder>>_data.orders\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTopOrders = (args: GetTopOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetTopOrdersReturn> => {\n    return this.fetch(this.url('GetTopOrders'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            orders: <Array<OrderbookOrder>>_data.orders\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  fetchTransactionReceiptWithFilter = (\n    args: FetchTransactionReceiptWithFilterArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<FetchTransactionReceiptWithFilterReturn> => {\n    return this.fetch(this.url('FetchTransactionReceiptWithFilter'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            receipt: <TransactionReceipt>_data.receipt\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getAllWebhookListeners = (\n    args: GetAllWebhookListenersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetAllWebhookListenersReturn> => {\n    return this.fetch(this.url('GetAllWebhookListeners'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            listeners: <Array<WebhookListener>>_data.listeners\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getWebhookListener = (\n    args: GetWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetWebhookListenerReturn> => {\n    return this.fetch(this.url('GetWebhookListener'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            listener: <WebhookListener>_data.listener\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addWebhookListener = (\n    args: AddWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddWebhookListenerReturn> => {\n    return this.fetch(this.url('AddWebhookListener'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status,\n            listener: <WebhookListener>_data.listener\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateWebhookListener = (\n    args: UpdateWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateWebhookListenerReturn> => {\n    return this.fetch(this.url('UpdateWebhookListener'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  removeWebhookListener = (\n    args: RemoveWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveWebhookListenerReturn> => {\n    return this.fetch(this.url('RemoveWebhookListener'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  toggleWebhookListener = (\n    args: ToggleWebhookListenerArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ToggleWebhookListenerReturn> => {\n    return this.fetch(this.url('ToggleWebhookListener'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            webhookListener: <WebhookListener>_data.webhookListener\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  pauseAllWebhookListeners = (\n    args: PauseAllWebhookListenersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<PauseAllWebhookListenersReturn> => {\n    return this.fetch(this.url('PauseAllWebhookListeners'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  resumeAllWebhookListeners = (\n    args: ResumeAllWebhookListenersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ResumeAllWebhookListenersReturn> => {\n    return this.fetch(this.url('ResumeAllWebhookListeners'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  subscribeReceipts = (args: SubscribeReceiptsArgs, options: WebrpcStreamOptions<SubscribeReceiptsReturn>): Promise<void> => {\n    const _fetch = () =>\n      this.fetch(this.url('SubscribeReceipts'), createHTTPRequest(args, options.headers, options.signal)).then(\n        async res => {\n          await sseResponse(res, options, _fetch)\n        },\n        error => {\n          options.onError(error, _fetch)\n        }\n      )\n    return _fetch()\n  }\n  subscribeEvents = (args: SubscribeEventsArgs, options: WebrpcStreamOptions<SubscribeEventsReturn>): Promise<void> => {\n    const _fetch = () =>\n      this.fetch(this.url('SubscribeEvents'), createHTTPRequest(args, options.headers, options.signal)).then(\n        async res => {\n          await sseResponse(res, options, _fetch)\n        },\n        error => {\n          options.onError(error, _fetch)\n        }\n      )\n    return _fetch()\n  }\n  subscribeBalanceUpdates = (\n    args: SubscribeBalanceUpdatesArgs,\n    options: WebrpcStreamOptions<SubscribeBalanceUpdatesReturn>\n  ): Promise<void> => {\n    const _fetch = () =>\n      this.fetch(this.url('SubscribeBalanceUpdates'), createHTTPRequest(args, options.headers, options.signal)).then(\n        async res => {\n          await sseResponse(res, options, _fetch)\n        },\n        error => {\n          options.onError(error, _fetch)\n        }\n      )\n    return _fetch()\n  }\n}\n\nconst sseResponse = async (res: Response, options: WebrpcStreamOptions<any>, retryFetch: () => Promise<void>) => {\n  const { onMessage, onOpen, onClose, onError } = options\n\n  if (!res.ok) {\n    try {\n      await buildResponse(res)\n    } catch (error) {\n      // @ts-ignore\n      onError(error, retryFetch)\n    }\n    return\n  }\n\n  if (!res.body) {\n    onError(\n      WebrpcBadResponseError.new({\n        status: res.status,\n        cause: 'Invalid response, missing body'\n      }),\n      retryFetch\n    )\n    return\n  }\n\n  onOpen && onOpen()\n\n  const reader = res.body.getReader()\n  const decoder = new TextDecoder()\n  let buffer = ''\n  let lastReadTime = Date.now()\n  const timeout = (10 + 1) * 1000\n  let timeoutError = false\n  const intervalId = setInterval(() => {\n    if (Date.now() - lastReadTime > timeout) {\n      timeoutError = true\n      clearInterval(intervalId)\n      reader.releaseLock()\n    }\n  }, timeout)\n\n  while (true) {\n    let value\n    let done\n    try {\n      ;({ value, done } = await reader.read())\n      if (timeoutError) throw new Error('Timeout, no data or heartbeat received')\n      lastReadTime = Date.now()\n      buffer += decoder.decode(value, { stream: true })\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n\n      if (error instanceof DOMException && error.name === 'AbortError') {\n        onError(\n          WebrpcRequestFailedError.new({\n            message: 'AbortError',\n            cause: `AbortError: ${message}`\n          }),\n          () => {\n            throw new Error('Abort signal cannot be used to reconnect')\n          }\n        )\n      } else {\n        onError(\n          WebrpcStreamLostError.new({\n            cause: `reader.read(): ${message}`\n          }),\n          retryFetch\n        )\n      }\n      return\n    }\n\n    let lines = buffer.split('\\n')\n    for (let i = 0; i < lines.length - 1; i++) {\n      if (lines[i].length == 0) {\n        continue\n      }\n      let data: any\n      try {\n        data = JSON.parse(lines[i])\n        if (data.hasOwnProperty('webrpcError')) {\n          const error = data.webrpcError\n          const code: number = typeof error.code === 'number' ? error.code : 0\n          onError((webrpcErrorByCode[code] || WebrpcError).new(error), retryFetch)\n          return\n        }\n      } catch (error) {\n        if (error instanceof Error && error.message === 'Abort signal cannot be used to reconnect') {\n          throw error\n        }\n        onError(\n          WebrpcBadResponseError.new({\n            status: res.status,\n            // @ts-ignore\n            cause: `JSON.parse(): ${error.message}`\n          }),\n          retryFetch\n        )\n      }\n      onMessage(data)\n    }\n\n    if (!done) {\n      buffer = lines[lines.length - 1]\n      continue\n    }\n\n    onClose && onClose()\n    return\n  }\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`\n      })\n    }\n    if (!res.ok) {\n      const code: number = typeof data.code === 'number' ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n// Schema errors\n\nexport class UnauthorizedError extends WebrpcError {\n  constructor(\n    name: string = 'Unauthorized',\n    code: number = 1000,\n    message: string = 'Unauthorized access',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnauthorizedError.prototype)\n  }\n}\n\nexport class PermissionDeniedError extends WebrpcError {\n  constructor(\n    name: string = 'PermissionDenied',\n    code: number = 1001,\n    message: string = 'Permission denied',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, PermissionDeniedError.prototype)\n  }\n}\n\nexport class SessionExpiredError extends WebrpcError {\n  constructor(\n    name: string = 'SessionExpired',\n    code: number = 1002,\n    message: string = 'Session expired',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, SessionExpiredError.prototype)\n  }\n}\n\nexport class MethodNotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'MethodNotFound',\n    code: number = 1003,\n    message: string = 'Method not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, MethodNotFoundError.prototype)\n  }\n}\n\nexport class RequestConflictError extends WebrpcError {\n  constructor(\n    name: string = 'RequestConflict',\n    code: number = 1004,\n    message: string = 'Conflict with target resource',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, RequestConflictError.prototype)\n  }\n}\n\nexport class AbortedError extends WebrpcError {\n  constructor(\n    name: string = 'Aborted',\n    code: number = 1005,\n    message: string = 'Request aborted',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, AbortedError.prototype)\n  }\n}\n\nexport class TimeoutError extends WebrpcError {\n  constructor(\n    name: string = 'Timeout',\n    code: number = 2000,\n    message: string = 'Request timed out',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, TimeoutError.prototype)\n  }\n}\n\nexport class InvalidArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidArgument',\n    code: number = 2001,\n    message: string = 'Invalid argument',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidArgumentError.prototype)\n  }\n}\n\nexport class UnavailableError extends WebrpcError {\n  constructor(\n    name: string = 'Unavailable',\n    code: number = 2002,\n    message: string = 'Unavailable resource',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnavailableError.prototype)\n  }\n}\n\nexport class QueryFailedError extends WebrpcError {\n  constructor(\n    name: string = 'QueryFailed',\n    code: number = 2003,\n    message: string = 'Query failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, QueryFailedError.prototype)\n  }\n}\n\nexport class ResourceExhaustedError extends WebrpcError {\n  constructor(\n    name: string = 'ResourceExhausted',\n    code: number = 2004,\n    message: string = 'Resource exhausted',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, ResourceExhaustedError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'NotFound',\n    code: number = 3000,\n    message: string = 'Resource not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport class ProjectNotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'ProjectNotFound',\n    code: number = 3002,\n    message: string = 'Project not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)\n  }\n}\n\nexport class MetadataCallFailedError extends WebrpcError {\n  constructor(\n    name: string = 'MetadataCallFailed',\n    code: number = 3003,\n    message: string = 'Metadata service call failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, MetadataCallFailedError.prototype)\n  }\n}\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  Unauthorized = 'Unauthorized',\n  PermissionDenied = 'PermissionDenied',\n  SessionExpired = 'SessionExpired',\n  MethodNotFound = 'MethodNotFound',\n  RequestConflict = 'RequestConflict',\n  Aborted = 'Aborted',\n  Timeout = 'Timeout',\n  InvalidArgument = 'InvalidArgument',\n  Unavailable = 'Unavailable',\n  QueryFailed = 'QueryFailed',\n  ResourceExhausted = 'ResourceExhausted',\n  NotFound = 'NotFound',\n  ProjectNotFound = 'ProjectNotFound',\n  MetadataCallFailed = 'MetadataCallFailed'\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1000]: UnauthorizedError,\n  [1001]: PermissionDeniedError,\n  [1002]: SessionExpiredError,\n  [1003]: MethodNotFoundError,\n  [1004]: RequestConflictError,\n  [1005]: AbortedError,\n  [2000]: TimeoutError,\n  [2001]: InvalidArgumentError,\n  [2002]: UnavailableError,\n  [2003]: QueryFailedError,\n  [2004]: ResourceExhaustedError,\n  [3000]: NotFoundError,\n  [3002]: ProjectNotFoundError,\n  [3003]: MetadataCallFailedError\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n\nexport interface WebrpcStreamOptions<T> extends WebrpcOptions {\n  onMessage: (message: T) => void\n  onError: (error: WebrpcError, reconnect: () => void) => void\n  onOpen?: () => void\n  onClose?: () => void\n}\nexport interface WebrpcOptions {\n  headers?: HeadersInit\n  signal?: AbortSignal\n}\n","export * from './indexer.gen'\n\nimport { Indexer as IndexerRpc } from './indexer.gen'\n\nconst fetch = globalThis.fetch\n\nexport class SequenceIndexer extends IndexerRpc {\n  constructor(\n    hostname: string,\n    public projectAccessKey?: string,\n    public jwtAuth?: string\n  ) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt and access key auth header to requests\n    // if its been set on the api client\n    const headers: { [key: string]: any } = {}\n\n    const jwtAuth = this.jwtAuth\n    const projectAccessKey = this.projectAccessKey\n\n    if (jwtAuth && jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${jwtAuth}`\n    }\n\n    if (projectAccessKey && projectAccessKey.length > 0) {\n      headers['X-Access-Key'] = projectAccessKey\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n}\n","/* eslint-disable */\n// sequence-metadata v0.4.0 9d0976f6ff345b6a688b69cff647454e7fd0e3a6\n// --\n// Code generated by webrpc-gen@v0.18.6 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=metadata.ridl -target=typescript -client -out=./clients/metadata.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = 'v1'\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = 'v0.4.0'\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = '9d0976f6ff345b6a688b69cff647454e7fd0e3a6'\n\n//\n// Types\n//\n\nexport enum ContractType {\n  UNKNOWN = 'UNKNOWN',\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155'\n}\n\nexport enum PropertyType {\n  INT = 'INT',\n  STRING = 'STRING',\n  ARRAY = 'ARRAY',\n  GENERIC = 'GENERIC'\n}\n\nexport enum SwapType {\n  UNKNOWN = 'UNKNOWN',\n  BUY = 'BUY',\n  SELL = 'SELL'\n}\n\nexport enum TaskStatus {\n  PENDING = 'PENDING',\n  PAUSED = 'PAUSED',\n  FAILED = 'FAILED',\n  COMPLETED = 'COMPLETED',\n  DISABLED = 'DISABLED'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  checks: RuntimeChecks\n}\n\nexport interface RuntimeChecks {}\n\nexport interface ContractIndex {\n  chainId: number\n  address: string\n  type: ContractType\n  metadata: { [key: string]: any }\n  contentHash: number\n  deployed: boolean\n  bytecodeHash: string\n  notFound: boolean\n  updatedAt: string\n}\n\nexport interface TokenIndex {\n  key: string\n  chainId: number\n  contractAddress: string\n  tokenId: string\n  metadata: { [key: string]: any }\n  notFound?: boolean\n  lastFetched?: string\n  fetchCount?: number\n  updatedAt: string\n}\n\nexport interface ContractInfo {\n  chainId: number\n  address: string\n  name: string\n  type: string\n  symbol: string\n  decimals?: number\n  logoURI: string\n  deployed: boolean\n  bytecodeHash: string\n  extensions: ContractInfoExtensions\n  updatedAt: string\n}\n\nexport interface ContractInfoExtensions {\n  link: string\n  description: string\n  ogImage: string\n  ogName: string\n  originChainId: number\n  originAddress: string\n  blacklist: boolean\n  verified: boolean\n  verifiedBy: string\n  featured: boolean\n  private: boolean\n}\n\nexport interface TokenMetadata {\n  tokenId: string\n  name: string\n  description?: string\n  image?: string\n  video?: string\n  audio?: string\n  properties?: { [key: string]: any }\n  attributes: Array<{ [key: string]: any }>\n  image_data?: string\n  external_url?: string\n  background_color?: string\n  animation_url?: string\n  decimals?: number\n  updatedAt?: string\n  assets?: Array<Asset>\n}\n\nexport interface PropertyFilter {\n  name: string\n  type: PropertyType\n  min?: number\n  max?: number\n  values?: Array<any>\n}\n\nexport interface Filter {\n  text?: string\n  properties?: Array<PropertyFilter>\n}\n\nexport interface Collection {\n  id: number\n  projectId: number\n  metadata: CollectionMetadata\n  private: boolean\n  revealKey?: string\n  tokenCount?: number\n  createdAt?: string\n  updatedAt?: string\n  deletedAt?: string\n  baseURIs?: CollectionBaseURIs\n  assets?: Array<Asset>\n}\n\nexport interface CollectionMetadata {\n  name: string\n  description?: string\n  image?: string\n  external_link?: string\n  properties?: { [key: string]: any }\n  attributes?: Array<{ [key: string]: any }>\n}\n\nexport interface CollectionBaseURIs {\n  contractMetadataURI: string\n  tokenMetadataURI: string\n}\n\nexport interface ContractCollection {\n  id: number\n  chainId: number\n  contractAddress: string\n  collectionId: number\n}\n\nexport interface Asset {\n  id: number\n  collectionId: number\n  tokenId?: string\n  url?: string\n  metadataField: string\n  name?: string\n  filesize?: number\n  mimeType?: string\n  width?: number\n  height?: number\n  updatedAt?: string\n}\n\nexport interface Token {\n  collectionId: number\n  tokenId: string\n  metadata: TokenMetadata\n  private: boolean\n  updatedAt?: string\n}\n\nexport interface GetNiftyswapUnitPricesRequest {\n  swapType: SwapType\n  ids: Array<string>\n  amounts: Array<string>\n}\n\nexport interface GetNiftyswapUnitPricesResponse {\n  unitPrice: string\n  unitAmount: string\n  availableAmount: string\n}\n\nexport interface Page {\n  page?: number\n  column?: string\n  before?: any\n  after?: any\n  pageSize?: number\n  more?: boolean\n}\n\nexport interface TaskRunner {\n  id: number\n  workGroup: string\n  runAt: string\n}\n\nexport interface Task {\n  id: number\n  queue: string\n  status?: TaskStatus\n  try: number\n  runAt?: string\n  lastRanAt?: string\n  createdAt?: string\n  payload: Array<string>\n  hash?: string\n}\n\nexport interface Metadata {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>\n  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>\n  getTokenMetadata(args: GetTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataReturn>\n  refreshTokenMetadata(\n    args: RefreshTokenMetadataArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RefreshTokenMetadataReturn>\n  enqueueTokensForRefresh(\n    args: EnqueueTokensForRefreshArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<EnqueueTokensForRefreshReturn>\n  getTokenRefreshStatus(\n    args: GetTokenRefreshStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenRefreshStatusReturn>\n  getTokenRefreshResult(\n    args: GetTokenRefreshResultArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenRefreshResultReturn>\n  cancelRefreshJob(args: CancelRefreshJobArgs, headers?: object, signal?: AbortSignal): Promise<CancelRefreshJobReturn>\n  getTokenMetadataBatch(\n    args: GetTokenMetadataBatchArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenMetadataBatchReturn>\n  searchTokenMetadata(args: SearchTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenMetadataReturn>\n  searchTokenIDs(args: SearchTokenIDsArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenIDsReturn>\n  tokenCollectionFilters(\n    args: TokenCollectionFiltersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<TokenCollectionFiltersReturn>\n  getContractInfo(args: GetContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoReturn>\n  getContractInfoBatch(\n    args: GetContractInfoBatchArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetContractInfoBatchReturn>\n  searchContractInfo(args: SearchContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractInfoReturn>\n  searchContractInfoBatch(\n    args: SearchContractInfoBatchArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SearchContractInfoBatchReturn>\n  searchMetadata(args: SearchMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchMetadataReturn>\n  searchTokens(args: SearchTokensArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokensReturn>\n  searchContracts(args: SearchContractsArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractsReturn>\n  getNiftyswapTokenQuantity(\n    args: GetNiftyswapTokenQuantityArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNiftyswapTokenQuantityReturn>\n  getNiftyswapUnitPrices(\n    args: GetNiftyswapUnitPricesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNiftyswapUnitPricesReturn>\n  getNiftyswapUnitPricesWithQuantities(\n    args: GetNiftyswapUnitPricesWithQuantitiesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>\n  addContractToMintMonitor(\n    args: AddContractToMintMonitorArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddContractToMintMonitorReturn>\n  removeContractFromMintMonitor(\n    args: RemoveContractFromMintMonitorArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveContractFromMintMonitorReturn>\n  mintMonitorJobStatus(\n    args: MintMonitorJobStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<MintMonitorJobStatusReturn>\n  mintMonitorTriggerJob(\n    args: MintMonitorTriggerJobArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<MintMonitorTriggerJobReturn>\n  syncContractTokens(args: SyncContractTokensArgs, headers?: object, signal?: AbortSignal): Promise<SyncContractTokensReturn>\n  abortContractSync(args: AbortContractSyncArgs, headers?: object, signal?: AbortSignal): Promise<AbortContractSyncReturn>\n  contractSyncJobStatus(\n    args: ContractSyncJobStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ContractSyncJobStatusReturn>\n  directoryGetNetworks(\n    args: DirectoryGetNetworksArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DirectoryGetNetworksReturn>\n  directoryGetCollections(\n    args: DirectoryGetCollectionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DirectoryGetCollectionsReturn>\n  directorySearchCollections(\n    args: DirectorySearchCollectionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DirectorySearchCollectionsReturn>\n}\n\nexport interface PingArgs {}\n\nexport interface PingReturn {\n  status: boolean\n}\nexport interface VersionArgs {}\n\nexport interface VersionReturn {\n  version: Version\n}\nexport interface RuntimeStatusArgs {}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus\n}\nexport interface GetTokenMetadataArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs: Array<string>\n}\n\nexport interface GetTokenMetadataReturn {\n  tokenMetadata: Array<TokenMetadata>\n}\nexport interface RefreshTokenMetadataArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs?: Array<string>\n  refreshAll?: boolean\n}\n\nexport interface RefreshTokenMetadataReturn {\n  taskId: number\n}\nexport interface EnqueueTokensForRefreshArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs?: Array<string>\n  refreshAll?: boolean\n}\n\nexport interface EnqueueTokensForRefreshReturn {\n  taskId: number\n}\nexport interface GetTokenRefreshStatusArgs {\n  taskId: number\n}\n\nexport interface GetTokenRefreshStatusReturn {\n  status?: TaskStatus\n}\nexport interface GetTokenRefreshResultArgs {\n  taskId: number\n}\n\nexport interface GetTokenRefreshResultReturn {\n  status?: TaskStatus\n  tokens: { [key: string]: boolean }\n  failureReasons: { [key: string]: string }\n}\nexport interface CancelRefreshJobArgs {\n  taskId: number\n}\n\nexport interface CancelRefreshJobReturn {\n  ok: boolean\n}\nexport interface GetTokenMetadataBatchArgs {\n  chainID: string\n  contractTokenMap: { [key: string]: Array<string> }\n}\n\nexport interface GetTokenMetadataBatchReturn {\n  contractTokenMetadata: { [key: string]: Array<TokenMetadata> }\n}\nexport interface SearchTokenMetadataArgs {\n  chainID: string\n  contractAddress: string\n  filter: Filter\n  page?: Page\n}\n\nexport interface SearchTokenMetadataReturn {\n  page: Page\n  tokenMetadata: Array<TokenMetadata>\n}\nexport interface SearchTokenIDsArgs {\n  chainID: string\n  contractAddress: string\n  filter: Filter\n  page?: Page\n}\n\nexport interface SearchTokenIDsReturn {\n  page: Page\n  tokenIds: Array<string>\n}\nexport interface TokenCollectionFiltersArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface TokenCollectionFiltersReturn {\n  filters: Array<PropertyFilter>\n}\nexport interface GetContractInfoArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface GetContractInfoReturn {\n  contractInfo: ContractInfo\n}\nexport interface GetContractInfoBatchArgs {\n  chainID: string\n  contractAddresses: Array<string>\n}\n\nexport interface GetContractInfoBatchReturn {\n  contractInfoMap: { [key: string]: ContractInfo }\n}\nexport interface SearchContractInfoArgs {\n  contractAddress: string\n}\n\nexport interface SearchContractInfoReturn {\n  contractInfoList: Array<ContractInfo>\n}\nexport interface SearchContractInfoBatchArgs {\n  contractAddresses: Array<string>\n}\n\nexport interface SearchContractInfoBatchReturn {\n  contractInfoByChain: { [key: string]: Array<ContractInfo> }\n}\nexport interface SearchMetadataArgs {\n  filter: string\n  chainID?: string\n  types?: Array<ContractType>\n  excludeTokenMetadata?: boolean\n}\n\nexport interface SearchMetadataReturn {\n  tokenMetadata: Array<TokenMetadata>\n  contractInfo: Array<ContractInfo>\n}\nexport interface SearchTokensArgs {\n  q: string\n  chainID?: string\n  page?: Page\n}\n\nexport interface SearchTokensReturn {\n  tokenMetadata: Array<TokenMetadata>\n  nextPage: Page\n}\nexport interface SearchContractsArgs {\n  q: string\n  chainID?: string\n  chainIDs?: Array<string>\n  types?: Array<ContractType>\n  page?: Page\n}\n\nexport interface SearchContractsReturn {\n  contractInfo: Array<ContractInfo>\n  nextPage: Page\n}\nexport interface GetNiftyswapTokenQuantityArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs: Array<string>\n}\n\nexport interface GetNiftyswapTokenQuantityReturn {\n  quantity: { [key: string]: string }\n}\nexport interface GetNiftyswapUnitPricesArgs {\n  chainID: string\n  contractAddress: string\n  req: GetNiftyswapUnitPricesRequest\n  fresh: boolean\n}\n\nexport interface GetNiftyswapUnitPricesReturn {\n  prices: { [key: string]: string }\n}\nexport interface GetNiftyswapUnitPricesWithQuantitiesArgs {\n  chainID: string\n  contractAddress: string\n  req: GetNiftyswapUnitPricesRequest\n  fresh: boolean\n}\n\nexport interface GetNiftyswapUnitPricesWithQuantitiesReturn {\n  prices: { [key: string]: GetNiftyswapUnitPricesResponse }\n}\nexport interface AddContractToMintMonitorArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface AddContractToMintMonitorReturn {\n  ok: boolean\n}\nexport interface RemoveContractFromMintMonitorArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface RemoveContractFromMintMonitorReturn {\n  ok: boolean\n}\nexport interface MintMonitorJobStatusArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface MintMonitorJobStatusReturn {\n  task: Task\n}\nexport interface MintMonitorTriggerJobArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface MintMonitorTriggerJobReturn {\n  ok: boolean\n}\nexport interface SyncContractTokensArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface SyncContractTokensReturn {\n  taskID: number\n}\nexport interface AbortContractSyncArgs {\n  taskID: number\n}\n\nexport interface AbortContractSyncReturn {\n  ok: boolean\n}\nexport interface ContractSyncJobStatusArgs {\n  taskID: number\n}\n\nexport interface ContractSyncJobStatusReturn {\n  refreshTask: Task\n  syncTask: Task\n}\nexport interface DirectoryGetNetworksArgs {\n  includeTestnets?: boolean\n  onlyFeatured?: boolean\n}\n\nexport interface DirectoryGetNetworksReturn {\n  networks: Array<number>\n}\nexport interface DirectoryGetCollectionsArgs {\n  chainId?: number\n  includeTestnets?: boolean\n  onlyFeatured?: boolean\n  page?: Page\n}\n\nexport interface DirectoryGetCollectionsReturn {\n  collections: Array<ContractInfo>\n  page: Page\n}\nexport interface DirectorySearchCollectionsArgs {\n  query: string\n  chainId?: number\n  includeTestnets?: boolean\n  onlyFeatured?: boolean\n  page?: Page\n}\n\nexport interface DirectorySearchCollectionsReturn {\n  collections: Array<ContractInfo>\n  page: Page\n}\n\nexport interface Collections {\n  createCollection(args: CreateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateCollectionReturn>\n  getCollection(args: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn>\n  listCollections(args: ListCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectionsReturn>\n  updateCollection(args: UpdateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionReturn>\n  deleteCollection(args: DeleteCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionReturn>\n  publishCollection(args: PublishCollectionArgs, headers?: object, signal?: AbortSignal): Promise<PublishCollectionReturn>\n  unpublishCollection(args: UnpublishCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UnpublishCollectionReturn>\n  createContractCollection(\n    args: CreateContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<CreateContractCollectionReturn>\n  getContractCollection(\n    args: GetContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetContractCollectionReturn>\n  listContractCollections(\n    args: ListContractCollectionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListContractCollectionsReturn>\n  updateContractCollection(\n    args: UpdateContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateContractCollectionReturn>\n  deleteContractCollection(\n    args: DeleteContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DeleteContractCollectionReturn>\n  createToken(args: CreateTokenArgs, headers?: object, signal?: AbortSignal): Promise<CreateTokenReturn>\n  getToken(args: GetTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenReturn>\n  listTokens(args: ListTokensArgs, headers?: object, signal?: AbortSignal): Promise<ListTokensReturn>\n  updateToken(args: UpdateTokenArgs, headers?: object, signal?: AbortSignal): Promise<UpdateTokenReturn>\n  deleteToken(args: DeleteTokenArgs, headers?: object, signal?: AbortSignal): Promise<DeleteTokenReturn>\n  createAsset(args: CreateAssetArgs, headers?: object, signal?: AbortSignal): Promise<CreateAssetReturn>\n  getAsset(args: GetAssetArgs, headers?: object, signal?: AbortSignal): Promise<GetAssetReturn>\n  updateAsset(args: UpdateAssetArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAssetReturn>\n  deleteAsset(args: DeleteAssetArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAssetReturn>\n}\n\nexport interface CreateCollectionArgs {\n  projectId?: number\n  collection: Collection\n}\n\nexport interface CreateCollectionReturn {\n  collection: Collection\n}\nexport interface GetCollectionArgs {\n  projectId?: number\n  collectionId: number\n}\n\nexport interface GetCollectionReturn {\n  collection: Collection\n}\nexport interface ListCollectionsArgs {\n  projectId?: number\n  page?: Page\n}\n\nexport interface ListCollectionsReturn {\n  page: Page\n  collections: Array<Collection>\n}\nexport interface UpdateCollectionArgs {\n  projectId?: number\n  collection: Collection\n}\n\nexport interface UpdateCollectionReturn {\n  collection: Collection\n}\nexport interface DeleteCollectionArgs {\n  projectId?: number\n  collectionId: number\n}\n\nexport interface DeleteCollectionReturn {\n  status: boolean\n}\nexport interface PublishCollectionArgs {\n  projectId?: number\n  collectionId: number\n  recursive?: boolean\n}\n\nexport interface PublishCollectionReturn {\n  collection: Collection\n}\nexport interface UnpublishCollectionArgs {\n  projectId?: number\n  collectionId: number\n}\n\nexport interface UnpublishCollectionReturn {\n  collection: Collection\n}\nexport interface CreateContractCollectionArgs {\n  projectId: number\n  contractCollection: ContractCollection\n}\n\nexport interface CreateContractCollectionReturn {\n  contractCollection: ContractCollection\n}\nexport interface GetContractCollectionArgs {\n  projectId: number\n  chainId: number\n  contractAddress: string\n}\n\nexport interface GetContractCollectionReturn {\n  contractCollection: ContractCollection\n}\nexport interface ListContractCollectionsArgs {\n  projectId: number\n  collectionId?: number\n  page?: Page\n}\n\nexport interface ListContractCollectionsReturn {\n  contractCollections: Array<ContractCollection>\n  collections: Array<Collection>\n  page: Page\n}\nexport interface UpdateContractCollectionArgs {\n  projectId: number\n  contractCollection: ContractCollection\n}\n\nexport interface UpdateContractCollectionReturn {\n  ok: boolean\n}\nexport interface DeleteContractCollectionArgs {\n  projectId: number\n  chainId: number\n  contractAddress: string\n}\n\nexport interface DeleteContractCollectionReturn {\n  ok: boolean\n}\nexport interface CreateTokenArgs {\n  projectId?: number\n  collectionId: number\n  token: TokenMetadata\n  private?: boolean\n}\n\nexport interface CreateTokenReturn {\n  token: TokenMetadata\n  assets: Array<Asset>\n}\nexport interface GetTokenArgs {\n  projectId?: number\n  collectionId: number\n  tokenId: string\n}\n\nexport interface GetTokenReturn {\n  token: TokenMetadata\n  assets: Array<Asset>\n}\nexport interface ListTokensArgs {\n  projectId?: number\n  collectionId: number\n  page?: Page\n}\n\nexport interface ListTokensReturn {\n  page: Page\n  tokens: Array<TokenMetadata>\n}\nexport interface UpdateTokenArgs {\n  projectId?: number\n  collectionId: number\n  tokenId: string\n  token: TokenMetadata\n  private?: boolean\n}\n\nexport interface UpdateTokenReturn {\n  token: TokenMetadata\n}\nexport interface DeleteTokenArgs {\n  projectId?: number\n  collectionId: number\n  tokenId: string\n}\n\nexport interface DeleteTokenReturn {\n  status: boolean\n}\nexport interface CreateAssetArgs {\n  projectId?: number\n  asset: Asset\n}\n\nexport interface CreateAssetReturn {\n  asset: Asset\n}\nexport interface GetAssetArgs {\n  projectId?: number\n  assetId: number\n}\n\nexport interface GetAssetReturn {\n  asset: Asset\n}\nexport interface UpdateAssetArgs {\n  projectId?: number\n  asset: Asset\n}\n\nexport interface UpdateAssetReturn {\n  asset: Asset\n}\nexport interface DeleteAssetArgs {\n  projectId?: number\n  assetId: number\n}\n\nexport interface DeleteAssetReturn {\n  status: boolean\n}\n\nexport interface Admin {\n  addContractsToTokenDirectory(\n    args: AddContractsToTokenDirectoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddContractsToTokenDirectoryReturn>\n  removeContractsFromTokenDirectory(\n    args: RemoveContractsFromTokenDirectoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveContractsFromTokenDirectoryReturn>\n  modifyFeatureIndex(args: ModifyFeatureIndexArgs, headers?: object, signal?: AbortSignal): Promise<ModifyFeatureIndexReturn>\n  getFeatureIndex(args: GetFeatureIndexArgs, headers?: object, signal?: AbortSignal): Promise<GetFeatureIndexReturn>\n  listTokenDirectory(args: ListTokenDirectoryArgs, headers?: object, signal?: AbortSignal): Promise<ListTokenDirectoryReturn>\n}\n\nexport interface AddContractsToTokenDirectoryArgs {\n  contracts: Array<ContractInfo>\n  featureIndexes: Array<number>\n}\n\nexport interface AddContractsToTokenDirectoryReturn {\n  ok: boolean\n}\nexport interface RemoveContractsFromTokenDirectoryArgs {\n  chainHandle: string\n  contracts: Array<string>\n}\n\nexport interface RemoveContractsFromTokenDirectoryReturn {\n  ok: boolean\n}\nexport interface ModifyFeatureIndexArgs {\n  chainHandle: string\n  contractAddress: string\n  featured: number\n}\n\nexport interface ModifyFeatureIndexReturn {\n  ok: boolean\n}\nexport interface GetFeatureIndexArgs {\n  chainHandle: string\n  contractAddress: string\n}\n\nexport interface GetFeatureIndexReturn {\n  featured: number\n}\nexport interface ListTokenDirectoryArgs {\n  chainID?: number\n  includeTestnets?: boolean\n  onlyFeatured?: boolean\n  page?: Page\n}\n\nexport interface ListTokenDirectoryReturn {\n  page: Page\n  collections: Array<ContractInfo>\n}\n\n//\n// Client\n//\nexport class Metadata implements Metadata {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Metadata/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {\n    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: <Version>_data.version\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {\n    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <RuntimeStatus>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenMetadata = (args: GetTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataReturn> => {\n    return this.fetch(this.url('GetTokenMetadata'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  refreshTokenMetadata = (\n    args: RefreshTokenMetadataArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RefreshTokenMetadataReturn> => {\n    return this.fetch(this.url('RefreshTokenMetadata'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            taskId: <number>_data.taskId\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  enqueueTokensForRefresh = (\n    args: EnqueueTokensForRefreshArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<EnqueueTokensForRefreshReturn> => {\n    return this.fetch(this.url('EnqueueTokensForRefresh'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            taskId: <number>_data.taskId\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenRefreshStatus = (\n    args: GetTokenRefreshStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenRefreshStatusReturn> => {\n    return this.fetch(this.url('GetTokenRefreshStatus'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <TaskStatus>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenRefreshResult = (\n    args: GetTokenRefreshResultArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenRefreshResultReturn> => {\n    return this.fetch(this.url('GetTokenRefreshResult'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <TaskStatus>_data.status,\n            tokens: <{ [key: string]: boolean }>_data.tokens,\n            failureReasons: <{ [key: string]: string }>_data.failureReasons\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  cancelRefreshJob = (args: CancelRefreshJobArgs, headers?: object, signal?: AbortSignal): Promise<CancelRefreshJobReturn> => {\n    return this.fetch(this.url('CancelRefreshJob'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getTokenMetadataBatch = (\n    args: GetTokenMetadataBatchArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetTokenMetadataBatchReturn> => {\n    return this.fetch(this.url('GetTokenMetadataBatch'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractTokenMetadata: <{ [key: string]: Array<TokenMetadata> }>_data.contractTokenMetadata\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchTokenMetadata = (\n    args: SearchTokenMetadataArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SearchTokenMetadataReturn> => {\n    return this.fetch(this.url('SearchTokenMetadata'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchTokenIDs = (args: SearchTokenIDsArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenIDsReturn> => {\n    return this.fetch(this.url('SearchTokenIDs'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            tokenIds: <Array<string>>_data.tokenIds\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  tokenCollectionFilters = (\n    args: TokenCollectionFiltersArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<TokenCollectionFiltersReturn> => {\n    return this.fetch(this.url('TokenCollectionFilters'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            filters: <Array<PropertyFilter>>_data.filters\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getContractInfo = (args: GetContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoReturn> => {\n    return this.fetch(this.url('GetContractInfo'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfo: <ContractInfo>_data.contractInfo\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getContractInfoBatch = (\n    args: GetContractInfoBatchArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetContractInfoBatchReturn> => {\n    return this.fetch(this.url('GetContractInfoBatch'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfoMap: <{ [key: string]: ContractInfo }>_data.contractInfoMap\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchContractInfo = (\n    args: SearchContractInfoArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SearchContractInfoReturn> => {\n    return this.fetch(this.url('SearchContractInfo'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfoList: <Array<ContractInfo>>_data.contractInfoList\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchContractInfoBatch = (\n    args: SearchContractInfoBatchArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SearchContractInfoBatchReturn> => {\n    return this.fetch(this.url('SearchContractInfoBatch'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfoByChain: <{ [key: string]: Array<ContractInfo> }>_data.contractInfoByChain\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchMetadata = (args: SearchMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchMetadataReturn> => {\n    return this.fetch(this.url('SearchMetadata'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata,\n            contractInfo: <Array<ContractInfo>>_data.contractInfo\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchTokens = (args: SearchTokensArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokensReturn> => {\n    return this.fetch(this.url('SearchTokens'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenMetadata: <Array<TokenMetadata>>_data.tokenMetadata,\n            nextPage: <Page>_data.nextPage\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  searchContracts = (args: SearchContractsArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractsReturn> => {\n    return this.fetch(this.url('SearchContracts'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfo: <Array<ContractInfo>>_data.contractInfo,\n            nextPage: <Page>_data.nextPage\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getNiftyswapTokenQuantity = (\n    args: GetNiftyswapTokenQuantityArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNiftyswapTokenQuantityReturn> => {\n    return this.fetch(this.url('GetNiftyswapTokenQuantity'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            quantity: <{ [key: string]: string }>_data.quantity\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getNiftyswapUnitPrices = (\n    args: GetNiftyswapUnitPricesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNiftyswapUnitPricesReturn> => {\n    return this.fetch(this.url('GetNiftyswapUnitPrices'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            prices: <{ [key: string]: string }>_data.prices\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getNiftyswapUnitPricesWithQuantities = (\n    args: GetNiftyswapUnitPricesWithQuantitiesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn> => {\n    return this.fetch(this.url('GetNiftyswapUnitPricesWithQuantities'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            prices: <{ [key: string]: GetNiftyswapUnitPricesResponse }>_data.prices\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  addContractToMintMonitor = (\n    args: AddContractToMintMonitorArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddContractToMintMonitorReturn> => {\n    return this.fetch(this.url('AddContractToMintMonitor'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  removeContractFromMintMonitor = (\n    args: RemoveContractFromMintMonitorArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveContractFromMintMonitorReturn> => {\n    return this.fetch(this.url('RemoveContractFromMintMonitor'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  mintMonitorJobStatus = (\n    args: MintMonitorJobStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<MintMonitorJobStatusReturn> => {\n    return this.fetch(this.url('MintMonitorJobStatus'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            task: <Task>_data.task\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  mintMonitorTriggerJob = (\n    args: MintMonitorTriggerJobArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<MintMonitorTriggerJobReturn> => {\n    return this.fetch(this.url('MintMonitorTriggerJob'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  syncContractTokens = (\n    args: SyncContractTokensArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SyncContractTokensReturn> => {\n    return this.fetch(this.url('SyncContractTokens'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            taskID: <number>_data.taskID\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  abortContractSync = (args: AbortContractSyncArgs, headers?: object, signal?: AbortSignal): Promise<AbortContractSyncReturn> => {\n    return this.fetch(this.url('AbortContractSync'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  contractSyncJobStatus = (\n    args: ContractSyncJobStatusArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ContractSyncJobStatusReturn> => {\n    return this.fetch(this.url('ContractSyncJobStatus'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            refreshTask: <Task>_data.refreshTask,\n            syncTask: <Task>_data.syncTask\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  directoryGetNetworks = (\n    args: DirectoryGetNetworksArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DirectoryGetNetworksReturn> => {\n    return this.fetch(this.url('DirectoryGetNetworks'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            networks: <Array<number>>_data.networks\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  directoryGetCollections = (\n    args: DirectoryGetCollectionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DirectoryGetCollectionsReturn> => {\n    return this.fetch(this.url('DirectoryGetCollections'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collections: <Array<ContractInfo>>_data.collections,\n            page: <Page>_data.page\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  directorySearchCollections = (\n    args: DirectorySearchCollectionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DirectorySearchCollectionsReturn> => {\n    return this.fetch(this.url('DirectorySearchCollections'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collections: <Array<ContractInfo>>_data.collections,\n            page: <Page>_data.page\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\nexport class Collections implements Collections {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Collections/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  createCollection = (args: CreateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateCollectionReturn> => {\n    return this.fetch(this.url('CreateCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collection: <Collection>_data.collection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getCollection = (args: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn> => {\n    return this.fetch(this.url('GetCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collection: <Collection>_data.collection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listCollections = (args: ListCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectionsReturn> => {\n    return this.fetch(this.url('ListCollections'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            collections: <Array<Collection>>_data.collections\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateCollection = (args: UpdateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionReturn> => {\n    return this.fetch(this.url('UpdateCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collection: <Collection>_data.collection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  deleteCollection = (args: DeleteCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionReturn> => {\n    return this.fetch(this.url('DeleteCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  publishCollection = (args: PublishCollectionArgs, headers?: object, signal?: AbortSignal): Promise<PublishCollectionReturn> => {\n    return this.fetch(this.url('PublishCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collection: <Collection>_data.collection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  unpublishCollection = (\n    args: UnpublishCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UnpublishCollectionReturn> => {\n    return this.fetch(this.url('UnpublishCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            collection: <Collection>_data.collection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  createContractCollection = (\n    args: CreateContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<CreateContractCollectionReturn> => {\n    return this.fetch(this.url('CreateContractCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractCollection: <ContractCollection>_data.contractCollection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getContractCollection = (\n    args: GetContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<GetContractCollectionReturn> => {\n    return this.fetch(this.url('GetContractCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractCollection: <ContractCollection>_data.contractCollection\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listContractCollections = (\n    args: ListContractCollectionsArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListContractCollectionsReturn> => {\n    return this.fetch(this.url('ListContractCollections'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractCollections: <Array<ContractCollection>>_data.contractCollections,\n            collections: <Array<Collection>>_data.collections,\n            page: <Page>_data.page\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateContractCollection = (\n    args: UpdateContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<UpdateContractCollectionReturn> => {\n    return this.fetch(this.url('UpdateContractCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  deleteContractCollection = (\n    args: DeleteContractCollectionArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<DeleteContractCollectionReturn> => {\n    return this.fetch(this.url('DeleteContractCollection'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  createToken = (args: CreateTokenArgs, headers?: object, signal?: AbortSignal): Promise<CreateTokenReturn> => {\n    return this.fetch(this.url('CreateToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            token: <TokenMetadata>_data.token,\n            assets: <Array<Asset>>_data.assets\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getToken = (args: GetTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenReturn> => {\n    return this.fetch(this.url('GetToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            token: <TokenMetadata>_data.token,\n            assets: <Array<Asset>>_data.assets\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listTokens = (args: ListTokensArgs, headers?: object, signal?: AbortSignal): Promise<ListTokensReturn> => {\n    return this.fetch(this.url('ListTokens'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            tokens: <Array<TokenMetadata>>_data.tokens\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateToken = (args: UpdateTokenArgs, headers?: object, signal?: AbortSignal): Promise<UpdateTokenReturn> => {\n    return this.fetch(this.url('UpdateToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            token: <TokenMetadata>_data.token\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  deleteToken = (args: DeleteTokenArgs, headers?: object, signal?: AbortSignal): Promise<DeleteTokenReturn> => {\n    return this.fetch(this.url('DeleteToken'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  createAsset = (args: CreateAssetArgs, headers?: object, signal?: AbortSignal): Promise<CreateAssetReturn> => {\n    return this.fetch(this.url('CreateAsset'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            asset: <Asset>_data.asset\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getAsset = (args: GetAssetArgs, headers?: object, signal?: AbortSignal): Promise<GetAssetReturn> => {\n    return this.fetch(this.url('GetAsset'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            asset: <Asset>_data.asset\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  updateAsset = (args: UpdateAssetArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAssetReturn> => {\n    return this.fetch(this.url('UpdateAsset'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            asset: <Asset>_data.asset\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  deleteAsset = (args: DeleteAssetArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAssetReturn> => {\n    return this.fetch(this.url('DeleteAsset'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\nexport class Admin implements Admin {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Admin/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  addContractsToTokenDirectory = (\n    args: AddContractsToTokenDirectoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<AddContractsToTokenDirectoryReturn> => {\n    return this.fetch(this.url('AddContractsToTokenDirectory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  removeContractsFromTokenDirectory = (\n    args: RemoveContractsFromTokenDirectoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<RemoveContractsFromTokenDirectoryReturn> => {\n    return this.fetch(this.url('RemoveContractsFromTokenDirectory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  modifyFeatureIndex = (\n    args: ModifyFeatureIndexArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ModifyFeatureIndexReturn> => {\n    return this.fetch(this.url('ModifyFeatureIndex'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: <boolean>_data.ok\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getFeatureIndex = (args: GetFeatureIndexArgs, headers?: object, signal?: AbortSignal): Promise<GetFeatureIndexReturn> => {\n    return this.fetch(this.url('GetFeatureIndex'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            featured: <number>_data.featured\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  listTokenDirectory = (\n    args: ListTokenDirectoryArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ListTokenDirectoryReturn> => {\n    return this.fetch(this.url('ListTokenDirectory'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: <Page>_data.page,\n            collections: <Array<ContractInfo>>_data.collections\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`\n      })\n    }\n    if (!res.ok) {\n      const code: number = typeof data.code === 'number' ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n// Schema errors\n\nexport class UnauthorizedError extends WebrpcError {\n  constructor(\n    name: string = 'Unauthorized',\n    code: number = 1000,\n    message: string = 'Unauthorized access',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnauthorizedError.prototype)\n  }\n}\n\nexport class PermissionDeniedError extends WebrpcError {\n  constructor(\n    name: string = 'PermissionDenied',\n    code: number = 1001,\n    message: string = 'Permission denied',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, PermissionDeniedError.prototype)\n  }\n}\n\nexport class SessionExpiredError extends WebrpcError {\n  constructor(\n    name: string = 'SessionExpired',\n    code: number = 1002,\n    message: string = 'Session expired',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, SessionExpiredError.prototype)\n  }\n}\n\nexport class MethodNotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'MethodNotFound',\n    code: number = 1003,\n    message: string = 'Method not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, MethodNotFoundError.prototype)\n  }\n}\n\nexport class RequestConflictError extends WebrpcError {\n  constructor(\n    name: string = 'RequestConflict',\n    code: number = 1004,\n    message: string = 'Conflict with target resource',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, RequestConflictError.prototype)\n  }\n}\n\nexport class FailError extends WebrpcError {\n  constructor(\n    name: string = 'Fail',\n    code: number = 1005,\n    message: string = 'Request Failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, FailError.prototype)\n  }\n}\n\nexport class GeoblockedError extends WebrpcError {\n  constructor(\n    name: string = 'Geoblocked',\n    code: number = 1006,\n    message: string = 'Geoblocked region',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, GeoblockedError.prototype)\n  }\n}\n\nexport class TimeoutError extends WebrpcError {\n  constructor(\n    name: string = 'Timeout',\n    code: number = 2000,\n    message: string = 'Request timed out',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, TimeoutError.prototype)\n  }\n}\n\nexport class InvalidArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidArgument',\n    code: number = 2001,\n    message: string = 'Invalid argument',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidArgumentError.prototype)\n  }\n}\n\nexport class RequiredArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'RequiredArgument',\n    code: number = 2002,\n    message: string = 'Required argument missing',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, RequiredArgumentError.prototype)\n  }\n}\n\nexport class QueryFailedError extends WebrpcError {\n  constructor(\n    name: string = 'QueryFailed',\n    code: number = 2003,\n    message: string = 'Query failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, QueryFailedError.prototype)\n  }\n}\n\nexport class ValidationFailedError extends WebrpcError {\n  constructor(\n    name: string = 'ValidationFailed',\n    code: number = 2004,\n    message: string = 'Validation failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, ValidationFailedError.prototype)\n  }\n}\n\nexport class RateLimitedError extends WebrpcError {\n  constructor(\n    name: string = 'RateLimited',\n    code: number = 2005,\n    message: string = 'Rate limited',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, RateLimitedError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'NotFound',\n    code: number = 3000,\n    message: string = 'Resource not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport class ProjectNotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'ProjectNotFound',\n    code: number = 3002,\n    message: string = 'Project not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, ProjectNotFoundError.prototype)\n  }\n}\n\nexport class ChainNotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'ChainNotFound',\n    code: number = 3003,\n    message: string = 'Chain not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, ChainNotFoundError.prototype)\n  }\n}\n\nexport class TokenDirectoryDisabledError extends WebrpcError {\n  constructor(\n    name: string = 'TokenDirectoryDisabled',\n    code: number = 4001,\n    message: string = 'Token Directory is disabled',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, TokenDirectoryDisabledError.prototype)\n  }\n}\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  Unauthorized = 'Unauthorized',\n  PermissionDenied = 'PermissionDenied',\n  SessionExpired = 'SessionExpired',\n  MethodNotFound = 'MethodNotFound',\n  RequestConflict = 'RequestConflict',\n  Fail = 'Fail',\n  Geoblocked = 'Geoblocked',\n  Timeout = 'Timeout',\n  InvalidArgument = 'InvalidArgument',\n  RequiredArgument = 'RequiredArgument',\n  QueryFailed = 'QueryFailed',\n  ValidationFailed = 'ValidationFailed',\n  RateLimited = 'RateLimited',\n  NotFound = 'NotFound',\n  ProjectNotFound = 'ProjectNotFound',\n  ChainNotFound = 'ChainNotFound',\n  TokenDirectoryDisabled = 'TokenDirectoryDisabled'\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1000]: UnauthorizedError,\n  [1001]: PermissionDeniedError,\n  [1002]: SessionExpiredError,\n  [1003]: MethodNotFoundError,\n  [1004]: RequestConflictError,\n  [1005]: FailError,\n  [1006]: GeoblockedError,\n  [2000]: TimeoutError,\n  [2001]: InvalidArgumentError,\n  [2002]: RequiredArgumentError,\n  [2003]: QueryFailedError,\n  [2004]: ValidationFailedError,\n  [2005]: RateLimitedError,\n  [3000]: NotFoundError,\n  [3002]: ProjectNotFoundError,\n  [3003]: ChainNotFoundError,\n  [4001]: TokenDirectoryDisabledError\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","export * from './metadata.gen'\n\nimport { Metadata as MetadataRpc, Collections as CollectionsRpc } from './metadata.gen'\n\nconst fetch = globalThis.fetch\n\nexport class SequenceMetadata extends MetadataRpc {\n  constructor(\n    hostname: string = 'https://metadata.sequence.app',\n    public projectAccessKey?: string,\n    public jwtAuth?: string\n  ) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt and access key auth header to requests\n    // if its been set on the client\n    const headers: { [key: string]: any } = {}\n\n    const jwtAuth = this.jwtAuth\n    const projectAccessKey = this.projectAccessKey\n\n    if (jwtAuth && jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${jwtAuth}`\n    }\n\n    if (projectAccessKey && projectAccessKey.length > 0) {\n      headers['X-Access-Key'] = projectAccessKey\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n}\n\nexport class SequenceCollections extends CollectionsRpc {\n  constructor(\n    hostname: string = 'https://metadata.sequence.app',\n    public jwtAuth?: string\n  ) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt auth header to requests\n    // if its been set on the client\n    const headers: { [key: string]: any } = {}\n\n    const jwtAuth = this.jwtAuth\n\n    if (jwtAuth && jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${jwtAuth}`\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n\n  // TODO: add uploadAsset() method similar to,\n  // https://github.com/0xsequence/go-sequence/blob/master/metadata/collections.go#L52\n}\n","import { Account } from '@0xsequence/account'\nimport { SequenceAPIClient } from '@0xsequence/api'\nimport { ETHAuth, Proof } from '@0xsequence/ethauth'\nimport { Indexer, SequenceIndexer } from '@0xsequence/indexer'\nimport { SequenceMetadata } from '@0xsequence/metadata'\nimport { ChainIdLike, findNetworkConfig } from '@0xsequence/network'\nimport { getFetchRequest } from '@0xsequence/utils'\nimport { ethers } from 'ethers'\n\nexport type SessionMeta = {\n  // name of the app requesting the session, used with ETHAuth\n  name: string\n\n  // expiration in seconds for a session before it expires, used with ETHAuth\n  expiration?: number\n}\n\nexport type ServicesSettings = {\n  metadata: SessionMeta\n  sequenceApiUrl: string\n  sequenceApiChainId: ethers.BigNumberish\n  sequenceMetadataUrl: string\n}\n\nexport type SessionJWT = {\n  token: string\n  expiration: number\n}\n\nexport type SessionJWTPromise = {\n  token: Promise<string>\n  expiration: number\n}\n\nexport type ProofStringPromise = {\n  proofString: Promise<string>\n  expiration: number\n}\n\n// Default session expiration of ETHAuth token (1 week)\nexport const DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7\n\n// Long session expiration of ETHAuth token (~1 year)\nexport const LONG_SESSION_EXPIRATION = 3e7\n\nconst EXPIRATION_JWT_MARGIN = 60 // seconds\n\nexport class Services {\n  _initialAuthRequest: Promise<SequenceAPIClient>\n\n  // proof strings are indexed by account address and app name, see getProofStringKey()\n  private readonly proofStrings: Map<string, ProofStringPromise> = new Map()\n\n  private onAuthCallbacks: ((result: PromiseSettledResult<string>) => void)[] = []\n\n  private apiClient: SequenceAPIClient | undefined\n  private metadataClient: SequenceMetadata | undefined\n  private indexerClients: Map<number, Indexer> = new Map()\n\n  private projectAccessKey?: string\n\n  constructor(\n    public readonly account: Account,\n    public readonly settings: ServicesSettings,\n    public readonly status: {\n      jwt?: SessionJWTPromise\n      metadata?: SessionMeta\n    } = {},\n    projectAccessKey?: string\n  ) {\n    this.projectAccessKey = projectAccessKey\n  }\n\n  private now(): number {\n    return Math.floor(Date.now() / 1000)\n  }\n\n  get expiration(): number {\n    return Math.max(this.settings.metadata.expiration ?? DEFAULT_SESSION_EXPIRATION, 120)\n  }\n\n  onAuth(cb: (result: PromiseSettledResult<string>) => void) {\n    this.onAuthCallbacks.push(cb)\n    return () => (this.onAuthCallbacks = this.onAuthCallbacks.filter(c => c !== cb))\n  }\n\n  async dump(): Promise<{\n    jwt?: SessionJWT\n    metadata?: SessionMeta\n  }> {\n    if (!this.status.jwt) return { metadata: this.settings.metadata }\n\n    return {\n      jwt: {\n        token: await this.status.jwt.token,\n        expiration: this.status.jwt.expiration\n      },\n      metadata: this.status.metadata\n    }\n  }\n\n  auth(maxTries: number = 5): Promise<SequenceAPIClient> {\n    if (this._initialAuthRequest) return this._initialAuthRequest\n\n    this._initialAuthRequest = (async () => {\n      const url = this.settings.sequenceApiUrl\n      if (!url) throw Error('No sequence api url')\n\n      let jwtAuth: string | undefined\n      for (let i = 1; ; i++) {\n        try {\n          jwtAuth = (await this.getJWT(true)).token\n          break\n        } catch (error) {\n          if (i === maxTries) {\n            console.error(`couldn't authenticate after ${maxTries} attempts`, error)\n            throw error\n          }\n        }\n      }\n\n      return new SequenceAPIClient(url, undefined, jwtAuth)\n    })()\n\n    return this._initialAuthRequest\n  }\n\n  private async getJWT(tryAuth: boolean): Promise<SessionJWT> {\n    const url = this.settings.sequenceApiUrl\n    if (!url) throw Error('No sequence api url')\n\n    // check if we already have or are waiting for a token\n    if (this.status.jwt) {\n      const jwt = this.status.jwt\n      const token = await jwt.token\n\n      if (this.now() < jwt.expiration) {\n        return { token, expiration: jwt.expiration }\n      }\n\n      // token expired, delete it and get a new one\n      this.status.jwt = undefined\n    }\n\n    if (!tryAuth) {\n      throw new Error('no auth token in memory')\n    }\n\n    const proofStringKey = this.getProofStringKey()\n    const { proofString, expiration } = this.getProofString(proofStringKey)\n\n    const jwt = {\n      token: proofString\n        .then(async proofString => {\n          const api = new SequenceAPIClient(url)\n\n          const authResp = await api.getAuthToken({ ewtString: proofString })\n\n          if (authResp?.status === true && authResp.jwtToken.length !== 0) {\n            return authResp.jwtToken\n          } else {\n            if (!(await this.isProofStringValid(proofString))) {\n              this.proofStrings.delete(proofStringKey)\n            }\n            throw new Error('no auth token from server')\n          }\n        })\n        .catch(reason => {\n          this.status.jwt = undefined\n          throw reason\n        }),\n      expiration\n    }\n\n    this.status.jwt = jwt\n\n    jwt.token\n      .then(token => {\n        this.onAuthCallbacks.forEach(cb => {\n          try {\n            cb({ status: 'fulfilled', value: token })\n          } catch {}\n        })\n      })\n      .catch((reason: any) => {\n        this.onAuthCallbacks.forEach(cb => {\n          try {\n            cb({ status: 'rejected', reason })\n          } catch {}\n        })\n      })\n\n    const token = await jwt.token\n    return { token, expiration }\n  }\n\n  private getProofStringKey(): string {\n    return `${this.account.address} - ${this.settings.metadata.name}`\n  }\n\n  private async isProofStringValid(proofString: string): Promise<boolean> {\n    try {\n      const ethAuth = new ETHAuth()\n      const chainId = BigInt(this.settings.sequenceApiChainId)\n      const found = findNetworkConfig(this.account.networks, chainId)\n      if (!found) {\n        throw Error('No network found')\n      }\n      ethAuth.chainId = Number(chainId)\n\n      const network = new ethers.Network(found.name, chainId)\n\n      // TODO: Modify ETHAuth so it can take a provider instead of a url\n      // -----\n      // Can't pass jwt here since this is used for getting the jwt\n      ethAuth.provider = new ethers.JsonRpcProvider(getFetchRequest(found.rpcUrl, this.projectAccessKey), network, {\n        staticNetwork: network\n      })\n\n      await ethAuth.decodeProof(proofString)\n\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async getAPIClient(tryAuth: boolean = true): Promise<SequenceAPIClient> {\n    if (!this.apiClient) {\n      const url = this.settings.sequenceApiUrl\n      if (!url) throw Error('No sequence api url')\n\n      const jwtAuth = (await this.getJWT(tryAuth)).token\n      this.apiClient = new SequenceAPIClient(url, undefined, jwtAuth)\n    }\n\n    return this.apiClient\n  }\n\n  async getMetadataClient(tryAuth: boolean = true): Promise<SequenceMetadata> {\n    if (!this.metadataClient) {\n      const jwtAuth = (await this.getJWT(tryAuth)).token\n      this.metadataClient = new SequenceMetadata(this.settings.sequenceMetadataUrl, undefined, jwtAuth)\n    }\n\n    return this.metadataClient\n  }\n\n  async getIndexerClient(chainId: ChainIdLike, tryAuth: boolean = true): Promise<Indexer> {\n    const network = findNetworkConfig(this.account.networks, chainId)\n    if (!network) {\n      throw Error(`No network for chain ${chainId}`)\n    }\n\n    if (!this.indexerClients.has(network.chainId)) {\n      if (network.indexer) {\n        this.indexerClients.set(network.chainId, network.indexer)\n      } else if (network.indexerUrl) {\n        const jwtAuth = (await this.getJWT(tryAuth)).token\n        this.indexerClients.set(network.chainId, new SequenceIndexer(network.indexerUrl, undefined, jwtAuth))\n      } else {\n        throw Error(`No indexer url for chain ${chainId}`)\n      }\n    }\n\n    return this.indexerClients.get(network.chainId)!\n  }\n\n  private getProofString(key: string): ProofStringPromise {\n    // check if we already have or are waiting for a proof string\n    if (this.proofStrings.has(key)) {\n      const proofString = this.proofStrings.get(key)!\n\n      if (this.now() < proofString.expiration) {\n        return proofString\n      }\n\n      // proof string expired, delete it and make a new one\n      this.proofStrings.delete(key)\n    }\n\n    const proof = new Proof({\n      address: this.account.address\n    })\n\n    proof.claims.app = this.settings.metadata.name\n    if (typeof window === 'object') {\n      proof.claims.ogn = window.location.origin\n    }\n    proof.setExpiryIn(this.expiration)\n\n    const ethAuth = new ETHAuth()\n    const chainId = BigInt(this.settings.sequenceApiChainId)\n    const found = findNetworkConfig(this.account.networks, chainId)\n    if (!found) {\n      throw Error('No network found')\n    }\n    ethAuth.chainId = Number(chainId)\n\n    const network = new ethers.Network(found.name, chainId)\n\n    // TODO: Modify ETHAuth so it can take a provider instead of a url\n    // -----\n    // Can't pass jwt here since this is used for getting the jwt\n    ethAuth.provider = new ethers.JsonRpcProvider(getFetchRequest(found.rpcUrl, this.projectAccessKey), network, {\n      staticNetwork: network\n    })\n\n    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN\n\n    const proofString = {\n      proofString: Promise.resolve(\n        // NOTICE: TODO: Here we ask the account to sign the message\n        // using whatever configuration we have ON-CHAIN, this means\n        // that the account will still use the v1 wallet, even if the migration\n        // was signed.\n        //\n        // This works for Sequence webapp v1 -> v2 because all v1 configurations share the same formula\n        // (torus + guard), but if we ever decide to allow cross-device login, then it will not work, because\n        // those other signers may not be part of the configuration.\n        //\n        this.account.signDigest(proof.messageDigest(), this.settings.sequenceApiChainId, true, 'eip6492')\n      )\n        .then(s => {\n          proof.signature = s\n          return ethAuth.encodeProof(proof, true)\n        })\n        .catch(reason => {\n          this.proofStrings.delete(key)\n          throw reason\n        }),\n      expiration\n    }\n\n    this.proofStrings.set(key, proofString)\n    return proofString\n  }\n}\n","import { ethers } from 'ethers'\nimport { ETHAuth, Proof } from '@0xsequence/ethauth'\nimport { ChainIdLike, toChainIdNumber } from '@0xsequence/network'\nimport { TypedData } from '@0xsequence/utils'\nimport { Signer } from '@0xsequence/wallet'\nimport { Account } from '@0xsequence/account'\nimport { DEFAULT_SESSION_EXPIRATION } from './services'\n\nexport interface AuthorizationOptions {\n  // app name string, ie 'Skyweaver'\n  app?: string\n\n  // origin hostname of encoded in the message, ie. 'play.skyweaver.net'\n  origin?: string\n\n  // expiry in seconds encoded in the message\n  expiry?: number\n\n  // nonce for the authorization request\n  nonce?: number\n}\n\nexport interface ETHAuthProof {\n  // eip712 typed-data payload for ETHAuth domain as input\n  typedData: TypedData\n\n  // signature encoded in an ETHAuth proof string\n  proofString: string\n}\n\n// signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided\n// Signer and authorization options.\nexport const signAuthorization = async (\n  signer: Signer | Account,\n  chainId: ChainIdLike,\n  options: AuthorizationOptions\n): Promise<ETHAuthProof> => {\n  const address = ethers.getAddress(await signer.getAddress())\n  if (!address || address === '' || address === '0x') {\n    throw ErrAccountIsRequired\n  }\n\n  const proof = new Proof()\n  proof.address = address\n\n  if (!options || !options.app || options.app === '') {\n    throw new AuthError('authorization options requires app to be set')\n  }\n  proof.claims.app = options.app\n  proof.claims.ogn = options.origin\n  proof.claims.n = options.nonce\n\n  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION)\n\n  const typedData = proof.messageTypedData()\n\n  const chainIdNumber = toChainIdNumber(chainId)\n\n  proof.signature = await (signer instanceof Account\n    ? // Account can sign EIP-6492 signatures, so it doesn't require deploying the wallet\n      signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber, 'eip6492')\n    : signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainIdNumber))\n\n  const ethAuth = new ETHAuth()\n  const proofString = await ethAuth.encodeProof(proof, true)\n\n  return {\n    typedData,\n    proofString\n  }\n}\n\n// TODO: review......\nexport class AuthError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'AuthError'\n  }\n}\n\nexport const ErrAccountIsRequired = new AuthError('auth error: account address is empty')\n","import { ethers } from 'ethers'\nimport { runByEIP5719, URISolver } from '.'\n\nexport class CachedEIP5719 {\n  constructor(\n    public provider: ethers.Provider,\n    public solver?: URISolver,\n    public window: number = 1000\n  ) {}\n\n  private pending: Map<\n    string,\n    {\n      timestamp: number\n      promise: Promise<ethers.BytesLike>\n    }\n  > = new Map()\n\n  async runByEIP5719(address: string, digest: ethers.BytesLike, signature: ethers.BytesLike): Promise<ethers.BytesLike> {\n    const key = `${address}-${digest}-${signature}`\n    const now = Date.now()\n\n    if (this.pending.has(key) && now - this.pending.get(key)!.timestamp < this.window) {\n      return this.pending.get(key)!.promise\n    }\n\n    const promise = runByEIP5719(address, this.provider, digest, signature, this.solver)\n    this.pending.set(key, { timestamp: now, promise })\n    return promise\n  }\n}\n","import { ethers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { isIPFS, useGateway } from './ipfs'\nimport { commons } from '@0xsequence/core'\n\nexport * from './cached'\n\nexport function eip5719Contract(address: string, provider: ethers.Provider): ethers.Contract {\n  // TODO: for some reason walletContracts is not being loaded from local\n  // remove this code once fixed\n  const abi = [\n    {\n      inputs: [\n        {\n          internalType: 'bytes32',\n          type: 'bytes32'\n        }\n      ],\n      name: 'getAlternativeSignature',\n      outputs: [\n        {\n          internalType: 'string',\n          type: 'string'\n        }\n      ],\n      stateMutability: 'view',\n      type: 'function'\n    }\n  ]\n\n  return new ethers.Contract(address, abi, provider)\n}\n\nexport function eip1271Contract(address: string, provider: ethers.Provider): ethers.Contract {\n  return new ethers.Contract(address, walletContracts.erc1271.abi, provider)\n}\n\nexport async function isValidSignature(\n  address: string,\n  provider: ethers.Provider,\n  digest: ethers.BytesLike,\n  signature: ethers.BytesLike\n): Promise<boolean> {\n  // First we try to validate the signature using Ethers\n  try {\n    const addr = ethers.recoverAddress(digest, ethers.hexlify(signature))\n    if (addr.toLowerCase() === address.toLowerCase()) return true\n  } catch {}\n\n  // Then we try to validate the signature using EIP1271\n  try {\n    const contract = eip1271Contract(address, provider)\n    const value = await contract.isValidSignature(digest, signature)\n    if (value === walletContracts.erc1271.returns) return true\n  } catch {}\n\n  // If all else fails, we return false\n  return false\n}\n\nexport interface URISolver {\n  resolve: (uri: string) => Promise<string>\n}\n\nasync function tryAwait<T>(promise: Promise<T>): Promise<T | undefined> {\n  try {\n    return await promise\n  } catch {\n    return undefined\n  }\n}\n\nexport async function runByEIP5719(\n  address: string,\n  provider: ethers.Provider,\n  digest: ethers.BytesLike,\n  signature: ethers.BytesLike,\n  solver?: URISolver,\n  tries: number = 0\n): Promise<ethers.BytesLike> {\n  if (tries > 10) throw new Error('EIP5719 - Too many tries')\n\n  if (commons.signer.canRecover(signature)) {\n    const recoveredAddr = commons.signer.recoverSigner(digest, signature)\n    if (recoveredAddr && recoveredAddr.toLowerCase() === address.toLowerCase()) return signature\n  }\n\n  try {\n    if (await commons.signer.isValidSignature(address, digest, signature, provider)) {\n      return signature\n    }\n  } catch {}\n\n  const altUri = await tryAwait(eip5719Contract(address, provider).getAlternativeSignature(digest) as Promise<string>)\n  if (!altUri || altUri === '') throw new Error('EIP5719 - Invalid signature and no alternative signature')\n\n  const altSignature = ethers.hexlify(await (solver || new URISolverIPFS()).resolve(altUri))\n  if (!altSignature || altSignature === '') throw new Error('EIP5719 - Empty alternative signature')\n  if (altSignature === ethers.hexlify(signature)) {\n    throw new Error('EIP5719 - Alternative signature is invalid or the same')\n  }\n  return runByEIP5719(address, provider, digest, altSignature, solver, tries + 1)\n}\n\nexport class URISolverIPFS implements URISolver {\n  constructor(public gateway: string = 'https://cloudflare-ipfs.com/ipfs/') {}\n\n  uri = (uri: string): string => {\n    if (isIPFS(uri)) return useGateway(uri, this.gateway)\n    return uri\n  }\n\n  resolve = async (uri: string): Promise<string> => {\n    const url = this.uri(uri)\n    const res = await fetch(url)\n    if (!res.ok) throw new Error(`URISolverIPFS - Failed to fetch ${url}`)\n    return await res.text()\n  }\n}\n","export function useGateway(uri: string, gateway: string) {\n  const clean = uri.replace('ipfs://ipfs/', '').replace('ipfs://', '')\n  if (uri.startsWith('ipfs://')) return `${gateway}${clean}`\n  return uri\n}\n\nexport function isIPFS(uri: string): boolean {\n  return uri.startsWith('ipfs://')\n}\n","import { commons, universal, v2 } from '@0xsequence/core'\nimport { migrator } from '@0xsequence/migration'\nimport { CachedEIP5719 } from '@0xsequence/replacer'\nimport { ethers } from 'ethers'\nimport { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../tracker'\n\n// depending on @0xsequence/abi breaks 0xsequence's proxy-transport-channel integration test\nconst MAIN_MODULE_ABI = [\n  'function execute((bool delegateCall, bool revertOnError, uint256 gasLimit, address target, uint256 value, bytes data)[] calldata transactions, uint256 nonce, bytes calldata signature)'\n]\n\nexport interface Options {\n  readonly namespace?: string\n  readonly owners?: string[]\n  readonly arweaveUrl?: string\n  readonly graphqlUrl?: string\n  readonly eip5719Provider?: ethers.Provider\n  readonly rateLimitRetryDelayMs?: number\n}\n\nexport const defaults = {\n  namespace: 'Sequence-Sessions',\n  owners: ['AZ6R2mG8zxW9q7--iZXGrBknjegHoPzmG5IG-nxvMaM'],\n  arweaveUrl: 'https://arweave.net',\n  graphqlUrl: 'https://arweave.net/graphql',\n  eip5719Provider: undefined,\n  rateLimitRetryDelayMs: 5 * 60 * 1000\n}\n\nexport class ArweaveReader implements ConfigTracker, migrator.PresignedMigrationTracker {\n  private readonly configs: Map<string, Promise<commons.config.Config | undefined>> = new Map()\n  private readonly eip5719?: CachedEIP5719\n\n  constructor(readonly options: Options = defaults) {\n    if (options.eip5719Provider) {\n      this.eip5719 = new CachedEIP5719(options.eip5719Provider)\n    }\n  }\n\n  async loadPresignedConfiguration(args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean\n  }): Promise<PresignedConfigLink[]> {\n    const wallet = ethers.getAddress(args.wallet)\n\n    const fromConfig = await this.configOfImageHash({ imageHash: args.fromImageHash })\n    if (!fromConfig) {\n      throw new Error(`unable to find from config ${args.fromImageHash}`)\n    }\n    if (!v2.config.isWalletConfig(fromConfig)) {\n      throw new Error(`from config ${args.fromImageHash} is not v2`)\n    }\n    const fromCheckpoint = BigInt(fromConfig.checkpoint)\n\n    const items = Object.entries(await findItems({ Type: 'config update', Wallet: wallet }, this.options)).flatMap(\n      ([id, tags]) => {\n        try {\n          const { Signer: signer, Subdigest: subdigest, Digest: digest, 'To-Config': toImageHash } = tags\n\n          let signatureType: 'eip-712' | 'eth_sign' | 'erc-1271'\n          switch (tags['Signature-Type']) {\n            case 'eip-712':\n            case 'eth_sign':\n            case 'erc-1271':\n              signatureType = tags['Signature-Type']\n              break\n            default:\n              throw new Error(`unknown signature type ${tags['Signature-Type']}`)\n          }\n\n          let toCheckpoint: bigint\n          try {\n            toCheckpoint = BigInt(tags['To-Checkpoint'])\n          } catch {\n            throw new Error(`to checkpoint is not a number: ${tags['To-Checkpoint']}`)\n          }\n          if (toCheckpoint <= fromCheckpoint) {\n            return []\n          }\n\n          if (!ethers.isAddress(signer)) {\n            throw new Error(`signer is not an address: ${signer}`)\n          }\n\n          if (!ethers.isHexString(subdigest, 32)) {\n            throw new Error(`subdigest is not a hash: ${subdigest}`)\n          }\n\n          if (!ethers.isHexString(digest, 32)) {\n            throw new Error(`digest is not a hash: ${digest}`)\n          }\n\n          let chainId: bigint\n          try {\n            chainId = BigInt(tags['Chain-ID'])\n          } catch {\n            throw new Error(`chain id is not a number: ${tags['Chain-ID']}`)\n          }\n\n          if (!ethers.isHexString(toImageHash, 32)) {\n            throw new Error(`to config is not a hash: ${toImageHash}`)\n          }\n\n          return [{ id, signatureType, signer, subdigest, digest, chainId, toImageHash, toCheckpoint }]\n        } catch (error) {\n          console.warn(`invalid wallet ${wallet} config update ${id}:`, error)\n          return []\n        }\n      }\n    )\n\n    const signatures: Map<string, Map<string, (typeof items)[number]>> = new Map()\n    let candidates: typeof items = []\n\n    for (const item of items) {\n      let imageHashSignatures = signatures.get(item.toImageHash)\n      if (!imageHashSignatures) {\n        imageHashSignatures = new Map()\n        signatures.set(item.toImageHash, imageHashSignatures)\n        candidates.push(item)\n      }\n      imageHashSignatures.set(item.signer, item)\n    }\n\n    if (args.longestPath) {\n      candidates.sort(({ toCheckpoint: a }, { toCheckpoint: b }) => (a === b ? 0 : a < b ? -1 : 1))\n    } else {\n      candidates.sort(({ toCheckpoint: a }, { toCheckpoint: b }) => (a === b ? 0 : a < b ? 1 : -1))\n    }\n\n    const updates: PresignedConfigLink[] = []\n\n    for (let currentConfig = fromConfig; candidates.length; ) {\n      const currentImageHash = v2.config.imageHash(currentConfig)\n\n      let nextCandidate: (typeof candidates)[number] | undefined\n      let nextCandidateItems: Map<string, (typeof items)[number]>\n      let nextCandidateSigners: string[] = []\n\n      for (const candidate of candidates) {\n        nextCandidateItems = signatures.get(candidate.toImageHash)!\n        nextCandidateSigners = Array.from(nextCandidateItems.keys())\n\n        const { weight } = v2.signature.encodeSigners(\n          currentConfig,\n          new Map(nextCandidateSigners.map(signer => [signer, { signature: '0x', isDynamic: false }])),\n          [],\n          0\n        )\n\n        if (weight >= BigInt(currentConfig.threshold)) {\n          nextCandidate = candidate\n          break\n        }\n      }\n\n      if (!nextCandidate) {\n        console.warn(`unreachable configs with checkpoint > ${currentConfig.checkpoint} from config ${currentImageHash}`)\n        break\n      }\n\n      const nextImageHash = nextCandidate.toImageHash\n\n      try {\n        const nextConfig = await this.configOfImageHash({ imageHash: nextImageHash })\n        if (!nextConfig) {\n          throw new Error(`unable to find config ${nextImageHash}`)\n        }\n        if (!v2.config.isWalletConfig(nextConfig)) {\n          throw new Error(`config ${nextImageHash} is not v2`)\n        }\n\n        const nextCandidateSignatures = new Map(\n          (\n            await Promise.all(\n              nextCandidateSigners.map(async signer => {\n                const { id, subdigest, signatureType } = nextCandidateItems.get(signer)!\n                try {\n                  let signature = await (await fetchItem(id, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl)).text()\n                  switch (signatureType) {\n                    case 'eip-712':\n                      signature += '01'\n                      break\n                    case 'eth_sign':\n                      signature += '02'\n                      break\n                    case 'erc-1271':\n                      signature += '03'\n                      break\n                  }\n                  if (this.eip5719) {\n                    try {\n                      signature = ethers.hexlify(await this.eip5719.runByEIP5719(signer, subdigest, signature))\n                    } catch (error) {\n                      console.warn(`unable to run eip-5719 on config update ${id}`)\n                    }\n                  }\n                  const recovered = commons.signer.tryRecoverSigner(subdigest, signature)\n                  return [[signer, { signature, isDynamic: recovered !== signer }] as const]\n                } catch (error) {\n                  console.warn(`unable to fetch signer ${signer} config update ${id}:`, error)\n                  return []\n                }\n              })\n            )\n          ).flat()\n        )\n\n        const { encoded: signature, weight } = v2.signature.encodeSigners(currentConfig, nextCandidateSignatures, [], 0)\n        if (weight < BigInt(currentConfig.threshold)) {\n          throw new Error(`insufficient signing power ${weight.toString()} < ${currentConfig.threshold}`)\n        }\n        updates.push({ wallet, signature, nextImageHash })\n\n        currentConfig = nextConfig\n        candidates = candidates.filter(({ toCheckpoint }) => toCheckpoint > BigInt(currentConfig.checkpoint))\n      } catch (error) {\n        console.warn(\n          `unable to reconstruct wallet ${wallet} update from config ${currentImageHash} to config ${nextImageHash}:`,\n          error\n        )\n        candidates = candidates.filter(({ toImageHash }) => toImageHash !== nextImageHash)\n      }\n    }\n\n    return updates\n  }\n\n  savePresignedConfiguration(_args: PresignedConfig): Promise<void> {\n    throw new Error('arweave backend does not support saving config updates')\n  }\n\n  saveWitnesses(_args: { wallet: string; digest: string; chainId: ethers.BigNumberish; signatures: string[] }): Promise<void> {\n    throw new Error('arweave backend does not support saving signatures')\n  }\n\n  async configOfImageHash(args: { imageHash: string; noCache?: boolean }): Promise<commons.config.Config | undefined> {\n    if (!args.noCache) {\n      const config = this.configs.get(args.imageHash)\n      if (config) {\n        try {\n          return await config\n        } catch {\n          const config = this.configs.get(args.imageHash)\n          if (config) {\n            return config\n          }\n        }\n      }\n    }\n\n    const config = (async (imageHash: string): Promise<commons.config.Config | undefined> => {\n      const items = Object.entries(await findItems({ Type: 'config', Config: imageHash }, this.options)).flatMap(([id, tags]) => {\n        try {\n          const version = Number(tags.Version)\n          if (!version) {\n            throw new Error(`invalid version: ${tags.Version}`)\n          }\n\n          return [{ id, version }]\n        } catch (error) {\n          console.warn(`config ${imageHash} at ${id} invalid:`, error)\n          return []\n        }\n      })\n\n      switch (items.length) {\n        case 0:\n          this.configs.set(imageHash, Promise.resolve(undefined))\n          return\n        case 1:\n          break\n        default:\n          console.warn(`multiple configs ${imageHash} at ${items.map(({ id }) => id).join(', ')}`)\n          break\n      }\n\n      for (const { id, version } of items) {\n        try {\n          const config = {\n            ...(await (await fetchItem(id, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl)).json()),\n            version\n          }\n          if (config.tree) {\n            config.tree = toTopology(config.tree)\n          }\n\n          const actual = universal.coderFor(version).config.imageHashOf(config)\n          if (actual !== imageHash) {\n            throw new Error(`image hash is ${actual}, expected ${imageHash}`)\n          }\n\n          this.configs.set(imageHash, Promise.resolve(config))\n          return config\n        } catch (error) {\n          console.warn(`config at ${id} invalid:`, error)\n        }\n      }\n\n      this.configs.set(imageHash, Promise.resolve(undefined))\n      return\n    })(args.imageHash)\n\n    if (!args.noCache) {\n      this.configs.set(args.imageHash, config)\n    }\n\n    return config\n  }\n\n  saveWalletConfig(_args: { config: commons.config.Config }): Promise<void> {\n    throw new Error('arweave backend does not support saving configs')\n  }\n\n  async imageHashOfCounterfactualWallet(args: {\n    wallet: string\n    noCache?: boolean\n  }): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> {\n    const wallet = ethers.getAddress(args.wallet)\n\n    const items = Object.entries(await findItems({ Type: 'wallet', Wallet: wallet }, this.options)).flatMap(([id, tags]) => {\n      try {\n        const { 'Deploy-Config': imageHash } = tags\n\n        const version = Number(tags['Deploy-Version'])\n        if (!version) {\n          throw new Error(`invalid version: ${tags['Deploy-Version']}`)\n        }\n\n        if (!imageHash) {\n          throw new Error('no deploy config')\n        }\n\n        const context = commons.context.defaultContexts[version]\n        if (!context) {\n          throw new Error(`unknown version: ${version}`)\n        }\n\n        if (commons.context.addressOf(context, imageHash) !== wallet) {\n          throw new Error(`incorrect v${version} deploy config: ${imageHash}`)\n        }\n\n        return [{ id, imageHash, context }]\n      } catch (error) {\n        console.warn(`wallet ${wallet} at ${id} invalid:`, error)\n        return []\n      }\n    })\n\n    switch (items.length) {\n      case 0:\n        return\n      case 1:\n        break\n      default:\n        console.warn(`multiple deploy configs for wallet ${wallet} at ${items.map(({ id }) => id).join(', ')}, using first`)\n        break\n    }\n\n    return items[0]\n  }\n\n  saveCounterfactualWallet(_args: { config: commons.config.Config; context: commons.context.WalletContext[] }): Promise<void> {\n    throw new Error('arweave backend does not support saving wallets')\n  }\n\n  async walletsOfSigner(args: {\n    signer: string\n    noCache?: boolean\n    allSignatures?: boolean\n  }): Promise<Array<{ wallet: string; proof: { digest: string; chainId: bigint; signature: string } }>> {\n    const signer = ethers.getAddress(args.signer)\n\n    const proofs: Map<string, { digest: string; chainId: bigint; signature: Promise<string> }> = new Map()\n\n    for (const [id, tags] of Object.entries(\n      await findItems(\n        { Type: ['signature', 'config update'], Signer: signer, Witness: args.allSignatures ? undefined : 'true' },\n        this.options\n      )\n    )) {\n      const { Wallet: wallet, Subdigest: subdigest, Digest: digest, 'Chain-ID': chainId } = tags\n\n      try {\n        if (proofs.has(wallet)) {\n          continue\n        }\n\n        let signatureType: '01' | '02' | '03'\n        switch (tags['Signature-Type']) {\n          case 'eip-712':\n            signatureType = '01'\n            break\n          case 'eth_sign':\n            signatureType = '02'\n            break\n          case 'erc-1271':\n            signatureType = '03'\n            break\n          default:\n            throw new Error(`unknown signature type ${tags['Signature-Type']}`)\n        }\n\n        if (subdigest !== commons.signature.subdigestOf({ digest, chainId, address: wallet })) {\n          throw new Error('incorrect subdigest')\n        }\n\n        const signature = fetchItem(id, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then(async response => {\n          const signature = (await response.text()) + signatureType\n          if (this.eip5719) {\n            try {\n              return ethers.hexlify(await this.eip5719.runByEIP5719(signer, subdigest, signature))\n            } catch (error) {\n              console.warn(`unable to run eip-5719 on signature ${id}`)\n            }\n          }\n          return signature\n        })\n\n        proofs.set(wallet, { digest, chainId: BigInt(chainId), signature })\n      } catch (error) {\n        console.warn(`signer ${signer} signature ${id} of wallet ${wallet} invalid:`, error)\n      }\n    }\n\n    return Promise.all(\n      [...proofs.entries()].map(async ([wallet, { digest, chainId, signature }]) => ({\n        wallet,\n        proof: { digest, chainId, signature: await signature }\n      }))\n    )\n  }\n\n  async getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    const wallet = ethers.getAddress(address)\n\n    const items = Object.entries(\n      await findItems(\n        {\n          Type: 'migration',\n          Migration: wallet,\n          'Chain-ID': BigInt(chainId).toString(),\n          'From-Version': `${fromVersion}`,\n          'From-Config': fromImageHash\n        },\n        this.options\n      )\n    ).flatMap(([id, tags]) => {\n      try {\n        const { 'To-Config': toImageHash, Executor: executor } = tags\n\n        const toVersion = Number(tags['To-Version'])\n        if (!toVersion) {\n          throw new Error(`invalid version: ${tags['To-Version']}`)\n        }\n\n        if (!ethers.isHexString(toImageHash, 32)) {\n          throw new Error(`to config is not a hash: ${toImageHash}`)\n        }\n\n        if (!ethers.isAddress(executor)) {\n          throw new Error(`executor is not an address: ${executor}`)\n        }\n\n        return { id, toVersion, toImageHash, executor }\n      } catch (error) {\n        console.warn(\n          `chain ${chainId} migration ${id} for v${fromVersion} wallet ${wallet} from config ${fromImageHash} invalid:`,\n          error\n        )\n        return []\n      }\n    })\n\n    switch (items.length) {\n      case 0:\n        return\n      case 1:\n        break\n      default:\n        console.warn(\n          `multiple chain ${chainId} migrations for v${fromVersion} wallet ${wallet} from config ${fromImageHash} at ${items.map(({ id }) => id).join(', ')}, using first`\n        )\n        break\n    }\n\n    const { id, toVersion, toImageHash, executor } = items[0]\n\n    const [data, toConfig] = await Promise.all([\n      fetchItem(id, this.options.rateLimitRetryDelayMs, this.options.arweaveUrl).then(response => response.text()),\n      this.configOfImageHash({ imageHash: toImageHash })\n    ])\n\n    if (!toConfig) {\n      throw new Error(`unable to find to config ${toImageHash} for migration`)\n    }\n\n    const mainModule = new ethers.Interface(MAIN_MODULE_ABI)\n    const [encoded, nonce, signature] = mainModule.decodeFunctionData('execute', data)\n    const transactions = commons.transaction.fromTxAbiEncode(encoded)\n    const subdigest = commons.transaction.subdigestOfTransactions(wallet, chainId, nonce, transactions)\n\n    return {\n      tx: { entrypoint: executor, transactions, nonce, chainId, intent: { id: subdigest, wallet }, signature },\n      fromVersion,\n      toVersion: Number(toVersion),\n      toConfig\n    }\n  }\n\n  saveMigration(_address: string, _signed: migrator.SignedMigration, _contexts: commons.context.VersionedContext): Promise<void> {\n    throw new Error('arweave backend does not support saving migrations')\n  }\n}\n\nasync function findItems(\n  filter: { [name: string]: undefined | string | string[] },\n  options?: Options & { pageSize?: number; maxResults?: number }\n): Promise<{ [id: string]: { [tag: string]: string } }> {\n  const namespace = options?.namespace ?? defaults.namespace\n  const owners = options?.owners\n  const graphqlUrl = options?.graphqlUrl ?? defaults.graphqlUrl\n  const rateLimitRetryDelayMs = options?.rateLimitRetryDelayMs ?? defaults.rateLimitRetryDelayMs\n  const pageSize = options?.pageSize ?? 100\n  const maxResults = options?.maxResults\n\n  const tags = Object.entries(filter).flatMap(([name, values]) =>\n    values === undefined\n      ? []\n      : [\n          `{ name: \"${namespace ? `${namespace}-${name}` : name}\", values: [${typeof values === 'string' ? `\"${values}\"` : values.map(value => `\"${value}\"`).join(', ')}] }`\n        ]\n  )\n\n  const edges: Array<{ cursor: string; node: { id: string; tags: Array<{ name: string; value: string }> } }> = []\n\n  for (let hasNextPage = true; hasNextPage && (maxResults === undefined || edges.length < maxResults); ) {\n    const query = `\n      query {\n        transactions(sort: HEIGHT_DESC, ${edges.length ? `first: ${pageSize}, after: \"${edges[edges.length - 1].cursor}\"` : `first: ${pageSize}`}, tags: [${tags.join(', ')}]${owners === undefined ? '' : `, owners: [${owners.map(owner => `\"${owner}\"`).join(', ')}]`}) {\n          pageInfo {\n            hasNextPage\n          }\n          edges {\n            cursor\n            node {\n              id\n              tags {\n                name\n                value\n              }\n            }\n          }\n        }\n      }\n    `\n\n    let response: Response\n    while (true) {\n      response = await fetch(graphqlUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ query }),\n        redirect: 'follow'\n      })\n      if (response.status !== 429) {\n        break\n      }\n      console.warn(\n        `rate limited by ${graphqlUrl}, trying again in ${rateLimitRetryDelayMs / 1000} seconds at ${new Date(Date.now() + rateLimitRetryDelayMs).toLocaleTimeString()}`\n      )\n      await new Promise(resolve => setTimeout(resolve, rateLimitRetryDelayMs))\n    }\n\n    const {\n      data: { transactions }\n    } = await response.json()\n\n    edges.push(...transactions.edges)\n\n    hasNextPage = transactions.pageInfo.hasNextPage\n  }\n\n  return Object.fromEntries(\n    edges.map(({ node: { id, tags } }) => [\n      id,\n      Object.fromEntries(\n        tags.map(({ name, value }) => [\n          namespace && name.startsWith(`${namespace}-`) ? name.slice(namespace.length + 1) : name,\n          value\n        ])\n      )\n    ])\n  )\n}\n\nasync function fetchItem(\n  id: string,\n  rateLimitRetryDelayMs = defaults.rateLimitRetryDelayMs,\n  arweaveUrl = defaults.arweaveUrl\n): Promise<Response> {\n  while (true) {\n    const response = await fetch(`${arweaveUrl}/${id}`, { redirect: 'follow' })\n    if (response.status !== 429) {\n      return response\n    }\n    console.warn(\n      `rate limited by ${arweaveUrl}, trying again in ${rateLimitRetryDelayMs / 1000} seconds at ${new Date(Date.now() + rateLimitRetryDelayMs).toLocaleTimeString()}`\n    )\n    await new Promise(resolve => setTimeout(resolve, rateLimitRetryDelayMs))\n  }\n}\n\nfunction toTopology(topology: any): v2.config.Topology {\n  if (typeof topology === 'string') {\n    return { nodeHash: topology }\n  }\n\n  if (typeof topology === 'object' && topology?.node !== undefined) {\n    return { nodeHash: topology.node }\n  }\n\n  if (topology instanceof Array && topology.length === 2) {\n    return { left: toTopology(topology[0]), right: toTopology(topology[1]) }\n  }\n\n  if (v2.config.isNode(topology)) {\n    return { left: toTopology(topology.left), right: toTopology(topology.right) }\n  }\n\n  if (v2.config.isNestedLeaf(topology)) {\n    return { ...topology, tree: toTopology(topology.tree) }\n  }\n\n  return topology\n}\n","import { commons } from '@0xsequence/core'\nimport { migrator } from '@0xsequence/migration'\nimport { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../tracker'\nimport { ethers } from 'ethers'\nimport { bigintReplacer } from '@0xsequence/utils'\n\nexport class DebugConfigTracker implements ConfigTracker, migrator.PresignedMigrationTracker {\n  constructor(private readonly tracker: ConfigTracker & migrator.PresignedMigrationTracker) {}\n\n  async loadPresignedConfiguration(args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean\n  }): Promise<PresignedConfigLink[]> {\n    console.debug('? loadPresignedConfiguration')\n    debug(args, '? ')\n    return debug(await this.tracker.loadPresignedConfiguration(args), '! ')\n  }\n\n  savePresignedConfiguration(args: PresignedConfig): Promise<void> {\n    console.debug('? savePresignedConfiguration')\n    debug(args, '? ')\n    return this.tracker.savePresignedConfiguration(args)\n  }\n\n  saveWitnesses(args: { wallet: string; digest: string; chainId: ethers.BigNumberish; signatures: string[] }): Promise<void> {\n    console.debug('? saveWitnesses')\n    debug(args, '? ')\n    return this.tracker.saveWitnesses(args)\n  }\n\n  async configOfImageHash(args: { imageHash: string }): Promise<commons.config.Config | undefined> {\n    console.debug('? configOfImageHash')\n    debug(args, '? ')\n    return debug(await this.tracker.configOfImageHash(args), '! ')\n  }\n\n  saveWalletConfig(args: { config: commons.config.Config }): Promise<void> {\n    console.debug('? saveWalletConfig')\n    debug(args, '? ')\n    return this.tracker.saveWalletConfig(args)\n  }\n\n  async imageHashOfCounterfactualWallet(args: {\n    wallet: string\n  }): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> {\n    console.debug('? imageHashOfCounterfactualWallet')\n    debug(args, '? ')\n    return debug(await this.tracker.imageHashOfCounterfactualWallet(args), '! ')\n  }\n\n  saveCounterfactualWallet(args: { config: commons.config.Config; context: commons.context.WalletContext[] }): Promise<void> {\n    console.debug('? saveCounterfactualWallet')\n    debug(args, '? ')\n    return this.tracker.saveCounterfactualWallet(args)\n  }\n\n  async walletsOfSigner(args: {\n    signer: string\n  }): Promise<{ wallet: string; proof: { digest: string; chainId: bigint; signature: string } }[]> {\n    console.debug('? walletsOfSigner')\n    debug(args, '? ')\n    return debug(await this.tracker.walletsOfSigner(args), '! ')\n  }\n\n  async getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    console.debug('? getMigration')\n    debug({ address, fromImageHash, fromVersion, chainId }, '? ')\n    return debug(await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId), '! ')\n  }\n\n  saveMigration(address: string, signed: migrator.SignedMigration, contexts: commons.context.VersionedContext): Promise<void> {\n    console.debug('? saveMigration')\n    debug({ address, signed, contexts }, '? ')\n    return this.tracker.saveMigration(address, signed, contexts)\n  }\n}\n\nfunction debug<T>(value: T, prefix: string = ''): T {\n  switch (value) {\n    case undefined:\n      console.debug(prefix + 'undefined')\n      break\n    default:\n      JSON.stringify(value, bigintReplacer, 2)\n        .split('\\n')\n        .map(line => prefix + line)\n        .forEach(line => console.debug(line))\n      break\n  }\n  return value\n}\n","import { commons, v1, v2 } from '@0xsequence/core'\nimport { ethers } from 'ethers'\nimport { PlainNested, PlainNode, PlainV2Config, TrackerStore } from '.'\n\nexport class MemoryTrackerStore implements TrackerStore {\n  private configs: { [imageHash: string]: v1.config.WalletConfig | v2.config.WalletConfig | PlainV2Config } = {}\n  private v2Nodes: { [nodeHash: string]: PlainNode | PlainNested | v2.config.Topology } = {}\n  private counterfactualWallets: { [wallet: string]: { imageHash: string; context: commons.context.WalletContext } } = {}\n  private payloads: { [subdigest: string]: commons.signature.SignedPayload } = {}\n  private signatures: { [signer: string]: { [subdigest: string]: ethers.BytesLike } } = {}\n  private migrations: {\n    [wallet: string]: { [fromVersion: number]: { [toVersion: number]: { subdigest: string; toImageHash: string }[] } }\n  } = {}\n\n  loadConfig = (imageHash: string): Promise<v1.config.WalletConfig | v2.config.WalletConfig | PlainV2Config | undefined> => {\n    return Promise.resolve(this.configs[imageHash])\n  }\n\n  saveConfig = (imageHash: string, config: v1.config.WalletConfig | v2.config.WalletConfig | PlainV2Config): Promise<void> => {\n    this.configs[imageHash] = config\n    return Promise.resolve()\n  }\n\n  loadV2Node = (nodeHash: string): Promise<v2.config.Topology | PlainNode | PlainNested | undefined> => {\n    return Promise.resolve(this.v2Nodes[nodeHash])\n  }\n\n  saveV2Node = (nodeHash: string, node: v2.config.Topology | PlainNode | PlainNested): Promise<void> => {\n    this.v2Nodes[nodeHash] = node\n    return Promise.resolve()\n  }\n\n  loadCounterfactualWallet = (\n    wallet: string\n  ): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> => {\n    return Promise.resolve(this.counterfactualWallets[wallet])\n  }\n\n  saveCounterfactualWallet = (wallet: string, imageHash: string, context: commons.context.WalletContext): Promise<void> => {\n    this.counterfactualWallets[wallet] = { imageHash, context }\n    return Promise.resolve()\n  }\n\n  loadPayloadOfSubdigest = (subdigest: string): Promise<commons.signature.SignedPayload | undefined> => {\n    return Promise.resolve(this.payloads[subdigest])\n  }\n\n  savePayloadOfSubdigest = (subdigest: string, payload: commons.signature.SignedPayload): Promise<void> => {\n    this.payloads[subdigest] = payload\n    return Promise.resolve()\n  }\n\n  loadSubdigestsOfSigner = (signer: string): Promise<string[]> => {\n    return Promise.resolve(Object.keys(this.signatures[signer] || {}))\n  }\n\n  loadSignatureOfSubdigest = (signer: string, subdigest: string): Promise<ethers.BytesLike | undefined> => {\n    return Promise.resolve(this.signatures[signer]?.[subdigest])\n  }\n\n  saveSignatureOfSubdigest = (signer: string, subdigest: string, payload: ethers.BytesLike): Promise<void> => {\n    if (!this.signatures[signer]) this.signatures[signer] = {}\n    this.signatures[signer][subdigest] = payload\n    return Promise.resolve()\n  }\n\n  loadMigrationsSubdigest = (\n    wallet: string,\n    fromVersion: number,\n    toVersion: number\n  ): Promise<{ subdigest: string; toImageHash: string }[]> => {\n    return Promise.resolve(this.migrations[wallet]?.[fromVersion]?.[toVersion] || [])\n  }\n\n  saveMigrationsSubdigest = (\n    wallet: string,\n    fromVersion: number,\n    toVersion: number,\n    subdigest: string,\n    toImageHash: string\n  ): Promise<void> => {\n    if (!this.migrations[wallet]) this.migrations[wallet] = {}\n    if (!this.migrations[wallet][fromVersion]) this.migrations[wallet][fromVersion] = {}\n    if (!this.migrations[wallet][fromVersion][toVersion]) this.migrations[wallet][fromVersion][toVersion] = []\n    this.migrations[wallet][fromVersion][toVersion].push({ subdigest, toImageHash })\n    return Promise.resolve()\n  }\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { commons, v1, v2 } from '@0xsequence/core'\nimport { ethers } from 'ethers'\nimport { PlainNested, PlainNode, PlainV2Config, TrackerStore } from '.'\n\nimport { DBSchema, IDBPDatabase, openDB } from 'idb'\n\nexport interface LocalTrackerDBSchema extends DBSchema {\n  configs: {\n    key: string\n    value: v1.config.WalletConfig | v2.config.WalletConfig | PlainV2Config\n  }\n  v2Nodes: {\n    key: string\n    value: v2.config.Topology | PlainNode | PlainNested\n  }\n  counterfactualWallets: {\n    key: string\n    value: {\n      imageHash: string\n      context: commons.context.WalletContext\n    }\n  }\n  payloads: {\n    key: string\n    value: commons.signature.SignedPayload\n  }\n  signatures: {\n    key: string // `${signer}-${subdigest}`\n    value: {\n      signature: ethers.BytesLike\n      signer: string\n    }\n    indexes: {\n      signer: string\n    }\n  }\n  migrations: {\n    key: string\n    value: {\n      wallet: string\n      fromVersion: number\n      toVersion: number\n      subdigest: string\n      toImageHash: string\n    }\n    indexes: {\n      jump: string // '${wallet}-${fromVersion}-${toVersion}\n    }\n  }\n}\n\nexport function recreateBigNumbers<T extends object | undefined>(object: T): T | undefined {\n  if (object === undefined) return undefined\n\n  const result = {} as any\n\n  for (const key of Object.keys(object)) {\n    const val = (object as any)[key as string]\n\n    if (val._isBigNumber === true && val._hex !== undefined && typeof val._hex === 'string' && val._hex.length !== '') {\n      // Entry is a big number\n      result[key] = BigInt(val._hex)\n    } else if (Array.isArray(val)) {\n      // Entry is an array, recurse\n      result[key] = val.map(v => recreateBigNumbers(v))\n    } else if (typeof val === 'object' && val !== null) {\n      // Entry is another object, recurse\n      result[key] = recreateBigNumbers(val)\n    } else {\n      // Entry is a primitive, just copy\n      result[key] = val\n    }\n  }\n\n  return result\n}\n\nexport class IndexedDBStore implements TrackerStore {\n  private _lazyDb: IDBPDatabase<LocalTrackerDBSchema> | undefined\n\n  constructor(public dbName: string) {}\n\n  async getDb() {\n    if (this._lazyDb) return this._lazyDb\n\n    const dbName = this.dbName\n    this._lazyDb = await openDB<LocalTrackerDBSchema>(dbName, 1, {\n      upgrade(db, oldVersion, newVersion, transaction) {\n        console.log(`upgrading ${dbName} from ${oldVersion} to ${newVersion} - ${transaction}`)\n        if (oldVersion === 0) {\n          db.createObjectStore('configs')\n          db.createObjectStore('v2Nodes')\n          db.createObjectStore('counterfactualWallets')\n          db.createObjectStore('payloads')\n\n          const signatures = db.createObjectStore('signatures')\n          signatures.createIndex('signer', 'signer', { unique: false })\n\n          const migrations = db.createObjectStore('migrations')\n          migrations.createIndex('jump', ['wallet', 'fromVersion', 'toVersion'])\n        }\n      }\n    })\n    return this._lazyDb\n  }\n\n  loadConfig = async (\n    imageHash: string\n  ): Promise<v1.config.WalletConfig | v2.config.WalletConfig | PlainV2Config | undefined> => {\n    const db = await this.getDb()\n    return db.get('configs', imageHash).then(c => recreateBigNumbers(c))\n  }\n\n  saveConfig = async (\n    imageHash: string,\n    config: v1.config.WalletConfig | v2.config.WalletConfig | PlainV2Config\n  ): Promise<void> => {\n    const db = await this.getDb()\n    await db.put('configs', config, imageHash)\n  }\n\n  loadV2Node = async (nodeHash: string): Promise<v2.config.Topology | PlainNode | PlainNested | undefined> => {\n    const db = await this.getDb()\n    return db.get('v2Nodes', nodeHash).then(c => recreateBigNumbers(c))\n  }\n\n  saveV2Node = async (nodeHash: string, node: v2.config.Topology | PlainNode | PlainNested): Promise<void> => {\n    const db = await this.getDb()\n    await db.put('v2Nodes', node, nodeHash)\n  }\n\n  loadCounterfactualWallet = async (\n    wallet: string\n  ): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> => {\n    const db = await this.getDb()\n    return db.get('counterfactualWallets', wallet)\n  }\n\n  saveCounterfactualWallet = async (wallet: string, imageHash: string, context: commons.context.WalletContext): Promise<void> => {\n    const db = await this.getDb()\n    await db.put('counterfactualWallets', { imageHash, context }, wallet)\n  }\n\n  loadPayloadOfSubdigest = async (subdigest: string): Promise<commons.signature.SignedPayload | undefined> => {\n    const db = await this.getDb()\n    return db.get('payloads', subdigest).then(c => recreateBigNumbers(c))\n  }\n\n  savePayloadOfSubdigest = async (subdigest: string, payload: commons.signature.SignedPayload): Promise<void> => {\n    const db = await this.getDb()\n    await db.put('payloads', payload, subdigest)\n  }\n\n  loadSubdigestsOfSigner = async (signer: string): Promise<string[]> => {\n    const db = await this.getDb()\n    const index = await db.getAllKeysFromIndex('signatures', 'signer', IDBKeyRange.only(signer))\n    return index.map(key => key.split('-')[0])\n  }\n\n  loadSignatureOfSubdigest = async (signer: string, subdigest: string): Promise<ethers.BytesLike | undefined> => {\n    const db = await this.getDb()\n    const signature = await db.get('signatures', [subdigest, signer].join('-'))\n    return signature?.signature\n  }\n\n  saveSignatureOfSubdigest = async (signer: string, subdigest: string, payload: ethers.BytesLike): Promise<void> => {\n    const db = await this.getDb()\n    await db.put('signatures', { signature: payload, signer }, [subdigest, signer].join('-'))\n  }\n\n  loadMigrationsSubdigest = async (\n    wallet: string,\n    fromVersion: number,\n    toVersion: number\n  ): Promise<{ subdigest: string; toImageHash: string }[]> => {\n    const db = await this.getDb()\n    const index = await db.getAllFromIndex('migrations', 'jump', IDBKeyRange.only([wallet, fromVersion, toVersion]))\n    return index.map(key => ({ subdigest: key.subdigest, toImageHash: key.toImageHash }))\n  }\n\n  saveMigrationsSubdigest = async (\n    wallet: string,\n    fromVersion: number,\n    toVersion: number,\n    subdigest: string,\n    toImageHash: string\n  ): Promise<void> => {\n    const db = await this.getDb()\n    await db.put('migrations', { wallet, fromVersion, toVersion, subdigest, toImageHash }, subdigest)\n  }\n}\n","import { commons, v1, v2 } from '@0xsequence/core'\nimport { ethers } from 'ethers'\n\nexport type PlainNode = {\n  left: string\n  right: string\n}\n\nexport type PlainNested = {\n  weight: string\n  threshold: string\n  tree: string\n}\n\nexport type PlainV2Config = {\n  version: 2\n  threshold: string\n  checkpoint: string\n  tree: string\n}\n\nexport function isPlainNode(node: any): node is PlainNode {\n  return node.left !== undefined && node.right !== undefined\n}\n\nexport function isPlainNested(node: any): node is PlainNested {\n  return node.weight !== undefined && node.threshold !== undefined && node.tree !== undefined\n}\n\nexport function isPlainV2Config(config: any): config is PlainV2Config {\n  return (\n    config.version === 2 &&\n    config.threshold !== undefined &&\n    config.checkpoint !== undefined &&\n    config.tree !== undefined &&\n    typeof config.tree === 'string'\n  )\n}\n\nexport interface TrackerStore {\n  // top level configurations store\n  loadConfig: (imageHash: string) => Promise<v1.config.WalletConfig | PlainV2Config | v2.config.WalletConfig | undefined>\n  saveConfig: (imageHash: string, config: v1.config.WalletConfig | PlainV2Config | v2.config.WalletConfig) => Promise<void>\n\n  // v2 configurations store\n  loadV2Node: (nodeHash: string) => Promise<PlainNode | PlainNested | v2.config.Topology | undefined>\n  saveV2Node: (nodeHash: string, node: PlainNode | PlainNested | v2.config.Topology) => Promise<void>\n\n  // counterfactual wallets\n  loadCounterfactualWallet: (wallet: string) => Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined>\n  saveCounterfactualWallet: (wallet: string, imageHash: string, context: commons.context.WalletContext) => Promise<void>\n\n  // payloads\n  loadPayloadOfSubdigest: (subdigest: string) => Promise<commons.signature.SignedPayload | undefined>\n  savePayloadOfSubdigest: (subdigest: string, payload: commons.signature.SignedPayload) => Promise<void>\n\n  // signatures\n  loadSubdigestsOfSigner: (signer: string) => Promise<string[]>\n  loadSignatureOfSubdigest: (signer: string, subdigest: string) => Promise<ethers.BytesLike | undefined>\n  saveSignatureOfSubdigest: (signer: string, subdigest: string, payload: ethers.BytesLike) => Promise<void>\n\n  // migrations\n  loadMigrationsSubdigest: (\n    wallet: string,\n    fromVersion: number,\n    toVersion: number\n  ) => Promise<{ subdigest: string; toImageHash: string }[]>\n  saveMigrationsSubdigest: (\n    wallet: string,\n    fromVersion: number,\n    toVersion: number,\n    subdigest: string,\n    toImageHash: string\n  ) => Promise<void>\n}\n\nexport * from './memoryStore'\nexport * from './indexedDBStore'\n","import { commons, universal, v1, v2 } from '@0xsequence/core'\nimport { migration, migrator } from '@0xsequence/migration'\nimport { ethers } from 'ethers'\nimport { CachedEIP5719 } from '@0xsequence/replacer'\nimport { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../tracker'\nimport { isPlainNested, isPlainNode, isPlainV2Config, MemoryTrackerStore, PlainNested, PlainNode, TrackerStore } from './stores'\n\nexport class LocalConfigTracker implements ConfigTracker, migrator.PresignedMigrationTracker {\n  private cachedEIP5719: CachedEIP5719\n\n  constructor(\n    // TODO: The provider is only used to determine that EIP1271 signatures have *some* validity\n    // but when reconstructing a presigned transaction we should do the replacement once per chain.\n    // For now, it's recommended to use Mainnet as the provider.\n    public provider: ethers.Provider,\n    private store: TrackerStore = new MemoryTrackerStore(),\n    public useEIP5719: boolean = false\n  ) {\n    this.cachedEIP5719 = new CachedEIP5719(provider)\n  }\n\n  private loadTopology = async (hash: string): Promise<v2.config.Topology> => {\n    const node = await this.store.loadV2Node(hash)\n    if (!node) return { nodeHash: hash }\n\n    if (isPlainNode(node)) {\n      const [left, right] = await Promise.all([this.loadTopology(node.left), this.loadTopology(node.right)])\n      return { left, right }\n    }\n\n    if (isPlainNested(node)) {\n      return {\n        weight: BigInt(node.weight),\n        threshold: BigInt(node.threshold),\n        tree: await this.loadTopology(node.tree)\n      }\n    }\n\n    return node\n  }\n\n  private saveTopology = async (node: v2.config.Topology): Promise<void> => {\n    if (v2.config.isNodeLeaf(node)) {\n      return // Nothing to do, this is a dead-end\n    }\n\n    const hash = v2.config.hashNode(node)\n\n    if (v2.config.isNode(node)) {\n      const saveLeft = this.saveTopology(node.left)\n      const saveRight = this.saveTopology(node.right)\n      const saveThis = this.store.saveV2Node(hash, {\n        left: v2.config.hashNode(node.left),\n        right: v2.config.hashNode(node.right)\n      } as PlainNode)\n\n      await Promise.all([saveLeft, saveRight, saveThis])\n\n      return\n    }\n\n    if (v2.config.isNestedLeaf(node)) {\n      const saveTree = this.saveTopology(node.tree)\n      const saveThis = this.store.saveV2Node(hash, {\n        weight: BigInt(node.weight).toString(),\n        threshold: BigInt(node.threshold).toString(),\n        tree: v2.config.hashNode(node.tree)\n      } as PlainNested)\n\n      await Promise.all([saveTree, saveThis])\n\n      return\n    }\n\n    // If it's a normal leaf, then we just store it\n    if (v2.config.isSignerLeaf(node)) {\n      return this.store.saveV2Node(hash, {\n        address: node.address,\n        weight: node.weight\n      })\n    }\n\n    if (v2.config.isSubdigestLeaf(node)) {\n      return this.store.saveV2Node(hash, {\n        subdigest: node.subdigest\n      })\n    }\n\n    throw new Error(`Unknown topology type: ${node}`)\n  }\n\n  saveWalletConfig = async (args: { config: commons.config.Config }): Promise<void> => {\n    const { config } = args\n    if (v1.config.ConfigCoder.isWalletConfig(config)) {\n      // We can store the configuration as-is\n      const imageHash = v1.config.ConfigCoder.imageHashOf(config)\n      return this.store.saveConfig(imageHash, config)\n    }\n\n    if (v2.config.ConfigCoder.isWalletConfig(config)) {\n      // We split the configuration in a list of nodes, and store them individually\n      // then we can reconstruct it. This also means we can combine multiple configurations\n      // if they share information\n      const imageHash = v2.config.ConfigCoder.imageHashOf(config)\n\n      // This is an optimization, it allows us to avoid splitting the tree if it's already complete\n      if (v2.config.isComplete(config.tree)) {\n        return this.store.saveConfig(imageHash, config)\n      }\n\n      // TODO: Re-enable storing partial v2 configs once\n      // we have more performant code to reconstructing them\n      // in the meantime, rely on the remote tracker\n\n      // const storeTree = this.saveTopology(config.tree)\n      // const storeConfig = this.store.saveConfig(imageHash, {\n      //   version: 2,\n      //   threshold: BigInt(config.threshold).toString(),\n      //   checkpoint: BigInt(config.checkpoint).toString(),\n      //   tree: v2.config.hashNode(config.tree)\n      // })\n\n      // await Promise.all([storeTree, storeConfig])\n    }\n\n    return\n  }\n\n  private configOfImageHashCache = {} as { [key: string]: commons.config.Config }\n\n  configOfImageHash = async (args: { imageHash: string }): Promise<commons.config.Config | undefined> => {\n    const { imageHash } = args\n\n    if (this.configOfImageHashCache[args.imageHash]) {\n      return this.configOfImageHashCache[args.imageHash]\n    }\n\n    const config = await this.store.loadConfig(imageHash)\n    if (!config) {\n      return undefined\n    }\n\n    if (config.version === 1 || (config.version === 2 && !isPlainV2Config(config))) {\n      this.configOfImageHashCache[args.imageHash] = config\n      return config\n    }\n\n    if (isPlainV2Config(config)) {\n      const fullConfig = {\n        version: 2,\n        threshold: BigInt(config.threshold),\n        checkpoint: BigInt(config.checkpoint),\n        tree: await this.loadTopology(config.tree)\n      } as v2.config.WalletConfig\n      this.configOfImageHashCache[args.imageHash] = fullConfig\n      return fullConfig\n    }\n\n    throw new Error(`Unknown config type: ${config}`)\n  }\n\n  saveCounterfactualWallet = async (args: {\n    config: commons.config.Config\n    context: commons.context.WalletContext[]\n  }): Promise<void> => {\n    const { config, context } = args\n    const imageHash = universal.genericCoderFor(config.version).config.imageHashOf(config)\n    await Promise.all([\n      this.saveWalletConfig({ config }),\n      ...context.map(ctx => {\n        const address = commons.context.addressOf(ctx, imageHash)\n        return this.store.saveCounterfactualWallet(address, imageHash, ctx)\n      })\n    ])\n  }\n\n  imageHashOfCounterfactualWallet = async (args: {\n    wallet: string\n  }): Promise<\n    | {\n        imageHash: string\n        context: commons.context.WalletContext\n      }\n    | undefined\n  > => {\n    const { wallet } = args\n    const result = await this.store.loadCounterfactualWallet(wallet)\n\n    if (!result) return undefined\n\n    return {\n      imageHash: result.imageHash,\n      context: result.context\n    }\n  }\n\n  savePayload = async (args: { payload: commons.signature.SignedPayload }): Promise<void> => {\n    const { payload } = args\n\n    const subdigest = commons.signature.subdigestOf(payload)\n    await this.store.savePayloadOfSubdigest(subdigest, payload)\n  }\n\n  private payloadOfSubdigestCache = {} as { [key: string]: commons.signature.SignedPayload }\n\n  payloadOfSubdigest = async (args: { subdigest: string }): Promise<commons.signature.SignedPayload | undefined> => {\n    if (this.payloadOfSubdigestCache[args.subdigest]) {\n      return this.payloadOfSubdigestCache[args.subdigest]\n    }\n\n    const { subdigest } = args\n    const res = await this.store.loadPayloadOfSubdigest(subdigest)\n\n    if (res) {\n      this.payloadOfSubdigestCache[subdigest] = res\n    }\n\n    return res\n  }\n\n  savePresignedConfiguration = async (args: PresignedConfig): Promise<void> => {\n    // Presigned configurations only work with v2 (for now)\n    // so we can assume that the signature is for a v2 configuration\n    const decoded = v2.signature.SignatureCoder.decode(args.signature)\n    const nextImageHash = universal.genericCoderFor(args.nextConfig.version).config.imageHashOf(args.nextConfig)\n    const message = v2.chained.messageSetImageHash(nextImageHash)\n    const digest = ethers.keccak256(message)\n    const payload = {\n      message,\n      address: args.wallet,\n      chainId: 0,\n      digest\n    }\n\n    const savePayload = this.savePayload({ payload })\n    const saveNextConfig = this.saveWalletConfig({ config: args.nextConfig })\n\n    const recovered = await v2.signature.SignatureCoder.recover(decoded, payload, this.provider)\n\n    // Save the recovered configuration and all signature parts\n    const signatures = v2.signature.signaturesOf(recovered.config.tree)\n    await Promise.all([\n      savePayload,\n      saveNextConfig,\n      this.saveWalletConfig({ config: recovered.config }),\n      ...signatures.map(sig => this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))\n    ])\n  }\n\n  loadPresignedConfiguration = async (args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean\n  }): Promise<PresignedConfigLink[]> => {\n    const { wallet, fromImageHash, longestPath } = args\n\n    const fromConfig = await this.configOfImageHash({ imageHash: fromImageHash })\n    if (!fromConfig || !v2.config.ConfigCoder.isWalletConfig(fromConfig)) {\n      return []\n    }\n\n    // Get all subdigests for the config members\n    const signers = v2.config.signersOf(fromConfig.tree).map(s => s.address)\n    const subdigestsOfSigner = await Promise.all(signers.map(s => this.store.loadSubdigestsOfSigner(s)))\n    const subdigests = [...new Set(subdigestsOfSigner.flat())]\n\n    // Get all unique payloads\n    const payloads = await Promise.all(\n      [...new Set(subdigests)].map(async s => ({ ...(await this.payloadOfSubdigest({ subdigest: s })), subdigest: s }))\n    )\n\n    // Get all possible next imageHashes based on the payloads\n    const nextImageHashes = payloads\n      .filter(p => p?.message && p?.address && p.address === wallet)\n      .map(p => ({ payload: p, nextImageHash: v2.chained.decodeMessageSetImageHash(p!.message!) }))\n      .filter(p => p?.nextImageHash) as {\n      payload: commons.signature.SignedPayload & { subdigest: string }\n      nextImageHash: string\n    }[]\n\n    // Build a signature for each next imageHash\n    // and filter out the ones that don't have enough weight\n    let bestCandidate:\n      | {\n          nextImageHash: string\n          checkpoint: bigint\n          signature: string\n        }\n      | undefined\n\n    const nextConfigsAndCheckpoints = await Promise.all(\n      nextImageHashes.map(async ({ nextImageHash, payload }) => {\n        const nextConfig = await this.configOfImageHash({ imageHash: nextImageHash })\n        if (!nextConfig || !v2.config.isWalletConfig(nextConfig)) return undefined\n        const nextCheckpoint = BigInt(nextConfig.checkpoint)\n        return { nextConfig, nextCheckpoint, nextImageHash, payload }\n      })\n    )\n\n    const sortedNextConfigsAndCheckpoints = nextConfigsAndCheckpoints\n      .filter(c => c !== undefined)\n      .filter(c => c!.nextCheckpoint > BigInt(fromConfig.checkpoint))\n      .sort((a, b) =>\n        // If we are looking for the longest path, sort by ascending checkpoint\n        // because we want to find the smalles jump, and we should start with the\n        // closest one. If we are not looking for the longest path, sort by\n        // descending checkpoint, because we want to find the largest jump.\n        //\n        // We don't have a guarantee that all \"next configs\" will be valid\n        // so worst case scenario we will need to try all of them.\n        // But we can try to optimize for the most common case.\n        a!.nextCheckpoint > b!.nextCheckpoint ? (longestPath ? 1 : -1) : longestPath ? -1 : 1\n      )\n\n    for (const entry of sortedNextConfigsAndCheckpoints) {\n      const { nextConfig, nextCheckpoint, nextImageHash, payload } = entry!\n\n      if (bestCandidate) {\n        const bestCheckpoint = bestCandidate.checkpoint\n        if (longestPath) {\n          // Only consider candidates earlier than our current best\n          if (nextCheckpoint >= bestCheckpoint) continue\n        } else {\n          // Only consider candidates later than our current best\n          if (nextCheckpoint <= bestCheckpoint) continue\n        }\n      }\n\n      // Get all signatures (for all signers) for this subdigest\n      const signatures = new Map(\n        (\n          await Promise.all(\n            signers.map(async signer => {\n              const signature = await this.store.loadSignatureOfSubdigest(signer, payload.subdigest)\n              if (!signature) {\n                return [signer, undefined]\n              }\n\n              const replacedSignature = ethers.hexlify(\n                this.useEIP5719 ? await this.cachedEIP5719.runByEIP5719(signer, payload.subdigest, signature) : signature\n              )\n\n              const isDynamic = commons.signer.tryRecoverSigner(payload.subdigest, replacedSignature) !== signer\n\n              return [signer, { isDynamic, signature: replacedSignature }]\n            })\n          )\n        ).filter((signature): signature is [string, commons.signature.SignaturePart] => Boolean(signature[1]))\n      )\n\n      // Skip if we don't have ANY signatures (it can never reach the threshold)\n      if (signatures.size === 0) continue\n\n      // Encode the full signature (to see if it has enough weight)\n      const encoded = v2.signature.SignatureCoder.encodeSigners(fromConfig, signatures, [], 0)\n      if (encoded.weight < BigInt(fromConfig.threshold)) continue\n\n      // Save the new best candidate\n      bestCandidate = {\n        nextImageHash,\n        checkpoint: BigInt(nextConfig.checkpoint),\n        signature: encoded.encoded\n      }\n    }\n\n    if (!bestCandidate) {\n      return []\n    }\n\n    // Get the next step\n    const nextStep = await this.loadPresignedConfiguration({\n      wallet,\n      fromImageHash: bestCandidate.nextImageHash,\n      longestPath\n    })\n\n    return [\n      {\n        wallet,\n        nextImageHash: bestCandidate.nextImageHash,\n        signature: bestCandidate.signature\n      },\n      ...nextStep\n    ]\n  }\n\n  saveWitnesses = async (args: {\n    wallet: string\n    digest: string\n    chainId: ethers.BigNumberish\n    signatures: string[]\n  }): Promise<void> => {\n    const payload = {\n      digest: args.digest,\n      address: args.wallet,\n      chainId: args.chainId\n    }\n\n    const subdigest = commons.signature.subdigestOf(payload)\n\n    await Promise.all([\n      this.savePayload({ payload }),\n      ...args.signatures\n        .filter(signature => {\n          // We don't support saving witnesses for non-recoverable signatures\n          // we could change this eventually, but the issue is that the witness may become invalid\n          return commons.signer.canRecover(signature)\n        })\n        .map(signature => {\n          const signer = commons.signer.recoverSigner(subdigest, signature)\n          return this.store.saveSignatureOfSubdigest(signer, subdigest, signature)\n        })\n    ])\n  }\n\n  walletsOfSigner = async (args: {\n    signer: string\n  }): Promise<\n    {\n      wallet: string\n      proof: {\n        digest: string\n        chainId: bigint\n        signature: string\n      }\n    }[]\n  > => {\n    const subdigests = await this.store.loadSubdigestsOfSigner(args.signer)\n    const payloads = await Promise.all(subdigests.map(s => this.payloadOfSubdigest({ subdigest: s }))).then(\n      p => p.filter(p => p !== undefined) as commons.signature.SignedPayload[]\n    )\n\n    // filter unique wallets, and provide a proof for each wallet\n    const result: {\n      wallet: string\n      proof: {\n        digest: string\n        chainId: bigint\n        signature: string\n      }\n    }[] = []\n\n    for (const payload of payloads) {\n      const wallet = payload.address\n      if (result.find(r => r.wallet === wallet)) continue\n\n      const subdigest = commons.signature.subdigestOf(payload)\n      const signature = await this.store.loadSignatureOfSubdigest(args.signer, subdigest)\n      if (!signature) continue\n\n      result.push({\n        wallet,\n        proof: {\n          digest: payload.digest,\n          chainId: BigInt(payload.chainId),\n          signature: ethers.hexlify(signature)\n        }\n      })\n    }\n\n    return result\n  }\n\n  async saveMigration(\n    address: string,\n    signed: migrator.SignedMigration,\n    contexts: commons.context.VersionedContext\n  ): Promise<void> {\n    const fromVersion = signed.fromVersion\n    if (fromVersion !== 1) throw new Error('Migration not supported')\n    if (!v2.config.isWalletConfig(signed.toConfig)) throw new Error('Invalid to config')\n\n    // Validate migration transaction\n    const { newImageHash, address: decodedAddress } = migration.v1v2.decodeTransaction(signed.tx, contexts)\n    if (decodedAddress !== address) throw new Error('Invalid migration transaction - address')\n    if (v2.config.ConfigCoder.imageHashOf(signed.toConfig) != newImageHash)\n      throw new Error('Invalid migration transaction - config')\n\n    // Split signature and save each part\n    const message = commons.transaction.packMetaTransactionsData(signed.tx.nonce, signed.tx.transactions)\n    const digest = ethers.keccak256(message)\n    const payload = { chainId: signed.tx.chainId, message, address, digest }\n    const subdigest = commons.signature.subdigestOf(payload)\n\n    const savePayload = this.savePayload({ payload })\n    const saveToConfig = this.saveWalletConfig({ config: signed.toConfig })\n\n    const decoded = v1.signature.SignatureCoder.decode(signed.tx.signature)\n    const recovered = await v1.signature.SignatureCoder.recover(decoded, payload, this.provider)\n\n    // Save the recovered config, the migrate transaction, and all signature parts\n    const signatures = v1.signature.SignatureCoder.signaturesOf(recovered.config)\n\n    await Promise.all([\n      savePayload,\n      saveToConfig,\n      this.saveWalletConfig({ config: recovered.config }),\n      this.store.saveMigrationsSubdigest(address, fromVersion, fromVersion + 1, subdigest, newImageHash),\n      ...signatures.map(sig => this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))\n    ])\n  }\n\n  async getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    // Get the current config and all possible migration payloads\n    const [currentConfig, txs] = await Promise.all([\n      this.configOfImageHash({ imageHash: fromImageHash }),\n      this.store.loadMigrationsSubdigest(address, fromVersion, fromVersion + 1)\n    ])\n\n    const coder = universal.coderFor(fromVersion)\n    if (!currentConfig) {\n      // We may not be able to find the config, because the migration is still not copied locally\n      // in that case we consider as we don't have any migration\n      return undefined\n    }\n\n    if (!coder.config.isWalletConfig(currentConfig)) {\n      // throw new Error(\"Invalid from config - version\")\n      // better to not fail here, some other tracker may be able to handle this migration\n      return undefined\n    }\n\n    // We need to process every migration candidate individually\n    // and see which one has enough signers to be valid (for the current config)\n    const candidates = await Promise.all(\n      txs.map(async tx => {\n        const { subdigest, toImageHash } = tx\n        const payload = await this.payloadOfSubdigest({ subdigest })\n        if (!payload || !payload.message) return undefined\n        if (BigInt(chainId) !== BigInt(payload.chainId)) return undefined\n\n        const signers = coder.config.signersOf(currentConfig as any).map(s => s.address)\n\n        // Get all signatures (for all signers) for this subdigest\n        const signatures = new Map(\n          (\n            await Promise.all(\n              signers.map(async signer => {\n                const signature = await this.store.loadSignatureOfSubdigest(signer, subdigest)\n                if (!signature) {\n                  return [signer, undefined]\n                }\n\n                const replacedSignature = ethers.hexlify(\n                  this.useEIP5719 ? await this.cachedEIP5719.runByEIP5719(signer, subdigest, signature) : signature\n                )\n\n                const isDynamic = commons.signer.tryRecoverSigner(subdigest, replacedSignature) !== signer\n\n                return [signer, { isDynamic, signature: replacedSignature }]\n              })\n            )\n          ).filter((signature): signature is [string, commons.signature.SignaturePart] => Boolean(signature[1]))\n        )\n\n        // Encode signature parts into a single signature\n        const encoded = coder.signature.encodeSigners(currentConfig as any, signatures, [], chainId)\n        if (!encoded || encoded.weight < BigInt(currentConfig.threshold)) return undefined\n\n        // Unpack payload (it should have transactions)\n        const [nonce, transactions] = commons.transaction.unpackMetaTransactionsData(payload.message)\n\n        return {\n          tx: {\n            entrypoint: address,\n            transactions: commons.transaction.fromTxAbiEncode(transactions),\n            chainId: chainId,\n            nonce: nonce,\n            signature: encoded.encoded,\n            intent: {\n              id: subdigest,\n              wallet: address\n            }\n          },\n          toConfig: await this.configOfImageHash({ imageHash: toImageHash }),\n          fromVersion,\n          toVersion: fromVersion + 1\n        } as migrator.SignedMigration\n      })\n    ).then(c => c.filter(c => c !== undefined))\n\n    // Return the first valid candidate\n    return candidates[0]\n  }\n\n  updateProvider(provider: ethers.Provider) {\n    this.provider = provider\n  }\n}\n","/* eslint-disable */\n// sessions v0.0.1 4940f44019460e32d0d262c35967ec1fe0786f30\n// --\n// Code generated by webrpc-gen@v0.20.3 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=sessions.ridl -target=typescript -client -out=./clients/sessions.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = 'v1'\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = 'v0.0.1'\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = '4940f44019460e32d0d262c35967ec1fe0786f30'\n\n//\n// Types\n//\n\nexport enum SignatureType {\n  EIP712 = 'EIP712',\n  EthSign = 'EthSign',\n  EIP1271 = 'EIP1271'\n}\n\nexport interface RuntimeStatus {\n  healthy: boolean\n  started: string\n  uptime: number\n  version: string\n  branch: string\n  commit: string\n  arweave: ArweaveStatus\n}\n\nexport interface ArweaveStatus {\n  nodeURL: string\n  namespace: string\n  sender: string\n  signer: string\n  flushInterval: string\n  bundleDelay: string\n  bundleLimit: number\n  confirmations: number\n  lockTTL: string\n  healthy: boolean\n  lastFlush?: string\n  lastFlushSeconds?: number\n}\n\nexport interface Info {\n  wallets: { [key: string]: number }\n  configs: { [key: string]: number }\n  configTrees: number\n  migrations: { [key: string]: number }\n  signatures: number\n  digests: number\n  recorder: RecorderInfo\n  arweave: ArweaveInfo\n}\n\nexport interface RecorderInfo {\n  requests: number\n  buffer: number\n  lastFlush?: string\n  lastFlushSeconds?: number\n  endpoints: { [key: string]: number }\n}\n\nexport interface ArweaveInfo {\n  nodeURL: string\n  namespace: string\n  sender: ArweaveSenderInfo\n  signer: string\n  flushInterval: string\n  bundleDelay: string\n  bundleLimit: number\n  confirmations: number\n  lockTTL: string\n  healthy: boolean\n  lastFlush?: string\n  lastFlushSeconds?: number\n  bundles: number\n  pending: ArweavePendingInfo\n}\n\nexport interface ArweaveSenderInfo {\n  address: string\n  balance: string\n}\n\nexport interface ArweavePendingInfo {\n  wallets: number\n  configs: number\n  migrations: number\n  signatures: number\n  bundles: Array<ArweaveBundleInfo>\n}\n\nexport interface ArweaveBundleInfo {\n  transaction: string\n  block: number\n  items: number\n  sentAt: string\n  confirmations: number\n}\n\nexport interface Context {\n  version: number\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n  walletCreationCode: string\n}\n\nexport interface Signature {\n  digest: string\n  toImageHash?: string\n  chainID: string\n  type: SignatureType\n  signature: string\n  validOnChain?: string\n  validOnBlock?: string\n  validOnBlockHash?: string\n}\n\nexport interface SignerSignature {\n  signer?: string\n  signature: string\n}\n\nexport interface ConfigUpdate {\n  toImageHash: string\n  signature: string\n}\n\nexport interface Transaction {\n  to: string\n  value?: string\n  data?: string\n  gasLimit?: string\n  delegateCall?: boolean\n  revertOnError?: boolean\n}\n\nexport interface TransactionBundle {\n  executor: string\n  transactions: Array<Transaction>\n  nonce: string\n  signature: string\n}\n\nexport interface Sessions {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  config(args: ConfigArgs, headers?: object, signal?: AbortSignal): Promise<ConfigReturn>\n  wallets(args: WalletsArgs, headers?: object, signal?: AbortSignal): Promise<WalletsReturn>\n  deployHash(args: DeployHashArgs, headers?: object, signal?: AbortSignal): Promise<DeployHashReturn>\n  configUpdates(args: ConfigUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<ConfigUpdatesReturn>\n  migrations(args: MigrationsArgs, headers?: object, signal?: AbortSignal): Promise<MigrationsReturn>\n  saveConfig(args: SaveConfigArgs, headers?: object, signal?: AbortSignal): Promise<SaveConfigReturn>\n  saveWallet(args: SaveWalletArgs, headers?: object, signal?: AbortSignal): Promise<SaveWalletReturn>\n  saveSignature(args: SaveSignatureArgs, headers?: object, signal?: AbortSignal): Promise<SaveSignatureReturn>\n  saveSignerSignatures(\n    args: SaveSignerSignaturesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SaveSignerSignaturesReturn>\n  saveSignerSignatures2(\n    args: SaveSignerSignatures2Args,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SaveSignerSignatures2Return>\n  saveMigration(args: SaveMigrationArgs, headers?: object, signal?: AbortSignal): Promise<SaveMigrationReturn>\n}\n\nexport interface PingArgs {}\n\nexport interface PingReturn {}\nexport interface ConfigArgs {\n  imageHash: string\n}\n\nexport interface ConfigReturn {\n  version: number\n  config: any\n}\nexport interface WalletsArgs {\n  signer: string\n  cursor?: number\n  limit?: number\n}\n\nexport interface WalletsReturn {\n  wallets: { [key: string]: Signature }\n  cursor: number\n}\nexport interface DeployHashArgs {\n  wallet: string\n}\n\nexport interface DeployHashReturn {\n  deployHash: string\n  context: Context\n}\nexport interface ConfigUpdatesArgs {\n  wallet: string\n  fromImageHash: string\n  allUpdates?: boolean\n}\n\nexport interface ConfigUpdatesReturn {\n  updates: Array<ConfigUpdate>\n}\nexport interface MigrationsArgs {\n  wallet: string\n  fromVersion: number\n  fromImageHash: string\n  chainID?: string\n}\n\nexport interface MigrationsReturn {\n  migrations: { [key: string]: { [key: number]: { [key: string]: TransactionBundle } } }\n}\nexport interface SaveConfigArgs {\n  version: number\n  config: any\n}\n\nexport interface SaveConfigReturn {}\nexport interface SaveWalletArgs {\n  version: number\n  deployConfig: any\n}\n\nexport interface SaveWalletReturn {}\nexport interface SaveSignatureArgs {\n  wallet: string\n  digest: string\n  chainID: string\n  signature: string\n  toConfig?: any\n}\n\nexport interface SaveSignatureReturn {}\nexport interface SaveSignerSignaturesArgs {\n  wallet: string\n  digest: string\n  chainID: string\n  signatures: Array<string>\n  toConfig?: any\n}\n\nexport interface SaveSignerSignaturesReturn {}\nexport interface SaveSignerSignatures2Args {\n  wallet: string\n  digest: string\n  chainID: string\n  signatures: Array<SignerSignature>\n  toConfig?: any\n}\n\nexport interface SaveSignerSignatures2Return {}\nexport interface SaveMigrationArgs {\n  wallet: string\n  fromVersion: number\n  toVersion: number\n  toConfig: any\n  executor: string\n  transactions: Array<Transaction>\n  nonce: string\n  signature: string\n  chainID?: string\n}\n\nexport interface SaveMigrationReturn {}\n\n//\n// Client\n//\nexport class Sessions implements Sessions {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Sessions/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname.replace(/\\/*$/, '')\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  config = (args: ConfigArgs, headers?: object, signal?: AbortSignal): Promise<ConfigReturn> => {\n    return this.fetch(this.url('Config'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: <number>_data.version,\n            config: <any>_data.config\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  wallets = (args: WalletsArgs, headers?: object, signal?: AbortSignal): Promise<WalletsReturn> => {\n    return this.fetch(this.url('Wallets'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            wallets: <{ [key: string]: Signature }>_data.wallets,\n            cursor: <number>_data.cursor\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  deployHash = (args: DeployHashArgs, headers?: object, signal?: AbortSignal): Promise<DeployHashReturn> => {\n    return this.fetch(this.url('DeployHash'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            deployHash: <string>_data.deployHash,\n            context: <Context>_data.context\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  configUpdates = (args: ConfigUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<ConfigUpdatesReturn> => {\n    return this.fetch(this.url('ConfigUpdates'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            updates: <Array<ConfigUpdate>>_data.updates\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  migrations = (args: MigrationsArgs, headers?: object, signal?: AbortSignal): Promise<MigrationsReturn> => {\n    return this.fetch(this.url('Migrations'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            migrations: <{ [key: string]: { [key: number]: { [key: string]: TransactionBundle } } }>_data.migrations\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  saveConfig = (args: SaveConfigArgs, headers?: object, signal?: AbortSignal): Promise<SaveConfigReturn> => {\n    return this.fetch(this.url('SaveConfig'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  saveWallet = (args: SaveWalletArgs, headers?: object, signal?: AbortSignal): Promise<SaveWalletReturn> => {\n    return this.fetch(this.url('SaveWallet'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  saveSignature = (args: SaveSignatureArgs, headers?: object, signal?: AbortSignal): Promise<SaveSignatureReturn> => {\n    return this.fetch(this.url('SaveSignature'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  saveSignerSignatures = (\n    args: SaveSignerSignaturesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SaveSignerSignaturesReturn> => {\n    return this.fetch(this.url('SaveSignerSignatures'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  saveSignerSignatures2 = (\n    args: SaveSignerSignatures2Args,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<SaveSignerSignatures2Return> => {\n    return this.fetch(this.url('SaveSignerSignatures2'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  saveMigration = (args: SaveMigrationArgs, headers?: object, signal?: AbortSignal): Promise<SaveMigrationReturn> => {\n    return this.fetch(this.url('SaveMigration'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`\n      })\n    }\n    if (!res.ok) {\n      const code: number = typeof data.code === 'number' ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n// Schema errors\n\nexport class InvalidArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidArgument',\n    code: number = 1,\n    message: string = 'invalid argument',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidArgumentError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(name: string = 'NotFound', code: number = 2, message: string = 'not found', status: number = 0, cause?: string) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  InvalidArgument = 'InvalidArgument',\n  NotFound = 'NotFound'\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1]: InvalidArgumentError,\n  [2]: NotFoundError\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","import { commons, universal, v1, v2 } from '@0xsequence/core'\nimport { migrator } from '@0xsequence/migration'\nimport { ethers } from 'ethers'\nimport { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../../tracker'\nimport { Sessions, SignatureType, Transaction } from './sessions.gen'\n\nexport class RemoteConfigTracker implements ConfigTracker, migrator.PresignedMigrationTracker {\n  private readonly sessions: Sessions\n\n  constructor(\n    hostname: string,\n    public readonly onlyRecoverable: boolean = true\n  ) {\n    this.sessions = new Sessions(hostname, fetch)\n  }\n\n  async loadPresignedConfiguration(args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean\n  }): Promise<PresignedConfigLink[]> {\n    try {\n      const { updates } = await this.sessions.configUpdates({\n        wallet: args.wallet,\n        fromImageHash: args.fromImageHash,\n        allUpdates: args.longestPath\n      })\n\n      return updates.map(({ toImageHash, signature }) => ({ wallet: args.wallet, nextImageHash: toImageHash, signature }))\n    } catch (error) {\n      if (is404NotFound(error)) {\n        return []\n      } else {\n        throw error\n      }\n    }\n  }\n\n  async savePresignedConfiguration(args: PresignedConfig): Promise<void> {\n    const config = args.nextConfig\n    const imageHash = universal.genericCoderFor(config.version).config.imageHashOf(config)\n    const message = v2.signature.setImageHashStruct(imageHash)\n    const digest = ethers.keccak256(message)\n\n    await this.sessions.saveSignature({\n      wallet: args.wallet,\n      digest,\n      chainID: '0',\n      signature: args.signature,\n      toConfig: encodeConfig(config)\n    })\n  }\n\n  async saveWitnesses(args: {\n    wallet: string\n    digest: string\n    chainId: ethers.BigNumberish\n    signatures: string[]\n  }): Promise<void> {\n    let filteredSignatures = args.signatures\n    if (this.onlyRecoverable) {\n      filteredSignatures = filteredSignatures.filter(signature => {\n        return commons.signer.canRecover(signature)\n      })\n    }\n\n    await this.sessions.saveSignerSignatures({\n      wallet: args.wallet,\n      digest: args.digest,\n      chainID: numberString(args.chainId),\n      signatures: filteredSignatures\n    })\n  }\n\n  async configOfImageHash(args: { imageHash: string }): Promise<commons.config.Config | undefined> {\n    try {\n      const { version, config } = await this.sessions.config(args)\n      return decodeConfig(version, config)\n    } catch (error) {\n      if (is404NotFound(error)) {\n        return\n      } else {\n        throw error\n      }\n    }\n  }\n\n  async saveWalletConfig(args: { config: commons.config.Config }): Promise<void> {\n    const config = encodeConfig(args.config)\n    await this.sessions.saveConfig({ version: args.config.version, config })\n  }\n\n  async imageHashOfCounterfactualWallet(args: {\n    wallet: string\n  }): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> {\n    try {\n      const { deployHash, context } = await this.sessions.deployHash(args)\n      return { imageHash: deployHash, context }\n    } catch (error) {\n      if (is404NotFound(error)) {\n        return\n      } else {\n        throw error\n      }\n    }\n  }\n\n  async saveCounterfactualWallet(args: {\n    config: commons.config.Config\n    context: commons.context.WalletContext[]\n  }): Promise<void> {\n    const deployConfig = encodeConfig(args.config)\n    await this.sessions.saveWallet({ version: args.config.version, deployConfig })\n  }\n\n  async walletsOfSigner(args: {\n    signer: string\n  }): Promise<{ wallet: string; proof: { digest: string; chainId: bigint; signature: string } }[]> {\n    const { wallets } = await this.sessions.wallets(args)\n    return Object.entries(wallets).map(([wallet, { digest, chainID, type, signature }]) => {\n      switch (type) {\n        case SignatureType.EIP712:\n          signature += ethers.toBeHex(commons.signer.SigType.EIP712).slice(2)\n          break\n        case SignatureType.EthSign:\n          signature += ethers.toBeHex(commons.signer.SigType.ETH_SIGN).slice(2)\n          break\n        case SignatureType.EIP1271:\n          signature += ethers.toBeHex(commons.signer.SigType.WALLET_BYTES32).slice(2)\n          break\n      }\n\n      return {\n        wallet,\n        proof: {\n          digest,\n          signature,\n          chainId: BigInt(chainID)\n        }\n      }\n    })\n  }\n\n  async getMigration(\n    wallet: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    const chainIdString = numberString(chainId)\n    const { migrations } = await this.sessions.migrations({ wallet, fromVersion, fromImageHash, chainID: chainIdString })\n\n    const chooseMigration = async (chainId: string): Promise<migrator.SignedMigration | undefined> => {\n      const migrations_ = migrations[chainId]\n      if (migrations_) {\n        const toVersions = Object.keys(migrations_)\n          .map(Number)\n          .sort((a: number, b: number) => b - a)\n\n        for (const toVersion of toVersions) {\n          for (const [toHash, transactions] of Object.entries(migrations_[toVersion])) {\n            try {\n              const toConfig = await this.configOfImageHash({ imageHash: toHash })\n              if (toConfig) {\n                return {\n                  fromVersion,\n                  toVersion,\n                  toConfig,\n                  tx: {\n                    entrypoint: transactions.executor,\n                    transactions: transactions.transactions,\n                    nonce: transactions.nonce,\n                    signature: transactions.signature,\n                    chainId,\n                    intent: {\n                      id: commons.transaction.subdigestOfTransactions(\n                        wallet,\n                        chainId,\n                        transactions.nonce,\n                        transactions.transactions\n                      ),\n                      wallet\n                    }\n                  }\n                }\n              }\n            } catch (error) {\n              console.error(error)\n            }\n          }\n        }\n      }\n      return\n    }\n\n    const migration = await chooseMigration(chainIdString)\n    if (migration) {\n      return migration\n    }\n\n    for (const chainId in migrations) {\n      if (chainId !== chainIdString) {\n        const migration = await chooseMigration(chainId)\n        if (migration) {\n          return migration\n        }\n      }\n    }\n\n    return\n  }\n\n  async saveMigration(\n    wallet: string,\n    signed: migrator.SignedMigration,\n    _contexts: commons.context.VersionedContext\n  ): Promise<void> {\n    await this.sessions.saveMigration({\n      wallet,\n      fromVersion: signed.fromVersion,\n      toVersion: signed.toVersion,\n      toConfig: encodeConfig(signed.toConfig),\n      executor: signed.tx.entrypoint,\n      transactions: signed.tx.transactions.map(encodeTransaction),\n      nonce: numberString(signed.tx.nonce),\n      signature: signed.tx.signature,\n      chainID: numberString(signed.tx.chainId)\n    })\n  }\n}\n\ntype SessionsConfig = {\n  1: { threshold: number; signers: Array<{ weight: number; address: string }> }\n  2: { threshold: number; checkpoint: number; tree: V2SessionsConfigTree }\n}\n\ntype V2SessionsConfigTree =\n  | { left: V2SessionsConfigTree; right: V2SessionsConfigTree }\n  | { weight: number; address: string }\n  | { node: string }\n  | { weight: number; threshold: number; tree: V2SessionsConfigTree }\n  | { subdigest: string }\n\nfunction encodeConfig(config: commons.config.Config): SessionsConfig[1 | 2] {\n  switch (config.version) {\n    case 1:\n      if (v1.config.ConfigCoder.isWalletConfig(config)) {\n        return {\n          threshold: numberNumber(config.threshold),\n          signers: config.signers.map(({ weight, address }) => ({ weight: numberNumber(weight), address }))\n        }\n      } else {\n        throw new Error(`not a v${config.version} config: ${config}`)\n      }\n\n    case 2:\n      if (v2.config.ConfigCoder.isWalletConfig(config)) {\n        return {\n          threshold: numberNumber(config.threshold),\n          checkpoint: numberNumber(config.checkpoint),\n          tree: encodeV2ConfigTree(config.tree)\n        }\n      } else {\n        throw new Error(`not a v${config.version} config: ${config}`)\n      }\n\n    default:\n      throw new Error(`unknown version ${config.version}`)\n  }\n}\n\nfunction encodeV2ConfigTree(tree: v2.config.Topology): V2SessionsConfigTree {\n  if (v2.config.isNode(tree)) {\n    return {\n      left: encodeV2ConfigTree(tree.left),\n      right: encodeV2ConfigTree(tree.right)\n    }\n  } else if (v2.config.isSignerLeaf(tree)) {\n    return {\n      weight: numberNumber(tree.weight),\n      address: tree.address\n    }\n  } else if (v2.config.isNestedLeaf(tree)) {\n    return {\n      weight: numberNumber(tree.weight),\n      threshold: numberNumber(tree.threshold),\n      tree: encodeV2ConfigTree(tree.tree)\n    }\n  } else if (v2.config.isNodeLeaf(tree)) {\n    return { node: tree.nodeHash }\n  } else {\n    return { ...tree }\n  }\n}\n\nfunction decodeConfig(version: number, config: any): commons.config.Config {\n  switch (version) {\n    case 1:\n      return { ...config, version }\n\n    case 2:\n      return { ...config, version, tree: decodeV2ConfigTree(config.tree) }\n\n    default:\n      throw new Error(`unknown version ${version}`)\n  }\n}\n\nfunction decodeV2ConfigTree(tree: any): v2.config.Topology {\n  switch (typeof tree) {\n    case 'object':\n      const tree_ = { ...tree }\n\n      if (tree_.left !== undefined) {\n        tree_.left = decodeV2ConfigTree(tree_.left)\n      }\n\n      if (tree_.right !== undefined) {\n        tree_.right = decodeV2ConfigTree(tree_.right)\n      }\n\n      if (tree_.tree !== undefined) {\n        tree_.tree = decodeV2ConfigTree(tree_.tree)\n      }\n\n      if (tree_.node !== undefined) {\n        tree_.nodeHash = tree_.node\n        delete tree_.node\n      }\n\n      return tree_\n\n    default:\n      throw new Error(`v2 config tree ${tree} is not an object`)\n  }\n}\n\nfunction encodeTransaction(transaction: commons.transaction.Transaction): Transaction {\n  return {\n    to: transaction.to,\n    value: transaction.value !== undefined ? numberString(transaction.value) : undefined,\n    data: transaction.data !== undefined ? ethers.hexlify(transaction.data) : undefined,\n    gasLimit: transaction.gasLimit !== undefined ? numberString(transaction.gasLimit) : undefined,\n    delegateCall: transaction.delegateCall,\n    revertOnError: transaction.revertOnError\n  }\n}\n\nfunction numberNumber(n: ethers.BigNumberish): number {\n  return Number(n)\n}\n\nfunction numberString(n: ethers.BigNumberish): string {\n  return BigInt(n).toString()\n}\n\nfunction is404NotFound(error: any): boolean {\n  return typeof error === 'object' && error.status === 404\n}\n","import { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../tracker'\nimport { migrator } from '@0xsequence/migration'\n\nimport { commons, universal } from '@0xsequence/core'\nimport { LocalConfigTracker } from './local'\nimport { ethers } from 'ethers'\n\nexport function raceUntil<T>(promises: Promise<T>[], fallback: T, evalRes: (val: T) => boolean): Promise<T> {\n  return new Promise(resolve => {\n    let count = 0\n\n    promises.forEach(p =>\n      p\n        .then((val: T) => {\n          if (evalRes(val)) {\n            resolve(val)\n          } else {\n            count++\n            if (count === promises.length) {\n              resolve(fallback)\n            }\n          }\n        })\n        .catch(() => {\n          // Ignore\n          count++\n          if (count === promises.length) {\n            resolve(fallback)\n          }\n        })\n    )\n  })\n}\n\nexport async function allSafe<T>(promises: Promise<T>[], fallback: T): Promise<T[]> {\n  return Promise.all(promises.map(promise => promise.catch(() => fallback)))\n}\n\nexport class MultipleTracker implements migrator.PresignedMigrationTracker, ConfigTracker {\n  constructor(private trackers: (migrator.PresignedMigrationTracker & ConfigTracker)[]) {}\n\n  async configOfImageHash(args: { imageHash: string }): Promise<commons.config.Config | undefined> {\n    const requests = this.trackers.map(async (t, i) => ({ res: await t.configOfImageHash(args), i }))\n\n    // We try to find a complete configuration, we race so that we don't wait for all trackers to respond\n    const result1 = await raceUntil(requests, undefined, val => {\n      if (val?.res === undefined) return false\n      return universal.genericCoderFor(val.res.version).config.isComplete(val.res)\n    })\n\n    if (result1?.res) {\n      // Skip saving the config to the tracker that returned the result\n      this.saveWalletConfig({ config: result1.res, skipTracker: result1.i })\n      return result1.res\n    }\n\n    // If we haven't found a complete configuration yet, it either means that the configuration is not complete\n    // (and thus we need to combine all results) or that the configuration is not found at all\n    // but we try to combine all results anyway\n    const tmptracker = new LocalConfigTracker(undefined as any) // TODO: Fix this, provider not needed anyway\n\n    const results = await allSafe(requests, undefined)\n\n    for (const r of results) {\n      if (r?.res) await tmptracker.saveWalletConfig({ config: r.res })\n    }\n\n    const result2 = await tmptracker.configOfImageHash(args)\n    if (result2) this.saveWalletConfig({ config: result2 })\n    return result2\n  }\n\n  async saveWalletConfig(args: { config: commons.config.Config; skipTracker?: number }): Promise<void> {\n    await Promise.all(\n      this.trackers.map((t, i) => {\n        if (i === args.skipTracker) return\n        return t.saveWalletConfig(args)\n      })\n    )\n  }\n\n  async imageHashOfCounterfactualWallet(args: {\n    wallet: string\n  }): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> {\n    const imageHash = await raceUntil(\n      this.trackers.map(t => t.imageHashOfCounterfactualWallet(args)),\n      undefined,\n      result => Boolean(result)\n    )\n\n    if (imageHash) {\n      this.configOfImageHash({ imageHash: imageHash.imageHash }).then(config => {\n        if (config) {\n          this.saveCounterfactualWallet({ config, context: [imageHash.context] })\n        }\n      })\n    }\n\n    return imageHash\n  }\n\n  async saveCounterfactualWallet(args: {\n    config: commons.config.Config\n    context: commons.context.WalletContext[]\n    skipTracker?: number\n  }): Promise<void> {\n    await Promise.all(\n      this.trackers.map((t, i) => {\n        if (i === args.skipTracker) return\n        return t.saveCounterfactualWallet(args)\n      })\n    )\n  }\n\n  async walletsOfSigner(args: {\n    signer: string\n  }): Promise<{ wallet: string; proof: { digest: string; chainId: bigint; signature: string } }[]> {\n    // We can't race here, because there is no \"correct\" response\n    // we just return the union of all results, skipping duplicates\n    const results = await allSafe(\n      this.trackers.map(t => t.walletsOfSigner(args)),\n      []\n    ).then(r => r.flat())\n\n    const wallets: { [wallet: string]: { digest: string; chainId: bigint; signature: string } } = {}\n    for (const r of results) {\n      wallets[r.wallet] = r.proof\n    }\n\n    // TODO: This will send redundant information back to the trackers\n    // consider optimizing this for better performance during login\n\n    const result = Object.keys(wallets).map(w => ({ wallet: w, proof: wallets[w] }))\n\n    const witnesses = new Map<string, { wallet: string; digest: string; chainId: bigint; signatures: string[] }>()\n    result.forEach(({ wallet, proof: { digest, chainId, signature } }) => {\n      const key = `${wallet}-${digest}-${chainId}`\n      let signatures = witnesses.get(key)\n      if (!signatures) {\n        signatures = { wallet, digest, chainId, signatures: [] }\n        witnesses.set(key, signatures)\n      }\n      signatures.signatures.push(signature)\n    })\n    witnesses.forEach(witnesses => this.saveWitnesses(witnesses))\n\n    return result\n  }\n\n  async saveWitnesses(args: {\n    wallet: string\n    digest: string\n    chainId: ethers.BigNumberish\n    signatures: string[]\n  }): Promise<void> {\n    await Promise.all(this.trackers.map(t => t.saveWitnesses(args)))\n  }\n\n  async loadPresignedConfiguration(args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean | undefined\n  }): Promise<PresignedConfigLink[]> {\n    // We can't race here, because any of the trackers could have a new \"link\" in the chain\n    const results = await allSafe(\n      this.trackers.map(t => t.loadPresignedConfiguration(args)),\n      []\n    )\n\n    // The \"best\" result is the one with the highest checkpoint\n    const checkpoints = await allSafe(\n      results.map(async r => {\n        const last = r[r.length - 1]\n\n        // TODO: This will fire a lot of requests, optimize it\n        const config = await this.configOfImageHash({ imageHash: last.nextImageHash })\n        if (!config) return undefined\n\n        return { checkpoint: universal.genericCoderFor(config.version).config.checkpointOf(config), result: r }\n      }),\n      undefined\n    )\n\n    const best = checkpoints.reduce((acc, val) => {\n      if (!val) return acc\n      if (!acc) return val\n      if (val.checkpoint > acc.checkpoint) return val\n      return acc\n    })\n\n    if (!best) return []\n\n    const configs = new Map<string, Promise<commons.config.Config | undefined>>()\n    const config = (imageHash: string): Promise<commons.config.Config | undefined> => {\n      if (!configs.has(imageHash)) {\n        configs.set(imageHash, this.configOfImageHash({ imageHash }))\n      }\n      return configs.get(imageHash)!\n    }\n    best.result.forEach(async res => {\n      const nextConfig = await config(res.nextImageHash)\n      if (nextConfig) {\n        this.savePresignedConfiguration({\n          wallet: args.wallet,\n          nextConfig,\n          signature: res.signature\n        })\n      }\n    })\n\n    return best.result\n  }\n\n  async savePresignedConfiguration(args: PresignedConfig): Promise<void> {\n    await Promise.all(this.trackers.map(t => t.savePresignedConfiguration(args)))\n  }\n\n  async getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    // TODO: Backfeed migration results to other trackers\n    const results = await Promise.all(this.trackers.map(t => t.getMigration(address, fromImageHash, fromVersion, chainId)))\n    return results.find(r => !!r)\n  }\n\n  async saveMigration(\n    address: string,\n    signed: migrator.SignedMigration,\n    contexts: commons.context.VersionedContext\n  ): Promise<void> {\n    await Promise.all(this.trackers.map(t => t.saveMigration(address, signed, contexts)))\n  }\n}\n","import { ethers } from 'ethers'\n\nexport class PromiseCache {\n  private readonly cache: Map<string, Entry>\n\n  constructor() {\n    this.cache = new Map()\n  }\n\n  do<S extends Array<unknown>, T>(\n    key: string,\n    validMilliseconds: number | undefined,\n    task: (...args: S) => Promise<T>,\n    ...args: S\n  ): Promise<T> {\n    key = `${key}:${ethers.id(JSON.stringify(args, deterministically))}`\n\n    let entry = this.cache.get(key)\n\n    if (entry) {\n      if (entry.expiration) {\n        if (new Date() >= entry.expiration) {\n          entry = undefined\n          this.cache.delete(key)\n        }\n      }\n    }\n\n    if (!entry) {\n      const entry_: Entry = { promise: task(...args) }\n\n      if (validMilliseconds !== undefined) {\n        entry_.promise = entry_.promise.then(result => {\n          entry_.expiration = new Date(Date.now() + validMilliseconds)\n          return result\n        })\n      }\n\n      entry = entry_\n      this.cache.set(key, entry)\n    }\n\n    return entry.promise as Promise<T>\n  }\n}\n\ntype Entry = {\n  promise: Promise<unknown>\n  expiration?: Date\n}\n\nfunction deterministically(_key: string, value: any): any {\n  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n    return Object.fromEntries(Object.entries(value).sort())\n  } else if (typeof value === 'bigint') {\n    return value.toString()\n  }\n\n  return value\n}\n","import { commons } from '@0xsequence/core'\nimport { migrator } from '@0xsequence/migration'\n\nimport { ethers } from 'ethers'\nimport { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../tracker'\nimport { PromiseCache } from './promise-cache'\nimport { LocalConfigTracker } from './local'\n\nexport function isDedupedTracker(tracker: any): tracker is DedupedTracker {\n  return tracker instanceof DedupedTracker\n}\n\n// This tracks wraps another tracker and dedupes calls to it, so in any calls\n// are sent in short succession, only the first call is forwarded to the\n// underlying tracker, and the rest are ignored.\nexport class DedupedTracker implements migrator.PresignedMigrationTracker, ConfigTracker {\n  private cache: PromiseCache = new PromiseCache()\n\n  constructor(\n    private readonly tracker: migrator.PresignedMigrationTracker & ConfigTracker,\n    public readonly window = 50,\n    public verbose = false\n  ) {}\n\n  invalidateCache() {\n    this.cache = new PromiseCache()\n  }\n\n  configOfImageHash(args: { imageHash: string }): Promise<commons.config.Config | undefined> {\n    return this.cache.do('configOfImageHash', this.window, args => this.tracker.configOfImageHash(args), args)\n  }\n\n  getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    return this.cache.do(\n      'getMigration',\n      this.window,\n      (...args) => this.tracker.getMigration(...args),\n      address,\n      fromImageHash,\n      fromVersion,\n      chainId\n    )\n  }\n\n  saveMigration(address: string, signed: migrator.SignedMigration, contexts: commons.context.VersionedContext): Promise<void> {\n    return this.cache.do('saveMigration', undefined, (...args) => this.tracker.saveMigration(...args), address, signed, contexts)\n  }\n\n  loadPresignedConfiguration(args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean | undefined\n  }): Promise<PresignedConfigLink[]> {\n    return this.cache.do('loadPresignedConfiguration', this.window, args => this.tracker.loadPresignedConfiguration(args), args)\n  }\n\n  savePresignedConfiguration(args: PresignedConfig): Promise<void> {\n    return this.cache.do('savePresignedConfiguration', undefined, args => this.tracker.savePresignedConfiguration(args), args)\n  }\n\n  saveWitnesses(args: { wallet: string; digest: string; chainId: ethers.BigNumberish; signatures: string[] }): Promise<void> {\n    return this.cache.do('saveWitnesses', undefined, args => this.tracker.saveWitnesses(args), args)\n  }\n\n  saveWalletConfig(args: { config: commons.config.Config }): Promise<void> {\n    return this.cache.do('saveWalletConfig', undefined, args => this.tracker.saveWalletConfig(args), args)\n  }\n\n  imageHashOfCounterfactualWallet(args: {\n    wallet: string\n  }): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> {\n    return this.cache.do(\n      'imageHashOfCounterfactualWallet',\n      undefined,\n      args => this.tracker.imageHashOfCounterfactualWallet(args),\n      args\n    )\n  }\n\n  saveCounterfactualWallet(args: { config: commons.config.Config; context: commons.context.WalletContext[] }): Promise<void> {\n    return this.cache.do('saveCounterfactualWallet', undefined, args => this.tracker.saveCounterfactualWallet(args), args)\n  }\n\n  walletsOfSigner(args: {\n    signer: string\n  }): Promise<{ wallet: string; proof: { digest: string; chainId: bigint; signature: string } }[]> {\n    return this.cache.do('walletsOfSigner', this.window, args => this.tracker.walletsOfSigner(args), args)\n  }\n\n  updateProvider(provider: ethers.Provider) {\n    if (this.tracker instanceof LocalConfigTracker) {\n      this.tracker.updateProvider(provider)\n    }\n  }\n}\n","import { commons, universal } from '@0xsequence/core'\nimport { migrator } from '@0xsequence/migration'\nimport { ConfigTracker, PresignedConfig, PresignedConfigLink } from '../tracker'\nimport { ethers } from 'ethers'\n\nexport class CachedTracker implements migrator.PresignedMigrationTracker, ConfigTracker {\n  constructor(\n    private readonly tracker: migrator.PresignedMigrationTracker & ConfigTracker,\n    private readonly cache: migrator.PresignedMigrationTracker & ConfigTracker,\n    public readonly contexts: commons.context.VersionedContext\n  ) {}\n\n  async loadPresignedConfiguration(args: {\n    wallet: string\n    fromImageHash: string\n    longestPath?: boolean | undefined\n  }): Promise<PresignedConfigLink[]> {\n    // We need to check both, and return the one with the highest checkpoint\n    // eventually we could try to combine them, but for now we'll just return\n    // the one with the highest checkpoint\n    const results = [this.tracker.loadPresignedConfiguration(args), this.cache.loadPresignedConfiguration(args)]\n\n    let best: PresignedConfigLink[]\n\n    // If both results end with the same image hash, we can just return the longest/shortest one\n    const [result1, result2] = await Promise.all(results)\n    if (\n      result1.length > 0 &&\n      result2.length > 0 &&\n      result1[result1.length - 1].nextImageHash === result2[result2.length - 1].nextImageHash\n    ) {\n      best =\n        args.longestPath === true\n          ? result1.length > result2.length\n            ? result1\n            : result2\n          : result1.length < result2.length\n            ? result1\n            : result2\n    } else {\n      // Otherwise we need to check the checkpoints\n      // this requires us to fetch the config for each image hash\n      const checkpoints = await Promise.all(\n        results.map(async result => {\n          const r = await result\n          const last = r[r.length - 1]\n          if (!last) return undefined\n\n          // TODO: This will fire a lot of requests, optimize it\n          const config = await this.configOfImageHash({ imageHash: last.nextImageHash })\n          if (!config) return undefined\n\n          return { checkpoint: universal.genericCoderFor(config.version).config.checkpointOf(config), result: r }\n        })\n      )\n\n      best =\n        checkpoints.reduce((acc, val) => {\n          if (!val) return acc\n          if (!acc) return val\n          if (val.checkpoint > acc.checkpoint) return val\n          return acc\n        })?.result ?? []\n    }\n\n    if (!best) return []\n\n    return best\n  }\n\n  async savePresignedConfiguration(args: PresignedConfig): Promise<void> {\n    await Promise.all([this.tracker.savePresignedConfiguration(args), this.cache.savePresignedConfiguration(args)])\n  }\n\n  async configOfImageHash(args: { imageHash: string; noCache?: boolean }): Promise<commons.config.Config | undefined> {\n    // We first check the cache, if it's not there, we check the tracker\n    // and then we save it to the cache\n    if (args.noCache !== true) {\n      const config = await this.cache.configOfImageHash(args)\n      if (config) return config\n    }\n\n    const config2 = await this.tracker.configOfImageHash(args)\n    if (config2) {\n      await this.cache.saveWalletConfig({ config: config2 })\n    }\n\n    return config2\n  }\n\n  async saveWalletConfig(args: { config: commons.config.Config }): Promise<void> {\n    await Promise.all([this.tracker.saveWalletConfig(args), this.cache.saveWalletConfig(args)])\n  }\n\n  async imageHashOfCounterfactualWallet(args: {\n    wallet: string\n    noCache?: boolean\n  }): Promise<{ imageHash: string; context: commons.context.WalletContext } | undefined> {\n    // We first check the cache, if it's not there, we check the tracker\n    // and then we save it to the cache\n    if (args.noCache !== true) {\n      const result1 = await this.cache.imageHashOfCounterfactualWallet(args)\n      if (result1) return result1\n    }\n\n    const result2 = await this.tracker.imageHashOfCounterfactualWallet(args)\n    if (result2) {\n      // TODO: We shouldn't need to get the config to save the counterfactual wallet\n      const config = await this.configOfImageHash({ imageHash: result2.imageHash })\n      if (config) {\n        await this.cache.saveCounterfactualWallet({ config, context: [result2.context] })\n      }\n    }\n\n    return result2\n  }\n\n  async saveCounterfactualWallet(args: {\n    config: commons.config.Config\n    context: commons.context.WalletContext[]\n  }): Promise<void> {\n    await Promise.all([this.tracker.saveCounterfactualWallet(args), this.cache.saveCounterfactualWallet(args)])\n  }\n\n  async walletsOfSigner(args: {\n    signer: string\n    noCache?: boolean\n  }): Promise<{ wallet: string; proof: { digest: string; chainId: bigint; signature: string } }[]> {\n    if (args.noCache) {\n      return this.tracker.walletsOfSigner(args)\n    }\n\n    // In this case we need to both aggregate the results from the cache and the tracker\n    // and then dedupe the results\n    const results = await Promise.all([this.tracker.walletsOfSigner(args), this.cache.walletsOfSigner(args)])\n    const wallets = new Map<string, { wallet: string; proof: { digest: string; chainId: bigint; signature: string } }>()\n\n    for (const result of results) {\n      for (const wallet of result) {\n        wallets.set(wallet.wallet, wallet)\n      }\n    }\n\n    return Array.from(wallets.values())\n  }\n\n  async saveWitnesses(args: {\n    wallet: string\n    digest: string\n    chainId: ethers.BigNumberish\n    signatures: string[]\n  }): Promise<void> {\n    await Promise.all([this.tracker.saveWitnesses(args), this.cache.saveWitnesses(args)])\n  }\n\n  async getMigration(\n    address: string,\n    fromImageHash: string,\n    fromVersion: number,\n    chainId: ethers.BigNumberish\n  ): Promise<migrator.SignedMigration | undefined> {\n    // We first check the cache, if it's not there, we check the tracker\n    // NOTICE: we could eventually try to combine the two, but now we just have 1 migration\n    // so it's not worth it.\n    const migration1 = await this.cache.getMigration(address, fromImageHash, fromVersion, chainId)\n    if (migration1) return migration1\n\n    const migration2 = await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId)\n    if (migration2) {\n      await this.cache.saveMigration(address, migration2, this.contexts)\n    }\n\n    return migration2\n  }\n\n  async saveMigration(\n    address: string,\n    signed: migrator.SignedMigration,\n    contexts: commons.context.VersionedContext\n  ): Promise<void> {\n    await Promise.all([\n      this.tracker.saveMigration(address, signed, contexts),\n      this.cache.saveMigration(address, signed, contexts)\n    ])\n  }\n}\n","import { ChainId, NetworkConfig, allNetworks, findNetworkConfig } from '@0xsequence/network'\nimport { jwtDecodeClaims } from '@0xsequence/utils'\nimport { Account } from '@0xsequence/account'\nimport { ethers } from 'ethers'\nimport { tracker, trackers } from '@0xsequence/sessions'\nimport { Orchestrator, SignatureOrchestrator, signers } from '@0xsequence/signhub'\nimport { migrator } from '@0xsequence/migration'\nimport { commons, universal, v1 } from '@0xsequence/core'\nimport { Services, ServicesSettings, SessionJWT, SessionMeta } from './services'\n\nexport interface SessionDumpV1 {\n  config: Omit<v1.config.WalletConfig, 'version'> & { address?: string }\n  jwt?: SessionJWT\n  metadata: SessionMeta\n}\n\nexport interface SessionDumpV2 {\n  version: 2\n  address: string\n  jwt?: SessionJWT\n  metadata?: SessionMeta\n}\n\nexport function isSessionDumpV1(obj: any): obj is SessionDumpV1 {\n  return obj.config && obj.metadata && obj.version === undefined\n}\n\nexport function isSessionDumpV2(obj: any): obj is SessionDumpV2 {\n  return obj.version === 2 && obj.address\n}\n\n// These chains are always validated for migrations\n// if they are not available, the login will fail\nexport const CRITICAL_CHAINS = [1, 137]\n\nexport type SessionSettings = {\n  services?: ServicesSettings\n  contexts: commons.context.VersionedContext\n  networks: NetworkConfig[]\n  tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker\n}\n\nexport const SessionSettingsDefault: SessionSettings = {\n  contexts: commons.context.defaultContexts,\n  networks: allNetworks,\n  tracker: new trackers.remote.RemoteConfigTracker('https://sessions.sequence.app')\n}\n\nexport class Session {\n  constructor(\n    public networks: NetworkConfig[],\n    public contexts: commons.context.VersionedContext,\n    public account: Account,\n    public services?: Services\n  ) {}\n\n  async dump(): Promise<SessionDumpV2> {\n    const base = {\n      version: 2 as const,\n      address: this.account.address\n    }\n\n    if (this.services) {\n      return {\n        ...base,\n        ...(await this.services.dump())\n      }\n    }\n\n    return base\n  }\n\n  static async singleSigner(args: {\n    settings?: Partial<SessionSettings>\n    signer: ethers.Signer | signers.SapientSigner | string\n    selectWallet?: (wallets: string[]) => Promise<string | undefined>\n    onAccountAddress?: (address: string) => void\n    onMigration?: (account: Account) => Promise<boolean>\n    editConfigOnMigration?: (config: commons.config.Config) => commons.config.Config\n    projectAccessKey: string\n  }): Promise<Session> {\n    let { signer } = args\n\n    if (typeof signer === 'string') {\n      signer = new ethers.Wallet(signer)\n    }\n\n    const orchestrator = new Orchestrator([signer])\n    const referenceSigner = await signer.getAddress()\n    const threshold = 1\n    const addSigners = [\n      {\n        weight: 1,\n        address: referenceSigner\n      }\n    ]\n\n    const selectWallet =\n      args.selectWallet ||\n      (async (wallets: string[]) => {\n        if (wallets.length === 0) return undefined\n\n        // Find a wallet that was originally created\n        // as a 1/1 of the reference signer\n        const tracker = args.settings?.tracker ?? SessionSettingsDefault.tracker\n\n        const configs = await Promise.all(\n          wallets.map(async wallet => {\n            const imageHash = await tracker.imageHashOfCounterfactualWallet({ wallet })\n\n            return {\n              wallet,\n              config: imageHash && (await tracker.configOfImageHash({ imageHash: imageHash.imageHash }))\n            }\n          })\n        )\n\n        for (const config of configs) {\n          if (!config.config) {\n            continue\n          }\n\n          const coder = universal.genericCoderFor(config.config.version)\n          const signers = coder.config.signersOf(config.config)\n\n          if (signers.length === 1 && signers[0].address === referenceSigner) {\n            return config.wallet\n          }\n        }\n\n        return undefined\n      })\n\n    return Session.open({\n      ...args,\n      orchestrator,\n      referenceSigner,\n      threshold,\n      addSigners,\n      selectWallet\n    })\n  }\n\n  static async open(args: {\n    settings?: Partial<SessionSettings>\n    orchestrator: SignatureOrchestrator\n    addSigners?: commons.config.SimpleSigner[]\n    referenceSigner: string\n    threshold?: ethers.BigNumberish\n    selectWallet: (wallets: string[]) => Promise<string | undefined>\n    onAccountAddress?: (address: string) => void\n    editConfigOnMigration?: (config: commons.config.Config) => commons.config.Config\n    onMigration?: (account: Account) => Promise<boolean>\n    projectAccessKey?: string\n  }): Promise<Session> {\n    const {\n      referenceSigner,\n      threshold,\n      addSigners,\n      selectWallet,\n      onAccountAddress,\n      settings,\n      editConfigOnMigration,\n      onMigration,\n      orchestrator,\n      projectAccessKey\n    } = args\n\n    const { contexts, networks, tracker, services } = { ...SessionSettingsDefault, ...settings }\n\n    // The reference network is mainnet, if mainnet is not available, we use the first network\n    const referenceChainId =\n      findNetworkConfig(networks, settings?.services?.sequenceApiChainId ?? ChainId.MAINNET)?.chainId ?? networks[0]?.chainId\n    if (!referenceChainId) throw Error('No reference chain found')\n\n    const foundWallets = await tracker.walletsOfSigner({ signer: referenceSigner })\n    const selectedWallet = await selectWallet(foundWallets.map(w => w.wallet))\n\n    let account: Account\n\n    if (selectedWallet) {\n      onAccountAddress?.(selectedWallet)\n\n      // existing account, lets update it\n      account = new Account({\n        address: selectedWallet,\n        tracker,\n        networks,\n        contexts,\n        orchestrator,\n        projectAccessKey\n      })\n\n      // Get the latest configuration of the wallet (on the reference chain)\n      // now this configuration should be of the latest version, so we can start\n      // manipulating it.\n\n      // NOTICE: We are performing the wallet update on a single chain, assuming that\n      // all other networks have the same configuration. This is not always true.\n      if (addSigners && addSigners.length > 0) {\n        // New wallets never need migrations\n        // (because we create them on the latest version)\n        let status = await account.status(referenceChainId)\n\n        // If the wallet was created originally on v2, then we can skip\n        // the migration checks all together.\n        if (status.original.version !== status.version || account.version !== status.version) {\n          // Account may not have been migrated yet, so we need to check\n          // if it has been migrated and if not, migrate it (in all chains)\n          const { migratedAllChains: isFullyMigrated, failedChains } = await account.isMigratedAllChains()\n\n          // Failed chains must not contain mainnet or polygon, otherwise we cannot proceed.\n          if (failedChains.some(c => CRITICAL_CHAINS.includes(c))) {\n            throw Error(`Failed to fetch account status on ${failedChains.join(', ')}`)\n          }\n\n          if (!isFullyMigrated) {\n            // This is an oportunity for whoever is opening the session to\n            // feed the orchestrator with more signers, so that the migration\n            // can be completed.\n            if (onMigration && !(await onMigration(account))) {\n              throw Error('Migration cancelled, cannot open session')\n            }\n\n            const { failedChains } = await account.signAllMigrations(editConfigOnMigration || (c => c))\n            if (failedChains.some(c => CRITICAL_CHAINS.includes(c))) {\n              throw Error(`Failed to sign migrations on ${failedChains.join(', ')}`)\n            }\n\n            // If we are using a dedupped tracker we need to invalidate the cache\n            // otherwise we run the risk of not seeing the signed migrations reflected.\n            if (trackers.isDedupedTracker(tracker)) {\n              tracker.invalidateCache()\n            }\n\n            let isFullyMigrated2: boolean\n            ;[isFullyMigrated2, status] = await Promise.all([\n              account.isMigratedAllChains().then(r => r.migratedAllChains),\n              account.status(referenceChainId)\n            ])\n\n            if (!isFullyMigrated2) throw Error('Failed to migrate account')\n          }\n        }\n\n        // NOTICE: We only need to do this because the API will not be able to\n        // validate the v2 signature (if the account has an onchain version of 1)\n        // we could speed this up by sending the migration alongside the jwt request\n        // and letting the API validate it offchain.\n        if (status.onChain.version !== status.version) {\n          await account.doBootstrap(referenceChainId, undefined, status)\n        }\n\n        const prevConfig = status.config\n        const nextConfig = account.coders.config.editConfig(prevConfig, {\n          add: addSigners,\n          threshold\n        })\n\n        // Only update the onchain config if the imageHash has changed\n        if (account.coders.config.imageHashOf(prevConfig) !== account.coders.config.imageHashOf(nextConfig)) {\n          const newConfig = account.coders.config.editConfig(nextConfig, {\n            checkpoint: account.coders.config.checkpointOf(prevConfig) + 1n\n          })\n\n          await account.updateConfig(newConfig)\n        }\n      }\n    } else {\n      if (!addSigners || addSigners.length === 0) {\n        throw Error('Cannot create new account without signers')\n      }\n\n      if (!threshold) {\n        throw Error('Cannot create new account without threshold')\n      }\n\n      // fresh account\n      account = await Account.new({\n        config: { threshold, checkpoint: 0, signers: addSigners },\n        tracker,\n        contexts,\n        orchestrator,\n        networks,\n        projectAccessKey\n      })\n\n      onAccountAddress?.(account.address)\n\n      // sign a digest and send it to the tracker\n      // otherwise the tracker will not know about this account\n      await account.publishWitness()\n\n      // safety check, the remove tracker should be able to find\n      // this account for the reference signer\n      const foundWallets = await tracker.walletsOfSigner({ signer: referenceSigner, noCache: true })\n      if (!foundWallets.some(w => w.wallet === account.address)) {\n        throw Error('Account not found on tracker')\n      }\n    }\n\n    let servicesObj: Services | undefined\n\n    if (services) {\n      servicesObj = new Services(account, services)\n      servicesObj.auth() // fire and forget\n\n      servicesObj.onAuth(result => {\n        if (result.status === 'fulfilled') {\n          account.setJwt(result.value)\n        }\n      })\n    }\n\n    return new Session(networks, contexts, account, servicesObj)\n  }\n\n  static async load(args: {\n    settings?: Partial<SessionSettings>\n    orchestrator: SignatureOrchestrator\n    dump: SessionDumpV1 | SessionDumpV2\n    editConfigOnMigration: (config: commons.config.Config) => commons.config.Config\n    onMigration?: (account: Account) => Promise<boolean>\n  }): Promise<Session> {\n    const { dump, settings, editConfigOnMigration, onMigration, orchestrator } = args\n    const { contexts, networks, tracker, services } = { ...SessionSettingsDefault, ...settings }\n\n    let account: Account\n\n    if (isSessionDumpV1(dump)) {\n      // Old configuration format used to also contain an \"address\" field\n      // but if it doesn't, it means that it was a \"counterfactual\" account\n      // not yet updated, so we need to compute the address\n      const oldAddress =\n        dump.config.address ||\n        commons.context.addressOf(contexts[1], v1.config.ConfigCoder.imageHashOf({ ...dump.config, version: 1 }))\n\n      const jwtExpired = (dump.jwt?.expiration ?? 0) < Math.floor(Date.now() / 1000)\n\n      account = new Account({\n        address: oldAddress,\n        tracker,\n        networks,\n        contexts,\n        orchestrator,\n        jwt: jwtExpired ? undefined : dump.jwt?.token\n      })\n\n      // TODO: This property may not hold if the user adds a new network\n      if (!(await account.isMigratedAllChains().then(r => r.migratedAllChains))) {\n        // This is an oportunity for whoever is opening the session to\n        // feed the orchestrator with more signers, so that the migration\n        // can be completed.\n        if (onMigration && !(await onMigration(account))) {\n          throw Error('Migration cancelled, cannot open session')\n        }\n\n        console.log('Migrating account...')\n        await account.signAllMigrations(editConfigOnMigration)\n        if (!(await account.isMigratedAllChains().then(r => r.migratedAllChains))) throw Error('Failed to migrate account')\n      }\n\n      // We may need to update the JWT if the account has been migrated\n    } else if (isSessionDumpV2(dump)) {\n      const jwtExpired = (dump.jwt?.expiration ?? 0) < Math.floor(Date.now() / 1000)\n\n      account = new Account({\n        address: dump.address,\n        tracker,\n        networks,\n        contexts,\n        orchestrator,\n        jwt: jwtExpired ? undefined : dump.jwt?.token\n      })\n    } else {\n      throw Error('Invalid dump format')\n    }\n\n    let servicesObj: Services | undefined\n\n    if (services) {\n      servicesObj = new Services(\n        account,\n        services,\n        dump.jwt && {\n          jwt: {\n            token: Promise.resolve(dump.jwt.token),\n            expiration: dump.jwt.expiration ?? jwtDecodeClaims(dump.jwt.token).exp\n          },\n          metadata: dump.metadata\n        }\n      )\n    }\n\n    return new Session(networks, contexts, account, servicesObj)\n  }\n}\n","import { commons } from '@0xsequence/core'\nimport { Proof, ValidatorFunc } from '@0xsequence/ethauth'\nimport { tracker } from '@0xsequence/sessions'\nimport { ethers } from 'ethers'\n\nexport const ValidateSequenceWalletProof = (\n  readerFor: (chainId: number) => commons.reader.Reader,\n  tracker: tracker.ConfigTracker,\n  context: commons.context.WalletContext\n): ValidatorFunc => {\n  return async (_provider: ethers.JsonRpcProvider, chainId: number, proof: Proof): Promise<{ isValid: boolean }> => {\n    const digest = proof.messageDigest()\n    const isValid = await readerFor(chainId).isValidSignature(proof.address, digest, proof.signature)\n    return { isValid }\n  }\n}\n","/* eslint-disable */\n// sequence-guard v0.4.0 5b203e30a5c79b2b9a37483ce17500a51b94ebe1\n// --\n// Code generated by webrpc-gen@v0.18.6 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=guard.ridl -target=typescript -client -out=./clients/guard.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = 'v1'\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = 'v0.4.0'\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = '5b203e30a5c79b2b9a37483ce17500a51b94ebe1'\n\n//\n// Types\n//\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n}\n\nexport interface WalletConfig {\n  address: string\n  content: string\n}\n\nexport interface WalletSigner {\n  address: string\n  weight: number\n}\n\nexport interface SignRequest {\n  chainId: number\n  msg: string\n  auxData: string\n}\n\nexport interface OwnershipProof {\n  wallet: string\n  timestamp: number\n  signer: string\n  signature: string\n}\n\nexport interface AuthToken {\n  id: string\n  token: string\n}\n\nexport interface RecoveryCode {\n  code: string\n  used: boolean\n}\n\nexport interface Guard {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>\n  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>\n  getSignerConfig(args: GetSignerConfigArgs, headers?: object, signal?: AbortSignal): Promise<GetSignerConfigReturn>\n  sign(args: SignArgs, headers?: object, signal?: AbortSignal): Promise<SignReturn>\n  signWith(args: SignWithArgs, headers?: object, signal?: AbortSignal): Promise<SignWithReturn>\n  patch(args: PatchArgs, headers?: object, signal?: AbortSignal): Promise<PatchReturn>\n  authMethods(args: AuthMethodsArgs, headers?: object, signal?: AbortSignal): Promise<AuthMethodsReturn>\n  setPIN(args: SetPINArgs, headers?: object, signal?: AbortSignal): Promise<SetPINReturn>\n  resetPIN(args: ResetPINArgs, headers?: object, signal?: AbortSignal): Promise<ResetPINReturn>\n  createTOTP(args: CreateTOTPArgs, headers?: object, signal?: AbortSignal): Promise<CreateTOTPReturn>\n  commitTOTP(args: CommitTOTPArgs, headers?: object, signal?: AbortSignal): Promise<CommitTOTPReturn>\n  resetTOTP(args: ResetTOTPArgs, headers?: object, signal?: AbortSignal): Promise<ResetTOTPReturn>\n  reset2FA(args: Reset2FAArgs, headers?: object, signal?: AbortSignal): Promise<Reset2FAReturn>\n  recoveryCodes(args: RecoveryCodesArgs, headers?: object, signal?: AbortSignal): Promise<RecoveryCodesReturn>\n  resetRecoveryCodes(args: ResetRecoveryCodesArgs, headers?: object, signal?: AbortSignal): Promise<ResetRecoveryCodesReturn>\n}\n\nexport interface PingArgs {}\n\nexport interface PingReturn {\n  status: boolean\n}\nexport interface VersionArgs {}\n\nexport interface VersionReturn {\n  version: Version\n}\nexport interface RuntimeStatusArgs {}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus\n}\nexport interface GetSignerConfigArgs {\n  signer: string\n}\n\nexport interface GetSignerConfigReturn {\n  signerConfig: WalletConfig\n}\nexport interface SignArgs {\n  request: SignRequest\n  token?: AuthToken\n}\n\nexport interface SignReturn {\n  sig: string\n}\nexport interface SignWithArgs {\n  signer: string\n  request: SignRequest\n  token?: AuthToken\n}\n\nexport interface SignWithReturn {\n  sig: string\n}\nexport interface PatchArgs {\n  signer: string\n  chainId: number\n  secret: string\n}\n\nexport interface PatchReturn {\n  txs: any\n}\nexport interface AuthMethodsArgs {\n  proof?: OwnershipProof\n}\n\nexport interface AuthMethodsReturn {\n  methods: Array<string>\n  active: boolean\n}\nexport interface SetPINArgs {\n  pin: string\n  timestamp: number\n  signature: string\n}\n\nexport interface SetPINReturn {}\nexport interface ResetPINArgs {\n  timestamp: number\n  signature: string\n}\n\nexport interface ResetPINReturn {}\nexport interface CreateTOTPArgs {\n  timestamp: number\n  signature: string\n}\n\nexport interface CreateTOTPReturn {\n  uri: string\n}\nexport interface CommitTOTPArgs {\n  token: string\n}\n\nexport interface CommitTOTPReturn {\n  codes: Array<RecoveryCode>\n}\nexport interface ResetTOTPArgs {\n  timestamp: number\n  signature: string\n}\n\nexport interface ResetTOTPReturn {}\nexport interface Reset2FAArgs {\n  code: string\n  proof?: OwnershipProof\n}\n\nexport interface Reset2FAReturn {}\nexport interface RecoveryCodesArgs {\n  timestamp: number\n  signature: string\n}\n\nexport interface RecoveryCodesReturn {\n  codes: Array<RecoveryCode>\n}\nexport interface ResetRecoveryCodesArgs {\n  timestamp: number\n  signature: string\n}\n\nexport interface ResetRecoveryCodesReturn {\n  codes: Array<RecoveryCode>\n}\n\n//\n// Client\n//\nexport class Guard implements Guard {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Guard/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n\n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <boolean>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {\n    return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: <Version>_data.version\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {\n    return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: <RuntimeStatus>_data.status\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  getSignerConfig = (args: GetSignerConfigArgs, headers?: object, signal?: AbortSignal): Promise<GetSignerConfigReturn> => {\n    return this.fetch(this.url('GetSignerConfig'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            signerConfig: <WalletConfig>_data.signerConfig\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  sign = (args: SignArgs, headers?: object, signal?: AbortSignal): Promise<SignReturn> => {\n    return this.fetch(this.url('Sign'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            sig: <string>_data.sig\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  signWith = (args: SignWithArgs, headers?: object, signal?: AbortSignal): Promise<SignWithReturn> => {\n    return this.fetch(this.url('SignWith'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            sig: <string>_data.sig\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  patch = (args: PatchArgs, headers?: object, signal?: AbortSignal): Promise<PatchReturn> => {\n    return this.fetch(this.url('Patch'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            txs: <any>_data.txs\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  authMethods = (args: AuthMethodsArgs, headers?: object, signal?: AbortSignal): Promise<AuthMethodsReturn> => {\n    return this.fetch(this.url('AuthMethods'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            methods: <Array<string>>_data.methods,\n            active: <boolean>_data.active\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  setPIN = (args: SetPINArgs, headers?: object, signal?: AbortSignal): Promise<SetPINReturn> => {\n    return this.fetch(this.url('SetPIN'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  resetPIN = (args: ResetPINArgs, headers?: object, signal?: AbortSignal): Promise<ResetPINReturn> => {\n    return this.fetch(this.url('ResetPIN'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  createTOTP = (args: CreateTOTPArgs, headers?: object, signal?: AbortSignal): Promise<CreateTOTPReturn> => {\n    return this.fetch(this.url('CreateTOTP'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            uri: <string>_data.uri\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  commitTOTP = (args: CommitTOTPArgs, headers?: object, signal?: AbortSignal): Promise<CommitTOTPReturn> => {\n    return this.fetch(this.url('CommitTOTP'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            codes: <Array<RecoveryCode>>_data.codes\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  resetTOTP = (args: ResetTOTPArgs, headers?: object, signal?: AbortSignal): Promise<ResetTOTPReturn> => {\n    return this.fetch(this.url('ResetTOTP'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  reset2FA = (args: Reset2FAArgs, headers?: object, signal?: AbortSignal): Promise<Reset2FAReturn> => {\n    return this.fetch(this.url('Reset2FA'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {}\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  recoveryCodes = (args: RecoveryCodesArgs, headers?: object, signal?: AbortSignal): Promise<RecoveryCodesReturn> => {\n    return this.fetch(this.url('RecoveryCodes'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            codes: <Array<RecoveryCode>>_data.codes\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n\n  resetRecoveryCodes = (\n    args: ResetRecoveryCodesArgs,\n    headers?: object,\n    signal?: AbortSignal\n  ): Promise<ResetRecoveryCodesReturn> => {\n    return this.fetch(this.url('ResetRecoveryCodes'), createHTTPRequest(args, headers, signal)).then(\n      res => {\n        return buildResponse(res).then(_data => {\n          return {\n            codes: <Array<RecoveryCode>>_data.codes\n          }\n        })\n      },\n      error => {\n        throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n      }\n    )\n  }\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch (error) {\n      let message = ''\n      if (error instanceof Error) {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`\n      })\n    }\n    if (!res.ok) {\n      const code: number = typeof data.code === 'number' ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n// Schema errors\n\nexport class UnauthorizedError extends WebrpcError {\n  constructor(\n    name: string = 'Unauthorized',\n    code: number = 1000,\n    message: string = 'Unauthorized access',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnauthorizedError.prototype)\n  }\n}\n\nexport class SessionExpiredError extends WebrpcError {\n  constructor(\n    name: string = 'SessionExpired',\n    code: number = 1002,\n    message: string = 'Session expired',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, SessionExpiredError.prototype)\n  }\n}\n\nexport class AbortedError extends WebrpcError {\n  constructor(\n    name: string = 'Aborted',\n    code: number = 1005,\n    message: string = 'Request aborted',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, AbortedError.prototype)\n  }\n}\n\nexport class InvalidArgumentError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidArgument',\n    code: number = 2001,\n    message: string = 'Invalid argument',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidArgumentError.prototype)\n  }\n}\n\nexport class UnavailableError extends WebrpcError {\n  constructor(\n    name: string = 'Unavailable',\n    code: number = 2002,\n    message: string = 'Unavailable resource',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnavailableError.prototype)\n  }\n}\n\nexport class QueryFailedError extends WebrpcError {\n  constructor(\n    name: string = 'QueryFailed',\n    code: number = 2003,\n    message: string = 'Query failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, QueryFailedError.prototype)\n  }\n}\n\nexport class ValidationFailedError extends WebrpcError {\n  constructor(\n    name: string = 'ValidationFailed',\n    code: number = 2004,\n    message: string = 'Validation Failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, ValidationFailedError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'NotFound',\n    code: number = 3000,\n    message: string = 'Resource not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  Unauthorized = 'Unauthorized',\n  SessionExpired = 'SessionExpired',\n  Aborted = 'Aborted',\n  InvalidArgument = 'InvalidArgument',\n  Unavailable = 'Unavailable',\n  QueryFailed = 'QueryFailed',\n  ValidationFailed = 'ValidationFailed',\n  NotFound = 'NotFound'\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1000]: UnauthorizedError,\n  [1002]: SessionExpiredError,\n  [1005]: AbortedError,\n  [2001]: InvalidArgumentError,\n  [2002]: UnavailableError,\n  [2003]: QueryFailedError,\n  [2004]: ValidationFailedError,\n  [3000]: NotFoundError\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","import { Account } from '@0xsequence/account'\nimport { commons, universal } from '@0xsequence/core'\nimport { signers, Status } from '@0xsequence/signhub'\nimport { encodeTypedDataDigest, TypedData } from '@0xsequence/utils'\nimport { ethers } from 'ethers'\nimport { AuthMethodsReturn, Guard, RecoveryCode as GuardRecoveryCode } from './guard.gen'\n\nconst fetch = globalThis.fetch\n\nexport class GuardSigner implements signers.SapientSigner {\n  private guard: Guard\n\n  constructor(\n    public readonly address: string,\n    public readonly url: string,\n    public readonly appendSuffix: boolean = false\n  ) {\n    this.guard = new Guard(url, fetch)\n  }\n\n  async getAddress(): Promise<string> {\n    return this.address\n  }\n\n  async buildDeployTransaction(_metadata: object): Promise<commons.transaction.TransactionBundle | undefined> {\n    return undefined\n  }\n\n  async predecorateSignedTransactions(_metadata: object): Promise<commons.transaction.SignedTransactionBundle[]> {\n    return []\n  }\n\n  async decorateTransactions(\n    bundle: commons.transaction.IntendedTransactionBundle,\n    _metadata: object\n  ): Promise<commons.transaction.IntendedTransactionBundle> {\n    return bundle\n  }\n\n  async sign(message: ethers.BytesLike, metadata: object): Promise<ethers.BytesLike> {\n    if (!commons.isWalletSignRequestMetadata(metadata)) {\n      throw new Error('expected sequence signature request metadata')\n    }\n\n    const guardTotpCode = (metadata as { guardTotpCode?: string }).guardTotpCode\n\n    // Building auxData, notice: this uses the old v1 format\n    // TODO: We should update the guard API so we can pass the metadata directly\n    const coder = universal.genericCoderFor(metadata.config.version)\n    const { encoded } = coder.signature.encodeSigners(metadata.config, metadata.parts ?? new Map(), [], metadata.chainId)\n\n    return (\n      await this.guard.signWith({\n        signer: this.address,\n        request: {\n          msg: ethers.hexlify(message),\n          auxData: this.packMsgAndSig(metadata.address, metadata.digest, encoded, metadata.chainId),\n          chainId: Number(metadata.chainId)\n        },\n        token: guardTotpCode ? { id: AuthMethod.TOTP, token: guardTotpCode } : undefined\n      })\n    ).sig\n  }\n\n  notifyStatusChange(_id: string, _status: Status, _metadata: object): void {}\n\n  async getAuthMethods(proof: OwnershipProof): Promise<{ methods: AuthMethod[]; active: boolean }> {\n    let response: AuthMethodsReturn\n\n    if ('jwt' in proof) {\n      response = await this.guard.authMethods({}, { Authorization: `BEARER ${proof.jwt}` })\n    } else {\n      const signedProof = await signOwnershipProof(proof)\n\n      response = await this.guard.authMethods({\n        proof: {\n          wallet: signedProof.walletAddress,\n          timestamp: signedProof.timestamp.getTime(),\n          signer: signedProof.signerAddress,\n          signature: signedProof.signature\n        }\n      })\n    }\n\n    return { ...response, methods: response.methods.map(parseAuthMethod) }\n  }\n\n  async setPin(pin: string | undefined, proof: AuthUpdateProof): Promise<void> {\n    const signedProof = await signAuthUpdateProof(proof)\n\n    if (pin === undefined) {\n      await this.guard.resetPIN(\n        { timestamp: signedProof.timestamp.getTime(), signature: signedProof.signature },\n        { Authorization: `BEARER ${proof.jwt}` }\n      )\n    } else {\n      await this.guard.setPIN(\n        { pin, timestamp: signedProof.timestamp.getTime(), signature: signedProof.signature },\n        { Authorization: `BEARER ${proof.jwt}` }\n      )\n    }\n  }\n\n  resetPin(proof: AuthUpdateProof): Promise<void> {\n    return this.setPin(undefined, proof)\n  }\n\n  async createTotp(proof: AuthUpdateProof): Promise<URL> {\n    const signedProof = await signAuthUpdateProof(proof)\n\n    const { uri } = await this.guard.createTOTP(\n      { timestamp: signedProof.timestamp.getTime(), signature: signedProof.signature },\n      { Authorization: `BEARER ${proof.jwt}` }\n    )\n\n    return new URL(uri)\n  }\n\n  async commitTotp(token: string, jwt: string): Promise<RecoveryCode[]> {\n    const { codes } = await this.guard.commitTOTP({ token }, { Authorization: `BEARER ${jwt}` })\n    return codes\n  }\n\n  async resetTotp(proof: AuthUpdateProof): Promise<void> {\n    const signedProof = await signAuthUpdateProof(proof)\n\n    await this.guard.resetTOTP(\n      { timestamp: signedProof.timestamp.getTime(), signature: signedProof.signature },\n      { Authorization: `BEARER ${proof.jwt}` }\n    )\n  }\n\n  async reset2fa(recoveryCode: string, proof: OwnershipProof): Promise<void> {\n    if ('jwt' in proof) {\n      await this.guard.reset2FA({ code: recoveryCode }, { Authorization: `BEARER ${proof.jwt}` })\n    } else {\n      const signedProof = await signOwnershipProof(proof)\n\n      await this.guard.reset2FA({\n        code: recoveryCode,\n        proof: {\n          wallet: signedProof.walletAddress,\n          timestamp: signedProof.timestamp.getTime(),\n          signer: signedProof.signerAddress,\n          signature: signedProof.signature\n        }\n      })\n    }\n  }\n\n  async getRecoveryCodes(proof: AuthUpdateProof): Promise<RecoveryCode[]> {\n    const signedProof = await signAuthUpdateProof(proof)\n\n    const { codes } = await this.guard.recoveryCodes(\n      { timestamp: signedProof.timestamp.getTime(), signature: signedProof.signature },\n      { Authorization: `BEARER ${proof.jwt}` }\n    )\n\n    return codes\n  }\n\n  async resetRecoveryCodes(proof: AuthUpdateProof): Promise<RecoveryCode[]> {\n    const signedProof = await signAuthUpdateProof(proof)\n\n    const { codes } = await this.guard.resetRecoveryCodes(\n      { timestamp: signedProof.timestamp.getTime(), signature: signedProof.signature },\n      { Authorization: `BEARER ${proof.jwt}` }\n    )\n\n    return codes\n  }\n\n  private packMsgAndSig(address: string, msg: ethers.BytesLike, sig: ethers.BytesLike, chainId: ethers.BigNumberish): string {\n    return ethers.AbiCoder.defaultAbiCoder().encode(['address', 'uint256', 'bytes', 'bytes'], [address, chainId, msg, sig])\n  }\n\n  suffix(): ethers.BytesLike {\n    return new Uint8Array(this.appendSuffix ? [3] : [])\n  }\n}\n\nexport type RecoveryCode = GuardRecoveryCode\n\nexport enum AuthMethod {\n  PIN = 'PIN',\n  TOTP = 'TOTP'\n}\n\nfunction parseAuthMethod(method: string): AuthMethod {\n  switch (method) {\n    case AuthMethod.PIN:\n    case AuthMethod.TOTP:\n      return method\n    default:\n      throw new Error(`unknown auth method '${method}'`)\n  }\n}\n\nexport type SignedOwnershipProof = {\n  walletAddress: string\n  timestamp: Date\n  signerAddress: string\n  signature: string\n}\n\nexport type OwnershipProof =\n  | SignedOwnershipProof\n  | { jwt: string }\n  | {\n      walletAddress: string\n      signer: ethers.Signer | signers.SapientSigner\n    }\n\nexport function isSignedOwnershipProof(proof: OwnershipProof): proof is SignedOwnershipProof {\n  return 'signerAddress' in proof && typeof proof.signerAddress === 'string'\n}\n\nexport async function signOwnershipProof(proof: Exclude<OwnershipProof, { jwt: string }>): Promise<SignedOwnershipProof> {\n  if (isSignedOwnershipProof(proof)) {\n    return proof\n  } else {\n    const signer = signers.isSapientSigner(proof.signer) ? proof.signer : new signers.SignerWrapper(proof.signer)\n    const signerAddress = await signer.getAddress()\n    const timestamp = new Date()\n    const typedData = getOwnershipProofTypedData(proof.walletAddress, timestamp)\n    const digest = encodeTypedDataDigest(typedData)\n\n    return {\n      walletAddress: proof.walletAddress,\n      timestamp,\n      signerAddress,\n      signature: ethers.hexlify(await signer.sign(digest, {}))\n    }\n  }\n}\n\nexport type AuthUpdateProof = { jwt: string } & ({ timestamp: Date; signature: string } | { wallet: Account })\n\nasync function signAuthUpdateProof(proof: AuthUpdateProof): Promise<{ jwt: string; timestamp: Date; signature: string }> {\n  if ('wallet' in proof) {\n    const timestamp = new Date()\n    const typedData = getAuthUpdateProofTypedData(timestamp)\n\n    const signature = await proof.wallet.signTypedData(\n      typedData.domain,\n      typedData.types,\n      typedData.message,\n      typedData.domain.chainId ?? 1,\n      'eip6492'\n    )\n\n    return { jwt: proof.jwt, timestamp, signature }\n  } else {\n    return proof\n  }\n}\n\nexport function getOwnershipProofTypedData(wallet: string, timestamp: Date): TypedData {\n  return {\n    domain,\n    types: {\n      AuthMethods: [\n        { name: 'wallet', type: 'address' },\n        { name: 'timestamp', type: 'string' }\n      ]\n    },\n    message: {\n      wallet: ethers.getAddress(wallet),\n      timestamp: toUTCString(timestamp)\n    }\n  }\n}\n\nexport function getAuthUpdateProofTypedData(timestamp: Date): TypedData {\n  return {\n    domain,\n    types: {\n      AuthUpdate: [{ name: 'timestamp', type: 'string' }]\n    },\n    message: {\n      timestamp: toUTCString(timestamp)\n    }\n  }\n}\n\nconst domain: ethers.TypedDataDomain = {\n  name: 'Sequence Guard',\n  version: '1',\n  chainId: 1\n}\n\nfunction toUTCString(date: Date): string {\n  return date.toUTCString().replace('GMT', 'UTC')\n}\n","import { ethers } from 'ethers'\nimport { EIP1193ProviderFunc, JsonRpcRequest, JsonRpcMiddleware } from '../types'\n\nexport const networkProviderMiddleware =\n  (getChainId: (request: JsonRpcRequest) => number): JsonRpcMiddleware =>\n  (next: EIP1193ProviderFunc) => {\n    return async (request: JsonRpcRequest): Promise<any> => {\n      const networkChainId = getChainId(request)\n\n      switch (request.method) {\n        case 'net_version': {\n          return `${networkChainId}`\n        }\n\n        case 'eth_chainId': {\n          return ethers.toQuantity(networkChainId)\n        }\n      }\n\n      // request is allowed. keep going..\n      return next(request)\n    }\n  }\n","import { ethers } from 'ethers'\nimport { EIP1193ProviderFunc, JsonRpcMiddlewareHandler, JsonRpcRequest } from '../types'\nimport { SignerJsonRpcMethods } from './signing-provider'\nimport { logger } from '@0xsequence/utils'\n\nexport class PublicProvider implements JsonRpcMiddlewareHandler {\n  private privateJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', ...SignerJsonRpcMethods]\n\n  private provider?: ethers.JsonRpcProvider\n  private rpcUrl?: string\n\n  constructor(rpcUrl?: string) {\n    if (rpcUrl) {\n      this.setRpcUrl(rpcUrl)\n    }\n  }\n\n  requestHandler = (next: EIP1193ProviderFunc) => {\n    return (request: JsonRpcRequest): Promise<any> => {\n      // When provider is configured, send non-private methods to our local public provider\n      if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {\n        return this.provider.send(request.method, request.params || [])\n      }\n\n      // Continue to next handler\n      logger.debug('[public-provider] sending request to signer window', request.method)\n      return next(request)\n    }\n  }\n\n  getRpcUrl() {\n    return this.rpcUrl\n  }\n\n  setRpcUrl(rpcUrl: string) {\n    if (!rpcUrl || rpcUrl === '') {\n      this.rpcUrl = undefined\n      this.provider = undefined\n    } else {\n      this.rpcUrl = rpcUrl\n      // TODO: maybe use @0xsequence/network JsonRpcProvider here instead,\n      // which supports better caching.\n      this.provider = new ethers.JsonRpcProvider(rpcUrl)\n    }\n  }\n}\n","import { walletContracts } from '@0xsequence/abi'\nimport { commons } from '@0xsequence/core'\nimport { ethers } from 'ethers'\n\nconst PROHIBITED_FUNCTIONS = new Map(\n  [\n    'addHook(bytes4,address)',\n    'clearExtraImageHashes(bytes32[])',\n    'removeHook(bytes4)',\n    'setExtraImageHash(bytes32,uint256)',\n    'updateIPFSRoot(bytes32)',\n    'updateImageHash(bytes32)',\n    'updateImageHashAndIPFS(bytes32,bytes32)',\n    'updateImplementation(address)'\n  ].map(signature => [ethers.id(signature).slice(0, 10), signature])\n)\n\nexport function validateTransactionRequest(wallet: string, transaction: commons.transaction.Transactionish) {\n  const transactions = commons.transaction.fromTransactionish(wallet, transaction)\n  const unwound = commons.transaction.unwind(wallet, transactions)\n  unwound.forEach(transaction => validateTransaction(wallet, transaction))\n}\n\nfunction validateTransaction(wallet: string, transaction: commons.transaction.Transaction) {\n  if (transaction.to.toLowerCase() === wallet.toLowerCase()) {\n    if (transaction.data) {\n      const data = ethers.getBytes(transaction.data)\n      if (data.length >= 4 && !isCreateContractCall(data)) {\n        throw new Error('self calls are forbidden')\n      }\n    }\n  }\n\n  if (transaction.delegateCall) {\n    throw new Error('delegate calls are forbidden')\n  }\n\n  if (transaction.data) {\n    const data = ethers.hexlify(transaction.data)\n    const selector = data.slice(0, 10)\n    const signature = PROHIBITED_FUNCTIONS.get(selector)\n    if (signature) {\n      const name = signature.slice(0, signature.indexOf('('))\n      throw new Error(`${name} calls are forbidden`)\n    }\n  }\n}\n\nfunction isCreateContractCall(data: ethers.BytesLike): boolean {\n  const walletInterface = new ethers.Interface(walletContracts.mainModule.abi)\n  try {\n    walletInterface.decodeFunctionData('createContract', data)\n    return true\n  } catch {\n    return false\n  }\n}\n","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';\n  var symbolsSupported= typeof Symbol==='function';\n  var reflectSupported= typeof Reflect === 'object';\n  var setImmediateSupported= typeof setImmediate === 'function';\n  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){\n    var arr= Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  }) : Object.keys;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n\n    var _observers= emitter._observers;\n    if(_observers){\n      _observers.push(this);\n    }else{\n      emitter._observers= [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function(event, localEvent, reducer){\n      var observer= this;\n      var target= this._target;\n      var emitter= this._emitter;\n      var listeners= this._listeners;\n      var handler= function(){\n        var args= toArray.apply(null, arguments);\n        var eventObj= {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if(reducer){\n          var result= reducer.call(target, eventObj);\n          if(result!==false){\n            emitter.emit.apply(emitter, [eventObj.name].concat(args))\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n\n      if(listeners[event]){\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){\n\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener= function(_event){\n          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){\n            listeners[event]= null;\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event]= null;\n\n        emitter.on('removeListener', this._onRemoveListener);\n      }else{\n        listeners[event]= handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n\n    unsubscribe: function(event){\n      var observer= this;\n      var listeners= this._listeners;\n      var emitter= this._emitter;\n      var handler;\n      var events;\n      var off= this._off;\n      var target= this._target;\n      var i;\n\n      if(event && typeof event!=='string'){\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs(){\n        if(observer._onNewListener){\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener= null;\n          observer._onRemoveListener= null;\n        }\n        var index= findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n\n      if(event){\n        handler= listeners[event];\n        if(!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if(!--this._listenersCount){\n          clearRefs();\n        }\n      }else{\n        events= ownKeys(listeners);\n        i= events.length;\n        while(i-->0){\n          event= events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners= {};\n        this._listenersCount= 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''))\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message= 'value must be type of ' + types.join('|');\n    var len= types.length;\n    var firstType= types[0];\n    var secondType= types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      }\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind= typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      }\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    }\n  }\n\n  var functionReducer= makeTypeReducer(['function']);\n\n  var objectFunctionReducer= makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscriptionClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          reason.code = 'ETIMEDOUT'\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if(!observers){\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],\n        nextType = type[i + 1], branches, _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if(tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n      xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches= ownKeys(xxTree);\n        n= branches.length;\n        while(n-->0){\n          branch= branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;\n\n    if(typeof type==='string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      }else{\n        ns= [type];\n        len= 1;\n      }\n    }else{\n      ns= type;\n      len= type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n\n\n    var tree = this.listenerTree, name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (\n              !tree._listeners.warned &&\n              this._maxListeners > 0 &&\n              tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray){\n     var branches= ownKeys(tree);\n     var i= branches.length;\n     var branch, branchName, path;\n     var hasListeners= tree['_listeners'];\n     var isArrayPath;\n\n     while(i-->0){\n         branchName= branches[i];\n\n         branch= tree[branchName];\n\n         if(branchName==='_listeners'){\n             path= root;\n         }else {\n             path = root ? root.concat(branchName) : [branchName];\n         }\n\n         isArrayPath= asArray || typeof branchName==='symbol';\n\n         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));\n\n         if(typeof branch==='object'){\n             collectTreeEvents.call(this, branch, events, path, isArrayPath);\n         }\n     }\n\n     return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i= keys.length;\n    var obj, key, flag;\n    while(i-->0){\n      key = keys[i];\n      obj = root[key];\n\n      if(obj){\n          flag= true;\n          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){\n             delete root[key];\n          }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener){\n    this.emitter= emitter;\n    this.event= event;\n    this.listener= listener;\n  }\n\n  Listener.prototype.off= function(){\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options){\n      if (options === true) {\n        promisify = true;\n      } else if (options === false) {\n        async = true;\n      } else {\n        if (!options || typeof options !== 'object') {\n          throw TypeError('options should be an object or true');\n        }\n        var async = options.async;\n        var promisify = options.promisify;\n        var nextTick = options.nextTick;\n        var objectify = options.objectify;\n      }\n\n      if (async || nextTick || promisify) {\n        var _listener = listener;\n        var _origin = listener._origin || listener;\n\n        if (nextTick && !nextTickSupported) {\n          throw Error('process.nextTick is not supported');\n        }\n\n        if (promisify === undefined) {\n          promisify = listener.constructor.name === 'AsyncFunction';\n        }\n\n        listener = function () {\n          var args = arguments;\n          var context = this;\n          var event = this.event;\n\n          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {\n            _setImmediate(resolve);\n          }).then(function () {\n            context.event = event;\n            return _listener.apply(context, args)\n          })) : (nextTick ? process.nextTick : _setImmediate)(function () {\n            context.event = event;\n            _listener.apply(context, args)\n          });\n        };\n\n        listener._async = true;\n        listener._origin = _origin;\n      }\n\n    return [listener, objectify? new Listener(this, event, listener): this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo= function(target, events, options){\n    if(typeof target!=='object'){\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter= this;\n\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events){\n      if(typeof events!=='object'){\n        throw TypeError('events must be an object');\n      }\n\n      var reducers= options.reducers;\n      var index= findTargetIndex.call(emitter, target);\n      var observer;\n\n      if(index===-1){\n        observer= new TargetObserver(emitter, target, options);\n      }else{\n        observer= emitter._observers[index];\n      }\n\n      var keys= ownKeys(events);\n      var len= keys.length;\n      var event;\n      var isSingleReducer= typeof reducers==='function';\n\n      for(var i=0; i<len; i++){\n        event= keys[i];\n        observer.subscribe(\n            event,\n            events[event] || event,\n            isSingleReducer ? reducers : reducers && reducers[event]\n        );\n      }\n    }\n\n    isArray(events)?\n        listen(toObject(events)) :\n        (typeof events==='string'? listen(toObject(events.split(/\\s+/))): listen(events));\n\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if(!observers){\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched= false;\n\n    if(target && typeof target!=='object'){\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched= true;\n      }\n    }\n\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], ns, wildcard= this.wildcard;\n    var args,l,i,j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;\n    var args,l,i,j;\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    var returnValue= this, temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if(!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree= this.listenerTree;\n        if(!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function(nsAsArray){\n    var _events= this._events;\n    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      },\n      _observers: {value: null, writable: true, configurable: true}\n  });\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  }\n  else {\n    // global for any kind of environment.\n    var _global= new Function('','return this')();\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();\n","import { ETHAuthProof as AuthETHAuthProof } from '@0xsequence/auth'\nimport { commons } from '@0xsequence/core'\nimport {\n  ChainIdLike,\n  EIP1193Provider,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  NetworkConfig,\n  JsonRpcErrorPayload\n} from '@0xsequence/network'\nimport { TypedData } from '@0xsequence/utils'\n\nexport interface ProviderTransport extends EIP1193Provider, ProviderMessageTransport, ProviderMessageRequestHandler {\n  register(): void\n  unregister(): void\n\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number): void\n  closeWallet(): void\n\n  isOpened(): boolean\n  isConnected(): boolean\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]): void\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]): void\n  emit<K extends keyof ProviderEventTypes>(event: K, ...args: Parameters<ProviderEventTypes[K]>): boolean\n\n  waitUntilOpened(): Promise<WalletSession | undefined>\n  waitUntilConnected(): Promise<ConnectDetails>\n}\n\nexport function isProviderTransport(transport: any): transport is ProviderTransport {\n  return (\n    transport &&\n    typeof transport === 'object' &&\n    typeof transport.register === 'function' &&\n    typeof transport.unregister === 'function' &&\n    typeof transport.openWallet === 'function' &&\n    typeof transport.closeWallet === 'function' &&\n    typeof transport.isOpened === 'function' &&\n    typeof transport.isConnected === 'function' &&\n    typeof transport.on === 'function'\n  )\n}\n\nexport interface WalletTransport extends EIP1193Provider, ProviderMessageTransport, ProviderMessageRequestHandler {\n  register(): void\n  unregister(): void\n\n  notifyOpen(openInfo: { chainId?: string; sessionId?: string; session?: WalletSession; error?: string }): void\n  notifyClose(error?: ProviderRpcError): void\n\n  notifyConnect(connectDetails: ConnectDetails): void\n  notifyAccountsChanged(accounts: string[]): void\n  notifyChainChanged(chainIdHex: string): void\n  notifyNetworks(networks: NetworkConfig[]): void\n}\n\nexport interface ProviderMessage<T> {\n  idx: number // message id number\n  type: string // message type\n  data: T // the ethereum json-rpc payload\n  chainId?: number // chain id which the message is intended\n  origin?: string // origin of the message\n  clientVersion: string // client version of the message\n}\n\nexport type ProviderMessageRequest = ProviderMessage<JsonRpcRequest>\n\n// Older versions of sequence.js will require a JsonRpcResponse result type, but newer versions use raw EIP1193 results\nexport type ProviderMessageResponse = ProviderMessage<JsonRpcResponse | any>\n\n// ProviderMessageCallback is used to respond to ProviderMessage requests. The error\n// argument is for exceptions during the execution, and response is the response payload\n// which may contain the result or an error payload from the wallet.\nexport type ProviderMessageResponseCallback = (error?: ProviderRpcError, response?: ProviderMessageResponse) => void\n\nexport type ProviderRpcError = JsonRpcErrorPayload\n\nexport interface ProviderMessageRequestHandler {\n  // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet.\n  // This method is similar to `sendMessage`, but it expects a response to this message.\n  sendMessageRequest(message: ProviderMessageRequest): Promise<ProviderMessageResponse>\n}\n\nexport interface ProviderMessageTransport {\n  // handleMessage will handle a message received from the remote wallet\n  handleMessage(message: ProviderMessage<any>): void\n\n  // sendMessage will send the provider message over the wire\n  sendMessage(message: ProviderMessage<any>): void\n}\n\nexport type WindowSessionParam = 'sid' | 'net' | 'intent'\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface WindowSessionParams extends URLSearchParams {\n  get(name: WindowSessionParam): string | null\n  set(name: WindowSessionParam, value: string): void\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class WindowSessionParams extends URLSearchParams {\n  static new(init?: Record<WindowSessionParam, string> | string) {\n    return new URLSearchParams(init) as WindowSessionParams\n  }\n}\n\nexport interface TransportSession {\n  sessionId?: string | null\n  networkId?: string | number | null\n  intent?: OpenWalletIntent\n}\n\nexport enum EventType {\n  OPEN = 'open',\n  CLOSE = 'close',\n\n  MESSAGE = 'message',\n  CONNECT = 'connect',\n  DISCONNECT = 'disconnect',\n  ACCOUNTS_CHANGED = 'accountsChanged',\n  CHAIN_CHANGED = 'chainChanged',\n\n  NETWORKS = 'networks',\n  WALLET_CONTEXT = 'walletContext',\n\n  INIT = 'init',\n  DEBUG = '_debug'\n}\n\nexport interface WalletEventTypes {\n  open: (openInfo: { chainId?: string; sessionId?: string; session?: WalletSession; error?: string }) => void\n  close: (error?: ProviderRpcError) => void\n\n  connect: (connectDetails: ConnectDetails) => void\n  disconnect: (error?: ProviderRpcError, origin?: string) => void\n\n  accountsChanged: (accounts: string[], origin?: string) => void\n  chainChanged: (chainIdHex: string, origin?: string) => void\n\n  networks: (networks: NetworkConfig[]) => void\n  walletContext: (walletContext: commons.context.VersionedContext) => void\n}\n\nexport interface ProviderEventTypes extends WalletEventTypes {\n  message: (message: ProviderMessageResponse) => void\n}\n\nexport enum OpenState {\n  CLOSED = 0,\n  OPENING = 1,\n  OPENED = 2\n}\n\nexport enum InitState {\n  NIL = 0,\n  SENT_NONCE = 1,\n  OK = 2\n}\n\nexport interface ConnectOptions {\n  /** app name of the dapp which will be announced to user on connect screen */\n  app: string\n\n  /** custom protocol for auth redirect (unity/unreal) */\n  appProtocol?: string\n\n  /** origin hint of the dapp's host opening the wallet. This value will automatically\n   * be determined and verified for integrity, and can be omitted. */\n  origin?: string\n\n  /** access key for the project that can be obtained from Sequence Builder on sequence.build.\n   * This value will be automatically populated using the key passed in initWallet. */\n  projectAccessKey?: string\n\n  /** expiry number (in seconds) that is used for ETHAuth proof. Default is 1 week in seconds. */\n  expiry?: number\n\n  /** authorize will perform an ETHAuth eip712 signing and return the proof to the dapp. */\n  authorize?: boolean\n\n  /** authorizeNonce is an optional number to be passed as ETHAuth's nonce claim for replay protection. **/\n  authorizeNonce?: number\n\n  /** authorizeVersion is the version of the SDK that will validate the ETHAuth proof. */\n  authorizeVersion?: number\n\n  /** askForEmail will prompt to give permission to the dapp to access email address */\n  askForEmail?: boolean\n\n  /** refresh flag will force a full re-connect (ie. disconnect then connect again) */\n  refresh?: boolean\n\n  /** keepWalletOpened will keep the wallet window opened after connecting. The default\n   * is to automatically close the wallet after connecting. */\n  keepWalletOpened?: boolean\n\n  /** clientVersion is the sequence.js version of the dapp client. */\n  clientVersion?: string\n\n  /** Options to further customize the wallet experience. */\n  settings?: Settings\n}\n\nexport interface NetworkedConnectOptions extends ConnectOptions {\n  /** chainId is the chainId to connect to. If not specified, the default chainId\n   * will be used. This does not define a default chain id, it is only used for the connect\n   * authorization signature. */\n  networkId?: string | number\n}\n\n/** Options to further customize the wallet experience. */\nexport interface Settings {\n  /** Specify a wallet theme. `light` and `dark` are the main themes, to use other available\n   * themes, you can use the camel case version of the theme names in the wallet settings.\n   * For example: \"Blue Dark\" on wallet UI can be passed as \"blueDark\".\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  theme?: ThemeOption\n\n  /** Specify a banner image. This image, if provided, will be displayed on the wallet during\n   * the connect/authorize process */\n  bannerUrl?: string\n\n  bannerSize?: BannerSize\n\n  /** Specify payment providers to use. If not specified,\n   * all available payment providers will be enabled.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  includedPaymentProviders?: PaymentProviderOption[]\n\n  /** Specify a default currency to use with payment providers.\n   * If not specified, the default is USDC.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  defaultFundingCurrency?: CurrencyOption\n\n  /** Specify default purchase amount as an integer, for prefilling the funding amount.\n   * If not specified, the default is 100.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  defaultPurchaseAmount?: number\n\n  /** If true, lockFundingCurrencyToDefault disables picking any currency provided by payment\n   * providers other than the defaultFundingCurrency.\n   * If false, it allows picking any currency provided by payment providers.\n   * The default is true.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  lockFundingCurrencyToDefault?: boolean\n\n  /** Specify an auth provider to allow dapp to specify ahead of time which auth method to redirect to.\n   * Will be ignored if user is already signed in.\n   */\n  signInWith?: SignInOption\n\n  /** Specify an email address to allow user automatically sign in with the email option.\n   * Will be ignored if user is already signed in.\n   */\n  signInWithEmail?: string\n\n  /** Specify which sign in options are allowed.\n   * Will be ignored if user is already signed in.\n   */\n  signInOptions?: SignInOption[]\n\n  /** Specify auxiliary data\n   */\n  aux?: any\n}\n\n/** light and dark are the main themes, to use other themes in wallet settings,\n * you can use the camel case version of the name in the wallet settings.\n * For example: \"Blue Dark\" on wallet UI can be passed as \"blueDark\" */\nexport type ThemeOption = 'light' | 'dark' | string\nexport type PaymentProviderOption = 'ramp' | 'moonpay' | 'transak' | 'onmeta' | 'paytrie' | 'sardine'\nexport type CurrencyOption = 'usdc' | 'eth' | 'matic'\nexport type SignInOption = 'email' | 'google' | 'apple' | 'facebook' | 'discord' | 'twitch'\nexport type BannerSize = 'small' | 'medium' // | 'large'\n\nexport interface ConnectDetails {\n  // chainId (in hex) and error are defined by EIP-1193 expected fields\n  chainId?: string\n  error?: string\n\n  // connected flag denotes user-accepted the connect request\n  connected: boolean\n\n  // session include account and network information needed by the dapp wallet provider.\n  session?: WalletSession\n\n  // proof is a signed typedData (EIP-712) payload using ETHAuth domain.\n  // NOTE: the proof is signed to the `authChainId`, as the canonical auth chain.\n  proof?: ETHAuthProof\n\n  // email address provided from wallet to the dapp, as request + accepted\n  // by a user during a connect request\n  email?: string\n}\n\nexport type PromptConnectDetails = Pick<ConnectDetails, 'chainId' | 'error' | 'connected' | 'proof' | 'email'>\n\nexport type OpenWalletIntent =\n  | { type: 'connect'; options?: NetworkedConnectOptions }\n  | { type: 'openWithOptions'; options?: ConnectOptions }\n  | { type: 'jsonRpcRequest'; method: string }\n\nexport interface MessageToSign {\n  message?: Uint8Array\n  typedData?: TypedData\n  chainId?: number\n\n  eip6492?: boolean\n}\n\nexport type ETHAuthProof = AuthETHAuthProof\n\nexport interface WalletSession {\n  // Wallet context\n  walletContext?: commons.context.VersionedContext\n\n  // Account address of the wallet\n  accountAddress?: string\n\n  // Networks in use for the session. The default/dapp network will show\n  // up as the first one in the list as the \"main chain\"\n  networks?: NetworkConfig[]\n}\n\nexport class ProviderError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'ProviderError'\n  }\n}\n\nexport const ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.')\n\n// TODO: lets build some nice error handling tools, prob in /utils ...\n\nexport interface TypedEventEmitter<Events> {\n  addListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  on<E extends keyof Events>(event: E, listener: Events[E]): this\n  once<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this\n\n  off<E extends keyof Events>(event: E, listener: Events[E]): this\n  removeAllListeners<E extends keyof Events>(event?: E): this\n  removeListener<E extends keyof Events>(event: E, listener: Events[E]): this\n\n  emit<E extends keyof Events>(event: E, ...args: Arguments<Events[E]>): boolean\n  eventNames(): (keyof Events | string | symbol)[]\n\n  // eslint-disable-next-line\n  listeners<E extends keyof Events>(event: E): Function[]\n  listenerCount<E extends keyof Events>(event: E): number\n}\n\ntype Arguments<T> = [T] extends [(...args: infer U) => any] ? U : [T] extends [void] ? [] : [T]\n\nexport type OptionalChainIdLike =\n  | {\n      chainId?: ChainIdLike\n    }\n  | undefined\n\nexport type OptionalChainId =\n  | {\n      chainId?: number\n    }\n  | undefined\n\nexport type OptionalEIP6492 =\n  | {\n      eip6492?: boolean\n    }\n  | undefined\n","import { EventEmitter2 as EventEmitter } from 'eventemitter2'\n\nimport {\n  ProviderTransport,\n  ProviderMessage,\n  ProviderMessageRequest,\n  EventType,\n  ProviderEventTypes,\n  ProviderMessageResponse,\n  ProviderMessageResponseCallback,\n  OpenState,\n  OpenWalletIntent,\n  ConnectDetails,\n  WalletSession,\n  ProviderRpcError,\n  InitState,\n  TypedEventEmitter\n} from '../types'\n\nimport { NetworkConfig } from '@0xsequence/network'\nimport { logger } from '@0xsequence/utils'\nimport { ethers } from 'ethers'\nimport { VERSION, commons } from '@0xsequence/core'\n\nexport const PROVIDER_OPEN_TIMEOUT = 30000 // in ms\n\nlet _messageIdx = 0\n\nexport const nextMessageIdx = () => ++_messageIdx\n\nexport abstract class BaseProviderTransport implements ProviderTransport {\n  protected pendingMessageRequests: ProviderMessageRequest[] = []\n  protected responseCallbacks = new Map<number, ProviderMessageResponseCallback>()\n\n  protected state: OpenState\n  protected confirmationOnly: boolean = false\n  protected events: TypedEventEmitter<ProviderEventTypes> = new EventEmitter() as TypedEventEmitter<ProviderEventTypes>\n\n  protected openPayload: { sessionId?: string; session?: WalletSession } | undefined\n  protected connectPayload: ConnectDetails | undefined\n  protected accountsChangedPayload: { accounts: string[]; origin?: string } | undefined\n  protected networksPayload: NetworkConfig[] | undefined\n  protected walletContextPayload: commons.context.VersionedContext | undefined\n\n  protected _sessionId?: string\n  protected _init: InitState\n  protected _registered: boolean\n\n  constructor() {\n    this.state = OpenState.CLOSED\n    this._registered = false\n    this._init = InitState.NIL\n  }\n\n  get registered(): boolean {\n    return this._registered\n  }\n\n  register() {\n    throw new Error('abstract method')\n  }\n\n  unregister() {\n    throw new Error('abstract method')\n  }\n\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number) {\n    throw new Error('abstract method')\n  }\n\n  closeWallet() {\n    throw new Error('abstract method')\n  }\n\n  isOpened(): boolean {\n    return this.registered && this.state === OpenState.OPENED\n  }\n\n  isConnected(): boolean {\n    // if we're registered, and we have the account details, then we are connected\n    const session = this.openPayload?.session\n    return (\n      this.registered &&\n      session !== undefined &&\n      !!session.accountAddress &&\n      session.accountAddress.length === 42 &&\n      !!session.networks &&\n      session.networks.length > 0\n    )\n  }\n\n  async request(request: { method: string; params?: any[]; chainId?: number }): Promise<any> {\n    if (this.state === OpenState.CLOSED) {\n      // flag the wallet to auto-close once user submits input. ie.\n      // prompting to sign a message or transaction\n      this.confirmationOnly = true\n    }\n\n    // open/focus the wallet.\n    // automatically open the wallet when a provider request makes it here.\n    //\n    // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.\n    //\n    // TODO: how does this behave with a session has expired?\n    this.openWallet(undefined, { type: 'jsonRpcRequest', method: request.method }, request.chainId)\n\n    if (!this.isOpened()) {\n      await this.waitUntilOpened() // will throw on timeout\n    }\n\n    const response = await this.sendMessageRequest({\n      idx: nextMessageIdx(),\n      type: EventType.MESSAGE,\n      data: request,\n      chainId: request.chainId,\n      clientVersion: VERSION\n    })\n\n    return response.data\n  }\n\n  // handleMessage will handle message received from the remote wallet\n  handleMessage(message: ProviderMessage<any>) {\n    // init incoming for initial handshake with transport.\n    // always respond to INIT messages, e.g. on popup window reload\n    if (message.type === EventType.INIT) {\n      logger.debug('MessageProvider, received INIT message', message)\n      const { nonce } = message.data as { nonce: string }\n      if (!nonce || nonce.length == 0) {\n        logger.error('invalid init nonce')\n        return\n      }\n      this._init = InitState.OK\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          sessionId: this._sessionId,\n          nonce: nonce\n        },\n        clientVersion: VERSION\n      })\n    }\n\n    if (this._init !== InitState.OK) {\n      // if provider is not init'd, then we drop any received messages. the only\n      // message we will process is of event type 'init', as our acknowledgement\n      return\n    }\n\n    // message is either a notification, or its a ProviderMessageResponse\n    logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message)\n\n    const requestIdx = message.idx\n    const responseCallback = this.responseCallbacks.get(requestIdx)\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx)\n    }\n\n    // OPEN response\n    //\n    // Flip opened flag, and flush the pending queue\n    if (message.type === EventType.OPEN && !this.isOpened()) {\n      if (this._sessionId && this._sessionId !== message.data?.sessionId) {\n        logger.debug('open event received from wallet, but does not match sessionId', this._sessionId)\n        return\n      }\n\n      // check if open error occured due to invalid defaultNetworkId\n      if (message.data?.error) {\n        const err = new Error(`opening wallet failed: received ${message.data?.error}`)\n        logger.error(err)\n        this.close()\n        throw err\n      }\n\n      // success!\n      this.state = OpenState.OPENED\n      this.openPayload = message.data\n      this.events.emit('open', this.openPayload!)\n\n      // flush pending requests when connected\n      if (this.pendingMessageRequests.length !== 0) {\n        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length)\n\n        pendingMessageRequests.forEach(async pendingMessageRequest => {\n          this.sendMessage(pendingMessageRequest)\n        })\n      }\n\n      return\n    }\n\n    // MESSAGE resposne\n    if (message.type === EventType.MESSAGE) {\n      // Require user confirmation, bring up wallet to prompt for input then close\n      // TODO: perhaps apply technique like in multicall to queue messages within\n      // a period of time, then close the window if responseCallbacks is empty, this is better.\n      if (this.confirmationOnly) {\n        setTimeout(() => {\n          if (this.responseCallbacks.size === 0) {\n            this.closeWallet()\n          }\n        }, 500) // TODO: be smarter about timer as we're processing the response callbacks..\n      }\n\n      if (!responseCallback) {\n        // NOTE: this would occur if 'idx' isn't set, which should never happen\n        // or when we register two handler, or duplicate messages with the same idx are sent,\n        // all of which should be prevented prior to getting to this point\n        throw new Error('impossible state')\n      }\n\n      // Callback to original caller\n      if (responseCallback) {\n        this.events.emit('message', message)\n        responseCallback((message as ProviderMessageResponse).data.error, message)\n        return\n      }\n    }\n\n    // ACCOUNTS_CHANGED -- when a user logs in or out\n    if (message.type === EventType.ACCOUNTS_CHANGED) {\n      this.accountsChangedPayload = { accounts: [] }\n      if (message.data && message.data.length > 0) {\n        this.accountsChangedPayload = {\n          accounts: [ethers.getAddress(message.data[0])],\n          origin: message.origin\n        }\n        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin)\n      } else {\n        this.events.emit('accountsChanged', [], message.origin)\n      }\n      return\n    }\n\n    // CHAIN_CHANGED -- when a user changes their default chain\n    if (message.type === EventType.CHAIN_CHANGED) {\n      this.events.emit('chainChanged', message.data, message.origin)\n      return\n    }\n\n    // NOTIFY NETWORKS -- when a user connects or logs in\n    if (message.type === EventType.NETWORKS) {\n      this.networksPayload = message.data\n      this.events.emit('networks', this.networksPayload!)\n      return\n    }\n\n    // NOTIFY WALLET_CONTEXT -- when a user connects or logs in\n    if (message.type === EventType.WALLET_CONTEXT) {\n      this.walletContextPayload = message.data\n      this.events.emit('walletContext', this.walletContextPayload!)\n      return\n    }\n\n    // NOTIFY CLOSE -- when wallet instructs to close\n    if (message.type === EventType.CLOSE) {\n      if (this.state !== OpenState.CLOSED) {\n        this.close(message.data)\n      }\n    }\n\n    // NOTIFY CONNECT -- when wallet instructs we've connected\n    if (message.type === EventType.CONNECT) {\n      this.connectPayload = message.data\n      this.events.emit('connect', this.connectPayload!)\n    }\n\n    // NOTIFY DISCONNECT -- when wallet instructs to disconnect\n    if (message.type === EventType.DISCONNECT) {\n      if (this.isConnected()) {\n        this.events.emit('disconnect', message.data, message.origin)\n        this.close()\n      }\n    }\n  }\n\n  // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet\n  sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    return new Promise((resolve, reject) => {\n      if ((!message.idx || message.idx <= 0) && message.type !== 'init') {\n        reject(new Error('message idx not set'))\n      }\n\n      const responseCallback: ProviderMessageResponseCallback = (error: ProviderRpcError, response?: ProviderMessageResponse) => {\n        if (error) {\n          reject(error)\n        } else if (response) {\n          resolve(response)\n        } else {\n          throw new Error('no valid response to return')\n        }\n      }\n\n      const idx = message.idx\n      if (!this.responseCallbacks.get(idx)) {\n        this.responseCallbacks.set(idx, responseCallback)\n      } else {\n        reject(new Error('duplicate message idx, should never happen'))\n      }\n\n      if (!this.isOpened()) {\n        logger.debug('pushing to pending requests', message)\n        this.pendingMessageRequests.push(message)\n      } else {\n        this.sendMessage(message)\n      }\n    })\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    throw new Error('abstract method')\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.on(event, fn as any)\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.once(event, fn as any)\n  }\n\n  emit<K extends keyof ProviderEventTypes>(event: K, ...args: Parameters<ProviderEventTypes[K]>): boolean {\n    return this.events.emit(event, ...(args as any))\n  }\n\n  waitUntilOpened = async (openTimeout = PROVIDER_OPEN_TIMEOUT): Promise<WalletSession | undefined> => {\n    let opened = false\n    return Promise.race([\n      new Promise<WalletSession | undefined>((_, reject) => {\n        const timeout = setTimeout(() => {\n          clearTimeout(timeout)\n          // only emit close if the timeout wins the race\n          if (!opened) {\n            this.state = OpenState.CLOSED\n            this.events.emit('close', { code: 1005, message: 'opening wallet timed out' } as ProviderRpcError)\n          }\n          reject(new Error('opening wallet timed out'))\n        }, openTimeout)\n      }),\n      new Promise<WalletSession | undefined>(resolve => {\n        if (this.isOpened()) {\n          opened = true\n          resolve(this.openPayload?.session)\n          return\n        }\n        this.events.once('open', (openInfo: { session?: WalletSession }) => {\n          this.openPayload = openInfo\n          opened = true\n          resolve(openInfo.session)\n        })\n      })\n    ])\n  }\n\n  waitUntilConnected = async (): Promise<ConnectDetails> => {\n    await this.waitUntilOpened()\n\n    const connect = new Promise<ConnectDetails>(resolve => {\n      if (this.connectPayload) {\n        resolve(this.connectPayload)\n        return\n      }\n\n      this.events.once('connect', connectDetails => {\n        this.connectPayload = connectDetails\n        resolve(connectDetails)\n      })\n    })\n\n    const closeWallet = new Promise<ConnectDetails>((_, reject) => {\n      this.events.once('close', error => {\n        if (error) {\n          reject(new Error(`wallet closed due to ${JSON.stringify(error)}`))\n        } else {\n          reject(new Error(`user closed the wallet`))\n        }\n      })\n    })\n\n    return Promise.race<ConnectDetails>([connect, closeWallet])\n  }\n\n  protected close(error?: ProviderRpcError) {\n    if (this.state === OpenState.CLOSED) return\n\n    this.state = OpenState.CLOSED\n    this.confirmationOnly = false\n    this._sessionId = undefined\n    logger.info('closing wallet and flushing!')\n\n    // flush pending requests and return error to all callbacks\n    this.pendingMessageRequests.length = 0\n    this.responseCallbacks.forEach(responseCallback => {\n      responseCallback({\n        ...new Error('wallet closed'),\n        code: 4001\n      })\n    })\n    this.responseCallbacks.clear()\n\n    this.connectPayload = undefined\n    this.openPayload = undefined\n    this.accountsChangedPayload = undefined\n    this.networksPayload = undefined\n    this.walletContextPayload = undefined\n\n    this.events.emit('close', error)\n  }\n}\n","import { ethers } from 'ethers'\n\nexport function messageIsExemptFromEIP191Prefix(message: Uint8Array): boolean {\n  return EIP_191_PREFIX_EXCEPTIONS.some(e => e.predicate(message))\n}\n\nconst EIP_191_PREFIX_EXCEPTIONS: Array<{\n  name: string\n  predicate: (message: Uint8Array) => boolean\n}> = [\n  // NOTE: Decentraland does not support 191 correctly.\n  {\n    name: 'Decentraland Exception',\n    predicate: isDecentralandLoginMessage\n  },\n\n  // NOTE: 0x v3 does not support 191 correctly.\n  // See https://gov.0x.org/t/zeip-proposal-fix-v3-eip-191-non-compliance-when-validating-eip-1271-signatures/3396 for more info.\n  { name: '0x v3 Exception', predicate: isZeroExV3Order }\n]\n\nconst DCL_REGEX =\n  /^Decentraland Login\\nEphemeral address: 0x[a-fA-F0-9]{40}\\nExpiration: (\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)((-(\\d{2}):(\\d{2})|Z)?)$/\nexport function isDecentralandLoginMessage(bytes: Uint8Array): boolean {\n  try {\n    const stringified = ethers.toUtf8String(bytes)\n    return DCL_REGEX.test(stringified)\n  } catch {\n    return false\n  }\n}\n\n// try to interpret bytes as abi-encoded 0x v3 OrderWithHash -\n// see https://github.com/0xProject/0x-protocol-specification/blob/master/v3/v3-specification.md\nexport function isZeroExV3Order(bytes: Uint8Array): boolean {\n  const abi = new ethers.Interface(ZeroXV3EIP1271OrderWithHashAbi)\n  try {\n    abi.decodeFunctionData('OrderWithHash', bytes)\n    return true\n  } catch (err) {\n    // failed to decode ABI, so it's not a v3 order.\n    return false\n  }\n}\n\nconst ZeroXV3EIP1271OrderWithHashAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'makerAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'address',\n            name: 'takerAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'address',\n            name: 'feeRecipientAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'address',\n            name: 'senderAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerAssetAmount',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerAssetAmount',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerFee',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerFee',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'expirationTimeSeconds',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'salt',\n            type: 'uint256'\n          },\n          {\n            internalType: 'bytes',\n            name: 'makerAssetData',\n            type: 'bytes'\n          },\n          {\n            internalType: 'bytes',\n            name: 'takerAssetData',\n            type: 'bytes'\n          },\n          {\n            internalType: 'bytes',\n            name: 'makerFeeAssetData',\n            type: 'bytes'\n          },\n          {\n            internalType: 'bytes',\n            name: 'takerFeeAssetData',\n            type: 'bytes'\n          }\n        ],\n        internalType: 'struct IEIP1271Data.Order',\n        name: 'order',\n        type: 'tuple'\n      },\n      {\n        internalType: 'bytes32',\n        name: 'orderHash',\n        type: 'bytes32'\n      }\n    ],\n    name: 'OrderWithHash',\n    outputs: [],\n    stateMutability: 'pure',\n    type: 'function'\n  }\n]\n","import { ethers } from 'ethers'\nimport { messageIsExemptFromEIP191Prefix } from './eip191exceptions'\nimport { AccountStatus } from '@0xsequence/account'\nimport { commons } from '@0xsequence/core'\nimport { encodeMessageDigest, TypedData, encodeTypedDataDigest } from '@0xsequence/utils'\n\nconst eip191prefix = ethers.toUtf8Bytes('\\x19Ethereum Signed Message:\\n')\n\nexport const messageToBytes = (message: ethers.BytesLike): Uint8Array => {\n  if (ethers.isBytesLike(message)) {\n    return ethers.getBytes(message)\n  }\n\n  return ethers.toUtf8Bytes(message)\n}\n\nexport const prefixEIP191Message = (message: ethers.BytesLike): Uint8Array => {\n  const messageBytes = messageToBytes(message)\n  if (messageIsExemptFromEIP191Prefix(messageBytes)) {\n    return messageBytes\n  } else {\n    return ethers.getBytes(ethers.concat([eip191prefix, ethers.toUtf8Bytes(String(messageBytes.length)), messageBytes]))\n  }\n}\n\nexport const trimEIP191Prefix = (prefixedMessage: Uint8Array): Uint8Array => {\n  // If the message is not prefixed, we return the message as is.\n  if (JSON.stringify(prefixedMessage.slice(0, eip191prefix.length)) !== JSON.stringify(eip191prefix)) {\n    return prefixedMessage\n  }\n\n  // We have two parts to remove.\n  // First is the EIP-191 prefix.\n  const ethereumSignedMessagePartSlicedArray = prefixedMessage.slice(eip191prefix.length)\n\n  // Second is the digits added which represent length of the message without the prefix\n  // and we need to find the prefix that will match this.\n  // Here first we take the max prefix char length, and check if as a number it is bigger\n  // than the length of the message (since prefix is added to represent length of original message),\n  // if it is we remove 1 from char length, if not we keep the max prefix char length.\n  // As an example for the case where , if the message is 123456789, the expected prefix char is 9, with starting value 9123456789\n  // the char length of the total message with the prefix is 10, so the max prefix char length we start is 2 from [1,0], and as a number 10, it is longer\n  // than the length of the message after removing prefix (10 - 2 = 8), so we slice 1 char less, which is 9, and we get the correct prefix.\n  const maxPrefixCharLength = String(ethereumSignedMessagePartSlicedArray.length).length\n\n  let prefixCharLenght: number\n  let prefixAsNumber: number\n\n  try {\n    prefixAsNumber = Number(ethers.toUtf8String(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)))\n  } catch {\n    prefixAsNumber = Number(ethers.hexlify(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)))\n  }\n\n  if (prefixAsNumber > ethereumSignedMessagePartSlicedArray.length || !Number.isInteger(prefixAsNumber)) {\n    prefixCharLenght = maxPrefixCharLength - 1\n  } else {\n    prefixCharLenght = maxPrefixCharLength\n  }\n\n  const prefixRevertedMessage = ethereumSignedMessagePartSlicedArray.slice(prefixCharLenght)\n\n  return prefixRevertedMessage\n}\n\nexport const isValidSignature = async (\n  address: string,\n  digest: Uint8Array,\n  sig: string,\n  provider: ethers.Provider\n): Promise<boolean> => {\n  const reader = new commons.reader.OnChainReader(provider)\n  return reader.isValidSignature(address, digest, sig)\n}\n\n// Verify message signature\nexport const isValidMessageSignature = async (\n  address: string,\n  message: string | Uint8Array,\n  signature: string,\n  provider: ethers.Provider\n): Promise<boolean> => {\n  const prefixed = prefixEIP191Message(message)\n  const digest = encodeMessageDigest(prefixed)\n  return isValidSignature(address, digest, signature, provider)\n}\n\n// Verify typedData signature\nexport const isValidTypedDataSignature = (\n  address: string,\n  typedData: TypedData,\n  signature: string,\n  provider: ethers.Provider\n): Promise<boolean> => {\n  return isValidSignature(address, encodeTypedDataDigest(typedData), signature, provider)\n}\n\nexport const isBrowserExtension = (): boolean =>\n  window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:'\n\nexport const isUnityPlugin = (): boolean => !!navigator.userAgent.match(/UnitySequence/i)\n\n// /**\n//  * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status\n//  *\n//  * @param {Status} of the wallet\n//  */\nexport const isWalletUpToDate = (status: AccountStatus): boolean => {\n  return status.onChain.deployed && status.fullyMigrated\n}\n\nexport interface ItemStore {\n  getItem(key: string): string | null\n  setItem(key: string, value: string): void\n\n  removeItem(key: string): void\n\n  onItemChange(key: string, cb: (value: string | null) => void): () => void\n}\n\nexport class MemoryItemStore implements ItemStore {\n  private callbacks: { key: string; cb: (value: string | null) => void }[] = []\n  private store: Record<string, string> = {}\n\n  getItem(key: string): string | null {\n    return this.store[key] || null\n  }\n\n  setItem(key: string, value: string): void {\n    this.store[key] = value\n    this.callbacks.filter(c => c.key === key).forEach(c => c.cb(value))\n  }\n\n  removeItem(key: string): void {\n    delete this.store[key]\n  }\n\n  onItemChange(key: string, cb: (value: string | null) => void): () => void {\n    this.callbacks.push({ key, cb })\n\n    return () => {\n      this.callbacks = this.callbacks.filter(c => c.cb !== cb)\n    }\n  }\n}\n\nexport class LocalStorage implements ItemStore {\n  private callbacks: { key: string; cb: (value: string | null) => void }[] = []\n\n  static isAvailable(): boolean {\n    return typeof window === 'object' && typeof window.localStorage === 'object'\n  }\n\n  constructor() {\n    if (!LocalStorage.isAvailable()) {\n      throw new Error('LocalStorage is not available')\n    }\n\n    window.addEventListener('storage', e => {\n      const { key } = e\n      const cb = this.callbacks.filter(c => c.key === key)\n      cb.forEach(c => c.cb(this.getItem(key!)))\n    })\n  }\n\n  getItem(key: string): string | null {\n    return window.localStorage.getItem(key)\n  }\n\n  setItem(key: string, value: string): void {\n    window.localStorage.setItem(key, value)\n\n    // Trigger callbacks\n    // NOTICE: the event is not triggered on the same window\n    this.callbacks.filter(c => c.key === key).forEach(c => c.cb(value))\n  }\n\n  removeItem(key: string): void {\n    window.localStorage.removeItem(key)\n\n    // Trigger callbacks\n    // NOTICE: the event is not triggered on the same window\n    this.callbacks.filter(c => c.key === key).forEach(c => c.cb(null))\n  }\n\n  onItemChange(key: string, cb: (value: string | null) => void): () => void {\n    this.callbacks.push({ key, cb })\n\n    return () => {\n      this.callbacks = this.callbacks.filter(c => c.cb !== cb)\n    }\n  }\n}\n\nexport function useBestStore(): ItemStore {\n  if (LocalStorage.isAvailable()) {\n    return new LocalStorage()\n  }\n\n  return new MemoryItemStore()\n}\n\nexport async function resolveArrayProperties<T>(object: Readonly<T> | Readonly<T>[]): Promise<T> {\n  if (Array.isArray(object)) {\n    // T must include array type\n    return Promise.all(object.map(o => ethers.resolveProperties(o))) as any\n  }\n\n  return ethers.resolveProperties(object)\n}\n","import { ethers } from 'ethers'\nimport {\n  WalletTransport,\n  ProviderMessage,\n  ProviderMessageRequest,\n  EventType,\n  ProviderMessageResponse,\n  ProviderRpcError,\n  InitState,\n  ConnectDetails,\n  WalletSession,\n  TransportSession\n} from '../types'\n\nimport { WalletRequestHandler } from './wallet-request-handler'\n\nimport { NetworkConfig, findSupportedNetwork } from '@0xsequence/network'\nimport { logger, sanitizeAlphanumeric, sanitizeHost, sanitizeNumberString } from '@0xsequence/utils'\nimport { AuthorizationOptions } from '@0xsequence/auth'\n\nimport { PROVIDER_OPEN_TIMEOUT } from './base-provider-transport'\nimport { isBrowserExtension, useBestStore } from '../utils'\nimport { VERSION, commons } from '@0xsequence/core'\n\nconst TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession'\n\nexport abstract class BaseWalletTransport implements WalletTransport {\n  protected walletRequestHandler: WalletRequestHandler\n  protected _sessionId: string\n  protected _registered: boolean\n\n  protected _init: InitState\n  protected _initNonce: string\n  protected _initCallback?: (error?: string) => void\n\n  // appOrigin identifies the dapp's origin which opened the app. A transport\n  // will auto-detect and set this value if it can. This is determined\n  // as the parent app/window which opened the wallet.\n  protected appOrigin?: string\n\n  constructor(walletRequestHandler: WalletRequestHandler) {\n    this.walletRequestHandler = walletRequestHandler\n    this._init = InitState.NIL\n\n    this.walletRequestHandler.on('connect', (connectDetails: ConnectDetails) => {\n      if (!this.registered) return\n      // means user has logged in and wallet is connected to the app\n      this.notifyConnect(connectDetails)\n    })\n\n    this.walletRequestHandler.on('disconnect', (error?: ProviderRpcError, origin?: string) => {\n      if (!this.registered) return\n      // means user has logged out the app / disconnected wallet from the app\n      this.notifyDisconnect(error, origin)\n    })\n\n    this.walletRequestHandler.on('accountsChanged', (accounts: string[], origin?: string) => {\n      if (!this.registered) return\n      this.notifyAccountsChanged(accounts, origin)\n    })\n\n    this.walletRequestHandler.on('networks', (networks: NetworkConfig[]) => {\n      if (!this.registered) return\n      this.notifyNetworks(networks)\n      if (!networks || networks.length === 0) {\n        this.notifyChainChanged('0x0')\n      } else {\n        this.notifyChainChanged(ethers.toQuantity(networks.find(network => network.isDefaultChain)!.chainId))\n      }\n    })\n\n    this.walletRequestHandler.on('chainChanged', (chainIdHex: string, origin?: string) => {\n      this.notifyChainChanged(chainIdHex, origin)\n    })\n\n    this.walletRequestHandler.on('walletContext', (walletContext: commons.context.VersionedContext) => {\n      if (!this.registered || !walletContext) return\n      this.notifyWalletContext(walletContext)\n    })\n\n    this.walletRequestHandler.on('close', (error?: ProviderRpcError) => {\n      if (!this.registered) return\n      this.notifyClose(error)\n    })\n  }\n\n  get registered(): boolean {\n    return this._registered\n  }\n\n  register() {\n    throw new Error('abstract method')\n  }\n\n  unregister() {\n    throw new Error('abstract method')\n  }\n\n  request(request: { method: string; params?: any[]; chainId?: number }): Promise<any> {\n    throw new Error('abstract method')\n  }\n\n  handleMessage = async (message: ProviderMessage<any>) => {\n    const request = message\n\n    // ensure initial handshake is complete before accepting\n    // other kinds of messages.\n    if (this._init !== InitState.OK) {\n      if (request.type === EventType.INIT) {\n        if (this.isValidInitAck(message)) {\n          // successful init\n          if (this._initCallback) this._initCallback()\n        } else {\n          // failed init\n          if (this._initCallback) this._initCallback('invalid init')\n          return\n        }\n      } else {\n        // we expect init message first. do nothing here.\n      }\n      return\n    }\n\n    // ensure signer is ready to handle requests\n    // if (this.walletRequestHandler.getSigner() === undefined) {\n    //   await this.walletRequestHandler.signerReady()\n    // }\n\n    // handle request\n    switch (request.type) {\n      case EventType.OPEN: {\n        if (this._init !== InitState.OK) return\n        const session: TransportSession = {\n          sessionId: request.data.sessionId,\n          intent: request.data.intent,\n          networkId: request.data.networkId\n        }\n        await this.open(session)\n        return\n      }\n\n      case EventType.CLOSE: {\n        if (this._init !== InitState.OK) return\n        // noop. just here to capture the message so event emitters may be notified\n        return\n      }\n\n      case EventType.MESSAGE: {\n        const response = await this.walletRequestHandler.sendMessageRequest(request)\n        this.sendMessage(response)\n\n        if (response.data.error) {\n          // TODO: for certain errors, whenever we want to render something to the UI\n          // we should throw\n        }\n        return\n      }\n\n      default: {\n        logger.error(`unexpected payload type ${request.type}`)\n      }\n    }\n  }\n\n  // sendMessageRequest sends a ProviderMessageRequest to the wallet post-message transport\n  sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    return this.walletRequestHandler.sendMessageRequest(message)\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    throw new Error('abstract method')\n  }\n\n  notifyOpen(openInfo: { chainId?: string; sessionId?: string; session?: WalletSession; error?: string }) {\n    const { chainId, sessionId, session, error } = openInfo\n    this.sendMessage({\n      idx: -1,\n      type: EventType.OPEN,\n      data: {\n        chainId,\n        sessionId,\n        session,\n        error\n      },\n      clientVersion: VERSION\n    })\n  }\n\n  notifyClose(error?: ProviderRpcError) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: error ? { error } : null,\n      clientVersion: VERSION\n    })\n  }\n\n  notifyConnect(connectDetails: ConnectDetails) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CONNECT,\n      data: connectDetails,\n      clientVersion: VERSION\n    })\n  }\n\n  notifyDisconnect(error?: ProviderRpcError, origin?: string) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.DISCONNECT,\n      data: error ? { error } : null,\n      origin,\n      clientVersion: VERSION\n    })\n  }\n\n  notifyAccountsChanged(accounts: string[], origin?: string) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.ACCOUNTS_CHANGED,\n      data: accounts,\n      origin,\n      clientVersion: VERSION\n    })\n  }\n\n  notifyChainChanged(chainIdHex: string, origin?: string) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CHAIN_CHANGED,\n      data: chainIdHex,\n      origin,\n      clientVersion: VERSION\n    })\n  }\n\n  notifyNetworks(networks: NetworkConfig[]) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.NETWORKS,\n      data: networks,\n      clientVersion: VERSION\n    })\n  }\n\n  notifyWalletContext(walletContext: commons.context.VersionedContext) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.WALLET_CONTEXT,\n      data: walletContext,\n      clientVersion: VERSION\n    })\n  }\n\n  protected isValidInitAck(message: ProviderMessage<any>): boolean {\n    if (this._init === InitState.OK) {\n      // we're already in init state, we shouldn't handle this message\n      logger.warn(\"isValidInitAck, already in init'd state, so inquiry is invalid.\")\n      return false\n    }\n    if (message.type !== EventType.INIT) {\n      logger.warn('isValidInitAck, invalid message type, expecting init')\n      return false\n    }\n\n    const { sessionId, nonce } = message.data as any as { sessionId: string; nonce: string }\n    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {\n      logger.error('invalid init ack')\n      return false\n    }\n    if (sessionId !== this._sessionId || nonce !== this._initNonce) {\n      logger.error('invalid init ack match')\n      return false\n    }\n\n    // all checks pass, its true\n    return true\n  }\n\n  private init(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      // avoid re-init`ing, or if there is a transport which doesn't require\n      // it, then it may set this._init to OK in its constructor.\n      if (this._init === InitState.OK) {\n        resolve()\n        return\n      }\n      if (this._init !== InitState.NIL || this._initCallback) {\n        reject('transport init is in progress')\n        return\n      }\n\n      // start init timeout, if we don't receive confirmation\n      // from provider within this amount of time, then we timeout\n      const initTimeout = setTimeout(() => {\n        logger.warn('transport init timed out')\n        if (this._initCallback) {\n          this._initCallback('transport init timed out')\n        }\n      }, PROVIDER_OPEN_TIMEOUT / 2)\n\n      // setup callback as we receive the init message async in the handleMessage function\n      this._initCallback = (error?: string) => {\n        this._initCallback = undefined // reset\n        clearTimeout(initTimeout)\n        if (error) {\n          reject(error)\n        } else {\n          this._init = InitState.OK\n          resolve()\n        }\n      }\n\n      // send init request with random nonce to the provider, where we expect\n      // for the provider to echo it back to us as complete handshake\n      this._initNonce = `${performance.now()}`\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: { nonce: this._initNonce },\n        clientVersion: VERSION\n      })\n      this._init = InitState.SENT_NONCE\n\n      // NOTE: the promise will resolve in the _initCallback method\n      // which will be called from either handleMessage or the initTimeout\n    })\n  }\n\n  protected open = async ({ sessionId, intent, networkId }: TransportSession): Promise<boolean> => {\n    if (sessionId) {\n      this._sessionId = sanitizeNumberString(sessionId)\n      // persist transport session in localstorage for restoring after redirect/reload\n      this.saveTransportSession({ sessionId, intent, networkId })\n    }\n\n    this.walletRequestHandler.setOpenIntent(intent)\n\n    // init handshake for certain transports, before we can open the communication.\n    //\n    // for example, with the window-transport, we have to exchange messages to determine the\n    // origin host of the dapp.\n    await this.init()\n\n    // determine chainId from networkId (string or number)\n    let chainId: number | undefined = undefined\n    try {\n      if (networkId) {\n        const network = findSupportedNetwork(networkId)\n        if (network) {\n          chainId = network.chainId\n        } else {\n          throw new Error(`unknown network ${networkId}`)\n        }\n      } else {\n        // if not provided, use defaultChainId\n        chainId = this.walletRequestHandler.defaultChainId()\n      }\n    } catch (err) {\n      console.error(err)\n    }\n\n    // Prepare connect options from intent\n    if (intent && intent.type === 'connect' && intent.options) {\n      const connectOptions = intent.options\n      const authorizeOptions: AuthorizationOptions = connectOptions // overlapping types\n\n      // Sanity/integrity check the intent payload, and set authorization origin\n      // if its been determined as part of the init handshake from earlier.\n      if (this.appOrigin && authorizeOptions?.origin) {\n        if (!isBrowserExtension()) {\n          if (authorizeOptions.origin !== this.appOrigin) {\n            throw new Error('origin is invalid')\n          } else {\n            // request origin and derived origins match, lets carry on\n          }\n        }\n      } else if (!this.appOrigin && authorizeOptions?.origin) {\n        // ie. when we can't determine the origin in our transport, but dapp provides it to us.\n        // we just sanitize the origin host.\n        connectOptions.origin = sanitizeHost(authorizeOptions.origin)\n      } else if (this.appOrigin) {\n        // ie. when we auto-determine the origin such as in window-transport\n        connectOptions.origin = this.appOrigin\n      }\n      if (connectOptions.app) {\n        connectOptions.app = sanitizeAlphanumeric(connectOptions.app)\n      }\n\n      if (connectOptions.networkId) {\n        networkId = connectOptions.networkId\n      } else if (networkId) {\n        connectOptions.networkId = networkId\n      }\n\n      // Set connect options on the walletRequestHandler as our primary\n      // wallet controller, and fall back to networkId if necessary\n      this.walletRequestHandler.setConnectOptions(connectOptions)\n    } else {\n      this.walletRequestHandler.setConnectOptions(undefined)\n    }\n\n    // ensure signer is ready\n    await this.walletRequestHandler.getAccount()\n\n    // Notify open and proceed to prompt for connection if intended\n    if (!(await this.walletRequestHandler.isSignedIn())) {\n      // open wallet without a specific connected chainId, as the user is not signed in\n      this.notifyOpen({\n        sessionId: this._sessionId\n      })\n      return true\n    } else {\n      // prompt user with a connect request. the options will be used as previously set above.\n      // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.\n      // upon cancellation by user, the walletRequestHandler will throw an error\n\n      if (intent && intent.type === 'connect') {\n        // Failed to set default network on open\n        // Fail silently here so we can continue with connect flow and ask\n        // user to connect on a different network if necessary\n        if (!chainId || chainId <= 0) {\n          console.log('Failed to set default network on open')\n        }\n\n        // notify wallet is opened, without session details\n        this.notifyOpen({\n          sessionId: this._sessionId\n        })\n\n        try {\n          const connectDetails = await this.walletRequestHandler.promptConnect(intent.options)\n          if (connectDetails.connected) {\n            this.walletRequestHandler.notifyConnect(connectDetails)\n          }\n        } catch (err) {\n          logger.warn('promptConnect not connected:', err)\n        } finally {\n          // auto-close by default, unless intent is to keep open\n          if (!intent.options || intent.options.keepWalletOpened !== true) {\n            this.notifyClose()\n          }\n        }\n      } else {\n        // Using default network\n\n        // Failed to set default network on open -- quit + close\n        if (!chainId || chainId <= 0) {\n          this.notifyOpen({\n            sessionId: this._sessionId,\n            error: `failed to open wallet on network ${networkId}`\n          })\n          return false\n        }\n\n        // user is already connected, notify session details.\n        // TODO: in future, keep list if 'connected' dapps / sessions in the session\n        // controller, and only sync with allowed apps\n        this.notifyOpen({\n          sessionId: this._sessionId,\n          chainId: `${chainId}`,\n          session: await this.walletRequestHandler.walletSession(chainId)\n        })\n      }\n    }\n\n    return true\n  }\n\n  private saveTransportSession = (session: TransportSession) => {\n    useBestStore().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session))\n  }\n\n  protected getCachedTransportSession = async (): Promise<TransportSession | null> => {\n    const session = useBestStore().getItem(TRANSPORT_SESSION_LS_KEY)\n\n    try {\n      return session ? (JSON.parse(session) as TransportSession) : null\n    } catch (err) {\n      console.error(`unable to parse transport session: ${session}`)\n      return null\n    }\n  }\n}\n","import { EventEmitter2 as EventEmitter } from 'eventemitter2'\nimport { ProviderMessage, ProviderMessageTransport, ProviderEventTypes, TypedEventEmitter } from '../../types'\n\nexport class ProxyMessageChannel {\n  app: ProxyMessageChannelPort\n  wallet: ProxyMessageChannelPort\n\n  constructor() {\n    const port1 = new ProxyMessageChannelPort()\n    const port2 = new ProxyMessageChannelPort()\n\n    port1.conn = port2\n    port2.conn = port1\n\n    this.app = port1\n    this.wallet = port2\n  }\n}\n\nexport class ProxyMessageChannelPort implements ProviderMessageTransport {\n  conn: ProviderMessageTransport\n  events: TypedEventEmitter<ProxyEventTypes> = new EventEmitter() as TypedEventEmitter<ProxyEventTypes>\n\n  // handle messages which hit this port\n  handleMessage = (message: ProviderMessage<any>): void => {\n    throw new Error('ProxyMessageChannelPort is not registered')\n  }\n\n  // send messages to the connected port\n  sendMessage = (message: ProviderMessage<any>): void => {\n    this.conn.handleMessage(message)\n\n    // trigger events\n    if (message.type === 'open') {\n      this.events.emit('open', message as any)\n    }\n    if (message.type === 'close') {\n      this.events.emit('close', message as any)\n    }\n    if (message.type === 'connect') {\n      this.events.emit('connect', message as any)\n    }\n    if (message.type === 'disconnect') {\n      this.events.emit('disconnect', message as any)\n    }\n  }\n\n  on<K extends keyof ProxyEventTypes>(event: K, fn: ProxyEventTypes[K]) {\n    this.events.on(event, fn as any)\n  }\n\n  once<K extends keyof ProxyEventTypes>(event: K, fn: ProxyEventTypes[K]) {\n    this.events.once(event, fn as any)\n  }\n}\n\nexport type ProxyEventTypes = Pick<ProviderEventTypes, 'open' | 'close' | 'connect' | 'disconnect'>\n","import { BaseProviderTransport } from '../base-provider-transport'\n\nimport { ProviderMessage, OpenState, OpenWalletIntent, EventType, InitState } from '../../types'\n\nimport { ProxyMessageChannelPort, ProxyEventTypes } from './proxy-message-channel'\nimport { VERSION } from '@0xsequence/core'\n\nexport class ProxyMessageProvider extends BaseProviderTransport {\n  private port: ProxyMessageChannelPort\n\n  constructor(port: ProxyMessageChannelPort) {\n    super()\n    this.state = OpenState.CLOSED\n    this.port = port\n    if (!port) {\n      throw new Error('port argument cannot be empty')\n    }\n\n    // disable init handshake for proxy-transport, we set it to OK, to\n    // consider it in completed state.\n    this._init = InitState.OK\n  }\n\n  register = () => {\n    this.port.handleMessage = (message: ProviderMessage<any>): void => {\n      this.handleMessage(message)\n    }\n\n    this.on('open', (...args: Parameters<ProxyEventTypes['open']>) => {\n      this.port.events.emit('open', ...args)\n    })\n    this.on('close', (...args: Parameters<ProxyEventTypes['close']>) => {\n      this.port.events.emit('close', ...args)\n    })\n    this.on('connect', (...args: Parameters<ProxyEventTypes['connect']>) => {\n      this.port.events.emit('connect', ...args)\n    })\n    this.on('disconnect', (...args: Parameters<ProxyEventTypes['disconnect']>) => {\n      this.port.events.emit('disconnect', ...args)\n    })\n\n    this._registered = true\n  }\n\n  unregister = () => {\n    this._registered = false\n    this.closeWallet()\n    this.events.removeAllListeners()\n    // @ts-ignore\n    this.port.handleMessage = undefined\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.state === OpenState.CLOSED) {\n      this.state = OpenState.OPENING\n      const sessionId = `${performance.now()}`\n      this._sessionId = sessionId\n      this.sendMessage({\n        idx: -1,\n        type: EventType.OPEN,\n        data: {\n          path,\n          intent,\n          networkId,\n          sessionId\n        },\n        clientVersion: VERSION\n      })\n    }\n  }\n\n  closeWallet() {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: null,\n      clientVersion: VERSION\n    })\n    this.close()\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    if (!message.idx) {\n      throw new Error('message idx is empty')\n    }\n    this.port.sendMessage(message)\n  }\n}\n","interface UnrealInjectedWindow {\n  ue?: {\n    sequencewallettransport?: {\n      logfromjs: (message: string) => void\n      warnfromjs: (message: string) => void\n      errorfromjs: (message: string) => void\n    }\n  }\n  logsOverriddenForUnreal?: boolean\n}\ndeclare const window: Window & typeof globalThis & UnrealInjectedWindow\n\n/**\n * This will redirect console logs from Sequence.js & the wallet to the Unreal console, for debugging purposes.\n */\nexport function overrideLogs(side: 'dapp' | 'wallet') {\n  if (window.ue?.sequencewallettransport && !window.logsOverriddenForUnreal) {\n    const t = window.ue?.sequencewallettransport\n    console.log = (...args: unknown[]) => {\n      t.logfromjs(`${side}: ${stringify(args)}`)\n    }\n    console.warn = (...args: unknown[]) => {\n      t.warnfromjs(`${side}: ${stringify(args)}`)\n    }\n    console.error = (...args: unknown[]) => {\n      t.errorfromjs(`${side}: ${stringify(args)}`)\n    }\n    window.logsOverriddenForUnreal = true\n  }\n}\n\nfunction stringify(things: unknown[]): string {\n  return things.map(a => (typeof a === 'object' ? (a instanceof Error ? a.message : JSON.stringify(a)) : String(a))).join(' ')\n}\n","import { OpenWalletIntent, ProviderMessage, InitState, WindowSessionParams } from '../../types'\nimport { BaseProviderTransport } from '../base-provider-transport'\nimport { base64EncodeObject, bigintReplacer } from '@0xsequence/utils'\nimport { overrideLogs } from './overridelogs'\n\nlet registeredUnrealMessageProvider: UnrealMessageProvider | undefined\n\n// all lowercase is an annoying limitation of Unreal CEF BindUObject\ninterface UnrealInjectedSequenceJSWindow {\n  ue?: {\n    sequencewallettransport?: {\n      onmessagefromwallet?: (message: ProviderMessage<any>) => void\n      sendmessagetowallet: (message: string) => void\n    }\n  }\n}\n\ndeclare const window: Window & typeof globalThis & UnrealInjectedSequenceJSWindow\n\n/**\n * Initialized on dApp side\n */\nexport class UnrealMessageProvider extends BaseProviderTransport {\n  private walletURL: URL\n\n  constructor(walletAppURL: string) {\n    super()\n    this.walletURL = new URL(walletAppURL)\n  }\n\n  register = () => {\n    overrideLogs('dapp')\n    if (registeredUnrealMessageProvider) {\n      // overriding the registered message provider\n      registeredUnrealMessageProvider.unregister()\n      registeredUnrealMessageProvider = this\n    }\n\n    // listen for incoming messages from wallet\n    if (window.ue?.sequencewallettransport) {\n      window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback\n    }\n    registeredUnrealMessageProvider = this\n\n    this._registered = true\n    console.log('registering transport!')\n  }\n\n  unregister = () => {\n    this._registered = false\n    this.closeWallet()\n\n    // disable message listener\n    if (registeredUnrealMessageProvider === this) {\n      registeredUnrealMessageProvider = undefined\n    }\n    if (window.ue?.sequencewallettransport?.onmessagefromwallet === this.onUnrealCallback) {\n      delete window.ue.sequencewallettransport.onmessagefromwallet\n    }\n\n    // clear event listeners\n    this.events.removeAllListeners()\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.isOpened()) {\n      // TODO focus wallet\n      console.log('wallet already open!')\n      return\n    }\n\n    console.log('opening wallet!')\n    // Instantiate new walletURL for this call\n    const walletURL = new URL(this.walletURL.href)\n    const windowSessionParams = new WindowSessionParams()\n\n    if (path) {\n      walletURL.pathname = path.toLowerCase()\n    }\n\n    // Set session, intent and network id on walletURL\n    this._init = InitState.NIL\n    this._sessionId = `${performance.now()}`\n    windowSessionParams.set('sid', this._sessionId)\n\n    if (intent) {\n      // encode intent as base64 url-encoded param\n      windowSessionParams.set('intent', base64EncodeObject(intent))\n    }\n    if (networkId) {\n      windowSessionParams.set('net', `${networkId}`)\n    }\n    // serialize params\n    walletURL.search = windowSessionParams.toString()\n\n    console.log('opening wallet to', walletURL.href)\n\n    window.open(walletURL.href)\n  }\n\n  closeWallet() {\n    this.close()\n  }\n\n  // onmessage, receives ProviderMessageResponse from the wallet unreal transport\n  private onUnrealCallback = (message: ProviderMessage<any>) => {\n    if (!message) {\n      throw new Error('ProviderMessage object is empty')\n    }\n\n    // handle message with base message provider\n    this.handleMessage(message)\n  }\n\n  // all lowercase is an annoying limitation of Unreal CEF BindUObject\n  sendMessage(message: ProviderMessage<unknown>) {\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message, bigintReplacer) : message\n    console.log('Sending message to wallet:', postedMessage)\n    window.ue?.sequencewallettransport?.sendmessagetowallet(postedMessage)\n  }\n}\n","import { WalletRequestHandler } from '../wallet-request-handler'\nimport { BaseWalletTransport } from '../base-wallet-transport'\nimport { InitState, ProviderMessage } from '../../types'\nimport { Runtime } from 'webextension-polyfill'\nimport { logger } from '@0xsequence/utils'\n\nexport const CHANNEL_ID = 'sequence-extension-message-handler'\n\nexport class ExtensionMessageHandler extends BaseWalletTransport {\n  private port: any\n\n  constructor(\n    walletRequestHandler: WalletRequestHandler,\n    public runtime: Runtime.Static\n  ) {\n    super(walletRequestHandler)\n    this._init = InitState.OK\n  }\n\n  register() {\n    this._registered = true\n    this.port = this.runtime.connect({ name: CHANNEL_ID })\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    logger.info('[ExtensionMessageHandler send]', message)\n    this.port.postMessage(message)\n  }\n}\n","import { InitState, OpenWalletIntent, ProviderMessage } from '../../types'\nimport { BaseProviderTransport } from '../base-provider-transport'\nimport { CHANNEL_ID } from './extension-message-handler'\n\nimport { Runtime } from 'webextension-polyfill'\n\nexport class ExtensionMessageProvider extends BaseProviderTransport {\n  constructor(runtime: Runtime.Static) {\n    super()\n\n    runtime.onConnect.addListener(port => {\n      if (port.name === CHANNEL_ID) {\n        this._init = InitState.OK\n\n        port.onMessage.addListener((message: ProviderMessage<any>) => {\n          this.handleMessage(message)\n        })\n      }\n    })\n  }\n\n  register = () => {\n    this._registered = true\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    //noop\n  }\n\n  unregister() {\n    //noop\n  }\n\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number) {\n    //noop\n  }\n\n  closeWallet() {\n    //noop\n  }\n}\n","import { JsonRpcRequest, JsonRpcResponse } from '@0xsequence/network'\nimport { logger } from '@0xsequence/utils'\nimport { EventEmitter2 as EventEmitter } from 'eventemitter2'\nimport {\n  ProviderMessageResponseCallback,\n  ProviderMessage,\n  EventType,\n  ProviderMessageRequest,\n  ProviderMessageResponse\n} from '../../types'\n\nexport interface Stream {\n  on(ev: string | symbol, fn: (...args: any[]) => void): void\n  writable: boolean\n  write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean\n}\n\n// to be used on injected window.ethereum EIP1193 proxy\nexport abstract class BaseInjectedTransport extends EventEmitter {\n  protected responseCallbacks = new Map<number, ProviderMessageResponseCallback>()\n\n  private _messageIdx = 0\n  protected nextMessageIdx = () => ++this._messageIdx\n\n  constructor(private stream: Stream) {\n    super()\n\n    this.stream.on('data', this.handleMessage)\n  }\n\n  private handleMessage = (message: ProviderMessage<JsonRpcResponse>) => {\n    if (!message.type || !message.data) {\n      return\n    }\n\n    logger.info('[received message]', message)\n\n    const requestIdx = message.idx\n    const responseCallback = this.responseCallbacks.get(requestIdx)\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx)\n    }\n\n    switch (message.type) {\n      case EventType.MESSAGE:\n        if (responseCallback) {\n          this.emit(EventType.MESSAGE, message)\n          responseCallback(message.data.error, message)\n        } else {\n          // NOTE: this would occur if 'idx' isn't set, which should never happen\n          // or when we register two handler, or duplicate messages with the same idx are sent,\n          // all of which should be prevented prior to getting to this point\n          throw new Error('impossible state')\n        }\n        break\n      case EventType.DISCONNECT:\n      case EventType.ACCOUNTS_CHANGED:\n      case EventType.CHAIN_CHANGED:\n        this.emit(message.type, message.data)\n        break\n      default:\n        console.error('unknown message type', message)\n        break\n    }\n  }\n\n  protected sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    return new Promise((resolve, reject) => {\n      if (!message.idx || message.idx <= 0) {\n        reject(new Error('message idx not set'))\n      }\n\n      const responseCallback: ProviderMessageResponseCallback = (error: any, response?: ProviderMessageResponse) => {\n        if (error) {\n          reject(error)\n        } else if (response) {\n          resolve(response)\n        } else {\n          throw new Error('no valid response to return')\n        }\n      }\n\n      const { idx } = message\n      if (!this.responseCallbacks.get(idx)) {\n        this.responseCallbacks.set(idx, responseCallback)\n      } else {\n        reject(new Error('duplicate message idx, should never happen'))\n      }\n\n      this.sendMessage(message)\n    })\n  }\n\n  private sendMessage(message: ProviderMessage<JsonRpcRequest>) {\n    if (!this.stream.writable) {\n      console.error('window post message stream is not writable')\n    }\n\n    this.stream.write(message)\n  }\n}\n","import { OpenWalletIntent, ProviderMessage, InitState, WindowSessionParams } from '../../types'\nimport { BaseProviderTransport } from '../base-provider-transport'\nimport { logger, base64EncodeObject, bigintReplacer, bigintReviver } from '@0xsequence/utils'\nimport { isBrowserExtension, isUnityPlugin } from '../../utils'\n\n// ..\nlet registeredWindowMessageProvider: WindowMessageProvider | undefined\n\nexport class WindowMessageProvider extends BaseProviderTransport {\n  private walletURL: URL\n  private walletWindow: Window | null\n\n  constructor(walletAppURL: string) {\n    super()\n    this.walletURL = new URL(walletAppURL)\n  }\n\n  register = () => {\n    if (registeredWindowMessageProvider) {\n      // overriding the registered message provider\n      registeredWindowMessageProvider.unregister()\n      registeredWindowMessageProvider = this\n    }\n\n    // listen for incoming messages from wallet\n    window.addEventListener('message', this.onWindowEvent)\n    registeredWindowMessageProvider = this\n\n    // open heartbeat\n    this.on('open', () => {\n      // Heartbeat to track if window closed\n      const popup = this.walletWindow\n      const interval = setInterval(() => {\n        if (popup && popup.closed) {\n          clearInterval(interval)\n          this.close()\n        }\n      }, 500)\n    })\n\n    // close clean up\n    this.on('close', () => {\n      if (this.walletWindow) {\n        this.walletWindow.close()\n        this.walletWindow = null\n      }\n    })\n\n    this._registered = true\n  }\n\n  unregister = () => {\n    this._registered = false\n    this.closeWallet()\n\n    // disable message listener\n    if (registeredWindowMessageProvider === this) {\n      registeredWindowMessageProvider = undefined\n    }\n    window.removeEventListener('message', this.onWindowEvent)\n\n    // clear event listeners\n    this.events.removeAllListeners()\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.walletWindow && this.isOpened()) {\n      // TODO: update the location of window to path\n      this.walletWindow.focus()\n      return\n    }\n\n    // Instantiate new walletURL for this call\n    const walletURL = new URL(this.walletURL.href)\n    const windowSessionParams = new WindowSessionParams()\n\n    if (path && path !== '') {\n      walletURL.pathname = path.toLowerCase()\n    }\n\n    // Set session, intent and network id on walletURL\n    this._init = InitState.NIL\n    this._sessionId = `${performance.now()}`\n    windowSessionParams.set('sid', this._sessionId)\n\n    if (intent) {\n      // for the window-transport, we eagerly/optimistically set the origin host\n      // when connecting to the wallet, however, this will be verified and enforced\n      // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.\n      if (intent.type === 'connect') {\n        if (!intent.options)\n          intent.options = {\n            app: window.location.origin\n          }\n\n        // skip setting origin host if we're in an browser extension execution context\n        // allow origin that is passed in\n        if (!isBrowserExtension() && !isUnityPlugin() && intent.options) {\n          intent.options.origin = window.location.origin\n        }\n      }\n      // encode intent as base64 url-encoded param\n      windowSessionParams.set('intent', base64EncodeObject(intent))\n    }\n    if (networkId) {\n      windowSessionParams.set('net', `${networkId}`)\n    }\n\n    // Open popup window on center of the app window\n    let windowSize: number[]\n    let windowPos: number[]\n\n    if (isBrowserExtension()) {\n      windowSize = [450, 750]\n      windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)]\n    } else {\n      windowSize = [450, 750]\n      windowPos = [\n        Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2),\n        Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)\n      ]\n    }\n\n    const windowFeatures =\n      `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` +\n      `,width=${windowSize[0]},height=${windowSize[1]}` +\n      `,left=${windowPos[0]},top=${windowPos[1]}`\n\n    // serialize params\n    walletURL.search = windowSessionParams.toString()\n\n    this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures)\n\n    // TODO: move this somewhere else\n    // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.\n\n    // Popup blocking detection and notice\n    // let warned = false\n    // const warnPopupBlocked = () => {\n    //   if (warned) return\n    //   warned = true\n    //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only\n    //   throw new Error('popup is blocked')\n    // }\n\n    // const popupCheck = setTimeout(() => {\n    //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {\n    //     // popup is definitely blocked if we reach here.\n    //     warnPopupBlocked()\n    //   }\n    // }, 1000)\n\n    // const popupBlocked = popup === null || popup === undefined\n    // if (popupBlocked) {\n    //   warnPopupBlocked()\n    //   return\n    // }\n  }\n\n  closeWallet() {\n    this.close()\n    this.walletWindow?.close()\n  }\n\n  // onmessage, receives ProviderMessageResponse from the wallet post-message transport\n  private onWindowEvent = (event: MessageEvent) => {\n    // Security check, ensure message is coming from wallet origin url\n    if (event.origin !== this.walletURL.origin) {\n      // Safetly can skip events not from the wallet\n      return\n    }\n\n    let message: ProviderMessage<any>\n    try {\n      message = JSON.parse(event.data, bigintReviver)\n    } catch (err) {\n      // event is not a ProviderMessage JSON object, skip\n      return\n    }\n\n    if (!message) {\n      throw new Error('ProviderMessage object is empty')\n    }\n\n    // handle message with base message provider\n    this.handleMessage(message)\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    if (!this.walletWindow) {\n      logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable')\n      return\n    }\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message, bigintReplacer) : message\n    this.walletWindow.postMessage(postedMessage, this.walletURL.origin)\n  }\n}\n","import {\n  ProviderMessage,\n  ProviderTransport,\n  ProviderEventTypes,\n  ProviderMessageRequest,\n  ProviderMessageResponse,\n  WalletSession,\n  OpenWalletIntent,\n  ConnectDetails\n} from '../../types'\n\nimport { ProxyMessageChannelPort, ProxyMessageProvider } from '../proxy-transport'\nimport { Runtime } from 'webextension-polyfill'\nimport { UnrealMessageProvider } from '../unreal-transport'\nimport { ExtensionMessageProvider } from '../extension-transport'\nimport { WindowMessageProvider } from '../window-transport'\nimport { JsonRpcResponse } from '@0xsequence/network'\n\nexport type MuxTransportTemplate = {\n  walletAppURL?: string\n\n  // WindowMessage transport (optional)\n  windowTransport?: {\n    enabled: boolean\n  }\n\n  // ProxyMessage transport (optional)\n  proxyTransport?: {\n    enabled: boolean\n    appPort?: ProxyMessageChannelPort\n  }\n\n  // Extension transport (optional)\n  extensionTransport?: {\n    enabled: boolean\n    runtime: Runtime.Static\n  }\n\n  // Unreal Engine transport (optional)\n  unrealTransport?: {\n    enabled: boolean\n  }\n}\n\nexport function isMuxTransportTemplate(obj: any): obj is MuxTransportTemplate {\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    ((obj.windowTransport && typeof obj.windowTransport === 'object') ||\n      (obj.proxyTransport && typeof obj.proxyTransport === 'object') ||\n      (obj.extensionTransport && typeof obj.extensionTransport === 'object') ||\n      (obj.unrealTransport && typeof obj.unrealTransport === 'object')) &&\n    // One of the transports must be enabled\n    ((obj.windowTransport && obj.windowTransport.enabled) ||\n      (obj.proxyTransport && obj.proxyTransport.enabled) ||\n      (obj.extensionTransport && obj.extensionTransport.enabled) ||\n      (obj.unrealTransport && obj.unrealTransport.enabled))\n  )\n}\n\nexport class MuxMessageProvider implements ProviderTransport {\n  private messageProviders: ProviderTransport[]\n  private provider: ProviderTransport | undefined\n\n  constructor(...messageProviders: ProviderTransport[]) {\n    this.messageProviders = messageProviders\n    this.provider = undefined\n  }\n\n  static new(template: MuxTransportTemplate): MuxMessageProvider {\n    const muxMessageProvider = new MuxMessageProvider()\n\n    if (template.windowTransport?.enabled && typeof window === 'object' && template.walletAppURL) {\n      const windowMessageProvider = new WindowMessageProvider(template.walletAppURL)\n      muxMessageProvider.add(windowMessageProvider)\n    }\n\n    if (template.proxyTransport?.enabled) {\n      const proxyMessageProvider = new ProxyMessageProvider(template.proxyTransport.appPort!)\n      muxMessageProvider.add(proxyMessageProvider)\n    }\n\n    if (template.extensionTransport?.enabled) {\n      const extensionMessageProvider = new ExtensionMessageProvider(template.extensionTransport.runtime)\n      muxMessageProvider.add(extensionMessageProvider)\n\n      // NOTE/REVIEW: see note in mux-message-provider\n      //\n      // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to\n      // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break\n      // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.\n    }\n\n    if (template.unrealTransport?.enabled && template.windowTransport && template.walletAppURL) {\n      const unrealMessageProvider = new UnrealMessageProvider(template.walletAppURL)\n      muxMessageProvider.add(unrealMessageProvider)\n    }\n\n    muxMessageProvider.register()\n\n    return muxMessageProvider\n  }\n\n  add(...messageProviders: ProviderTransport[]) {\n    this.messageProviders.push(...messageProviders)\n  }\n\n  register = () => {\n    if (this.messageProviders.length === 1) {\n      this.provider = this.messageProviders[0]\n      this.provider.register()\n      return\n    }\n\n    // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes\n    // when the browser quits or restarts, the \"open\" event is never triggered. Perhaps the code here is fine,\n    // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet\n    // below, in which case one of the events will register. So perhaps this is fine.\n    this.messageProviders.forEach(m => {\n      m.register()\n\n      m.once('open', () => {\n        // the first one to open is the winner, and others will be unregistered\n        if (!this.provider) {\n          this.provider = m\n\n          // unregister other providers\n          this.messageProviders.forEach(m => {\n            if (this.provider !== m) {\n              m.unregister()\n            }\n          })\n        }\n      })\n    })\n  }\n\n  unregister = () => {\n    this.messageProviders.forEach(m => m.unregister())\n    this.provider = undefined\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.provider) {\n      this.provider.openWallet(path, intent, networkId)\n      return\n    }\n    this.messageProviders.forEach(m => m.openWallet(path, intent, networkId))\n  }\n\n  closeWallet() {\n    if (this.provider) {\n      this.provider.closeWallet()\n    }\n  }\n\n  isOpened(): boolean {\n    if (this.provider) {\n      return this.provider.isOpened()\n    }\n    return false\n  }\n\n  isConnected(): boolean {\n    if (this.provider) {\n      return this.provider.isConnected()\n    }\n    return false\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    if (this.provider) {\n      this.provider.on(event, fn)\n      return\n    }\n    this.messageProviders.forEach(m => {\n      m.on(event, fn)\n    })\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    if (this.provider) {\n      this.provider.once(event, fn)\n      return\n    }\n    this.messageProviders.forEach(m => {\n      m.once(event, fn)\n    })\n  }\n\n  emit<K extends keyof ProviderEventTypes>(event: K, ...args: Parameters<ProviderEventTypes[K]>): boolean {\n    if (this.provider) {\n      return this.provider.emit(event, ...args)\n    }\n    for (let i = 0; i < this.messageProviders.length; i++) {\n      this.messageProviders[i].emit(event, ...args)\n    }\n    return true\n  }\n\n  request(request: { method: string; params?: any[]; chainId?: number }): Promise<any> {\n    if (!this.provider) {\n      throw new Error('impossible state, wallet must be opened first')\n    }\n    return this.provider.request(request)\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    if (!message.idx || message.idx <= 0) {\n      throw new Error('message idx is empty')\n    }\n\n    if (this.provider) {\n      this.provider.sendMessage(message)\n    } else {\n      throw new Error('impossible state, wallet must be opened first')\n    }\n  }\n\n  sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    if (this.provider) {\n      return this.provider.sendMessageRequest(message)\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n\n  handleMessage(message: ProviderMessage<any>): void {\n    if (this.provider) {\n      this.provider.handleMessage(message)\n      return\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n\n  waitUntilOpened = async (): Promise<WalletSession | undefined> => {\n    if (this.provider) {\n      return this.provider.waitUntilOpened()\n    }\n    return Promise.race(this.messageProviders.map(p => p.waitUntilOpened()))\n  }\n\n  waitUntilConnected = async (): Promise<ConnectDetails> => {\n    if (this.provider) {\n      return this.provider.waitUntilConnected()\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n}\n","import { Account, AccountStatus } from '@0xsequence/account'\nimport { signAuthorization, AuthorizationOptions } from '@0xsequence/auth'\nimport { commons } from '@0xsequence/core'\nimport {\n  ChainId,\n  ChainIdLike,\n  findNetworkConfig,\n  findSupportedNetwork,\n  NetworkConfig,\n  EIP1193Provider,\n  JsonRpcResponse\n} from '@0xsequence/network'\nimport { logger, toHexString, TypedData } from '@0xsequence/utils'\nimport { ethers } from 'ethers'\nimport { EventEmitter2 as EventEmitter } from 'eventemitter2'\n\nimport { fromExtended } from '../extended'\nimport { validateTransactionRequest } from '../transactions'\nimport {\n  ConnectDetails,\n  ConnectOptions,\n  ErrSignedInRequired,\n  MessageToSign,\n  NetworkedConnectOptions,\n  OpenWalletIntent,\n  PromptConnectDetails,\n  ProviderEventTypes,\n  ProviderMessageRequest,\n  ProviderMessageRequestHandler,\n  ProviderMessageResponse,\n  ProviderRpcError,\n  TypedEventEmitter,\n  WalletSession\n} from '../types'\nimport { prefixEIP191Message } from '../utils'\n\nconst SIGNER_READY_TIMEOUT = 10000\n\nexport interface WalletSignInOptions {\n  connect?: boolean\n  defaultNetworkId?: number\n}\n\nexport class WalletRequestHandler implements EIP1193Provider, ProviderMessageRequestHandler {\n  // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined\n  // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course\n  // a Signer value is the actually interface to a signed-in account\n  private account: Account | null | undefined\n  private signerReadyCallbacks: Array<() => void> = []\n\n  private prompter: WalletUserPrompter | null\n  private networks: NetworkConfig[]\n\n  private _openIntent?: OpenWalletIntent\n  private _connectOptions?: ConnectOptions\n\n  private events: TypedEventEmitter<ProviderEventTypes> = new EventEmitter() as TypedEventEmitter<ProviderEventTypes>\n\n  onConnectOptionsChange: ((connectOptions: ConnectOptions | undefined) => void) | undefined = undefined\n\n  constructor(account: Account | null | undefined, prompter: WalletUserPrompter | null, networks: NetworkConfig[]) {\n    this.account = account\n    this.prompter = prompter\n    this.networks = networks\n  }\n\n  defaultChainId(): number {\n    return this.prompter?.getDefaultChainId() ?? this.networks[0].chainId\n  }\n\n  async signIn(account: Account | null, options: WalletSignInOptions = {}) {\n    this.setAccount(account)\n\n    const { connect, defaultNetworkId } = options\n\n    // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform\n    // necessary auth request, and then notify the dapp of the 'connect' details.\n    //\n    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made\n    // we don't trigger the promptConnect flow, as we consider the user just authenticated\n    // for this dapp, so its safe to authorize in the promptSignInConnect() which will directly\n    // connect after signing in.\n    //\n    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows\n    if (connect) {\n      const connectOptions = this._connectOptions\n\n      let connectDetails: ConnectDetails | PromptConnectDetails\n\n      if (this.prompter !== null) {\n        connectDetails = await this.prompter?.promptSignInConnect(connectOptions)\n      } else {\n        connectDetails = await this.connect(connectOptions)\n      }\n\n      this.notifyConnect(connectDetails)\n\n      if (!connectOptions || connectOptions.keepWalletOpened !== true) {\n        this.notifyClose()\n      }\n    }\n\n    if (defaultNetworkId && this.defaultChainId() !== defaultNetworkId) {\n      await this.prompter?.promptChangeNetwork(defaultNetworkId)\n    }\n  }\n\n  signOut() {\n    if (this.account) {\n      this.notifyDisconnect()\n    }\n\n    // signed out state\n    this.setAccount(null)\n  }\n\n  signerReset() {\n    // resetting signer puts the wallet in an uninitialized state, which requires the app to\n    // re-initiatize and set the signer either as \"null\" (ie. no signer) or \"Signer\" (ie. signed in).\n    this.account = undefined\n  }\n\n  signerReady(timeout: number = SIGNER_READY_TIMEOUT): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.account !== undefined) {\n        resolve()\n      } else {\n        setTimeout(() => {\n          if (this.account === undefined) {\n            this.signerReadyCallbacks = []\n            reject(`signerReady timed out`)\n          }\n        }, timeout)\n        this.signerReadyCallbacks.push(resolve)\n      }\n    })\n  }\n\n  async connect(options?: NetworkedConnectOptions): Promise<ConnectDetails> {\n    if (!this.account) {\n      return {\n        connected: false,\n        chainId: '0x0',\n        error: 'unable to connect without signed in account'\n      }\n    }\n\n    const networkId = options?.networkId ?? this.defaultChainId() ?? ChainId.MAINNET\n    const chainId = findSupportedNetwork(networkId)!.chainId\n\n    const connectDetails: ConnectDetails = {\n      connected: true,\n      chainId: ethers.toQuantity(chainId)\n    }\n\n    if (options && options.authorize) {\n      // Perform ethauth eip712 request and construct the ConnectDetails response\n      // including the auth proof\n      const authOptions: AuthorizationOptions = {\n        app: options.app,\n        origin: options.origin,\n        expiry: options.expiry,\n        nonce: options.authorizeNonce\n      }\n      // if (typeof(options.authorize) === 'object') {\n      //   authOptions = { ...authOptions, ...options.authorize }\n      // }\n\n      try {\n        // TODO: Either implement account as a signer, or change signAuthorization to accept an account\n        connectDetails.proof = await signAuthorization(this.account, chainId, authOptions)\n      } catch (err) {\n        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`)\n        return {\n          connected: false,\n          chainId: '0x0',\n          error: `signAuthorization failed: ${err.message}`\n        }\n      }\n    }\n\n    // Build session response for connect details\n    connectDetails.session = this.walletSession(chainId)\n\n    return connectDetails\n  }\n\n  promptConnect = async (options?: NetworkedConnectOptions): Promise<ConnectDetails> => {\n    if (!options && !this._connectOptions) {\n      // this is an unexpected state and should not happen\n      throw new Error('prompter connect options are empty')\n    }\n\n    if (!this.prompter) {\n      // if prompter is null, we'll auto connect\n      return this.connect(options)\n    }\n\n    const promptConnectDetails = await this.prompter.promptConnect(options || this._connectOptions).catch(_ => {\n      return { connected: false } as ConnectDetails\n    })\n\n    const connectDetails: ConnectDetails = promptConnectDetails\n    if (connectDetails.connected && !connectDetails.session) {\n      connectDetails.session = await this.walletSession(options?.networkId)\n    }\n\n    return promptConnectDetails\n  }\n\n  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler\n  // (aka, the signer in this instance) and then responds with a wrapped response of\n  // ProviderMessageResponse to be sent over the transport\n  async sendMessageRequest(message: ProviderMessageRequest): Promise<ProviderMessageResponse> {\n    // Older versions of the client require the response to be jsonrpc wrapped\n    const majorVersion = Number(message.clientVersion?.split('.')[0] || '0')\n    const isJsonRpcResponse = majorVersion < 2\n    const jsonRpcResponse: JsonRpcResponse = {\n      id: message.data.id!,\n      jsonrpc: '2.0',\n      result: null,\n      error: undefined\n    }\n\n    try {\n      const result = await this.request({\n        method: message.data.method,\n        params: message.data.params,\n        chainId: message.chainId\n      })\n\n      return {\n        ...message,\n        data: isJsonRpcResponse ? { ...jsonRpcResponse, result } : result\n      }\n    } catch (error) {\n      return {\n        ...message,\n        data: isJsonRpcResponse ? { ...jsonRpcResponse, error } : { error }\n      }\n    }\n  }\n\n  async request(request: { method: string; params?: any[]; chainId?: number }): Promise<any> {\n    await this.getAccount()\n\n    try {\n      // only allow public json rpc method to the provider when user is not logged in, aka signer is not set\n      if ((!this.account || this.account === null) && !permittedJsonRpcMethods.includes(request.method)) {\n        // throw new Error(`not logged in. ${request.method} is unavailable`)\n        throw ErrSignedInRequired\n      }\n\n      // wallet account\n      const account = this.account\n      if (!account) {\n        throw new Error('WalletRequestHandler: wallet account is not configured')\n      }\n\n      // fetch the provider for the specific chain, or undefined will select defaultChain\n      const provider = this.account?.providerFor(request.chainId ?? this.defaultChainId())\n      if (!provider) {\n        throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${request.chainId}`)\n      }\n\n      // NOTE: we cannot use `instanceof ethers.JsonRpcProvider` because despite that we know\n      // its the proper type, its not resolving properly at runtime during the pupeteer e2e tests.\n      // Switching to the type guard function below is safer and more reliable.\n      //\n      // const jsonRpcProvider = provider instanceof ethers.JsonRpcProvider ? provider : undefined\n      const jsonRpcProvider = isJsonRpcProvider(provider) ? provider : undefined\n\n      switch (request.method) {\n        case 'net_version': {\n          if (!jsonRpcProvider) {\n            throw new Error(`Account provider doesn't support send method`)\n          }\n\n          return await jsonRpcProvider.send('net_version', [])\n        }\n\n        case 'eth_chainId': {\n          if (!jsonRpcProvider) {\n            throw new Error(`Account provider doesn't support send method`)\n          }\n\n          return await jsonRpcProvider.send('eth_chainId', [])\n        }\n\n        case 'eth_accounts': {\n          return [account.address]\n        }\n\n        case 'eth_getBalance': {\n          const [accountAddress, blockTag] = request.params!\n          const walletBalance = await provider.getBalance(accountAddress, blockTag)\n          return toHexString(walletBalance)\n        }\n\n        case 'sequence_sign':\n        case 'personal_sign':\n        case 'eth_sign': {\n          // note: message from json-rpc input is in hex format\n          let message: any\n\n          // there is a difference in the order of the params:\n          // sequence_sign, personal_sign: [data, address]\n          // eth_sign: [address, data]\n          switch (request.method) {\n            case 'sequence_sign':\n            case 'personal_sign': {\n              const [data, _address] = request.params!\n              message = data\n              break\n            }\n            case 'eth_sign': {\n              const [_address, data] = request.params!\n              message = data\n              break\n            }\n          }\n\n          let sig = ''\n\n          // Message must be prefixed with \"\\x19Ethereum Signed Message:\\n\"\n          // as defined by EIP-191\n          const prefixedMessage = prefixEIP191Message(message)\n\n          // TODO:\n          // if (process.env.TEST_MODE === 'true' && this.prompter === null) {\n          const sequenceVerified = request.method === 'sequence_sign'\n\n          if (this.prompter === null) {\n            // prompter is null, so we'll sign from here\n            sig = await account.signMessage(\n              prefixedMessage,\n              request.chainId ?? this.defaultChainId(),\n              sequenceVerified ? 'eip6492' : 'ignore'\n            )\n          } else {\n            sig = await this.prompter.promptSignMessage(\n              {\n                chainId: request.chainId,\n                message: ethers.getBytes(prefixedMessage),\n                eip6492: sequenceVerified\n              },\n              this.connectOptions\n            )\n          }\n\n          if (sig && sig.length > 0) {\n            return sig\n          } else {\n            // The user has declined the request when value is null\n            throw new Error('declined by user')\n          }\n        }\n\n        case 'sequence_signTypedData_v4':\n        case 'eth_signTypedData':\n        case 'eth_signTypedData_v4': {\n          // note: signingAddress from json-rpc input is in hex format, and typedDataObject\n          // should be an object, but in some instances may be double string encoded\n          const [signingAddress, typedDataObject] = request.params!\n\n          let typedData: TypedData | undefined = undefined\n          if (typeof typedDataObject === 'string') {\n            try {\n              typedData = JSON.parse(typedDataObject)\n            } catch (e) {\n              console.warn('walletRequestHandler: error parsing typedData', e)\n            }\n          } else {\n            typedData = typedDataObject\n          }\n\n          if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {\n            throw new Error('invalid typedData object')\n          }\n\n          let sig = ''\n\n          const sequenceVerified = request.method === 'sequence_signTypedData_v4'\n          if (this.prompter === null) {\n            // prompter is null, so we'll sign from here\n            sig = await account.signTypedData(\n              typedData.domain,\n              typedData.types,\n              typedData.message,\n              request.chainId ?? this.defaultChainId(),\n              sequenceVerified ? 'eip6492' : 'ignore'\n            )\n          } else {\n            sig = await this.prompter.promptSignMessage(\n              {\n                chainId: request.chainId,\n                typedData: typedData,\n                eip6492: sequenceVerified\n              },\n              this.connectOptions\n            )\n          }\n\n          if (sig && sig.length > 0) {\n            return sig\n          } else {\n            // The user has declined the request when value is null\n            throw new Error('declined by user')\n          }\n        }\n\n        case 'eth_sendTransaction': {\n          // https://eth.wiki/json-rpc/API#eth_sendtransaction\n          const transactionParams = fromExtended(request.params![0]).map(tx => {\n            // eth_sendTransaction uses 'gas'\n            // ethers and sequence use 'gasLimit'\n            if ('gas' in tx && tx.gasLimit === undefined) {\n              tx.gasLimit = tx.gas as any\n              delete tx.gas\n            }\n\n            return tx\n          })\n\n          validateTransactionRequest(account.address, transactionParams)\n\n          let txnHash = ''\n          if (this.prompter === null) {\n            // prompter is null, so we'll send from here\n            const txnResponse = await account.sendTransaction(transactionParams, request.chainId ?? this.defaultChainId())\n            txnHash = txnResponse?.hash ?? ''\n          } else {\n            // prompt user to provide the response\n            txnHash = await this.prompter.promptSendTransaction(transactionParams, request.chainId, this.connectOptions)\n          }\n\n          if (txnHash) {\n            return txnHash\n          } else {\n            // The user has declined the request when value is null\n            throw new Error('declined by user')\n          }\n        }\n\n        case 'eth_signTransaction': {\n          // https://eth.wiki/json-rpc/API#eth_signTransaction\n          const [transaction] = request.params!\n          const sender = ethers.getAddress(transaction.from)\n\n          if (sender !== account.address) {\n            throw new Error('sender address does not match wallet')\n          }\n\n          validateTransactionRequest(account.address, transaction)\n\n          if (this.prompter === null) {\n            // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,\n            // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.\n            //\n            // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however\n            // we will want to resolveProperties the big number values to hex strings\n            return await account.signTransactions(transaction, request.chainId ?? this.defaultChainId())\n          } else {\n            return await this.prompter.promptSignTransaction(transaction, request.chainId, this.connectOptions)\n          }\n        }\n\n        case 'eth_sendRawTransaction': {\n          // NOTE: we're not using a prompter here as the transaction is already signed\n          // and would have prompted the user upon signing.\n\n          // https://eth.wiki/json-rpc/API#eth_sendRawTransaction\n          if (commons.transaction.isSignedTransactionBundle(request.params![0])) {\n            const txChainId = Number(request.params![0].chainId)\n            const tx = await account.relayer(txChainId)!.relay(request.params![0])\n            return tx.hash\n          } else {\n            const tx = await provider.broadcastTransaction(request.params![0])\n            return tx.hash\n          }\n        }\n\n        case 'eth_getTransactionCount': {\n          const address = ethers.getAddress(request.params![0] as string)\n          const tag = request.params![1]\n\n          // TODO: Maybe we should fetch this data from the relayer or from the reader\n          // but for now we keep it simple and just use the provider\n\n          const count = await provider.getTransactionCount(address, tag)\n          return toHexString(BigInt(count))\n        }\n\n        case 'eth_blockNumber': {\n          return await provider.getBlockNumber()\n        }\n\n        case 'eth_getBlockByNumber': {\n          return await provider.getBlock(request.params![0] /* , jsonRpcRequest.params[1] */)\n        }\n\n        case 'eth_getBlockByHash': {\n          return await provider.getBlock(request.params![0] /* , jsonRpcRequest.params[1] */)\n        }\n\n        case 'eth_getTransactionByHash': {\n          return await provider.getTransaction(request.params![0])\n        }\n\n        case 'eth_call': {\n          const [transactionObject, blockTag] = request.params!\n          return await provider.call({ ...transactionObject, blockTag })\n        }\n\n        case 'eth_getCode': {\n          const [contractAddress, blockTag] = request.params!\n          return await provider.getCode(contractAddress, blockTag)\n        }\n\n        case 'eth_estimateGas': {\n          const [transactionObject] = request.params!\n          return await provider.estimateGas(transactionObject)\n        }\n\n        case 'eth_gasPrice': {\n          const feeData = await provider.getFeeData()\n          return feeData.gasPrice === null ? null : toHexString(feeData.gasPrice)\n        }\n\n        case 'wallet_switchEthereumChain': {\n          const [switchParams] = request.params!\n          if (!switchParams.chainId || switchParams.chainId.length === 0) {\n            throw new Error('invalid chainId')\n          }\n\n          const chainId = BigInt(switchParams.chainId)\n\n          this.setDefaultChainId(Number(chainId))\n\n          return null // success\n        }\n\n        // smart wallet method\n        case 'sequence_getWalletContext': {\n          return account.contexts\n        }\n\n        // smart wallet method\n        case 'sequence_getWalletConfig': {\n          const [chainId] = request.params!\n          if (chainId) {\n            return [(await account.status(chainId)).onChain.config]\n          } else {\n            return await Promise.all(\n              account.networks.map(async network => {\n                const status = await account.status(network.chainId)\n                return status.onChain.config\n              })\n            )\n          }\n        }\n\n        // smart wallet method\n        case 'sequence_getWalletState': {\n          const [chainId] = request.params!\n          // TODO: Add getWalletState to the Signer interface\n          if (chainId) {\n            return [getLegacyWalletState(chainId, await account.status(chainId))]\n          } else {\n            return await Promise.all(\n              account.networks.map(async network => {\n                const status = await account.status(network.chainId)\n                return getLegacyWalletState(network.chainId, status)\n              })\n            )\n          }\n        }\n\n        // smart wallet method\n        case 'sequence_getNetworks': {\n          // NOTE: must ensure that the response result below returns clean serialized data, which is to omit\n          // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.\n          // This is handled by this.getNetworks() but noted here for future readers.\n          return await this.getNetworks(true)\n        }\n\n        case 'sequence_isSequence': {\n          return true\n        }\n\n        // smart wallet method\n        case 'sequence_updateConfig': {\n          throw new Error('sequence_updateConfig method is not allowed from a dapp')\n          // NOTE: method is disabled as we don't need a dapp to request to update a config.\n          // However, if we ever want this, we can enable it but must also use the prompter\n          // for confirmation.\n          //\n          // const [newConfig] = request.params\n          // return await signer.updateConfig(newConfig)\n        }\n\n        // smart wallet method\n        case 'sequence_publishConfig': {\n          throw new Error('sequence_publishConfig method is not allowed from a dapp')\n        }\n\n        // relayer method\n        case 'sequence_gasRefundOptions': {\n          // TODO\n          break\n        }\n\n        // relayer method\n        case 'sequence_getNonce': {\n          // TODO\n          break\n        }\n\n        // relayer method\n        case 'sequence_relay': {\n          // TODO\n          break\n        }\n\n        // set default network of wallet\n        case 'sequence_setDefaultNetwork': {\n          const [defaultChainId] = request.params!\n\n          if (!defaultChainId) {\n            throw new Error('invalid request, method argument defaultChainId cannot be empty')\n          }\n\n          this.setDefaultChainId(defaultChainId)\n          return await this.getNetworks(true)\n        }\n\n        default: {\n          if (!jsonRpcProvider) {\n            throw new Error(`Account provider doesn't support send method`)\n          }\n\n          // NOTE: provider here will be chain-bound if chainId is provided\n          return await jsonRpcProvider.send(request.method, request.params!)\n        }\n      }\n    } catch (err) {\n      logger.error(err)\n      throw { message: typeof err == 'string' ? err : err?.message || 'unkown error', code: 4001 } as ProviderRpcError\n    }\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.on(event, fn as any)\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.once(event, fn as any)\n  }\n\n  async getAddress(): Promise<string> {\n    return this.account?.address ?? ''\n  }\n\n  get openIntent(): OpenWalletIntent | undefined {\n    return this._openIntent\n  }\n\n  setOpenIntent(intent: OpenWalletIntent | undefined) {\n    this._openIntent = intent\n  }\n\n  get connectOptions(): ConnectOptions | undefined {\n    return this._connectOptions\n  }\n\n  setConnectOptions(options: ConnectOptions | undefined) {\n    this._connectOptions = options\n    this.onConnectOptionsChange?.(options)\n  }\n\n  async setDefaultChainId(chainId: number): Promise<number> {\n    await this.prompter?.promptChangeNetwork(chainId)\n    return this.defaultChainId()\n  }\n\n  async getNetworks(jsonRpcResponse?: boolean): Promise<NetworkConfig[]> {\n    if (!this.account) {\n      logger.warn('signer not set: getNetworks is returning an empty list')\n      return []\n    }\n\n    if (jsonRpcResponse) {\n      // omit provider and relayer objects as they are not serializable\n      return this.account.networks.map(n => {\n        const network: NetworkConfig = { ...n }\n        network.provider = undefined\n        network.relayer = undefined\n        return network\n      })\n    } else {\n      return this.account.networks\n    }\n  }\n\n  walletSession(networkId?: ChainIdLike): WalletSession | undefined {\n    if (!this.account) {\n      return undefined\n    }\n\n    const session = {\n      walletContext: this.account.contexts,\n      accountAddress: this.account.address,\n      // The dapp shouldn't access the relayer directly, and the provider (as an object) is not serializable.\n      networks: this.account.networks.map(n => ({ ...n, provider: undefined, relayer: undefined }))\n    }\n\n    if (networkId) {\n      const network = findNetworkConfig(session.networks, networkId)\n\n      if (network) {\n        // Delete the isDefaultChain property from the session network\n        session.networks?.forEach(n => delete n.isDefaultChain)\n\n        // Add the isDefaultChain property to the network with the given networkId\n        network.isDefaultChain = true\n      }\n    }\n\n    return session\n  }\n\n  notifyConnect(connectDetails: ConnectDetails, origin?: string) {\n    console.log('emit connect', connectDetails)\n    this.events.emit('connect', connectDetails)\n    if (connectDetails.session?.accountAddress) {\n      this.events.emit('accountsChanged', [connectDetails.session?.accountAddress], origin)\n    }\n  }\n\n  notifyDisconnect(origin?: string) {\n    this.events.emit('accountsChanged', [], origin)\n    this.events.emit('disconnect', undefined, origin)\n  }\n\n  notifyChainChanged(chainId: number, origin?: string) {\n    this.events.emit('chainChanged', ethers.toQuantity(chainId), origin)\n  }\n\n  async notifyNetworks(networks?: NetworkConfig[]) {\n    const n = networks || (await this.getNetworks(true))\n    this.events.emit('networks', n)\n    if (n.length > 0) {\n      const defaultNetwork = n.find(network => network.chainId === this.defaultChainId())\n      if (defaultNetwork) {\n        this.events.emit('chainChanged', ethers.toQuantity(defaultNetwork.chainId))\n      }\n    } else {\n      this.events.emit('chainChanged', '0x0')\n    }\n  }\n\n  async notifyWalletContext() {\n    if (!this.account) {\n      logger.warn('signer not set: skipping to notify wallet context')\n      return\n    }\n    const walletContext = this.account.contexts\n    this.events.emit('walletContext', walletContext)\n  }\n\n  notifyClose(error?: ProviderRpcError) {\n    this.events.emit('close', error)\n  }\n\n  isSignedIn = async (): Promise<boolean> => {\n    await this.signerReady()\n    return !!this.account\n  }\n\n  getAccount = async (): Promise<Account | null> => {\n    await this.signerReady()\n    if (this.account === undefined) {\n      throw new Error('signerReady failed resolve')\n    }\n    return this.account\n  }\n\n  setAccount(account: Account | null | undefined) {\n    this.account = account\n\n    if (account !== undefined) {\n      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {\n        this.signerReadyCallbacks[i]()\n      }\n      this.signerReadyCallbacks = []\n    }\n  }\n\n  private async handleConfirmWalletDeployPrompt(\n    prompter: WalletUserPrompter,\n    account: Account,\n    sequenceVerified: boolean,\n    chainId?: number\n  ): Promise<boolean> {\n    // check if wallet is deployed and up to date, if not, prompt user to deploy\n    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date\n    if (!chainId) {\n      return true\n    }\n\n    const skipsDeploy = (status: AccountStatus) => {\n      return status.canOnchainValidate || (status.original.version === 2 && sequenceVerified)\n    }\n\n    const status = await account.status(chainId)\n    if (skipsDeploy(status)) {\n      return true\n    }\n\n    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions)\n\n    // if client returned true, check again to make sure wallet is deployed and up to date\n    if (promptResult) {\n      const status2 = await account.status(chainId)\n\n      if (skipsDeploy(status2)) {\n        return true\n      } else {\n        logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct')\n        return false\n      }\n    }\n\n    return false\n  }\n}\n\nexport interface WalletUserPrompter {\n  getDefaultChainId(): number\n\n  promptConnect(options?: ConnectOptions): Promise<PromptConnectDetails>\n  promptSignInConnect(options?: ConnectOptions): Promise<PromptConnectDetails>\n\n  promptSignMessage(message: MessageToSign, options?: ConnectOptions): Promise<string>\n  promptSignTransaction(txn: commons.transaction.Transactionish, chainId?: number, options?: ConnectOptions): Promise<string>\n  promptSendTransaction(txn: commons.transaction.Transactionish, chainId?: number, options?: ConnectOptions): Promise<string>\n  promptConfirmWalletDeploy(chainId: number, options?: ConnectOptions): Promise<boolean>\n\n  promptChangeNetwork(chainId: number): Promise<boolean>\n}\n\ninterface LegacyWalletState {\n  context: commons.context.WalletContext\n  config?: commons.config.Config\n\n  // the wallet address\n  address: string\n\n  // the chainId of the network\n  chainId: number\n\n  // whether the wallet has been ever deployed\n  deployed: boolean\n\n  // the imageHash of the `config` WalletConfig\n  imageHash: string\n\n  // the last imageHash of a WalletConfig, stored on-chain\n  lastImageHash?: string\n\n  // whether the WalletConfig object itself has been published to logs\n  published?: boolean\n\n  status: AccountStatus\n}\n\nfunction getLegacyWalletState(chainId: number, status: AccountStatus): LegacyWalletState {\n  return {\n    context: status.original.context,\n    config: status.onChain.config,\n    address: commons.context.addressOf(status.original.context, status.original.imageHash),\n    chainId,\n    deployed: status.onChain.deployed,\n    imageHash: status.imageHash,\n    lastImageHash: status.onChain.imageHash,\n    published: true,\n    status\n  }\n}\n\nconst permittedJsonRpcMethods = [\n  'net_version',\n  'eth_chainId',\n  'eth_getBalance',\n  'eth_getTransactionCount',\n  'eth_blockNumber',\n  'eth_getBlockByNumber',\n  'eth_getBlockByHash',\n  'eth_getTransactionByHash',\n  'eth_getCode',\n  'eth_estimateGas',\n  'eth_gasPrice',\n\n  'sequence_getWalletContext',\n  'sequence_getNetworks',\n  'sequence_setDefaultNetwork'\n]\n\nfunction isJsonRpcProvider(provider: any): provider is ethers.JsonRpcProvider {\n  return (\n    provider && typeof provider === 'object' && typeof provider.send === 'function' && typeof provider.getNetwork === 'function'\n  )\n}\n","import { ethers } from 'ethers'\n\nimport { SequenceProvider, SingleNetworkSequenceProvider } from './provider'\nimport { SequenceClient } from './client'\nimport { commons } from '@0xsequence/core'\nimport { ChainIdLike, NetworkConfig } from '@0xsequence/network'\nimport { resolveArrayProperties } from './utils'\nimport { WalletUtils } from './utils/index'\nimport { OptionalChainIdLike, OptionalEIP6492 } from './types'\n\nexport interface ISequenceSigner extends Omit<ethers.Signer, 'connect'> {\n  getProvider(): SequenceProvider\n  getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider\n  getProvider(chainId?: ChainIdLike): SequenceProvider | SingleNetworkSequenceProvider\n\n  getSigner(): SequenceSigner\n  getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner\n  getSigner(chainId?: ChainIdLike): SequenceSigner | SingleNetworkSequenceSigner\n\n  getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>\n  getNetworks(): Promise<NetworkConfig[]>\n\n  connect: (provider: SequenceProvider) => SequenceSigner\n\n  signMessage(message: ethers.BytesLike, options?: OptionalChainIdLike & OptionalEIP6492): Promise<string>\n\n  signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, Array<ethers.TypedDataField>>,\n    message: Record<string, any>,\n    options?: OptionalChainIdLike & OptionalEIP6492\n  ): Promise<string>\n\n  // sendTransaction takes an unsigned transaction, or list of unsigned transactions, and then has it signed by\n  // the signer, and finally sends it to the relayer for submission to an Ethereum network.\n  // It supports any kind of transaction, including regular ethers transactions, and Sequence transactions.\n  sendTransaction(\n    transaction: ethers.TransactionRequest[] | ethers.TransactionRequest,\n    options?: OptionalChainIdLike\n  ): Promise<commons.transaction.TransactionResponse>\n\n  utils: WalletUtils\n}\n\nexport class SequenceSigner implements ISequenceSigner {\n  private readonly singleNetworkSigners: { [chainId: number]: SingleNetworkSequenceSigner } = {}\n\n  readonly _isSequenceSigner: boolean = true\n\n  get utils(): WalletUtils {\n    return this.provider.utils\n  }\n\n  constructor(\n    public client: SequenceClient,\n    public provider: SequenceProvider\n  ) {}\n\n  async getAddress(): Promise<string> {\n    return this.client.getAddress()\n  }\n\n  // This method shouldn't be used directly\n  // it exists to maintain compatibility with ethers.Signer\n  connect(provider: ethers.Provider): SequenceSigner {\n    if (!SequenceProvider.is(provider)) {\n      throw new Error('SequenceSigner can only be connected to a SequenceProvider')\n    }\n\n    return new SequenceSigner(this.client, provider)\n  }\n\n  getSigner(): SequenceSigner\n  getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner\n  getSigner(chainId?: ChainIdLike): SingleNetworkSequenceSigner | SequenceSigner\n\n  getSigner(chainId?: ChainIdLike): SingleNetworkSequenceSigner | SequenceSigner {\n    // The signer for the default network is this signer\n    if (!chainId) {\n      return this\n    }\n\n    const useChainId = this.provider.toChainId(chainId)\n\n    if (!this.singleNetworkSigners[useChainId]) {\n      this.singleNetworkSigners[useChainId] = new SingleNetworkSequenceSigner(this.client, this.provider, useChainId)\n    }\n\n    return this.singleNetworkSigners[useChainId]\n  }\n\n  /**\n   *  Resolves the chainId to use for the given request. If no chainId is provided,\n   *  it uses the chainId defined by the client (default chainId). This can be\n   *  overriden to build a single-network SequenceProvider.\n   */\n  protected useChainId(chainId?: ChainIdLike): number {\n    return this.provider.toChainId(chainId) || this.client.getChainId()\n  }\n\n  async signMessage(message: ethers.BytesLike, options?: OptionalChainIdLike & OptionalEIP6492): Promise<string> {\n    const { eip6492 = true } = options || {}\n    const chainId = this.useChainId(options?.chainId)\n    return this.client.signMessage(message, { eip6492, chainId })\n  }\n\n  async signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, Array<ethers.TypedDataField>>,\n    message: Record<string, any>,\n    options?: OptionalChainIdLike & OptionalEIP6492\n  ): Promise<string> {\n    const { eip6492 = true } = options || {}\n    const chainId = this.useChainId(options?.chainId)\n    return this.client.signTypedData({ domain, types, message }, { eip6492, chainId })\n  }\n\n  getProvider(): SequenceProvider\n  getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider\n  getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider | SequenceProvider\n\n  getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider | SequenceProvider {\n    return this.provider.getProvider(chainId)\n  }\n\n  async sendTransaction(transaction: ethers.TransactionRequest[] | ethers.TransactionRequest, options?: OptionalChainIdLike) {\n    const chainId = this.useChainId(options?.chainId)\n    const resolved = await resolveArrayProperties(transaction)\n    const txHash = await this.client.sendTransaction(resolved, { chainId })\n    const provider = this.getProvider(chainId)\n\n    try {\n      const result = await new Promise<ethers.TransactionResponse>(resolve => {\n        const check = async () => {\n          const tx = await provider.getTransaction(txHash)\n\n          if (tx !== null) {\n            return resolve(tx)\n          }\n\n          await provider.once('block', check)\n        }\n\n        check()\n      })\n\n      return result\n    } catch (err) {\n      err.transactionHash = txHash\n      throw err\n    }\n  }\n\n  async getWalletConfig(chainId?: ChainIdLike | undefined): Promise<commons.config.Config> {\n    const useChainId = this.useChainId(chainId)\n    return this.client.getOnchainWalletConfig({ chainId: useChainId })\n  }\n\n  getNetworks(): Promise<NetworkConfig[]> {\n    return this.client.getNetworks()\n  }\n\n  async getBalance(blockTag?: ethers.BlockTag | undefined, optionals?: OptionalChainIdLike): Promise<bigint> {\n    const provider = this.getProvider(optionals?.chainId)\n    return provider.getBalance(this.getAddress(), blockTag)\n  }\n\n  async estimateGas(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike): Promise<bigint> {\n    return this.getProvider(optionals?.chainId).estimateGas(transaction)\n  }\n\n  async call(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike): Promise<string> {\n    return this.getProvider(optionals?.chainId).call(transaction)\n  }\n\n  getChainId(): Promise<number> {\n    return Promise.resolve(this.client.getChainId())\n  }\n\n  async getFeeData(optionals?: OptionalChainIdLike): Promise<ethers.FeeData> {\n    return this.getProvider(optionals?.chainId).getFeeData()\n  }\n\n  async resolveName(name: string): Promise<string> {\n    const res = await this.provider.resolveName(name)\n\n    // For some reason ethers.Signer expects this to return `string`\n    // but ethers.Provider expects this to return `string | null`.\n    // The signer doesn't have any other source of information, so we'll\n    // fail if the provider doesn't return a result.\n    if (res === null) {\n      throw new Error(`ENS name not found: ${name}`)\n    }\n\n    return res\n  }\n\n  _checkProvider(_operation?: string | undefined): void {\n    // We always have a provider, so this is a noop\n  }\n\n  getNonce(_blockTag?: ethers.BlockTag): Promise<number> {\n    throw new Error('SequenceSigner does not support getNonce')\n  }\n\n  populateCall(_transaction: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>> {\n    throw new Error('SequenceSigner does not support populateCall')\n  }\n\n  populateTransaction(_transaction: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>> {\n    throw new Error('SequenceSigner does not support populateTransaction')\n  }\n\n  checkTransaction(_transaction: ethers.TransactionRequest): ethers.TransactionRequest {\n    throw new Error('SequenceSigner does not support checkTransaction')\n  }\n\n  getTransactionCount(_blockTag?: ethers.BlockTag): Promise<number> {\n    // We could try returning the sequence nonce here\n    // but we aren't sure how ethers will use this nonce\n    throw new Error('SequenceSigner does not support getTransactionCount')\n  }\n\n  signTransaction(_transaction: commons.transaction.Transactionish): Promise<string> {\n    // We could implement signTransaction/sendTransaction here\n    // but first we need a way of serializing these signed transactions\n    // and it could lead to more trouble, because the dapp could try to send this transaction\n    // using a different provider, which would fail.\n    throw new Error('SequenceWallet does not support signTransaction, use sendTransaction instead.')\n  }\n\n  static is(cand: any): cand is SequenceSigner {\n    return cand && typeof cand === 'object' && cand._isSequenceSigner === true\n  }\n}\n\n/**\n *  This is the same provider, but it only allows a single network at a time.\n *  the network defined by the constructor is the only one that can be used.\n *\n *  Attempting to call any method with a different network will throw an error.\n *  Attempting to change the network of this provider will throw an error.\n *\n *  NOTICE: These networks won't support ENS unless they are the mainnet.\n */\nexport class SingleNetworkSequenceSigner extends SequenceSigner {\n  readonly _isSingleNetworkSequenceSigner = true\n\n  constructor(\n    client: SequenceClient,\n    provider: SequenceProvider,\n    public readonly chainId: ChainIdLike\n  ) {\n    super(client, provider.getProvider(chainId))\n  }\n\n  private _useChainId(chainId?: ChainIdLike): number {\n    const provided = this.provider.toChainId(chainId)\n\n    if (provided && provided !== this.chainId) {\n      throw new Error(`This signer only supports the network ${this.chainId}, but ${provided} was requested.`)\n    }\n\n    return provided || this.provider.toChainId(this.chainId)\n  }\n\n  protected useChainId(chainId?: ChainIdLike): number {\n    return this._useChainId(chainId)\n  }\n\n  getChainId(): Promise<number> {\n    return Promise.resolve(this.provider.toChainId(this.chainId))\n  }\n\n  /**\n   *  Override getProvider and getSigner so they always use `useChainId`\n   *  this way they can't return providers and signers that can switch networks,\n   *  or that don't match the chainId of this signer.\n   */\n  getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider {\n    return super.getProvider(this._useChainId(chainId))\n  }\n\n  getSigner(chainId?: ChainIdLike | undefined): SingleNetworkSequenceSigner {\n    if (this._useChainId(chainId) !== this.chainId) {\n      throw new Error(`Unreachable code`)\n    }\n\n    return this\n  }\n\n  static is(cand: any): cand is SingleNetworkSequenceSigner {\n    return cand && typeof cand === 'object' && cand._isSingleNetworkSequenceSigner === true\n  }\n}\n","import { ethers } from 'ethers'\nimport { ChainIdLike } from '@0xsequence/network'\nimport { encodeMessageDigest, TypedData, encodeTypedDataDigest } from '@0xsequence/utils'\nimport { isValidSignature, prefixEIP191Message } from '../utils'\nimport { SequenceSigner, SingleNetworkSequenceSigner } from '../signer'\n\n/**\n *  This class is redundant with the SequenceSigner class, but it is here for now to\n *  maintain compatibility with the old wallet API. Eventually we should move these\n *  methods to the SequenceSigner class and deprecate this class.\n */\nexport class WalletUtils {\n  constructor(public signer: SequenceSigner) {\n    if (SingleNetworkSequenceSigner.is(signer)) {\n      throw new Error('WalletUtils does not support SingleNetworkSequenceSigner')\n    }\n  }\n\n  // Sign message on a specified chain, or DefaultChain by default\n  signMessage(message: ethers.BytesLike, chainId?: ChainIdLike, eip6492?: boolean): Promise<string> {\n    return this.signer.signMessage(message, { chainId, eip6492 })\n  }\n\n  // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default\n  signTypedData(\n    domain: ethers.TypedDataDomain,\n    types: Record<string, Array<ethers.TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    eip6492?: boolean\n  ): Promise<string> {\n    return this.signer.signTypedData(domain, types, message, { chainId, eip6492 })\n  }\n\n  // Verify signature of a digest, one of a message, typedData or other\n  async isValidSignature(address: string, digest: Uint8Array, signature: string, chainId: number): Promise<boolean> {\n    return isValidSignature(address, digest, signature, this.signer.getProvider(chainId))\n  }\n\n  // Verify message signature\n  async isValidMessageSignature(\n    address: string,\n    message: string | Uint8Array,\n    signature: string,\n    chainId: number\n  ): Promise<boolean> {\n    const provider = this.signer.getProvider(chainId)\n    const prefixed = prefixEIP191Message(message)\n    const digest = encodeMessageDigest(prefixed)\n    return isValidSignature(address, digest, signature, provider)\n  }\n\n  // Verify typedData signature\n  isValidTypedDataSignature(address: string, typedData: TypedData, signature: string, chainId: number): Promise<boolean> {\n    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature, chainId)\n  }\n\n  // sendTransaction()\n  // sendTransactions()\n\n  // sendETH()\n  // sendToken()\n  // sendCoin() -- sugar for sendToken()\n  // sendCollectible() -- sugar for sendToken()\n  // callContract()\n\n  // transactionHistory()\n  // getReceipt()\n  // getLogs()\n  // // ..\n\n  // validateSignature()\n  // recoverWalletConfig()\n  // recoverAddress()\n}\n","import { ethers } from 'ethers'\nimport { SequenceClient } from './client'\nimport { EIP1193Provider, ChainIdLike, NetworkConfig, allNetworks, findNetworkConfig } from '@0xsequence/network'\nimport { ConnectDetails, ConnectOptions, OpenWalletIntent, OptionalChainIdLike, WalletSession } from './types'\nimport { commons } from '@0xsequence/core'\nimport { WalletUtils } from './utils/index'\nimport { SequenceSigner, SingleNetworkSequenceSigner } from './signer'\n\nexport interface ISequenceProvider {\n  readonly _isSequenceProvider: true\n\n  connect(options?: ConnectOptions): Promise<ConnectDetails>\n  disconnect(): void\n\n  isConnected(): boolean\n  getSession(): WalletSession | undefined\n\n  listAccounts(): string[]\n\n  // @deprecated use getSigner().getAddress() instead\n  getAddress(): string\n\n  getNetworks(): Promise<NetworkConfig[]>\n  getChainId(): number\n\n  setDefaultChainId(chainId: ChainIdLike): void\n\n  isOpened(): boolean\n  openWallet(path?: string, intent?: OpenWalletIntent): Promise<boolean>\n  closeWallet(): void\n\n  getProvider(): SequenceProvider\n  getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider\n  getProvider(chainId?: ChainIdLike): SequenceProvider | SingleNetworkSequenceProvider\n\n  getSigner(): SequenceSigner\n  getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner\n  getSigner(chainId?: ChainIdLike): SequenceSigner | SingleNetworkSequenceSigner\n\n  // @deprecated use getSigner().getWalletContext() instead\n  getWalletContext(): Promise<commons.context.VersionedContext>\n\n  // @deprecated use getSigner().getWalletConfig() instead\n  getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>\n\n  utils: WalletUtils\n}\n\nconst EIP1193EventTypes = ['connect', 'disconnect', 'chainChanged', 'accountsChanged'] as const\ntype EIP1193EventType = (typeof EIP1193EventTypes)[number]\n\nexport class SequenceProvider extends ethers.AbstractProvider implements ISequenceProvider, EIP1193Provider {\n  private readonly singleNetworkProviders: { [chainId: number]: SingleNetworkSequenceProvider } = {}\n\n  readonly _isSequenceProvider = true\n  readonly utils: WalletUtils\n\n  readonly signer: SequenceSigner\n\n  readonly eip1193EventListeners = new Map<EIP1193EventType, Set<ethers.Listener>>()\n\n  constructor(\n    public readonly client: SequenceClient,\n    private readonly providerFor: (networkId: number) => ethers.JsonRpcProvider,\n    public readonly networks: NetworkConfig[] = allNetworks,\n    public readonly options?: ethers.AbstractProviderOptions\n  ) {\n    // We support a lot of networks\n    // but we start with the default one\n    super(client.getChainId(), options)\n\n    // Emit events as defined by EIP-1193\n    client.onConnect(details => {\n      //this.emit('connect', details)\n      this.eip1193EventListeners.get('connect')?.forEach(listener => listener(details))\n    })\n\n    client.onDisconnect(error => {\n      //this.emit('disconnect', error)\n      this.eip1193EventListeners.get('disconnect')?.forEach(listener => listener(error))\n    })\n\n    client.onDefaultChainIdChanged(chainId => {\n      //this.emit('chainChanged', chainId)\n      this.eip1193EventListeners.get('chainChanged')?.forEach(listener => listener(chainId))\n    })\n\n    client.onAccountsChanged(accounts => {\n      //this.emit('accountsChanged', accounts)\n      this.eip1193EventListeners.get('accountsChanged')?.forEach(listener => listener(accounts))\n    })\n\n    // NOTICE: We don't emit 'open' and 'close' events\n    // because these are handled by the library, and they\n    // are not part of EIP-1193\n\n    // devs can still access them using\n    //   client.onOpen()\n    //   client.onClose()\n\n    // Create a Sequence signer too\n    this.signer = new SequenceSigner(this.client, this)\n\n    // Create a utils instance\n    this.utils = new WalletUtils(this.signer)\n  }\n\n  async on(event: ethers.ProviderEvent | EIP1193EventType, listener: ethers.Listener): Promise<this> {\n    if (EIP1193EventTypes.includes(event as EIP1193EventType)) {\n      const listeners = this.eip1193EventListeners.get(event as EIP1193EventType) || new Set()\n      listeners.add(listener)\n      this.eip1193EventListeners.set(event as EIP1193EventType, listeners)\n\n      return this\n    }\n\n    return super.on(event, listener) as Promise<this>\n  }\n\n  async off(event: ethers.ProviderEvent | EIP1193EventType, listener?: ethers.Listener | undefined): Promise<this> {\n    if (EIP1193EventTypes.includes(event as EIP1193EventType)) {\n      const listeners = this.eip1193EventListeners.get(event as EIP1193EventType)\n\n      if (listeners) {\n        if (listener) {\n          listeners.delete(listener)\n        } else {\n          listeners.clear()\n        }\n      }\n\n      return this\n    }\n\n    return super.off(event, listener) as Promise<this>\n  }\n\n  getSigner(): SequenceSigner\n  getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner\n  getSigner(chainId?: ChainIdLike): SequenceSigner | SingleNetworkSequenceSigner\n\n  getSigner(chainId?: ChainIdLike) {\n    return this.signer.getSigner(chainId)\n  }\n\n  connect(options: ConnectOptions) {\n    return this.client.connect(options)\n  }\n\n  disconnect() {\n    return this.client.disconnect()\n  }\n\n  isConnected() {\n    return this.client.isConnected()\n  }\n\n  getSession() {\n    return this.client.getSession()\n  }\n\n  listAccounts(): string[] {\n    return [this.client.getAddress()]\n  }\n\n  // @deprecated use getSigner() instead\n  getAddress() {\n    return this.client.getAddress()\n  }\n\n  getNetworks(): Promise<NetworkConfig[]> {\n    return this.client.getNetworks()\n  }\n\n  getChainId(): number {\n    return this.client.getChainId()\n  }\n\n  setDefaultChainId(chainId: ChainIdLike) {\n    return this.client.setDefaultChainId(this.toChainId(chainId))\n  }\n\n  isOpened(): boolean {\n    return this.client.isOpened()\n  }\n\n  closeWallet(): void {\n    return this.client.closeWallet()\n  }\n\n  getWalletContext(): Promise<commons.context.VersionedContext> {\n    return this.client.getWalletContext()\n  }\n\n  // @deprecated use getSigner() instead\n  async getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config> {\n    const useChainId = await this.useChainId(chainId)\n    return this.client.getOnchainWalletConfig({ chainId: useChainId })\n  }\n\n  authorize(options: ConnectOptions) {\n    // Just an alias for connect with authorize: true\n    return this.client.connect({ ...options, authorize: true })\n  }\n\n  async openWallet(path?: string, intent?: OpenWalletIntent) {\n    await this.client.openWallet(path, intent)\n    return true\n  }\n\n  toChainId(chainId: ChainIdLike): number\n  toChainId(chainId?: ChainIdLike): number | undefined\n\n  toChainId(chainId?: ChainIdLike) {\n    if (chainId === undefined) {\n      return undefined\n    }\n\n    const resolved = findNetworkConfig(this.networks, chainId as ChainIdLike)\n\n    if (!resolved) {\n      throw new Error(`Unsupported network ${chainId}`)\n    }\n\n    return resolved.chainId\n  }\n\n  /**\n   *  Resolves the chainId to use for the given request. If no chainId is provided,\n   *  it uses the chainId defined by the client (default chainId). This can be\n   *  overriden to build a single-network SequenceProvider.\n   */\n  protected async useChainId(chainId?: ChainIdLike): Promise<number> {\n    return this.toChainId(chainId) || this.client.getChainId()\n  }\n\n  /**\n   *  This generates a provider that ONLY works for the given chainId.\n   *  the generated provider can't switch networks, and can't handle requests\n   *  for other networks.\n   */\n  getProvider(): SequenceProvider\n  getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider\n  getProvider(chainId?: ChainIdLike): SequenceProvider | SingleNetworkSequenceProvider\n\n  getProvider(chainId?: ChainIdLike) {\n    // The provider without a chainId is... this one\n    if (!chainId) {\n      return this as SequenceProvider\n    }\n\n    const useChainId = this.toChainId(chainId)\n\n    if (!this.singleNetworkProviders[useChainId]) {\n      this.singleNetworkProviders[useChainId] = new SingleNetworkSequenceProvider(\n        this.client,\n        this.providerFor,\n        useChainId,\n        this.options\n      )\n    }\n\n    return this.singleNetworkProviders[useChainId]\n  }\n\n  /**\n   *  This returns a subprovider, this is a regular non-sequence provider that\n   *  can be used to fulfill read only requests on a given network.\n   */\n  async _getSubprovider(chainId?: ChainIdLike): Promise<ethers.JsonRpcProvider> {\n    const useChainId = await this.useChainId(chainId)\n\n    // Whoever implements providerFrom should memoize the generated provider\n    // otherwise every instance of SequenceProvider will create a new subprovider\n    const provider = this.providerFor(useChainId)\n\n    if (!provider) {\n      throw new Error(`Unsupported network ${useChainId}`)\n    }\n\n    return provider\n  }\n\n  async _perform(req: ethers.PerformActionRequest): Promise<any> {\n    const { method, ...args } = req\n\n    const provider = await this._getSubprovider()\n    const prepared = provider.getRpcRequest(req) ?? { method, args: Object.values(args) }\n\n    if (!prepared) {\n      throw new Error(`Unsupported method ${req.method}`)\n    }\n\n    return provider.send(prepared.method, prepared.args)\n  }\n\n  async perform(method: string, params: any): Promise<any> {\n    // First we check if the method should be handled by the client\n    if (method === 'eth_chainId') {\n      return ethers.toQuantity(await this.useChainId())\n    }\n\n    if (method === 'eth_accounts') {\n      return [this.client.getAddress()]\n    }\n\n    if (method === 'wallet_switchEthereumChain') {\n      const args = params[0] as { chainId: string } | number | string\n      const chainId = normalizeChainId(args)\n      return this.setDefaultChainId(chainId)\n    }\n\n    // Usually these methods aren't used by calling the provider\n    // but to maximize compatibility we support them too.\n    // The correct way of accessing these methods is by using .getSigner()\n    if (\n      method === 'eth_sendTransaction' ||\n      method === 'eth_sign' ||\n      method === 'eth_signTypedData' ||\n      method === 'eth_signTypedData_v4' ||\n      method === 'personal_sign' ||\n      // These methods will use EIP-6492\n      // but this is handled directly by the wallet\n      method === 'sequence_sign' ||\n      method === 'sequence_signTypedData_v4'\n    ) {\n      // We pass the chainId to the client, if we don't pass one\n      // the client will use its own default chainId\n      return this.client.request({ method, params, chainId: this.getChainId() })\n    }\n\n    return this._perform({ method, ...params })\n  }\n\n  send(method: string, params: any): Promise<any> {\n    return this.perform(method, params)\n  }\n\n  request(request: { method: string; params?: any[] | undefined }) {\n    return this.perform(request.method, request.params)\n  }\n\n  async _detectNetwork(): Promise<ethers.Network> {\n    const chainId = this.client.getChainId()\n    const found = findNetworkConfig(this.networks, chainId)\n\n    if (!found) {\n      throw new Error(`Unknown network ${chainId}`)\n    }\n\n    const network = new ethers.Network(found.name, found.chainId)\n\n    return network\n  }\n\n  async detectNetwork(): Promise<ethers.Network> {\n    return this._detectNetwork()\n  }\n\n  // Override most of the methods, so we add support for an optional chainId\n  // argument, which is used to select the provider to use.\n  //\n  // NOTICE: We could use generics to avoid repeating the same code\n  // but this would make the code harder to read, and it's not worth it\n  // since we only have a few methods to override.\n\n  async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.waitForTransaction(transactionHash, confirmations, timeout)\n  }\n\n  async getBlockNumber(optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getBlockNumber()\n  }\n\n  async getFeeData(optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getFeeData()\n  }\n\n  async getBalance(addressOrName: string | Promise<string>, blockTag?: ethers.BlockTag, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getBalance(addressOrName, blockTag)\n  }\n\n  async getTransactionCount(\n    addressOrName: string | Promise<string>,\n    blockTag?: ethers.BlockTag,\n    optionals?: OptionalChainIdLike\n  ) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getTransactionCount(addressOrName, blockTag)\n  }\n\n  async getCode(addressOrName: string | Promise<string>, blockTag?: ethers.BlockTag, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getCode(addressOrName, blockTag)\n  }\n\n  async getStorage(\n    addressOrName: string | Promise<string>,\n    position: ethers.BigNumberish,\n    blockTag?: ethers.BlockTag,\n    optionals?: OptionalChainIdLike\n  ) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getStorage(addressOrName, position, blockTag)\n  }\n\n  async call(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.call(transaction)\n  }\n\n  async estimateGas(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.estimateGas(transaction)\n  }\n\n  async getBlock(blockHashOrBlockTag: ethers.BlockTag | string, prefetchTxs?: boolean, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getBlock(blockHashOrBlockTag, prefetchTxs)\n  }\n\n  async getTransaction(transactionHash: string, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getTransaction(transactionHash)\n  }\n\n  async getLogs(filter: ethers.Filter, optionals?: OptionalChainIdLike) {\n    const provider = await this._getSubprovider(optionals?.chainId)\n    return provider.getLogs(filter)\n  }\n\n  // ENS methods\n\n  async supportsENS(): Promise<boolean> {\n    const networks = await this.getNetworks()\n    return networks.some(n => n.chainId === 1)\n  }\n\n  async getResolver(name: string) {\n    if (!(await this.supportsENS())) {\n      return null\n    }\n\n    // Resolver is always on the chainId 1\n    const provider = await this._getSubprovider(1)\n    return provider.getResolver(name)\n  }\n\n  async resolveName(name: string) {\n    if (ethers.isAddress(name)) {\n      return name\n    }\n\n    if (!(await this.supportsENS())) {\n      return null\n    }\n\n    // Resolver is always on the chainId 1\n    const provider = await this._getSubprovider(1)\n    return provider.resolveName(name)\n  }\n\n  async lookupAddress(address: string) {\n    if (!(await this.supportsENS())) {\n      return null\n    }\n\n    // Resolver is always on the chainId 1\n    const provider = await this._getSubprovider(1)\n    return provider.lookupAddress(address)\n  }\n\n  async getAvatar(nameOrAddress: string) {\n    if (!(await this.supportsENS())) {\n      return null\n    }\n\n    const provider = await this._getSubprovider(1)\n    return provider.getAvatar(nameOrAddress)\n  }\n\n  static is = (provider: any): provider is SequenceProvider => {\n    return provider && typeof provider === 'object' && provider._isSequenceProvider === true\n  }\n}\n\nfunction normalizeChainId(chainId: ethers.BigNumberish | { chainId: string }): number {\n  if (typeof chainId === 'object') return normalizeChainId(chainId.chainId)\n  return Number(chainId)\n}\n\n/**\n *  This is the same provider, but it only allows a single network at a time.\n *  the network defined by the constructor is the only one that can be used.\n *\n *  Attempting to call any method with a different network will throw an error.\n *  Attempting to change the network of this provider will throw an error.\n *\n *  NOTICE: These networks won't support ENS unless they are the mainnet.\n */\nexport class SingleNetworkSequenceProvider extends SequenceProvider {\n  readonly _isSingleNetworkSequenceProvider = true\n\n  constructor(\n    client: SequenceClient,\n    providerFor: (networkId: number) => ethers.JsonRpcProvider,\n    public readonly chainId: ChainIdLike,\n    options?: ethers.AbstractProviderOptions\n  ) {\n    super(client, providerFor, undefined, options)\n  }\n\n  private _useChainId(chainId?: ChainIdLike): number {\n    const provided = this.toChainId(chainId)\n\n    if (provided && provided !== this.chainId) {\n      throw new Error(`This provider only supports the network ${this.chainId}, but ${provided} was requested.`)\n    }\n\n    return provided || super.toChainId(this.chainId)\n  }\n\n  protected useChainId(chainId?: ChainIdLike): Promise<number> {\n    return Promise.resolve(this._useChainId(chainId))\n  }\n\n  getChainId(): number {\n    return super.toChainId(this.chainId)\n  }\n\n  async getNetwork(): Promise<ethers.Network> {\n    const networks = await this.client.getNetworks()\n    const found = findNetworkConfig(networks, this.chainId)\n\n    if (!found) {\n      throw new Error(`Unsupported network ${this.chainId}`)\n    }\n\n    return new ethers.Network(found.name, found.chainId)\n  }\n\n  /**\n   *  Override getProvider and getSigner so they always use `useChainId`\n   *  this way they can't return providers and signers that can switch networks,\n   *  or that don't match the chainId of this signer.\n   */\n  getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider {\n    if (this._useChainId(chainId) !== this.chainId) {\n      throw new Error(`Unreachable code`)\n    }\n\n    return this\n  }\n\n  getSigner(chainId?: ChainIdLike): SingleNetworkSequenceSigner {\n    return super.getSigner(this._useChainId(chainId))\n  }\n\n  setDefaultChainId(_chainId: ChainIdLike): void {\n    throw new Error(`This provider only supports the network ${this.chainId}; use the parent provider to switch networks.`)\n  }\n\n  static is(cand: any): cand is SingleNetworkSequenceProvider {\n    return cand && typeof cand === 'object' && cand._isSingleNetworkSequenceProvider === true\n  }\n}\n","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","// src/rpc/proto/databeat.gen.ts\nvar Databeat = class {\n  hostname;\n  fetch;\n  path = \"/rpc/Databeat/\";\n  constructor(hostname, fetch) {\n    this.hostname = hostname;\n    this.fetch = (input, init) => fetch(input, init);\n  }\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n  ping = (headers, signal) => {\n    return this.fetch(\n      this.url(\"Ping\"),\n      createHTTPRequest({}, headers, signal)\n    ).then((res) => {\n      return buildResponse(res).then((_data) => {\n        return {\n          status: _data.status\n        };\n      });\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || \"\"}` });\n    });\n  };\n  version = (headers, signal) => {\n    return this.fetch(\n      this.url(\"Version\"),\n      createHTTPRequest({}, headers, signal)\n    ).then((res) => {\n      return buildResponse(res).then((_data) => {\n        return {\n          version: _data.version\n        };\n      });\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || \"\"}` });\n    });\n  };\n  runtimeStatus = (headers, signal) => {\n    return this.fetch(\n      this.url(\"RuntimeStatus\"),\n      createHTTPRequest({}, headers, signal)\n    ).then((res) => {\n      return buildResponse(res).then((_data) => {\n        return {\n          status: _data.status\n        };\n      });\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || \"\"}` });\n    });\n  };\n  tick = (args, headers, signal) => {\n    return this.fetch(\n      this.url(\"Tick\"),\n      createHTTPRequest(args, headers, signal)\n    ).then((res) => {\n      return buildResponse(res).then((_data) => {\n        return {\n          ok: _data.ok\n        };\n      });\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || \"\"}` });\n    });\n  };\n  rawEvents = (args, headers, signal) => {\n    return this.fetch(\n      this.url(\"RawEvents\"),\n      createHTTPRequest(args, headers, signal)\n    ).then((res) => {\n      return buildResponse(res).then((_data) => {\n        return {\n          ok: _data.ok\n        };\n      });\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || \"\"}` });\n    });\n  };\n};\nvar createHTTPRequest = (body = {}, headers = {}, signal = null) => {\n  return {\n    method: \"POST\",\n    headers: { ...headers, \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(body || {}),\n    signal\n  };\n};\nvar buildResponse = (res) => {\n  return res.text().then((text) => {\n    let data;\n    try {\n      data = JSON.parse(text);\n    } catch (error) {\n      let message = \"\";\n      if (error instanceof Error) {\n        message = error.message;\n      }\n      throw WebrpcBadResponseError.new(\n        {\n          status: res.status,\n          cause: `JSON.parse(): ${message}: response text: ${text}`\n        }\n      );\n    }\n    if (!res.ok) {\n      const code = typeof data.code === \"number\" ? data.code : 0;\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data);\n    }\n    return data;\n  });\n};\nvar WebrpcError = class _WebrpcError extends Error {\n  name;\n  code;\n  message;\n  status;\n  cause;\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg;\n  constructor(name, code, message, status, cause) {\n    super(message);\n    this.name = name || \"WebrpcError\";\n    this.code = typeof code === \"number\" ? code : 0;\n    this.message = message || `endpoint error ${this.code}`;\n    this.msg = this.message;\n    this.status = typeof status === \"number\" ? status : 0;\n    this.cause = cause;\n    Object.setPrototypeOf(this, _WebrpcError.prototype);\n  }\n  static new(payload) {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);\n  }\n};\nvar WebrpcEndpointError = class _WebrpcEndpointError extends WebrpcError {\n  constructor(name = \"WebrpcEndpoint\", code = 0, message = \"endpoint error\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcEndpointError.prototype);\n  }\n};\nvar WebrpcRequestFailedError = class _WebrpcRequestFailedError extends WebrpcError {\n  constructor(name = \"WebrpcRequestFailed\", code = -1, message = \"request failed\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcRequestFailedError.prototype);\n  }\n};\nvar WebrpcBadRouteError = class _WebrpcBadRouteError extends WebrpcError {\n  constructor(name = \"WebrpcBadRoute\", code = -2, message = \"bad route\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcBadRouteError.prototype);\n  }\n};\nvar WebrpcBadMethodError = class _WebrpcBadMethodError extends WebrpcError {\n  constructor(name = \"WebrpcBadMethod\", code = -3, message = \"bad method\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcBadMethodError.prototype);\n  }\n};\nvar WebrpcBadRequestError = class _WebrpcBadRequestError extends WebrpcError {\n  constructor(name = \"WebrpcBadRequest\", code = -4, message = \"bad request\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcBadRequestError.prototype);\n  }\n};\nvar WebrpcBadResponseError = class _WebrpcBadResponseError extends WebrpcError {\n  constructor(name = \"WebrpcBadResponse\", code = -5, message = \"bad response\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcBadResponseError.prototype);\n  }\n};\nvar WebrpcServerPanicError = class _WebrpcServerPanicError extends WebrpcError {\n  constructor(name = \"WebrpcServerPanic\", code = -6, message = \"server panic\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcServerPanicError.prototype);\n  }\n};\nvar WebrpcInternalErrorError = class _WebrpcInternalErrorError extends WebrpcError {\n  constructor(name = \"WebrpcInternalError\", code = -7, message = \"internal error\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcInternalErrorError.prototype);\n  }\n};\nvar WebrpcClientDisconnectedError = class _WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(name = \"WebrpcClientDisconnected\", code = -8, message = \"client disconnected\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcClientDisconnectedError.prototype);\n  }\n};\nvar WebrpcStreamLostError = class _WebrpcStreamLostError extends WebrpcError {\n  constructor(name = \"WebrpcStreamLost\", code = -9, message = \"stream lost\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcStreamLostError.prototype);\n  }\n};\nvar WebrpcStreamFinishedError = class _WebrpcStreamFinishedError extends WebrpcError {\n  constructor(name = \"WebrpcStreamFinished\", code = -10, message = \"stream finished\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _WebrpcStreamFinishedError.prototype);\n  }\n};\nvar UnauthorizedError = class _UnauthorizedError extends WebrpcError {\n  constructor(name = \"Unauthorized\", code = 1e3, message = \"Unauthorized access\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _UnauthorizedError.prototype);\n  }\n};\nvar PermissionDeniedError = class _PermissionDeniedError extends WebrpcError {\n  constructor(name = \"PermissionDenied\", code = 2e3, message = \"Permission denied\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _PermissionDeniedError.prototype);\n  }\n};\nvar SessionExpiredError = class _SessionExpiredError extends WebrpcError {\n  constructor(name = \"SessionExpired\", code = 2001, message = \"Session expired\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _SessionExpiredError.prototype);\n  }\n};\nvar NotFoundError = class _NotFoundError extends WebrpcError {\n  constructor(name = \"NotFound\", code = 3e3, message = \"Resource not found\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _NotFoundError.prototype);\n  }\n};\nvar InvalidAppKeyError = class _InvalidAppKeyError extends WebrpcError {\n  constructor(name = \"InvalidAppKey\", code = 4e3, message = \"Invalid app key\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _InvalidAppKeyError.prototype);\n  }\n};\nvar QueryFailedError = class _QueryFailedError extends WebrpcError {\n  constructor(name = \"QueryFailed\", code = 4001, message = \"DB query failed\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _QueryFailedError.prototype);\n  }\n};\nvar InvalidProjectIdError = class _InvalidProjectIdError extends WebrpcError {\n  constructor(name = \"InvalidProjectId\", code = 4002, message = \"Invalid project id\", status = 0, cause) {\n    super(name, code, message, status, cause);\n    Object.setPrototypeOf(this, _InvalidProjectIdError.prototype);\n  }\n};\nvar webrpcErrorByCode = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1e3]: UnauthorizedError,\n  [2e3]: PermissionDeniedError,\n  [2001]: SessionExpiredError,\n  [3e3]: NotFoundError,\n  [4e3]: InvalidAppKeyError,\n  [4001]: QueryFailedError,\n  [4002]: InvalidProjectIdError\n};\n\n// src/rpc/proto/index.ts\nvar DatabeatRpcClient = class extends Databeat {\n  constructor(hostname, auth) {\n    const globalFetch = globalThis.fetch.bind(globalThis);\n    super(hostname.endsWith(\"/\") ? hostname.slice(0, -1) : hostname, globalFetch);\n    this.auth = auth;\n    this._globalFetch = globalFetch;\n    this.fetch = this._fetch;\n  }\n  _globalFetch;\n  _fetch = (input, init) => {\n    if (this.auth) {\n      let headers = {};\n      if (this.auth.jwt?.length > 0) {\n        headers[\"Authorization\"] = `BEARER ${this.auth.jwt}`;\n      }\n      if (this.auth.headers) {\n        headers = { ...headers, ...this.auth.headers };\n      }\n      init.headers = { ...init.headers, ...headers };\n    }\n    return this._globalFetch(input, init);\n  };\n};\n\n// src/index.ts\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nvar Ident = /* @__PURE__ */ ((Ident2) => {\n  Ident2[Ident2[\"ANON\"] = 0] = \"ANON\";\n  Ident2[Ident2[\"PRIVATE\"] = 1] = \"PRIVATE\";\n  Ident2[Ident2[\"USER\"] = 2] = \"USER\";\n  return Ident2;\n})(Ident || {});\nvar MAX_QUEUE_SIZE = 150;\nvar defaultDatabeatOptions = {\n  defaultEnabled: true,\n  noop: false,\n  privacy: { userIdHash: true, userAgentSalt: false },\n  userIdentTracking: false,\n  strictMode: false,\n  flushInterval: 500,\n  initProps: () => {\n    return {};\n  }\n};\nvar Databeat2 = class {\n  rpc;\n  auth;\n  options;\n  enabled;\n  ident;\n  userId;\n  sessionId;\n  allowUserTracking;\n  projectId;\n  queue;\n  flushTimeout;\n  defaultProps;\n  dedupeIdentKey;\n  dedupeViewKey;\n  ts;\n  constructor(host, auth, options) {\n    if (typeof auth === \"string\") {\n      this.auth = { jwt: auth };\n    } else {\n      this.auth = auth;\n    }\n    this.rpc = new DatabeatRpcClient(host, this.auth);\n    this.options = defaultDatabeatOptions;\n    if (options) {\n      this.options = {\n        defaultEnabled: options.defaultEnabled || defaultDatabeatOptions.defaultEnabled,\n        projectId: options.projectId || null,\n        privacy: options.privacy || defaultDatabeatOptions.privacy,\n        userIdentTracking: options.userIdentTracking || defaultDatabeatOptions.userIdentTracking,\n        strictMode: options.strictMode || defaultDatabeatOptions.strictMode,\n        flushInterval: options.flushInterval || defaultDatabeatOptions.flushInterval,\n        noop: options.noop || false,\n        initProps: options.initProps || defaultDatabeatOptions.initProps\n      };\n    }\n    this.init();\n  }\n  // init is called on load by the constructor and also by reset().\n  init() {\n    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);\n    this.projectId = this.options.projectId || null;\n    this.userId = null;\n    this.sessionId = genSessionId();\n    this.queue = [];\n    this.flushTimeout = null;\n    this.defaultProps = { ...getDefaultProps(), ...this.options.initProps() };\n    this.identify();\n  }\n  // reset will reset the user_id and session_id details. Similar to a \"logout\" action.\n  reset(skipInit) {\n    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);\n    if (this.userId && !this.isAnon()) {\n      this.userId = null;\n    }\n    this.ident = 0 /* ANON */;\n    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });\n    if (skipInit === true) {\n      return;\n    }\n    this.init();\n  }\n  // identify can be called to seed the userId, where the behaviour changes\n  // depending on privacy or strict modes. identify is also called on init,\n  // where we load the data from localStorage.\n  identify(userId, options) {\n    if (!isBrowser()) return;\n    if (options && options.allowTracking !== void 0) {\n      this.allowTracking(options.allowTracking);\n    }\n    if (!userId) {\n      const val = getStorageVal();\n      if (val !== null && val.id !== null) {\n        this.userId = val.id;\n        this.ident = val.it;\n        this.allowUserTracking = val.ut;\n        if (val.it === void 0) {\n          if (this.userId.startsWith(\"anon:\")) {\n            this.ident = 0 /* ANON */;\n          } else {\n            this.ident = 1 /* PRIVATE */;\n          }\n          this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });\n        } else {\n          this.ident = val.it;\n        }\n      }\n    }\n    if (userId || this.userId === null) {\n      const v = genUserId(userId, this.allowUserTracking, this.options);\n      this.userId = v.userId;\n      this.ident = v.ident;\n      this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });\n    }\n    const dedupeIdentKey = `${this.userId}:${this.sessionId}`;\n    if (this.dedupeIdentKey === dedupeIdentKey) return;\n    this.dedupeIdentKey = dedupeIdentKey;\n    this.track({ event: \"INIT\", source: getPagePath(), props: this.defaultProps });\n    this.flush();\n  }\n  // allowTracking is used by strict mode to enable/disable tracking.\n  allowTracking(allowTracking) {\n    this.allowUserTracking = allowTracking;\n    setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });\n    if (this.options.strictMode) {\n      if (allowTracking) {\n        this.enable();\n      } else {\n        this.disable();\n      }\n    }\n  }\n  async track(events, options) {\n    if (isBrowser() && this.userId === null) {\n      throw new Error(\"databeat: init first\");\n    }\n    if (Array.isArray(events)) {\n      for (let i = 0; i < events.length; i++) {\n        events[i].ident = this.ident;\n        events[i].userId = this.userId;\n        events[i].sessionId = this.sessionId;\n        if (!events[i].projectId && this.projectId) {\n          events[i].projectId = this.projectId;\n        }\n      }\n      this.queue.push(...events);\n    } else {\n      events.ident = this.ident;\n      events.userId = this.userId;\n      events.sessionId = this.sessionId;\n      if (!events.projectId && this.projectId) {\n        events.projectId = this.projectId;\n      }\n      this.queue.push(events);\n    }\n    if (this.queue.length > MAX_QUEUE_SIZE) {\n      this.queue = this.queue.splice(this.queue.length - MAX_QUEUE_SIZE);\n    }\n    if (!this.enabled) return;\n    if (options && options.flush) {\n      await this.flush();\n    } else if (this.flushTimeout === null) {\n      this.flushTimeout = setTimeout(() => {\n        this.flush();\n      }, this.options.flushInterval);\n    }\n  }\n  trackView(props = {}) {\n    const eventProps = { ...this.defaultProps, ...props };\n    const eventSource = getPagePath();\n    const pageKey = `${eventSource}:${JSON.stringify(eventProps)}:${this.userId}:${this.sessionId}`;\n    if (this.dedupeViewKey === pageKey) return;\n    this.dedupeViewKey = pageKey;\n    this.track({ event: \"VIEW\", source: eventSource, props: eventProps });\n  }\n  flush = async () => {\n    if (this.flushTimeout !== null) {\n      clearTimeout(this.flushTimeout);\n      this.flushTimeout = null;\n    }\n    if (!this.enabled) return;\n    if (this.options.noop) return;\n    if (this.options.strictMode && !this.allowUserTracking) return;\n    if (this.queue.length === 0) return;\n    const events = this.dedupedQueue();\n    this.queue = [];\n    try {\n      await this.rpc.tick({ events });\n    } catch (err) {\n      console.warn(`databeat flush failed: ${err}`);\n    }\n  };\n  isEnabled() {\n    return this.enabled;\n  }\n  isAnon() {\n    return this.ident === 0 /* ANON */;\n  }\n  getIdent() {\n    return this.ident;\n  }\n  getUserId() {\n    return this.userId;\n  }\n  getSessionId() {\n    return this.sessionId;\n  }\n  getStorageTS() {\n    if (this.ts) {\n      return this.ts;\n    }\n    const val = getStorageVal();\n    if (val === void 0 || val === null || val.id === null) {\n      return void 0;\n    }\n    this.ts = val.ts;\n    return this.ts;\n  }\n  enable() {\n    if (!isAuthEnabled(this.auth)) {\n      this.enabled = false;\n      return;\n    }\n    if (!isBrowser()) return;\n    this.enabled = true;\n    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });\n    this.identify();\n  }\n  disable() {\n    if (!isBrowser()) return;\n    this.enabled = false;\n    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });\n  }\n  dedupedQueue = () => {\n    const uniqEvents = /* @__PURE__ */ new Map();\n    for (let i = 0; i < this.queue.length; i++) {\n      const ev = this.queue[i];\n      const key = `${ev.event}:${ev.source}:${ev.userId}:${ev.sessionId}:${JSON.stringify(ev.props)}:${JSON.stringify(ev.nums)}`;\n      if (!uniqEvents.has(key)) {\n        uniqEvents.set(key, ev);\n      }\n    }\n    return Array.from(uniqEvents.values());\n  };\n};\nvar isBrowser = () => {\n  return typeof window === \"object\" && typeof window.localStorage === \"object\" && typeof window.localStorage.getItem === \"function\" && typeof window.localStorage.setItem === \"function\";\n};\nvar isEnabled = (defaultEnabled, auth) => {\n  if (!isAuthEnabled(auth)) {\n    return false;\n  }\n  if (!isBrowser()) {\n    return true;\n  }\n  const val = getStorageVal();\n  if (val === null) {\n    if (defaultEnabled !== null && defaultEnabled !== void 0) {\n      return defaultEnabled;\n    } else {\n      return true;\n    }\n  } else {\n    return val.on;\n  }\n};\nvar isAuthEnabled = (auth) => {\n  if (auth?.jwt?.length > 0) {\n    return true;\n  }\n  if (auth?.headers && Object.keys(auth.headers).length > 0) {\n    return true;\n  }\n  return false;\n};\nvar getPagePath = () => {\n  try {\n    return window.location.pathname;\n  } catch (err) {\n    return \"\";\n  }\n};\nvar getDefaultProps = () => {\n  if (!isBrowser()) return {};\n  const params = new URL(window.location.href).searchParams;\n  const props = {};\n  props[\"origin\"] = window.location.origin;\n  if (params.get(\"ref\") && params.get(\"ref\") !== \"\") {\n    props[\"ref\"] = params.get(\"ref\") || \"\";\n  }\n  if (params.get(\"source\") && params.get(\"source\") !== \"\") {\n    props[\"source\"] = params.get(\"source\") || \"\";\n  }\n  if (params.get(\"utm_source\") && params.get(\"utm_source\") !== \"\") {\n    props[\"utmSource\"] = params.get(\"utm_source\") || \"\";\n  }\n  if (params.get(\"utm_campaign\") && params.get(\"utm_campaign\") !== \"\") {\n    props[\"utmCampaign\"] = params.get(\"utm_campaign\") || \"\";\n  }\n  if (params.get(\"utm_medium\") && params.get(\"utm_medium\") !== \"\") {\n    props[\"utmMedium\"] = params.get(\"utm_medium\") || \"\";\n  }\n  if (params.get(\"utm_content\") && params.get(\"utm_content\") !== \"\") {\n    props[\"utmContent\"] = params.get(\"utm_content\") || \"\";\n  }\n  if (params.get(\"utm_term\") && params.get(\"utm_term\") !== \"\") {\n    props[\"utmTerm\"] = params.get(\"utm_term\") || \"\";\n  }\n  if (document.referrer && document.referrer !== \"\") {\n    props[\"referrer\"] = document.referrer;\n  }\n  if (params.get(\"gclid\") && params.get(\"gclid\") !== \"\") {\n    props[\"gclid\"] = params.get(\"gclid\") || \"\";\n  }\n  if (params.get(\"wbraid\") && params.get(\"wbraid\") !== \"\") {\n    props[\"wbraid\"] = params.get(\"wbraid\") || \"\";\n  }\n  return props;\n};\nvar storageKey = \"_dbeat\";\nvar getStorageVal = () => {\n  try {\n    return JSON.parse(window.localStorage.getItem(storageKey));\n  } catch (err) {\n    return null;\n  }\n};\nvar setStorageVal = (val) => {\n  try {\n    if (!val.ts) {\n      val.ts = Math.floor(Date.now() / 1e3);\n    }\n    window.localStorage.setItem(storageKey, JSON.stringify(val));\n    return val.ts;\n  } catch (err) {\n    return;\n  }\n};\nvar genUserId = (seed, allowUserTracking, options) => {\n  if (!seed || seed === null || seed === \"\") {\n    const id = Math.floor(Math.random() * 1e14);\n    return { userId: `${id}`, ident: 0 /* ANON */ };\n  }\n  if (options.userIdentTracking && allowUserTracking) {\n    return { userId: seed, ident: 2 /* USER */ };\n  }\n  if (options.privacy.userIdHash === true || !options.userIdentTracking || !allowUserTracking) {\n    if (isBrowser() && options.privacy.userAgentSalt === true) {\n      seed = seed + \":\" + navigator.userAgent;\n    }\n    if (options.privacy.extraSalt && options.privacy.extraSalt.length > 0) {\n      seed = seed + \":\" + options.privacy.extraSalt;\n    }\n    return { userId: bytesToHex(sha256(seed)).substring(0, 50), ident: 1 /* PRIVATE */ };\n  } else {\n    throw new Error(\"invalid configuration\");\n  }\n};\nvar genSessionId = () => {\n  const isSessionStorageAvail = isBrowser() && typeof window.sessionStorage === \"object\" && typeof window.sessionStorage.getItem === \"function\" && typeof window.sessionStorage.setItem === \"function\";\n  if (!isSessionStorageAvail) {\n    return genRandHex(16);\n  } else {\n    const sid = window.sessionStorage.getItem(storageKey);\n    if (!!sid && sid.length > 0) {\n      return sid;\n    } else {\n      const sid2 = genRandHex(16);\n      window.sessionStorage.setItem(storageKey, sid2);\n      return sid2;\n    }\n  }\n};\nvar genRandHex = (n) => {\n  let hexString = \"\";\n  for (let i = 0; i < n; i++) {\n    hexString += Math.floor(Math.random() * 16).toString(16);\n  }\n  return \"0x\" + hexString;\n};\nif (typeof process === \"object\" && process.version && process.version < \"v18\") {\n  console.error(`ERROR! expecting node v18+ but your node version is reporting ${process.version}`);\n  if (process && process.exit) {\n    process.exit(1);\n  }\n}\nexport {\n  Databeat2 as Databeat,\n  Ident,\n  genSessionId,\n  genUserId,\n  getStorageVal,\n  isBrowser\n};\n//# sourceMappingURL=databeat-tracker.mjs.map","import { Databeat, Event as DatabeatEvent, Auth, isBrowser } from '@databeat/tracker'\n\nexport enum EventType {\n  // Core types part of Databeat\n  INIT,\n  VIEW,\n\n  // Provider specific\n  SIGN_MESSAGE_REQUEST,\n  SIGN_TYPED_DATA_REQUEST,\n  SEND_TRANSACTION_REQUEST\n}\n\nexport type EventTypes = keyof typeof EventType\nexport type Event = DatabeatEvent<EventTypes>\n\n// Analytics sub-class to add some custom helper methods\nexport class Analytics extends Databeat<EventTypes> {}\n\n// Setup analytics tracker\nexport const setupAnalytics = (projectAccessKey: string, server?: string) => {\n  if (!server) {\n    server = 'https://nodes.sequence.app'\n  }\n\n  // disable tracking if projectAccessKey is not set\n  const noop = !projectAccessKey\n\n  // auth\n  const auth: Auth = {}\n  if (projectAccessKey) {\n    auth.headers = { 'X-Access-Key': projectAccessKey }\n  }\n\n  return new Analytics(server, auth, {\n    noop: noop,\n    defaultEnabled: true,\n    privacy: { userIdHash: true, userAgentSalt: false },\n    initProps: () => {\n      if (!isBrowser()) {\n        return {}\n      } else {\n        return { origin: window.location.origin }\n      }\n    }\n  })\n}\n","import { NetworkConfig } from '@0xsequence/network'\nimport {\n  ConnectDetails,\n  ConnectOptions,\n  ItemStore,\n  MuxMessageProvider,\n  MuxTransportTemplate,\n  OpenWalletIntent,\n  OptionalChainId,\n  OptionalEIP6492,\n  ProviderTransport,\n  WalletEventTypes,\n  WalletSession,\n  isMuxTransportTemplate,\n  isProviderTransport,\n  messageToBytes\n} from '.'\nimport { commons, VERSION } from '@0xsequence/core'\nimport { TypedData } from '@0xsequence/utils'\nimport { toExtended } from './extended'\nimport { Analytics, setupAnalytics } from './analytics'\nimport { ethers } from 'ethers'\n\n/**\n *  This session class is meant to persist the state of the wallet connection\n *  whitin the dapp. This enables the client to retain the wallet address (and some more)\n *  even if the user refreshes the page. Otherwise we would have to open the popup again.\n */\nexport class SequenceClientSession {\n  static readonly SESSION_LOCALSTORE_KEY = '@sequence.session'\n\n  constructor(private store: ItemStore) {}\n\n  connectedSession(): Required<WalletSession> {\n    const session = this.getSession()\n\n    if (session && session.accountAddress && session.walletContext && session.networks) {\n      return {\n        accountAddress: session.accountAddress!,\n        walletContext: session.walletContext!,\n        networks: session.networks!\n      }\n    }\n\n    throw new Error('Sequence session not connected')\n  }\n\n  hasSession(): boolean {\n    return this.getSession()?.accountAddress !== undefined\n  }\n\n  setSession(session: WalletSession) {\n    return this.store.setItem(SequenceClientSession.SESSION_LOCALSTORE_KEY, JSON.stringify(session))\n  }\n\n  getSession(): WalletSession | undefined {\n    const session = this.store.getItem(SequenceClientSession.SESSION_LOCALSTORE_KEY)\n\n    if (session) {\n      return JSON.parse(session)\n    }\n\n    return undefined\n  }\n\n  async clearSession() {\n    return this.store.removeItem(SequenceClientSession.SESSION_LOCALSTORE_KEY)\n  }\n}\n\n/**\n *  The wallet webapp doesn't really care what's the \"default chain\" for the user.\n *  so we don't even bother to send this information to the wallet. Instead, we\n *  track it locally using storage, that way the data stays always in sync.\n */\nexport class DefaultChainIdTracker {\n  static readonly SESSION_CHAIN_ID_KEY = '@sequence.session.defaultChainId'\n\n  callbacks: ((chainId: number) => void)[] = []\n\n  constructor(\n    private store: ItemStore,\n    private startingChainId: number = 1\n  ) {\n    store.onItemChange(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, (value: string | null) => {\n      if (value) {\n        const chainId = parseInt(value)\n        this.callbacks.forEach(cb => cb(chainId))\n      }\n    })\n  }\n\n  onDefaultChainIdChanged(callback: (chainId: number) => void) {\n    this.callbacks.push(callback)\n    return () => {\n      this.callbacks = this.callbacks.filter(cb => cb !== callback)\n    }\n  }\n\n  setDefaultChainId(chainId: number) {\n    if (chainId !== this.getDefaultChainId()) {\n      this.store.setItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, chainId.toString())\n    }\n  }\n\n  getDefaultChainId(): number {\n    const read = this.store.getItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY)\n\n    if (!read || read.length === 0) {\n      return this.startingChainId\n    }\n\n    return parseInt(read)\n  }\n}\n\nexport type SequenceClientOptions = {\n  defaultChainId?: number\n  defaultEIP6492?: boolean\n  projectAccessKey?: string\n  analytics?: boolean\n}\n\n/**\n *  This is a wallet client for sequence wallet-webapp. It connects using *some* transport\n *  and it allows to perform all sequence specific (or write) operations related to the wallet.\n *s\n *  It doesn't implement a full ethereum Provider, it doesn't include read-only methods.\n */\n\n// TODO: rename Client to transport.. or something.. like SequenceTransport ..\nexport class SequenceClient {\n  private readonly session: SequenceClientSession\n  private readonly defaultChainId: DefaultChainIdTracker\n  private readonly callbacks: { [K in keyof WalletEventTypes]?: WalletEventTypes[K][] } = {}\n\n  public readonly transport: ProviderTransport\n\n  public readonly defaultEIP6492: boolean\n  public readonly projectAccessKey?: string\n  public readonly analytics?: Analytics\n\n  constructor(transport: ProviderTransport | MuxTransportTemplate, store: ItemStore, options?: SequenceClientOptions) {\n    if (isMuxTransportTemplate(transport)) {\n      this.transport = MuxMessageProvider.new(transport)\n    } else if (isProviderTransport(transport)) {\n      this.transport = transport\n    } else {\n      throw new Error('Invalid transport')\n    }\n\n    const defaultChainId = options?.defaultChainId\n    this.defaultEIP6492 = options?.defaultEIP6492 ?? false\n\n    this.session = new SequenceClientSession(store)\n    this.defaultChainId = new DefaultChainIdTracker(store, defaultChainId)\n\n    this.transport.on('accountsChanged', (accounts: string[]) => {\n      if (accounts.length > 1) {\n        console.warn('SequenceClient: wallet-webapp returned more than one account')\n      }\n\n      this.callbacks.accountsChanged?.forEach(cb => cb(accounts))\n    })\n\n    this.transport.on('connect', (response: ConnectDetails) => {\n      const chainIdHex = ethers.toQuantity(this.getChainId())\n      this.callbacks.connect?.forEach(cb =>\n        cb({\n          ...response,\n          // Ignore the full connect response\n          // use the chainId defined locally\n          chainId: chainIdHex\n        })\n      )\n    })\n\n    this.transport.on('disconnect', (error, origin) => {\n      this.callbacks.disconnect?.forEach(cb => cb(error, origin))\n    })\n\n    this.transport.on('networks', networks => {\n      this.callbacks.networks?.forEach(cb => cb(networks))\n    })\n\n    this.transport.on('walletContext', context => {\n      this.callbacks.walletContext?.forEach(cb => cb(context))\n    })\n\n    this.transport.on('open', info => {\n      this.callbacks.open?.forEach(cb => cb(info))\n    })\n\n    this.transport.on('close', () => {\n      this.callbacks.close?.forEach(cb => cb())\n    })\n\n    this.transport.on('chainChanged', (chainIdHex, origin) => {\n      this.callbacks.chainChanged?.forEach(cb => cb(chainIdHex, origin))\n    })\n\n    // We don't listen for the transport chainChanged event\n    // instead we handle it locally, so we listen for changes in the store\n    this.defaultChainId.onDefaultChainIdChanged((chainId: number) => {\n      const chainIdHex = ethers.toQuantity(chainId)\n      this.callbacks.chainChanged?.forEach(cb => cb(chainIdHex))\n    })\n\n    if (options?.projectAccessKey) {\n      this.projectAccessKey = options.projectAccessKey\n    }\n    if (this.projectAccessKey && options?.analytics) {\n      this.analytics = setupAnalytics(this.projectAccessKey)\n    }\n\n    if (this.session.getSession()?.accountAddress) {\n      this.analytics?.identify(this.session.getSession()?.accountAddress?.toLowerCase())\n    }\n  }\n\n  // Callbacks\n\n  registerCallback<K extends keyof WalletEventTypes>(eventName: K, callback: WalletEventTypes[K]) {\n    if (!this.callbacks[eventName]) {\n      this.callbacks[eventName] = []\n    }\n\n    this.callbacks[eventName]!.push(callback)\n\n    return () => {\n      this.callbacks[eventName] = this.callbacks[eventName]!.filter(c => c !== callback) as any\n    }\n  }\n\n  // Individual callbacks lead to more idiomatic code\n\n  onOpen(callback: WalletEventTypes['open']) {\n    return this.registerCallback('open', callback)\n  }\n\n  onClose(callback: WalletEventTypes['close']) {\n    return this.registerCallback('close', callback)\n  }\n\n  onConnect(callback: WalletEventTypes['connect']) {\n    return this.registerCallback('connect', callback)\n  }\n\n  onDisconnect(callback: WalletEventTypes['disconnect']) {\n    return this.registerCallback('disconnect', callback)\n  }\n\n  onNetworks(callback: WalletEventTypes['networks']) {\n    return this.registerCallback('networks', callback)\n  }\n\n  onAccountsChanged(callback: WalletEventTypes['accountsChanged']) {\n    return this.registerCallback('accountsChanged', callback)\n  }\n\n  // @deprecated\n  onWalletContext(callback: WalletEventTypes['walletContext']) {\n    return this.registerCallback('walletContext', callback)\n  }\n\n  onChainChanged(callback: WalletEventTypes['chainChanged']) {\n    return this.registerCallback('chainChanged', callback)\n  }\n\n  onDefaultChainIdChanged(callback: WalletEventTypes['chainChanged']) {\n    return this.registerCallback('chainChanged', callback)\n  }\n\n  getChainId(): number {\n    return this.defaultChainId.getDefaultChainId()\n  }\n\n  setDefaultChainId(chainId: number) {\n    return this.defaultChainId.setDefaultChainId(chainId)\n  }\n\n  // Proxy transport methods\n\n  async openWallet(path?: string, intent?: OpenWalletIntent) {\n    this.transport.openWallet(path, intent, this.getChainId())\n    await this.transport.waitUntilOpened()\n    return this.isOpened()\n  }\n\n  closeWallet() {\n    return this.transport.closeWallet()\n  }\n\n  isOpened(): boolean {\n    return this.transport.isOpened()\n  }\n\n  isConnected(): boolean {\n    return this.session.hasSession()\n  }\n\n  getSession(): WalletSession | undefined {\n    return this.session.getSession()\n  }\n\n  // Basic API\n  getAddress(): string {\n    const session = this.session.connectedSession()\n    return session.accountAddress\n  }\n\n  async connect(options: ConnectOptions): Promise<ConnectDetails> {\n    if (options?.authorizeVersion === undefined) {\n      // Populate default authorize version if not provided\n      options.authorizeVersion = 2\n    }\n\n    if (options?.refresh === true) {\n      this.disconnect()\n    }\n\n    options.projectAccessKey = this.projectAccessKey\n\n    if (options) {\n      if (options.authorize) {\n        if (!options.app) {\n          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`)\n        }\n\n        if (options.authorizeVersion === undefined) {\n          options.authorizeVersion = 2\n        }\n      }\n    }\n\n    await this.openWallet(undefined, {\n      type: 'connect',\n      options: { ...options, networkId: this.getChainId(), clientVersion: VERSION }\n    })\n\n    const connectDetails = await this.transport.waitUntilConnected().catch((error): ConnectDetails => {\n      if (error instanceof Error) {\n        return { connected: false, error: error.message }\n      } else {\n        return { connected: false, error: JSON.stringify(error) }\n      }\n    })\n\n    // Normalize chainId into a decimal string\n    // TODO: Remove this once wallet-webapp returns chainId as a string\n    if (connectDetails.chainId) {\n      connectDetails.chainId = BigInt(connectDetails.chainId).toString()\n    }\n\n    if (connectDetails.connected) {\n      if (!connectDetails.session) {\n        throw new Error('impossible state, connect response is missing session')\n      }\n\n      this.session.setSession(connectDetails.session)\n\n      if (connectDetails.session?.accountAddress) {\n        this.analytics?.identify(connectDetails.session.accountAddress.toLowerCase())\n      }\n    }\n\n    return connectDetails\n  }\n\n  disconnect() {\n    if (this.isOpened()) {\n      this.closeWallet()\n    }\n\n    this.analytics?.reset()\n\n    return this.session.clearSession()\n  }\n\n  // Higher level API\n\n  async request(request: { method: string; params?: any[]; chainId?: number }): Promise<any> {\n    // Internally when sending requests we use `legacy_sign`\n    // to avoid the default EIP6492 behavior overriding an explicit\n    // \"legacy sign\" request, so we map the method here.\n    request.method = this.mapSignMethod(request.method)\n\n    const result = await this.transport.request(request)\n\n    // We may need to unwrap the response if it's a JSON-RPC response. ie. older universal wallet versions\n    return unwrapJsonRpcResponse(result)\n  }\n\n  async getNetworks(pull?: boolean): Promise<NetworkConfig[]> {\n    const connectedSession = this.session.connectedSession()\n\n    if (pull) {\n      connectedSession.networks = await this.request({ method: 'sequence_getNetworks' })\n      this.session.setSession(connectedSession)\n    }\n\n    return connectedSession.networks\n  }\n\n  // NOTICE: `legacy_sign` will get overriden by `send`\n  // it is done this way to ensure that:\n  //  - `send` handles `personal_sign` as a request for the default sign method\n  //  - explicit `personal_sign` is not replaced by `sequence_sign` (if default is EI6492)\n  private signMethod(options?: OptionalEIP6492) {\n    if (options?.eip6492 === undefined) {\n      return 'personal_sign'\n    }\n\n    return options.eip6492 ? 'sequence_sign' : 'legacy_sign'\n  }\n\n  private signTypedDataMethod(options?: OptionalEIP6492) {\n    if (options?.eip6492 === undefined) {\n      return 'eth_signTypedData_v4'\n    }\n\n    return options.eip6492 ? 'sequence_signTypedData_v4' : 'legacy_signTypedData_v4'\n  }\n\n  private mapSignMethod(method: string): string {\n    if (method === 'personal_sign') {\n      if (this.defaultEIP6492) {\n        return 'sequence_sign'\n      } else {\n        return 'personal_sign'\n      }\n    }\n\n    if (method === 'eth_signTypedData_v4') {\n      if (this.defaultEIP6492) {\n        return 'sequence_signTypedData_v4'\n      } else {\n        return 'eth_signTypedData_v4'\n      }\n    }\n\n    if (method === 'legacy_sign') {\n      return 'personal_sign'\n    }\n\n    if (method === 'legacy_signTypedData_v4') {\n      return 'eth_signTypedData_v4'\n    }\n\n    return method\n  }\n\n  async signMessage(message: ethers.BytesLike, options?: OptionalEIP6492 & OptionalChainId): Promise<string> {\n    const method = this.signMethod(options)\n\n    this.analytics?.track({ event: 'SIGN_MESSAGE_REQUEST', props: { chainId: `${options?.chainId || this.getChainId()}` } })\n\n    message = ethers.hexlify(messageToBytes(message))\n\n    // Address is ignored by the wallet webapp\n    return this.request({\n      method,\n      params: [message, this.getAddress()],\n      chainId: options?.chainId\n    })\n  }\n\n  async signTypedData(typedData: TypedData, options?: OptionalEIP6492 & OptionalChainId): Promise<string> {\n    const method = this.signTypedDataMethod(options)\n\n    // TODO: Stop using ethers for this, this is the only place where we use it\n    // and it makes the client depend on ethers.\n    const encoded = ethers.TypedDataEncoder.getPayload(typedData.domain, typedData.types, typedData.message)\n\n    // The sign typed data will use one of the following chainIds, in order:\n    // - The one provided in the options\n    // - The one provided in the typedData.domain.chainId\n    // - The default chainId\n\n    this.analytics?.track({ event: 'SIGN_TYPED_DATA_REQUEST', props: { chainId: `${options?.chainId || this.getChainId()}` } })\n\n    return this.request({\n      method,\n      params: [this.getAddress(), encoded],\n      chainId: options?.chainId || (typedData.domain.chainId && Number(typedData.domain.chainId)) || this.getChainId()\n    })\n  }\n\n  async sendTransaction(tx: ethers.TransactionRequest[] | ethers.TransactionRequest, options?: OptionalChainId): Promise<string> {\n    const sequenceTxs = Array.isArray(tx) ? tx : [tx]\n    const extendedTxs = toExtended(sequenceTxs)\n\n    this.analytics?.track({ event: 'SEND_TRANSACTION_REQUEST', props: { chainId: `${options?.chainId || this.getChainId()}` } })\n\n    return this.request({ method: 'eth_sendTransaction', params: [extendedTxs], chainId: options?.chainId })\n  }\n\n  async getWalletContext(): Promise<commons.context.VersionedContext> {\n    return this.request({ method: 'sequence_getWalletContext' })\n  }\n\n  async getOnchainWalletConfig(options?: OptionalChainId): Promise<commons.config.Config> {\n    // NOTICE: sequence_getWalletConfig sends the chainId as a param\n    const res = await this.request({\n      method: 'sequence_getWalletConfig',\n      params: [options?.chainId || this.getChainId()],\n      chainId: options?.chainId\n    })\n    return Array.isArray(res) ? res[0] : res\n  }\n\n  // NOTICE: We are leaving out all the \"regular\" methods os a tipical\n  // JSON RPC Provider (eth_getBlockByNumber, eth_call, etc)\n  // wallet-webapp does implement them, but this client is meant to be\n  // exclusively used for Sequence specific methods\n}\n\n// Unwrap a JsonRpcResponse result\nconst unwrapJsonRpcResponse = (response: any): any => {\n  if (response && typeof response === 'object' && 'jsonrpc' in response && 'result' in response) {\n    return response.result\n  }\n\n  return response\n}\n","import { ethers } from 'ethers'\n\nexport type ExtendedTransactionRequest = ethers.TransactionRequest & {\n  auxiliary?: ethers.TransactionRequest[]\n}\n\nexport function toExtended(transactions: ethers.TransactionRequest[]): ExtendedTransactionRequest {\n  if (transactions.length === 0) {\n    throw new Error('No transaction provided')\n  }\n\n  const [first, ...rest] = transactions\n\n  return {\n    ...first,\n    auxiliary: rest\n  }\n}\n\nexport function fromExtended(transaction: ExtendedTransactionRequest): ethers.TransactionRequest[] {\n  return [transaction, ...(transaction.auxiliary || [])]\n}\n\nexport function isExtended(transaction: ethers.TransactionRequest): transaction is ExtendedTransactionRequest {\n  return (transaction as any).auxiliary !== undefined\n}\n","import {\n  CachedProvider,\n  ChainIdLike,\n  NetworkConfig,\n  allNetworks,\n  exceptionProviderMiddleware,\n  findNetworkConfig,\n  loggingProviderMiddleware,\n  JsonRpcProvider\n} from '@0xsequence/network'\nimport { MuxTransportTemplate } from './transports'\nimport { ItemStore, useBestStore } from './utils'\nimport { ethers } from 'ethers'\nimport { SequenceClient } from './client'\nimport { SequenceProvider } from './provider'\n\nexport interface ProviderConfig {\n  // The local storage dependency for the wallet provider, defaults to window.localStorage.\n  // For example, this option should be used when using React Native since window.localStorage is not available.\n  localStorage?: ItemStore\n\n  // defaultNetwork is the primary network of a dapp and the default network a\n  // provider will communicate. Note: this setting is also configurable from the\n  // Wallet constructor's first argument. If both are specified, then they\n  // need to match\n  defaultNetwork?: ChainIdLike\n\n  // defaultEIP6492 defines if EIP-6492 is enabled by default when signing messages.\n  defaultEIP6492?: boolean\n\n  // networks is a configuration list of networks used by the wallet. This list\n  // is combined with the network list specified by sequence.js.\n  // notice that this can only replace the rpc urls on the dapp side,\n  // the networks on wallet-webapp side remain the same.\n  //\n  // NOTICE: It's not possible to define networks that aren't already\n  // defined in sequence.js.\n  networks?: Partial<NetworkConfig>[]\n\n  // transports for dapp to wallet jron-rpc communication\n  transports?: MuxTransportTemplate\n\n  // analytics .... (default: true)\n  analytics?: boolean\n}\n\nexport const DefaultProviderConfig = {\n  transports: {\n    walletAppURL: 'https://sequence.app',\n    windowTransport: { enabled: true },\n    proxyTransport: { enabled: false }\n  },\n\n  defaultNetwork: 1,\n  analytics: true\n}\n\nlet sequenceWalletProvider: SequenceProvider | undefined\n\n/**\n * Initializes a wallet with the provided project access key and optional configuration.\n *\n * @param projectAccessKey - Access key for the project that can be obtained from Sequence Builder on sequence.build\n * @param partialConfig - Optional partial configuration for the wallet.\n * @returns The initialized wallet provider.\n * @throws Error if projectAccessKey is not provided, empty string or is not string.\n */\nexport const initWallet = (projectAccessKey: string, partialConfig?: Partial<ProviderConfig>) => {\n  if (!projectAccessKey || typeof projectAccessKey !== 'string') {\n    throw new Error('Please pass a projectAccessKey in initWallet.')\n  }\n\n  if (sequenceWalletProvider) {\n    return sequenceWalletProvider\n  }\n\n  // Combine both the provided config and the default config\n  const config = {\n    ...DefaultProviderConfig,\n    ...partialConfig,\n    transports: {\n      ...DefaultProviderConfig.transports,\n      ...partialConfig?.transports\n    }\n  }\n\n  const rpcProviders: Record<number, ethers.JsonRpcProvider> = {}\n\n  // Find any new networks that aren't already defined in sequence.js\n  // and add them to the list of networks, (they must have a rpcUrl and chainId)\n  const newNetworks = (config.networks?.filter(n => {\n    // eslint-disable-next-line\n    n.rpcUrl !== undefined && n.chainId !== undefined && !allNetworks.find(an => an.chainId === n.chainId)\n  }) ?? []) as NetworkConfig[]\n\n  // Override any information about the networks using the config\n  const combinedNetworks = allNetworks\n    .map(n => {\n      const network = config.networks?.find(cn => cn.chainId === n.chainId)\n      return network ? { ...n, ...network } : n\n    })\n    .concat(newNetworks)\n    .map(network => {\n      // don't double-append in the case the user has already included their access key in the rpc URL\n      if (network.rpcUrl.includes(projectAccessKey)) {\n        return network\n      }\n\n      // this will probably break non-sequence RPC provider URLs.\n      network.rpcUrl = network.rpcUrl + `/${projectAccessKey}`\n      return network\n    })\n\n  // This builds a \"public rpc\" on demand, we build them on demand because we don't want to\n  // generate a bunch of providers for networks that aren't used.\n  const providerForChainId = (chainId: number) => {\n    if (!rpcProviders[chainId]) {\n      const rpcUrl = combinedNetworks.find(n => n.chainId === chainId)?.rpcUrl\n      if (!rpcUrl) {\n        throw new Error(`no rpcUrl found for chainId: ${chainId}`)\n      }\n\n      rpcProviders[chainId] = new JsonRpcProvider(\n        rpcUrl,\n        {\n          middlewares: [loggingProviderMiddleware, exceptionProviderMiddleware, new CachedProvider()]\n        },\n        { cacheTimeout: -1 }\n      )\n    }\n\n    return rpcProviders[chainId]\n  }\n\n  // This is the starting default network (as defined by the config)\n  // it can be later be changed using `wallet_switchEthereumChain` or some\n  // of the other methods on the provider.\n  const defaultNetwork = config.defaultNetwork ? findNetworkConfig(combinedNetworks, config.defaultNetwork)?.chainId : undefined\n  if (!defaultNetwork && config.defaultNetwork) {\n    throw new Error(`defaultNetwork not found for chainId: ${config.defaultNetwork}`)\n  }\n\n  // Generate ItemStore\n  const itemStore = config.localStorage || useBestStore()\n\n  // Create client, provider and return signer\n  const client = new SequenceClient(config.transports, itemStore, {\n    defaultChainId: defaultNetwork,\n    defaultEIP6492: config.defaultEIP6492,\n    projectAccessKey: projectAccessKey,\n    analytics: config.analytics\n  })\n\n  sequenceWalletProvider = new SequenceProvider(client, providerForChainId)\n  return sequenceWalletProvider\n}\n\nexport const unregisterWallet = () => {\n  if (!sequenceWalletProvider) return\n  sequenceWalletProvider.client.closeWallet()\n  sequenceWalletProvider.client.transport.unregister()\n  sequenceWalletProvider = undefined\n}\n\nexport const getWallet = () => {\n  if (!sequenceWalletProvider) {\n    throw new Error('Wallet has not been initialized, call sequence.initWallet(config) first.')\n  }\n  return sequenceWalletProvider\n}\n","import { BaseWalletTransport } from '../base-wallet-transport'\nimport { WalletRequestHandler } from '../wallet-request-handler'\nimport { InitState, ProviderMessage } from '../../types'\nimport { ProxyMessageChannelPort } from './proxy-message-channel'\n\nexport class ProxyMessageHandler extends BaseWalletTransport {\n  private port: ProxyMessageChannelPort\n\n  constructor(walletRequestHandler: WalletRequestHandler, port: ProxyMessageChannelPort) {\n    super(walletRequestHandler)\n    this.port = port\n    this._init = InitState.OK\n  }\n\n  register() {\n    this.port.handleMessage = (message: ProviderMessage<any>): void => {\n      this.handleMessage(message)\n    }\n    this._registered = true\n  }\n\n  // note: we can't decide whether to restore the session within register(), because session info is\n  // received asyncronously via EventType.OPEN after register() is executed.\n  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,\n  // because the wallet is already open.\n  //\n  // call this method from wallet redirect hander when a session restore is needed\n  async restoreSession() {\n    const cachedSession = await this.getCachedTransportSession()\n    if (cachedSession) {\n      this.open(cachedSession)\n    }\n  }\n\n  unregister() {\n    // @ts-ignore\n    this.port.handleMessage = undefined\n    this._registered = false\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    this.port.sendMessage(message)\n  }\n}\n","import {\n  ProviderMessageRequest,\n  ProviderMessage,\n  EventType,\n  InitState,\n  WindowSessionParams,\n  OpenWalletIntent,\n  ProviderRpcError,\n  TransportSession\n} from '../../types'\nimport { WalletRequestHandler } from '../wallet-request-handler'\nimport { BaseWalletTransport } from '../base-wallet-transport'\nimport { logger, base64DecodeObject, bigintReviver, bigintReplacer } from '@0xsequence/utils'\nimport { ethers } from 'ethers'\n\nexport class WindowMessageHandler extends BaseWalletTransport {\n  protected parentWindow: Window\n\n  private _isPopup: boolean = false\n\n  constructor(walletRequestHandler: WalletRequestHandler) {\n    super(walletRequestHandler)\n    this._init = InitState.NIL\n  }\n\n  async register(windowHref?: any) {\n    const isPopup = parent.window.opener !== null\n    this._isPopup = isPopup\n    if (isPopup !== true) {\n      return\n    }\n\n    // record open details (sessionId + default network) from the window url\n    const { search: rawParams } = new URL(windowHref || window.location.href)\n\n    let session: TransportSession | null = this.getWindowTransportSession(rawParams)\n\n    // provider should always include sid when opening a new window\n    const isNewWindowSession = !!session.sessionId\n\n    // attempt to restore previous session in the case of a redirect or window reload\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession()\n    }\n\n    if (!session) {\n      logger.error('window session is undefined')\n      return\n    }\n\n    // record parent window instance for communication\n    this.parentWindow = parent.window.opener\n\n    // listen for window-transport requests\n    window.addEventListener('message', this.onWindowEvent, false)\n    this._registered = true\n\n    // send open event to the app which opened us\n    this.open(session)\n      .then(opened => {\n        if (!opened) {\n          const err = `failed to open to network ${session?.networkId}`\n          logger.error(err)\n          this.notifyClose({ message: err } as ProviderRpcError)\n          window.close()\n        }\n      })\n      .catch(e => {\n        const err = `failed to open to network ${session?.networkId}, due to: ${e}`\n        logger.error(err)\n        this.notifyClose({ message: err } as ProviderRpcError)\n        window.close()\n      })\n  }\n\n  unregister() {\n    window.removeEventListener('message', this.onWindowEvent)\n    this._registered = false\n  }\n\n  // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the window post-messaging transport\n  private onWindowEvent = async (event: MessageEvent) => {\n    if (!event.origin || event.origin === '') {\n      // skip same-origin or when event.origin is empty/undefined\n      return\n    }\n    if (this.appOrigin && event.origin !== this.appOrigin) {\n      // skip message as not from expected app origin\n      return\n    }\n\n    // Wallet always expects json-rpc request messages from a dapp\n    let request: ProviderMessageRequest\n    try {\n      request = JSON.parse(event.data, bigintReviver)\n    } catch (err) {\n      // event is not a ProviderMessage JSON object, skip\n      return\n    }\n\n    logger.debug('RECEIVED MESSAGE', request)\n\n    // Record event origin for valid init ack\n    if (this._init !== InitState.OK && this.isValidInitAck(request)) {\n      this.appOrigin = event.origin\n    }\n    if (this._init === InitState.OK && (!this.appOrigin || this.appOrigin.length < 8)) {\n      // impossible state\n      logger.error('impossible state, init.OK and appOrigin required')\n      return\n    }\n\n    // Handle message via the base transport\n    this.handleMessage(request)\n  }\n\n  // postMessage sends message to the dapp window\n  sendMessage(message: ProviderMessage<any>) {\n    // prepare payload\n    const payload = JSON.stringify(message, bigintReplacer)\n\n    // post-message to app.\n    // only for init requests, we send to '*' origin\n    if (message.type === EventType.INIT) {\n      this.postMessage(payload, true)\n    } else {\n      this.postMessage(payload)\n    }\n  }\n\n  get isPopup(): boolean {\n    return this._isPopup\n  }\n\n  private postMessage(message: any, init = false) {\n    if (init !== true && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited')\n      return\n    }\n\n    if (init) {\n      // init message transmission to global target -- for 'init' payloads only\n      this.parentWindow.postMessage(message, '*')\n    } else {\n      // open message transmission\n      if (this.appOrigin && this.appOrigin.length > 4) {\n        // just above '.com'\n        this.parentWindow.postMessage(message, this.appOrigin)\n      } else {\n        logger.error('unable to postMessage as parentOrigin is invalid')\n      }\n    }\n  }\n\n  private getWindowTransportSession = (windowParams: string | undefined): TransportSession => {\n    const params = new WindowSessionParams(windowParams)\n    return {\n      sessionId: params.get('sid'),\n      networkId: params.get('net'),\n      intent: base64DecodeObject<OpenWalletIntent>(params.get('intent'))\n    }\n  }\n}\n","import {\n  ProviderMessageRequest,\n  ProviderMessage,\n  EventType,\n  InitState,\n  WindowSessionParams,\n  OpenWalletIntent,\n  ProviderRpcError,\n  TransportSession\n} from '../../types'\nimport { WalletRequestHandler } from '../wallet-request-handler'\nimport { BaseWalletTransport } from '../base-wallet-transport'\nimport { logger, base64DecodeObject, bigintReplacer } from '@0xsequence/utils'\nimport { overrideLogs } from './overridelogs'\n\n// all lowercase is an annoying limitation of Unreal CEF BindUObject\ninterface UnrealInjectedWalletWindow {\n  ue?: {\n    sequencewallettransport?: {\n      onmessagefromsequencejs?: (message: ProviderMessageRequest) => void\n      sendmessagetosequencejs: (message: string) => void\n    }\n  }\n}\ndeclare const window: Window & typeof globalThis & UnrealInjectedWalletWindow\n\n/**\n * Initialized on Wallet side\n */\nexport class UnrealMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler: WalletRequestHandler) {\n    super(walletRequestHandler)\n    this._init = InitState.NIL\n  }\n\n  async register(windowHref?: string | URL) {\n    if (window.ue?.sequencewallettransport === undefined) {\n      return\n    }\n    overrideLogs('wallet')\n\n    // record open details (sessionId + default network) from the window url\n    const { search: rawParams } = new URL(windowHref || window.location.href)\n\n    let session: TransportSession | null = this.getUnrealTransportSession(rawParams)\n\n    // provider should always include sid when opening a new window\n    const isNewWindowSession = !!session.sessionId\n\n    // attempt to restore previous session in the case of a redirect or window reload\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession()\n    }\n\n    if (!session) {\n      logger.error('unreal session is undefined')\n      return\n    }\n\n    // listen for window-transport requests\n    window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal\n    this._registered = true\n\n    // send open event to the app which opened us\n    this.open(session)\n      .then(opened => {\n        if (!opened) {\n          const err = `failed to open to network ${session?.networkId}`\n          logger.error(err)\n          this.notifyClose({ message: err } as ProviderRpcError)\n          window.close()\n        }\n      })\n      .catch(e => {\n        const err = `failed to open to network ${session?.networkId}, due to: ${e}`\n        logger.error(err)\n        this.notifyClose({ message: err } as ProviderRpcError)\n        window.close()\n      })\n  }\n\n  unregister() {\n    if (window.ue?.sequencewallettransport?.onmessagefromsequencejs === this.onMessageFromUnreal) {\n      delete window.ue.sequencewallettransport.onmessagefromsequencejs\n    }\n    this._registered = false\n  }\n\n  // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the unreal json-messaging transport\n  private onMessageFromUnreal = (request: ProviderMessageRequest) => {\n    // Wallet always expects json-rpc request messages from a dapp\n\n    logger.debug('RECEIVED MESSAGE', request)\n\n    // Handle message via the base transport\n    this.handleMessage(request)\n  }\n\n  // sendMessage sends message to the dapp window\n  sendMessage(message: ProviderMessage<any>) {\n    if (message.type !== EventType.INIT && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited')\n      return\n    }\n    // prepare payload\n    const payload = JSON.stringify(message, bigintReplacer)\n\n    // post-message to app.\n    window.ue?.sequencewallettransport?.sendmessagetosequencejs(payload)\n  }\n\n  private getUnrealTransportSession = (windowParams: string | undefined): TransportSession => {\n    const params = new WindowSessionParams(windowParams)\n    return {\n      sessionId: params.get('sid'),\n      networkId: params.get('net'),\n      intent: base64DecodeObject<OpenWalletIntent>(params.get('intent'))\n    }\n  }\n}\n","import { commons } from '@0xsequence/core'\n\nexport const transactions = commons.transaction\n\nexport type Transaction = commons.transaction.Transaction\nexport type TransactionEncoded = commons.transaction.TransactionEncoded\nexport type TransactionResponse = commons.transaction.TransactionResponse\nexport type Transactionish = commons.transaction.Transactionish\nexport type SignedTransactionBundle = commons.transaction.SignedTransactionBundle\nexport type RelayReadyTransactionBundle = commons.transaction.RelayReadyTransactionBundle\n","export const extractProjectIdFromAccessKey = (accessKey: string): number => {\n  // Convert URL-safe base64 string to standard base64 string\n  const base64String = accessKey.replace(/-/g, '+').replace(/_/g, '/')\n  // Decode the base64 string to a binary string\n  const binaryString = atob(base64String)\n\n  // Convert the binary string to a byte array (Uint8Array)\n  const byteArray = new Uint8Array(binaryString.length)\n  for (let i = 0; i < binaryString.length; i++) {\n    byteArray[i] = binaryString.charCodeAt(i)\n  }\n\n  if (byteArray[0] !== 1) {\n    throw new Error('UnsupportedVersion')\n  }\n\n  // Extract the project ID from bytes 2 to 9 (8 bytes)\n  const projectIdBytes = byteArray.slice(1, 9)\n  const projectId =\n    projectIdBytes[7] |\n    (projectIdBytes[6] << 8) |\n    (projectIdBytes[5] << 16) |\n    (projectIdBytes[4] << 24) |\n    (projectIdBytes[3] << 32) |\n    (projectIdBytes[2] << 40) |\n    (projectIdBytes[1] << 48) |\n    (projectIdBytes[0] << 56)\n\n  return projectId\n}\n","export function promisify<T>(f: (cb: (err: any, res: T) => void) => void, thisContext?: any): () => Promise<T>\nexport function promisify<A, T>(f: (arg: A, cb: (err: any, res: T) => void) => void, thisContext?: any): (arg: A) => Promise<T>\nexport function promisify<A, A2, T>(\n  f: (arg: A, arg2: A2, cb: (err: any, res: T) => void) => void,\n  thisContext?: any\n): (arg: A, arg2: A2) => Promise<T>\nexport function promisify<A, A2, A3, T>(\n  f: (arg: A, arg2: A2, arg3: A3, cb: (err: any, res: T) => void) => void,\n  thisContext?: any\n): (arg: A, arg2: A2, arg3: A3) => Promise<T>\nexport function promisify<A, A2, A3, A4, T>(\n  f: (arg: A, arg2: A2, arg3: A3, arg4: A4, cb: (err: any, res: T) => void) => void,\n  thisContext?: any\n): (arg: A, arg2: A2, arg3: A3, arg4: A4) => Promise<T>\nexport function promisify<A, A2, A3, A4, A5, T>(\n  f: (arg: A, arg2: A2, arg3: A3, arg4: A4, arg5: A5, cb: (err: any, res: T) => void) => void,\n  thisContext?: any\n): (arg: A, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Promise<T>\n\nexport function promisify(f: any, thisContext?: any) {\n  return function (...a: any[]) {\n    const args = Array.prototype.slice.call(a)\n    return new Promise(async (resolve, reject) => {\n      try {\n        args.push((err: any, result: any) => (err ? reject(err) : resolve(result)))\n        await f.apply(thisContext, args)\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n}\n","export function queryStringFromObject(name: string, obj: any) {\n  const k = encodeURIComponent(name)\n  const v = encodeURIComponent(JSON.stringify(obj))\n  return `${k}=${v}`\n}\n\nexport function queryStringToObject(qs: string): { [key: string]: any } {\n  const p = qs.split('&')\n  const o: { [key: string]: any } = {}\n  for (const v of p) {\n    const z = v.split('=')\n    o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]))\n  }\n  return o\n}\n","export const sleep = (t: number) => {\n  return new Promise<void>(resolve => {\n    const timeout = setTimeout(() => {\n      clearTimeout(timeout)\n      resolve()\n    }, t)\n  })\n}\n","// urlClean removes double slashes from url path\nexport const urlClean = (url: string) => url.replace(/([^:]\\/)\\/+/g, '$1')\n"],"names":["inputs","internalType","type","name","outputs","stateMutability","constant","payable","isValidSignatureBytes32","walletContracts","erc6492","erc5719","erc1271","factory","mainModule","components","mainModuleUpgradable","sequenceUtils","anonymous","indexed","requireFreshSigner","SortOrder","SardinePaymentType","SardineQuoteType","TokenType","API","constructor","hostname","fetch","this","path","ping","headers","signal","url","createHTTPRequest","then","res","buildResponse","_data","status","error","WebrpcRequestFailedError","new","cause","message","version","runtimeStatus","clock","serverTime","getSequenceContext","data","getAuthToken","args","jwtToken","address","user","getAuthToken2","sendPasswordlessLink","friendList","page","friends","getFriendByAddress","friend","searchFriends","addFriend","updateFriendNickname","removeFriend","contractCall","returns","decodeContractCall","call","lookupContractCallSelectors","signatures","userStorageFetch","object","userStorageSave","ok","userStorageDelete","userStorageFetchAll","objects","getMoonpayLink","signedUrl","resolveENSAddress","isValidSignature","isValid","isValidMessageSignature","isValidTypedDataSignature","isValidETHAuthProof","sardineGetClientToken","token","sardineGetNFTCheckoutToken","resp","sardineGetNFTCheckoutOrderStatus","sardineGetSupportedRegions","regions","sardineGetSupportedFiatCurrencies","tokens","sardineGetSupportedTokens","sardineGetEnabledTokens","sardineGetQuote","quote","getSardineClientToken","getSardineNFTCheckoutToken","getSardineNFTCheckoutOrderStatus","getCoinPrices","tokenPrices","getCollectiblePrices","getExchangeRate","exchangeRate","memoryStore","memoryLoad","value","getInviteInfo","inviteInfo","isValidAccessCode","internalClaimAccessCode","blockNumberAtTime","blocks","paperSessionSecret","secret","paperSessionSecret2","linkWallet","getLinkedWallets","linkedWallets","removeLinkedWallet","generateWaaSVerificationURL","nonce","verificationURL","validateWaaSVerificationNonce","walletAddress","getSwapPrices","swapPrices","getSwapQuote","swapQuote","listCurrencyGroups","currencyGroups","addOffchainInventory","inventoryId","getOffchainInventory","inventory","listOffchainInventories","updateOffchainInventory","deleteOffchainInventory","requestOffchainPayment","payment","listOffchainPayments","payments","input","init","body","method","_extends","JSON","stringify","text","parse","Error","WebrpcBadResponseError","code","webrpcErrorByCode","WebrpcError","super","msg","Object","setPrototypeOf","prototype","payload","WebrpcEndpointError","WebrpcBadRouteError","WebrpcBadMethodError","WebrpcBadRequestError","WebrpcServerPanicError","WebrpcInternalErrorError","WebrpcClientDisconnectedError","WebrpcStreamLostError","WebrpcStreamFinishedError","UnauthorizedError","PermissionDeniedError","SessionExpiredError","AbortedError","GeoblockedError","InvalidArgumentError","UnavailableError","QueryFailedError","NotFoundError","errors","globalThis","SequenceAPIClient","ApiRpc","projectAccessKey","jwtAuth","endsWith","slice","_fetch","length","_hasBuffer","Buffer","_TD","TextDecoder","undefined","_TE","TextEncoder","b64chs","Array","b64tab","a","tab","forEach","c","i","b64re","_fromCC","String","fromCharCode","bind","_U8Afrom","Uint8Array","from","it","_mkUriSafe","src","replace","m0","_tidyB64","s","btoaPolyfill","bin","u32","c0","c1","c2","asc","pad","charCodeAt","TypeError","substring","_btoa","btoa","toString","_fromUint8Array","u8a","strs","l","push","apply","subarray","join","cb_utob","cc","re_utob","utob","u","_encode","encode","urlsafe","re_btou","cb_btou","cccc","offset","btou","b","atobPolyfill","test","u24","r1","r2","charAt","_atob","atob","_toUint8Array","split","map","_decode","decode","_unURI","gBase64","__assign","assign","t","n","arguments","p","hasOwnProperty","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","__generator","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","pop","ETHAuthPrefix","ETHAuthEIP712Domain","Proof","prefix","toLowerCase","claims","app","iat","exp","signature","extra","setIssuedAtNow","Math","round","Date","getTime","setExpiryIn","seconds","validateClaims","messageDigest","typedData","err","ethers","getBytes","messageTypedData","TypedDataEncoder","hash","domain","types","Claims","typ","ogn","now","max","ValidateEOAProof","provider","chainId","proof","_a","verifyMessage","ValidateContractAccountProof","walletCode","abi","getCode","Contract","IsValidSignatureBytes32MagicValue","ETHAuth","validators","_i","_this","configJsonRpcProvider","ethereumJsonRpcURL","netVersion","JsonRpcProvider","send","parseInt","configValidators","encodeProof","skipSignatureValidation","claimsJSON","proofString","validateProof","Base64","decodeProof","parts","messageBase64","isValidClaims","validateProofClaims","concat","validateProofSignature","retIsValid","validator","ChainId","NetworkType","networks","MAINNET","title","logoURI","blockExplorer","rootUrl","nativeToken","symbol","decimals","ensAddress","ROPSTEN","TESTNET","testnet","deprecated","RINKEBY","GOERLI","KOVAN","SEPOLIA","POLYGON","POLYGON_MUMBAI","POLYGON_AMOY","POLYGON_ZKEVM","BSC","BSC_TESTNET","OPTIMISM","OPTIMISM_KOVAN","OPTIMISM_GOERLI","OPTIMISM_SEPOLIA","ARBITRUM","ARBITRUM_GOERLI","ARBITRUM_SEPOLIA","ARBITRUM_NOVA","AVALANCHE","AVALANCHE_TESTNET","GNOSIS","BASE","BASE_GOERLI","BASE_SEPOLIA","HOMEVERSE","HOMEVERSE_TESTNET","XAI","XAI_SEPOLIA","XR_SEPOLIA","B3","B3_SEPOLIA","APECHAIN","APECHAIN_TESTNET","BLAST","BLAST_SEPOLIA","TELOS","BORNE_TESTNET","SKALE_NEBULA","SKALE_NEBULA_TESTNET","SONEIUM_MINATO","TOY_TESTNET","IMMUTABLE_ZKEVM","IMMUTABLE_ZKEVM_TESTNET","ROOT_NETWORK","ROOT_NETWORK_PORCINI","HARDHAT","HARDHAT_2","getChainId","Number","isValidNetworkConfig","networkConfig","raise","skipRelayerCheck","configs","isArray","chainIds","sort","dupes","filter","indexOf","names","nameDupes","defaultChain","rpcUrl","relayer","isDefaultChain","ensureValidNetworks","validateAndSortNetworks","sortNetworks","findNetworkConfig","startsWith","id","find","config","defaultConfigIdx","findIndex","splice","stringTemplate","sTemplate","mData","fullMath","grp","val","valueOf","MAX_UINT_256","BigInt","isBigNumberish","match","isHexString","toHexString","parseUnits","integer","fraction","negative","left","unit","right","rounded","padStart","padEnd","formatUnits","display","bigintReplacer","key","$bigint","bigintReviver","hex","base64EncodeObject","obj","base64DecodeObject","encodedObject","encodeMessageDigest","keccak256","packMessageData","digest","solidityPacked","subDigestOf","isNode","jwtDecodeClaims","jwt","logLevel","Logger","configure","DEBUG","INFO","WARN","ERROR","DISABLED","silence","debug","optionalParams","console","log","info","warn","onwarn","onerror","logger","Base","bufferIndexOf","array","element","isSorted","binarySearch","compare","linearSearch","eqChecker","buffer1","buffer2","compareFunction","start","end","mid","floor","ordering","len","min","bufferify","bufferToHex","withPrefix","prefixed","hexlify","bufferifyFn","MerkleTree","leaves","options","hashFn","layers","sortLeaves","sortPairs","processLeaves","getOptions","createHashes","nodes","layerIndex","layerLimit","combined","getRoot","getHexRoot","getProof","leaf","index","isInteger","layer","isRightNode","pairIndex","position","getHexProof","item","verify","targetNode","root","node","isLeftNode","buffers","getFetchRequest","req","FetchRequest","setHeader","deterministically","_key","fromEntries","entries","sanitizeNumberString","numString","trim","sanitizeAlphanumeric","alphanum","sanitizeHost","host","encodeTypedDataHash","encodeTypedDataDigest","defineProperties","resolveProperties","indexerURL","network","relayerURL","nodesURL","findSupportedNetwork","chainIdOrName","allNetworks","toChainIdNumber","chainIdLike","createNetworkConfig","indexerUrl","hardhatNetworks","isAuthChain","disabled","JsonRpcRouter","middlewares","sender","handler","setMiddleware","createJsonRpcMiddlewareStack","request","toMiddleware","requestHandler","chain","isJsonRpcProvider","cand","defaultUrl","detectNetwork","getSigner","perform","isJsonRpcSender","JsonRpcHandler","defaultChainId","params","allowProviderMiddleware","isAllowed","CachedProvider","cachableJsonRpcMethods","cachableJsonRpcMethodsByBlock","cache","cacheByBlock","cacheByBlockResetLock","onUpdateCallback","async","includes","cacheKey","getCacheValue","shouldCacheResponse","setCacheValue","setCacheByBlockValue","getCache","setCache","setTimeout","clearCache","blockCache","onUpdate","callback","EagerProvider","toQuantity","accountAddress","getAddress","walletContext","exceptionProviderMiddleware","loggingProviderMiddleware","chainIdLabel","SignerJsonRpcMethods","SingleflightMiddleware","singleflightJsonRpcMethods","inflight","requestKey","response","_chainId","_classPrivateFieldLooseKey","_nextId","_sender","jsonRpcApiProviderOptions","defineProperty","writable","jsonRpcRequest","_classPrivateFieldLooseBase","jsonrpc","fetchRequest","getResult","toUtf8String","router","getNetwork","Network","chainIdHex","subdigestOf","solidityPackedKeccak256","isSignedPayload","EIP1271_ABI","isValidEIP1271Signature","contract","SigType","canRecover","bytes","EIP712","ETH_SIGN","recoverSigner","digestBytes","splitSignature","r","recoverAddress","hashMessage","WALLET_BYTES32","tryRecoverSigner","_unused","SignaturePartType","isAddressMember","member","isUnrecoveredSignatureMember","weight","isDynamic","isUnrecoveredSignature","threshold","signers","decodeSignature","EOASignature","unrecovered","Address","DynamicSignature","size","encodeSignature","isBytesLike","encodedSigners","fill","recoverSignature","subdigest","base","all","encodeSigners","subdigests","has","get","encoded","SignatureCoder","supportsNoChainId","recover","hasEnoughSigningPower","chainSignatures","_main","_suffix","hashSetImageHash","_imageHash","signaturesOf","signaturesOfDecoded","ConfigCoder","isWalletConfig","imageHashOf","reduce","imageHash","signer","AbiCoder","defaultAbiCoder","hasSubdigest","_walletConfig","_subdigest","isComplete","_config","checkpointOf","signersOf","fromSimple","checkpoint","update","isKindUsed","buildTransaction","wallet","context","kind","module","Interface","transactions","to","encodeFunctionData","getFunction","gasLimit","delegateCall","revertOnError","entrypoint","decodeTransaction","tx","toJSON","plainMembers","fromJSON","json","parsed","editConfig","action","_action$threshold","newSigners","add","remove","buildStubSignature","overrides","Map","set","DeployedWalletContext","guestModule","walletCreationCode","SetImageHashPrefix","messageSetImageHash","decodeMessageSetImageHash","arr","SignatureType","isUnrecoveredNode","isUnrecoveredNestedLeaf","tree","isUnrecoveredSignatureLeaf","decodeSignatureTree","pointer","append","prevPointer","Signature","SignaturePartTypeLength","Node","nodeHash","Branch","Subdigest","Nested","InvalidSignatureLeafError","recoverTopology","partEncoder","branch","nested","dynamicSignature","arrSignature","encodeTree","NoChainIdDynamic","Dynamic","Legacy","topology","disableTrim","isLeftSigner","isSignerLeaf","isRightSigner","hashNode","isNestedLeaf","isNodeLeaf","isSubdigestLeaf","include","part","forceDynamicEncoding","deepestConfigOfSignature","isChainedSignature","suffix","sig","decoded","isUnrecoveredChainedSignature","every","isSignature","decodeSignatureBody","Chained","decodeChainedSignature","main","setImageHashStruct","signedPayload","mutatedPayload","recovered","unshift","nextMessage","encodeChain","encodedMap","flat","encodeSignatureBody","encodeSignatureTree","encodedRight","encodedLeft","utopology","trimSignature","trimmed","trimUnrecoveredTree","trimStaticDigest","ZeroHash","_unused2","isEncodedSignerLeaf","decodeSignerLeaf","Infinity","reversed","reverse","subdigestsOfDecoded","topologyToJSON","topologyFromJSON","isLeaf","encodeSignerLeaf","byte","isSimpleNestedMember","members","topologyToMembers","membersAsTopologies","builder","legacyTopologyBuilder","acc","merkleTopologyBuilder","j1","j2","optimized2SignersTopologyBuilder","toWalletConfig","simpleWalletConfig","stack","Set","_config$subdigests","_context","_kind","_tx$transactions$0$va","_tx$transactions$","_tx$transactions$0$ga","_tx$transactions$2","decodeFunctionData","newImageHash","_action$checkpoint","prev","hasUnknownNodes","coders","addressOf","codeHash","zeroPadValue","dataSlice","defaultContexts","context1","context2","contexts","allVersions","recovered1","recovered2","imageHash2","some","versions","keys","MetaTransactionsType","intendedTransactionID","bundle","intent","unpackMetaTransactionsData","packMetaTransactionsData","txs","sequenceTxAbiEncode","digestOfTransactions","subdigestOfTransactions","subdigestOfGuestModuleTransactions","toSequenceTransactions","toSequenceTransaction","ZeroAddress","isNullish","transaction","walletInterface","isSequenceTransaction","hasSequenceTransactions","_tx$to","target","fromTxAbiEncode","encodeNonce","space","bspace","bnonce","shl","decodeNonce","shr","fromTransactionish","isTransactionBundle","isSignedTransactionBundle","encodeBundleExecData","selfExecuteSelector","selfExecuteAbi","unwind","unwound","txData","d","innerTransactions","unwoundTransactions","toObject","EIP_6492_OFFCHAIN_DEPLOY_CODE","EIP_6492_SUFFIX","validateEIP6492Offchain","OnChainReader","isDeployedCache","isDeployed","implementation","getStorage","readNonce","isWalletSignRequestMetadata","ALL_CODERS","v1","v2","coderFor","genericCoderFor","VERSION","counterfactualVersion","firstImageHash","commons","MIGRATION_NONCE_SPACE","v1v2","configCoder","signatureCoder","newConfig","v2Config","updateBundle","fromVersion","toVersion","toConfig","decoded2","Migrator","tracker","migrations","migration","validateMigrations","lastMigration","last","values","getAllMigratePresignedTransaction","fromImageHash","fih","fversion","migs","mig","getMigration","signedMigrations","missing","lastImageHash","lastVersion","signNextMigration","nextConfig","unsignedMigration","signTransactionBundle","DefaultMigrations","DEFAULT_GAS_LIMIT","ProviderRelayerDefaults","waitPollRate","deltaBlocksLog","fromBlockLog","ProviderRelayer","opts","simulate","estimateGas","executed","succeeded","gasUsed","getNonce","blockTag","wait","metaTxnId","timeoutDuration","delay","maxFails","_this2","timedOut","retry","errorMessage","fails","waitReceipt","lastBlock","block","getBlockNumber","normalMetaTxnId","logs","getLogs","fromBlock","toBlock","topics","found","getTransactionReceipt","transactionHash","getTransaction","out","receipt","race","isAbstractSigner","connect","ETHTxnStatus","TransferType","FeeTokenType","Relayer","getChainID","chainID","sendMetaTxn","txnHash","getMetaTxnNonce","getMetaTxnReceipt","results","updateMetaTxnGasLimits","feeTokens","isFeeRequired","feeOptions","sponsored","getMetaTxnNetworkFeeOptions","getMetaTransactions","sentTransactions","pendingTransactions","getGasTank","gasTank","addGasTank","updateGasTank","getGasSponsor","gasSponsor","addressGasSponsors","gasSponsors","listGasSponsors","addGasSponsor","updateGasSponsor","removeGasSponsor","reportGasSponsorUsage","gasSponsorUsage","nextGasTankBalanceAdjustmentNonce","adjustGasTankBalance","adjustment","getGasTankBalanceAdjustment","listGasTankBalanceAdjustments","adjustments","MethodNotFoundError","FINAL_STATUSES","proto","DROPPED","SUCCEEDED","PARTIALLY_FAILED","FAILED","FAILED_STATUSES","RpcRelayer","service","isAbstractProvider","staticNetwork","isCancelled","metaTxID","txnReceipt","getFeeOptions","symbols","_tag","_quote","getFeeOptionsRaw","gasRefundOptions","encodedNonce","walletContractAddress","decodedSpace","decodedNonce","relay","signedTxs","waitForReceipt","typecheckedQuote","metaTxn","confirmations","_confirmations","_waitResponse$receipt","waitResponse","waitForTransaction","timeout","MetaTransactionResponseException","txReceipt","blockHash","blockNumber","raw","isRelayer","AbstractSigner","resolveArrayProperties","o","isSapientSigner","buildDeployTransaction","predecorateSignedTransactions","decorateTransactions","sign","notifyStatusChange","SignerWrapper","eoa","_metadata","signMessage","_s","_m","SignerState","isSignerStatusPending","state","INITIAL","SIGNING","Orchestrator","tag","randomTag","observers","count","setSigners","randomBytes","pullId","getSigners","subscribe","observer","notifyObservers","metadata","newBundle","output","candidates","ended","lastMetadata","onNewMetadata","newMetadata","onStatusUpdate","pending","addresses","accepted","allSettled","saddr","SIGNED","catch","promise","reason","statusToSignatureParts","suffixed","Wallet","_options$provider","orchestrator","_reader","reader","newWallet","setConfig","setOrchestrator","setAddress","decorated","deployTx","ignoreDeployed","includeChildren","childBundle","deploy","factoryInterface","buildUpdateConfigurationTransaction","isLaterUpdate","signDigest","childMetadata","subdigestBytes","signTypedData","signTransactions","fetchNonceOrSpace","spaceValue","randomNonce","serial","resultNonce","defaultedNonce","meta","sendSignedTransaction","signedBundle","sendTransaction","signed","fillGasLimits","simulations","signTransaction","encodeGasRefundTransaction","option","UNKNOWN","ERC20_TOKEN","contractAddress","AccountSigner","account","providerFor","_this$options$cantVal","_this$options","cantValidateBehavior","_this$options$cantVal2","_this$options2","defaultSelectFee","_txs","balanceOfAbi","getBalance","balanceOf","_this$options$stubSig","_this$options3","_this$options$selectF","_this$options4","_this$options5","prepare","prepareTransactions","stubSignatureOverrides","simulateForFeeOptions","selectMethod","selectFee","feeOption","finalTransactions","feeQuote","nonceSpace","resolveName","_provider","getTransactionCount","getGasPrice","getFeeData","populateCall","checkTransaction","populateTransaction","_checkProvider","operation","Chain0Reader","_wallet","_space","_digest","_signature","Account","migrator","defaults","_options$migrations","lastCoder","saveCounterfactualWallet","tcid","setJwt","contextFor","ctx","walletForStatus","coder","universal","walletFor","isNetworkZero","longestPath","isDeployedPromise","counterfactualImageHashPromise","imageHashOfCounterfactualWallet","counterFactualVersionPromise","onChainVersionPromise","onChainImageHashPromise","deployedImageHash","counterfactualImageHash","onChainConfigPromise","onChainImageHash","onChainConfig","configOfImageHash","onChainVersion","presignedMigrate","presigned","loadPresignedConfiguration","nextImageHash","original","onChain","deployed","fullyMigrated","presignedConfigurations","canOnchainValidate","mustBeFullyMigrated","bundles","predecorated","predecorateTransactions","updateConfig","_bundles$","bootstrapBundle","buildBootstrapTransactions","hasBootstrapTxs","decoratedBundle","decorateSignature","chainedSignature","publishWitnessFor","allOfAll","saveWitnesses","publishWitness","decorate","chainRef","buildEIP6492Signature","buildOnChainSignature","hexSubdigest","saveWalletConfig","changes","currentConfig","updateStruct","savePresignedConfiguration","reverseConfig","noCache","_bundle$transactions","deployTransaction","m","bootstrapTransactions","prestatus","doBootstrap","bootstrapTxs","pstatus","nonceOptions","signMigrations","nextCoder","saveMigration","signAllMigrations","failedChains","successfulSignedMigrations","isMigratedAllChains","_this3","migratedAllChains","sendSignedTransactions","gasRefundQuotes","wstatus","stubSignature","gasRefundQuote","flatDecorated","skipPreDecorate","childBundles","_this4","ts","_last","latestImageHash","latestConfig","getAllSigners","_this5","allSigners","fullChain","iconf","isLast","exists","flaggedForRemoval","ContractType","EventLogType","EventLogDataType","OrderStatus","TxnTransferType","TransactionStatus","TransactionType","ContractVerificationStatus","Indexer","getEtherBalance","balance","getNativeTokenBalance","getTokenBalancesSummary","balances","getTokenBalancesDetails","getTokenBalancesByContract","getTokenBalances","getTokenSupplies","contractType","tokenIDs","getTokenSuppliesMap","supplies","getBalanceUpdates","getTransactionHistory","syncBalance","fetchTransactionReceipt","getOrderbookOrders","orders","getTopOrders","fetchTransactionReceiptWithFilter","getAllWebhookListeners","listeners","getWebhookListener","listener","addWebhookListener","updateWebhookListener","removeWebhookListener","toggleWebhookListener","webhookListener","pauseAllWebhookListeners","resumeAllWebhookListeners","subscribeReceipts","sseResponse","onError","subscribeEvents","subscribeBalanceUpdates","retryFetch","onMessage","onOpen","onClose","getReader","decoder","buffer","lastReadTime","timeoutError","intervalId","setInterval","clearInterval","releaseLock","read","stream","DOMException","lines","webrpcError","RequestConflictError","TimeoutError","ResourceExhaustedError","ProjectNotFoundError","MetadataCallFailedError","SequenceIndexer","IndexerRpc","PropertyType","SwapType","TaskStatus","Metadata","getTokenMetadata","tokenMetadata","refreshTokenMetadata","taskId","enqueueTokensForRefresh","getTokenRefreshStatus","getTokenRefreshResult","failureReasons","cancelRefreshJob","getTokenMetadataBatch","contractTokenMetadata","searchTokenMetadata","searchTokenIDs","tokenIds","tokenCollectionFilters","filters","getContractInfo","contractInfo","getContractInfoBatch","contractInfoMap","searchContractInfo","contractInfoList","searchContractInfoBatch","contractInfoByChain","searchMetadata","searchTokens","nextPage","searchContracts","getNiftyswapTokenQuantity","quantity","getNiftyswapUnitPrices","prices","getNiftyswapUnitPricesWithQuantities","addContractToMintMonitor","removeContractFromMintMonitor","mintMonitorJobStatus","task","mintMonitorTriggerJob","syncContractTokens","taskID","abortContractSync","contractSyncJobStatus","refreshTask","syncTask","directoryGetNetworks","directoryGetCollections","collections","directorySearchCollections","Collections","createCollection","collection","getCollection","listCollections","updateCollection","deleteCollection","publishCollection","unpublishCollection","createContractCollection","contractCollection","getContractCollection","listContractCollections","contractCollections","updateContractCollection","deleteContractCollection","createToken","assets","getToken","listTokens","updateToken","deleteToken","createAsset","asset","getAsset","updateAsset","deleteAsset","FailError","RequiredArgumentError","ValidationFailedError","RateLimitedError","ChainNotFoundError","TokenDirectoryDisabledError","SequenceMetadata","MetadataRpc","DEFAULT_SESSION_EXPIRATION","Services","settings","_initialAuthRequest","proofStrings","onAuthCallbacks","apiClient","metadataClient","indexerClients","expiration","_this$settings$metada","onAuth","cb","dump","auth","maxTries","sequenceApiUrl","getJWT","tryAuth","proofStringKey","getProofStringKey","getProofString","api","authResp","ewtString","isProofStringValid","delete","ethAuth","sequenceApiChainId","_unused3","getAPIClient","getMetadataClient","sequenceMetadataUrl","getIndexerClient","indexer","window","location","origin","signAuthorization","ErrAccountIsRequired","AuthError","expiry","chainIdNumber","CachedEIP5719","solver","runByEIP5719","timestamp","tries","recoveredAddr","_unused4","altUri","tryAwait","eip5719Contract","getAlternativeSignature","altSignature","URISolverIPFS","gateway","uri","isIPFS","clean","useGateway","MAIN_MODULE_ABI","namespace","owners","arweaveUrl","graphqlUrl","eip5719Provider","rateLimitRetryDelayMs","findItems","_options$namespace","_options$graphqlUrl","_options$rateLimitRet","_options$pageSize","pageSize","maxResults","tags","flatMap","edges","hasNextPage","query","cursor","owner","redirect","toLocaleTimeString","pageInfo","fetchItem","toTopology","eip5719","fromConfig","fromCheckpoint","items","Type","Signer","Digest","toImageHash","signatureType","toCheckpoint","isAddress","imageHashSignatures","updates","currentImageHash","nextCandidate","nextCandidateItems","nextCandidateSigners","candidate","nextCandidateSignatures","_args","Config","Version","actual","walletsOfSigner","proofs","Witness","allSignatures","Migration","Executor","executor","_address","_signed","_contexts","line","MemoryTrackerStore","v2Nodes","counterfactualWallets","payloads","loadConfig","saveConfig","loadV2Node","saveV2Node","loadCounterfactualWallet","loadPayloadOfSubdigest","savePayloadOfSubdigest","loadSubdigestsOfSigner","loadSignatureOfSubdigest","_this$signatures$sign","saveSignatureOfSubdigest","loadMigrationsSubdigest","_this$migrations$wall","saveMigrationsSubdigest","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","wrapFunction","func","IDBDatabase","IDBCursor","advance","continue","continuePrimaryKey","unwrap","storeNames","transformCachableValue","unlisten","removeEventListener","complete","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","success","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","storeName","store","shift","recreateBigNumbers","_isBigNumber","_hex","oldTraps","isPlainNode","isPlainNested","isPlainV2Config","dbName","_lazyDb","getDb","db","put","getAllKeysFromIndex","IDBKeyRange","only","getAllFromIndex","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","createObjectStore","createIndex","unique","LocalConfigTracker","useEIP5719","cachedEIP5719","loadTopology","saveTopology","saveLeft","saveRight","saveThis","saveTree","configOfImageHashCache","fullConfig","savePayload","payloadOfSubdigestCache","payloadOfSubdigest","saveNextConfig","subdigestsOfSigner","nextImageHashes","bestCandidate","sortedNextConfigsAndCheckpoints","nextCheckpoint","entry","bestCheckpoint","replacedSignature","Boolean","nextStep","decodedAddress","saveToConfig","updateProvider","Sessions","wallets","deployHash","configUpdates","saveWallet","saveSignature","saveSignerSignatures","saveSignerSignatures2","RemoteConfigTracker","onlyRecoverable","sessions","allUpdates","is404NotFound","encodeConfig","filteredSignatures","numberString","decodeV2ConfigTree","decodeConfig","deployConfig","toBeHex","EthSign","EIP1271","chainIdString","chooseMigration","migrations_","toVersions","toHash","encodeTransaction","numberNumber","encodeV2ConfigTree","tree_","raceUntil","promises","fallback","evalRes","allSafe","PromiseCache","do","validMilliseconds","entry_","isDedupedTracker","DedupedTracker","verbose","invalidateCache","trackers","requests","result1","skipTracker","tmptracker","result2","w","witnesses","checkpoints","best","_checkpoints$reduce$r","_checkpoints$reduce","config2","migration1","migration2","isSessionDumpV1","isSessionDumpV2","CRITICAL_CHAINS","SessionSettingsDefault","Session","services","singleSigner","referenceSigner","addSigners","selectWallet","_args$settings$tracke","_args$settings","_findNetworkConfig$ch","_findNetworkConfig","_settings$services$se","_settings$services","_networks$","onAccountAddress","editConfigOnMigration","onMigration","referenceChainId","foundWallets","selectedWallet","servicesObj","isFullyMigrated","isFullyMigrated2","prevConfig","load","_dump$jwt$expiration","_dump$jwt","_dump$jwt2","oldAddress","jwtExpired","_dump$jwt$expiration2","_dump$jwt3","_dump$jwt4","_dump$jwt$expiration3","ValidateSequenceWalletProof","readerFor","Guard","getSignerConfig","signerConfig","signWith","patch","authMethods","methods","active","setPIN","resetPIN","createTOTP","commitTOTP","codes","resetTOTP","reset2FA","recoveryCodes","resetRecoveryCodes","AuthMethod","parseAuthMethod","PIN","TOTP","isSignedOwnershipProof","signerAddress","signOwnershipProof","getOwnershipProofTypedData","signAuthUpdateProof","_typedData$domain$cha","getAuthUpdateProofTypedData","AuthMethods","toUTCString","AuthUpdate","date","appendSuffix","guard","_metadata$parts","guardTotpCode","auxData","packMsgAndSig","_id","_status","getAuthMethods","Authorization","signedProof","setPin","pin","resetPin","createTotp","URL","commitTotp","resetTotp","reset2fa","recoveryCode","getRecoveryCodes","addContractsToTokenDirectory","removeContractsFromTokenDirectory","modifyFeatureIndex","getFeatureIndex","featured","listTokenDirectory","CollectionsRpc","isAllowedFunc","setIsAllowedFunc","fn","networkChainId","privateJsonRpcMethods","setRpcUrl","getRpcUrl","ensureUniqueNetworks","updateNetworkConfig","dest","checkNetworkConfig","PROHIBITED_FUNCTIONS","validateTransactionRequest","isCreateContractCall","selector","validateTransaction","nextTickSupported","process","nextTick","symbolsSupported","reflectSupported","Reflect","_setImmediate","setImmediate","ownKeys","getOwnPropertyNames","getOwnPropertySymbols","_events","_conf","conf","delimiter","maxListeners","_maxListeners","wildcard","newListener","_newListener","removeListener","_removeListener","verboseMemoryLeak","ignoreErrors","listenerTree","logPossibleMemoryLeak","eventName","errorMsg","emitWarning","emitter","trace","toArray","valuesCount","TargetObserver","on","off","_emitter","_target","_listeners","_listenersCount","addListener","_on","_off","_observers","resolveOptions","schema","reducers","allowUnknown","computedOptions","reducer","constructorReducer","makeTypeReducer","firstType","secondType","localEvent","eventObj","emit","_onNewListener","_event","_onRemoveListener","hasListeners","unsubscribe","events","clearRefs","findTargetIndex","functionReducer","objectFunctionReducer","makeCancelablePromise","isCancelable","callbacks","subscriptionClosed","timer","onCancel","cleanup","clearTimeout","overload","isFinite","cancel","_resolve","_reject","searchListenerTree","handlers","typeLength","ns","j","dl","xTree","xxTree","isolatedBranch","endReached","branches","currentType","nextType","growListenerTree","prepend","warned","collectTreeEvents","asArray","branchName","isArrayPath","recursivelyGarbageCollect","flag","Listener","setupListener","promisify","objectify","_listener","_origin","_async","EventEmitter","EventEmitter2","listenTo","listen","isSingleReducer","stopListeningTo","matched","setMaxListeners","getMaxListeners","once","_once","prependOnceListener","_many","many","ttl","prependMany","self","_all","containsSymbol","al","emitAsync","prependListener","onAny","_onAny","prependAny","temp","returnValue","leafs","iLeaf","offAny","fns","removeAllListeners","allListeners","eventNames","nsAsArray","listenerCount","listenersAny","waitFor","handleError","defaultMaxListeners","isNaN","enumerable","errorListener","eventListener","configurable","exports","isProviderTransport","transport","register","unregister","openWallet","closeWallet","isOpened","isConnected","WindowSessionParams","URLSearchParams","EventType","OpenState","InitState","ProviderError","ErrSignedInRequired","PROVIDER_OPEN_TIMEOUT","_messageIdx","nextMessageIdx","BaseProviderTransport","pendingMessageRequests","responseCallbacks","confirmationOnly","openPayload","connectPayload","accountsChangedPayload","networksPayload","walletContextPayload","_sessionId","_init","_registered","sendMessageRequest","idx","responseCallback","sendMessage","waitUntilOpened","openTimeout","opened","CLOSED","_this$openPayload","session","openInfo","waitUntilConnected","connectDetails","NIL","registered","networkId","OPENED","_this$openPayload2","MESSAGE","clientVersion","handleMessage","INIT","OK","sessionId","requestIdx","OPEN","ACCOUNTS_CHANGED","accounts","CHAIN_CHANGED","NETWORKS","WALLET_CONTEXT","CLOSE","close","CONNECT","DISCONNECT","_message$data","_message$data2","_message$data3","pendingMessageRequest","clear","EIP_191_PREFIX_EXCEPTIONS","predicate","stringified","DCL_REGEX","ZeroXV3EIP1271OrderWithHashAbi","eip191prefix","toUtf8Bytes","messageToBytes","prefixEIP191Message","messageBytes","messageIsExemptFromEIP191Prefix","isBrowserExtension","protocol","isUnityPlugin","navigator","userAgent","isWalletUpToDate","MemoryItemStore","getItem","setItem","removeItem","onItemChange","LocalStorage","isAvailable","localStorage","useBestStore","TRANSPORT_SESSION_LS_KEY","BaseWalletTransport","walletRequestHandler","_initNonce","_initCallback","appOrigin","isValidInitAck","saveTransportSession","setOpenIntent","connectOptions","authorizeOptions","setConnectOptions","getAccount","isSignedIn","notifyOpen","promptConnect","connected","notifyConnect","keepWalletOpened","notifyClose","walletSession","getCachedTransportSession","notifyDisconnect","notifyAccountsChanged","notifyNetworks","notifyChainChanged","notifyWalletContext","initTimeout","performance","SENT_NONCE","ProxyMessageChannelPort","conn","ProxyMessageProvider","port","OPENING","overrideLogs","side","_window$ue","ue","sequencewallettransport","logsOverriddenForUnreal","_window$ue2","logfromjs","warnfromjs","errorfromjs","things","registeredUnrealMessageProvider","UnrealMessageProvider","walletAppURL","walletURL","onmessagefromwallet","onUnrealCallback","href","windowSessionParams","pathname","search","_window$ue3","postedMessage","sendmessagetowallet","CHANNEL_ID","ExtensionMessageProvider","runtime","onConnect","BaseInjectedTransport","write","registeredWindowMessageProvider","WindowMessageProvider","walletWindow","onWindowEvent","popup","interval","closed","focus","windowSize","windowPos","abs","screen","width","height","screenX","innerWidth","screenY","innerHeight","windowFeatures","_this$walletWindow","postMessage","isMuxTransportTemplate","windowTransport","proxyTransport","extensionTransport","unrealTransport","enabled","MuxMessageProvider","messageProviders","template","_template$windowTrans","_template$proxyTransp","_template$extensionTr","_template$unrealTrans","muxMessageProvider","windowMessageProvider","proxyMessageProvider","appPort","extensionMessageProvider","unrealMessageProvider","getLegacyWalletState","published","permittedJsonRpcMethods","SequenceSigner","utils","client","singleNetworkSigners","_isSequenceSigner","SequenceProvider","is","useChainId","toChainId","SingleNetworkSequenceSigner","eip6492","getProvider","resolved","txHash","check","getWalletConfig","getOnchainWalletConfig","getNetworks","optionals","_operation","_blockTag","_transaction","_isSingleNetworkSequenceSigner","_useChainId","provided","WalletUtils","EIP1193EventTypes","AbstractProvider","singleNetworkProviders","_isSequenceProvider","eip1193EventListeners","details","_this$eip1193EventLis","onDisconnect","_this$eip1193EventLis2","onDefaultChainIdChanged","_this$eip1193EventLis3","onAccountsChanged","_this$eip1193EventLis4","disconnect","getSession","listAccounts","setDefaultChainId","getWalletContext","authorize","SingleNetworkSequenceProvider","_getSubprovider","_perform","_provider$getRpcReque","_objectWithoutPropertiesLoose","_excluded","prepared","getRpcRequest","normalizeChainId","_detectNetwork","addressOrName","getBlock","blockHashOrBlockTag","prefetchTxs","supportsENS","getResolver","lookupAddress","getAvatar","nameOrAddress","_isSingleNetworkSequenceProvider","lengths","instance","checkFinished","destroyed","finished","createView","DataView","byteOffset","byteLength","rotr","word","Uint32Array","hexes","bytesToHex","abytes","toBytes","str","utf8ToBytes","Hash","clone","_cloneInto","wrapConstructor","hashCons","hashC","tmp","outputLen","blockLen","create","Maj","HashMD","padOffset","isLE","pos","view","take","dataView","roundClean","digestInto","setBigUint64","_32n","_u32_max","wh","wl","h","setUint32","oview","outLen","destroy","SHA256_K","SHA256_IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","getUint32","W15","W2","s0","s1","T1","T2","sha256","Databeat","tick","rawEvents","_WebrpcError","_WebrpcRequestFailedError","_WebrpcBadResponseError","_WebrpcEndpointError","_WebrpcBadRouteError","_WebrpcBadMethodError","_WebrpcBadRequestError","_WebrpcServerPanicError","_WebrpcInternalErrorError","_WebrpcClientDisconnectedError","_WebrpcStreamLostError","_WebrpcStreamFinishedError","_UnauthorizedError","_PermissionDeniedError","_SessionExpiredError","_NotFoundError","_InvalidAppKeyError","_QueryFailedError","_InvalidProjectIdError","DatabeatRpcClient","globalFetch","_globalFetch","defaultDatabeatOptions","defaultEnabled","noop","privacy","userIdHash","userAgentSalt","userIdentTracking","strictMode","flushInterval","initProps","Databeat2","rpc","ident","userId","allowUserTracking","projectId","queue","flushTimeout","defaultProps","dedupeIdentKey","dedupeViewKey","isEnabled","genSessionId","getDefaultProps","identify","reset","skipInit","isAnon","setStorageVal","ut","isBrowser","allowTracking","getStorageVal","genUserId","track","source","getPagePath","props","flush","enable","disable","trackView","eventProps","eventSource","pageKey","dedupedQueue","getIdent","getUserId","getSessionId","getStorageTS","isAuthEnabled","uniqEvents","ev","nums","searchParams","document","referrer","storageKey","seed","random","extraSalt","sessionStorage","sid","sid2","genRandHex","hexString","exit","Analytics","SequenceClientSession","connectedSession","hasSession","_this$getSession","setSession","SESSION_LOCALSTORE_KEY","clearSession","DefaultChainIdTracker","startingChainId","SESSION_CHAIN_ID_KEY","getDefaultChainId","SequenceClient","_options$defaultEIP","_this$session$getSess","defaultEIP6492","analytics","_this$analytics","_this$session$getSess2","_this$callbacks$accou","accountsChanged","_this$callbacks$conne","_this$callbacks$disco","_this$callbacks$netwo","_this$callbacks$walle","_this$callbacks$open","_this$callbacks$close","_this$callbacks$chain","chainChanged","_this$callbacks$chain2","setupAnalytics","server","registerCallback","onNetworks","onWalletContext","onChainChanged","authorizeVersion","refresh","_connectDetails$sessi","_this$analytics2","_this$analytics3","mapSignMethod","unwrapJsonRpcResponse","pull","signMethod","signTypedDataMethod","_this$analytics4","_this$analytics5","getPayload","_this$analytics6","extendedTxs","first","rest","auxiliary","toExtended","DefaultProviderConfig","transports","defaultNetwork","sequenceWalletProvider","initWallet","partialConfig","_config$networks$filt","_config$networks","rpcProviders","newNetworks","an","combinedNetworks","_config$networks2","cn","itemStore","_combinedNetworks$fin","cacheTimeout","unregisterWallet","getWallet","port1","port2","restoreSession","cachedSession","parentWindow","_isPopup","getWindowTransportSession","windowParams","windowHref","isPopup","parent","opener","rawParams","_session","_session2","prompter","signerReadyCallbacks","_openIntent","_connectOptions","onConnectOptionsChange","promptConnectDetails","signerReady","_this$prompter$getDef","_this$prompter","signIn","setAccount","defaultNetworkId","_this$prompter2","promptSignInConnect","_this$prompter3","promptChangeNetwork","signOut","signerReset","_ref","_options$networkId","authOptions","authorizeNonce","_message$clientVersio","isJsonRpcResponse","jsonRpcResponse","_this$account","_request$chainId","jsonRpcProvider","walletBalance","prefixedMessage","sequenceVerified","_request$chainId2","promptSignMessage","signingAddress","typedDataObject","_request$chainId3","transactionParams","fromExtended","gas","_request$chainId4","_txnResponse$hash","txnResponse","promptSendTransaction","_request$chainId5","promptSignTransaction","txChainId","broadcastTransaction","transactionObject","feeData","gasPrice","switchParams","_this$account$address","_this$account2","openIntent","_this$onConnectOption","_this$prompter4","_session$networks","_connectDetails$sessi2","handleConfirmWalletDeployPrompt","skipsDeploy","promptConfirmWalletDeploy","onMessageFromUnreal","getUnrealTransportSession","onmessagefromsequencejs","sendmessagetosequencejs","ethereumSignedMessagePartSlicedArray","maxPrefixCharLength","prefixCharLenght","prefixAsNumber","txnOptions","_transactions","_entrypoint","_options","setTransactionOptions","transactionRequest","responsePromise","accessKey","base64String","binaryString","byteArray","projectIdBytes","encodedString","elements","toLeaf","generateTree","hashed","generateRoot","generateProof","verifyProof","tokenId","thisContext","encodeURIComponent","qs","z","decodeURIComponent","getRandomInt","MAX_SAFE_INTEGER","ceil"],"mappings":"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EACTF,gBAAiB,cAEnB,CACEH,KAAM,WACNC,KAAM,UACNG,UAAU,EACVN,OAAQ,CACN,CACEe,WAAY,CACV,CACEb,KAAM,OACNC,KAAM,gBAER,CACED,KAAM,OACNC,KAAM,iBAER,CACED,KAAM,UACNC,KAAM,YAER,CACED,KAAM,UACNC,KAAM,UAER,CACED,KAAM,UACNC,KAAM,SAER,CACED,KAAM,QACNC,KAAM,SAGVD,KAAM,WAER,CACEA,KAAM,WAER,CACEA,KAAM,UAGVE,QAAS,GACTG,SAAS,EACTF,gBAAiB,cAEnB,CACEH,KAAM,WACNC,KAAM,iBACNH,OAAQ,CACN,CACEE,KAAM,UAGVK,SAAS,EACTF,gBAAiB,WAEnB,CACEH,KAAM,WACNC,KAAM,oBACNG,UAAU,EACVN,OAAQ,CACN,CACEE,KAAM,UACNC,KAAM,aAER,CACED,KAAM,UACNC,KAAM,eAGVC,QAAS,GACTG,SAAS,EACTF,gBAAiB,iBH5InBW,uDIfiB,CACjB,CACEd,KAAM,WACNC,KAAM,kBACNG,UAAU,EACVN,OAAQ,CACN,CACEE,KAAM,YAGVE,QAAS,GACTG,SAAS,EACTF,gBAAiB,QAEnB,CACEH,KAAM,WACNC,KAAM,YACNG,UAAU,EACVN,OAAQ,GACRI,QAAS,CACP,CACEF,KAAM,YAGVK,SAAS,EACTF,gBAAiB,WJTnBY,gDKhBiB,CACjB,CACEjB,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,WACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,cACND,KAAM,YAGVG,gBAAiB,aACjBH,KAAM,eAER,CACEgB,WAAW,EACXlB,OAAQ,CACN,CACEmB,SAAS,EACTlB,aAAc,UACdE,KAAM,UACND,KAAM,WAER,CACEiB,SAAS,EACTlB,aAAc,UACdE,KAAM,aACND,KAAM,WAER,CACEiB,SAAS,EACTlB,aAAc,UACdE,KAAM,aACND,KAAM,WAER,CACEiB,SAAS,EACTlB,aAAc,QACdE,KAAM,WACND,KAAM,UAGVC,KAAM,iBACND,KAAM,SAER,CACEgB,WAAW,EACXlB,OAAQ,CACN,CACEmB,SAAS,EACTlB,aAAc,UACdE,KAAM,UACND,KAAM,WAER,CACEiB,SAAS,EACTlB,aAAc,UACdE,KAAM,UACND,KAAM,YAGVC,KAAM,iBACND,KAAM,SAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,QACND,KAAM,YAGVC,KAAM,gBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,kBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,KACND,KAAM,YAGVC,KAAM,gBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,cACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,KACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,QACND,KAAM,YAGVC,KAAM,WACNC,QAAS,CACP,CACEH,aAAc,QACdE,KAAM,OACND,KAAM,UAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,QACND,KAAM,YAGVC,KAAM,eACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,WACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,QACND,KAAM,YAGVC,KAAM,eACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,OACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,eACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,iBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,cACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,eACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,eACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,aACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,GACRG,KAAM,gBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,GACND,KAAM,YAGVC,KAAM,mBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,GACND,KAAM,YAGVC,KAAM,sBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,GACND,KAAM,YAGVC,KAAM,mBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,GACND,KAAM,YAGVC,KAAM,mBACNC,QAAS,CACP,CACEH,aAAc,UACdE,KAAM,GACND,KAAM,YAGVG,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEe,WAAY,CACV,CACEd,aAAc,OACdE,KAAM,eACND,KAAM,QAER,CACED,aAAc,OACdE,KAAM,gBACND,KAAM,QAER,CACED,aAAc,UACdE,KAAM,WACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,SACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,QACND,KAAM,WAER,CACED,aAAc,QACdE,KAAM,OACND,KAAM,UAGVD,aAAc,oCACdE,KAAM,OACND,KAAM,YAGVC,KAAM,YACNC,QAAS,CACP,CACEH,aAAc,SACdE,KAAM,aACND,KAAM,UAER,CACED,aAAc,UACdE,KAAM,WACND,KAAM,YAGVG,gBAAiB,UACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,UACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,aACND,KAAM,WAER,CACEa,WAAY,CACV,CACEd,aAAc,UACdE,KAAM,SACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,SACND,KAAM,YAGVD,aAAc,+BACdE,KAAM,WACND,KAAM,WAER,CACED,aAAc,OACdE,KAAM,SACND,KAAM,SAGVC,KAAM,gBACNC,QAAS,GACTC,gBAAiB,aACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,UACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,QACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,eACND,KAAM,WAER,CACED,aAAc,QACdE,KAAM,aACND,KAAM,SAER,CACED,aAAc,OACdE,KAAM,SACND,KAAM,SAGVC,KAAM,wBACNC,QAAS,GACTC,gBAAiB,aACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,UACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,SACND,KAAM,YAGVC,KAAM,kBACNC,QAAS,GACTC,gBAAiB,OACjBH,KAAM,YAER,CACEF,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,cACND,KAAM,YAGVC,KAAM,oBACNC,QAAS,GACTC,gBAAiB,OACjBH,KAAM,eLhfRkB,qDMjBiB,CACjB,CACEpB,OAAQ,CACN,CACEC,aAAc,UACdE,KAAM,GACND,KAAM,YAGVC,KAAM,qBACNC,QAAS,GACTC,gBAAiB,a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,OAAO69C,GAAUh6D,KAAK+5D,EACvB,CAAC,MAAAj9C,GACA,OAAO,CACT,CACF,GAZE,CAAEltB,KAAM,kBAAmBkqE,UAgBtB,SAAyB39C,GAC9B,MAAMpW,EAAM,IAAIpB,EAAAA,OAAOmc,UAAUm5C,IACjC,IAEE,OADAl0D,EAAIwjB,mBAAmB,gBAAiBpN,IACjC,CACR,CAAC,MAAOzX,GAEP,OAAO,CACT,CACF,IAtBMs1D,GACJ,2JAuBF,MAAMC,GAAiC,CACrC,CACExqE,OAAQ,CACN,CACEe,WAAY,CACV,CACEd,aAAc,UACdE,KAAM,eACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,eACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,sBACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,gBACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,mBACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,mBACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,WACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,WACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,wBACND,KAAM,WAER,CACED,aAAc,UACdE,KAAM,OACND,KAAM,WAER,CACED,aAAc,QACdE,KAAM,iBACND,KAAM,SAER,CACED,aAAc,QACdE,KAAM,iBACND,KAAM,SAER,CACED,aAAc,QACdE,KAAM,oBACND,KAAM,SAER,CACED,aAAc,QACdE,KAAM,oBACND,KAAM,UAGVD,aAAc,4BACdE,KAAM,QACND,KAAM,SAER,CACED,aAAc,UACdE,KAAM,YACND,KAAM,YAGVC,KAAM,gBACNC,QAAS,GACTC,gBAAiB,OACjBH,KAAM,aChIJuqE,GAAev1D,EAAMA,OAACw1D,YAAY,+BAE3BC,GAAkB9nE,GACzBqS,EAAMA,OAACoZ,YAAYzrB,GACdqS,EAAMA,OAACC,SAAStS,GAGlBqS,EAAMA,OAACw1D,YAAY7nE,GAGf+nE,GAAuB/nE,IAClC,MAAMgoE,EAAeF,GAAe9nE,GACpC,ODhBK,SAAyCA,GAC9C,OAAOunE,GAA0BpvC,MAAKzo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"}