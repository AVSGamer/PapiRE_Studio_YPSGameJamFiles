{"version":3,"sources":["/Users/peter/Dev/horizon/databeat/trackers/webtracker/dist/databeat-tracker.js","../src/rpc/proto/databeat.gen.ts","../src/rpc/proto/index.ts","../src/index.ts"],"names":["Ident","sid"],"mappings":"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","file":"/Users/peter/Dev/horizon/databeat/trackers/webtracker/dist/databeat-tracker.js","sourcesContent":[null,"/* eslint-disable */\n// databeat v0.1.0 f99550b11883527a9ba7db8f8371c616a50f0dd3\n// --\n// Code generated by webrpc-gen@v0.18.6 with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=databeat.ridl -target=typescript -client -out=./clients/databeat.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = \"v1\"\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = \"v0.1.0\"\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = \"f99550b11883527a9ba7db8f8371c616a50f0dd3\"\n\n//\n// Types\n//\n\n\nexport enum EventType {\n  INIT = 'INIT',\n  VIEW = 'VIEW',\n  REQUEST = 'REQUEST'\n}\n\nexport enum Ident {\n  ANONYMOUS = 'ANONYMOUS',\n  PRIVATE = 'PRIVATE',\n  USER = 'USER',\n  SERVICE = 'SERVICE'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  sinkStats: SinkStats\n  pipelineStats: {[key: string]: any}\n  gcpPubSub: boolean\n}\n\nexport interface SinkStats {\n  numEvents: number\n  numFails: number\n}\n\nexport interface App {\n  uid: string\n  name: string\n  domains: Array<string>\n  disabled: boolean\n}\n\nexport interface Event {\n  event: string\n  projectId?: number\n  source?: string\n  ident?: number\n  userId?: string\n  sessionId?: string\n  device?: Device\n  countryCode?: string\n  props?: {[key: string]: string}\n  nums?: {[key: string]: number}\n}\n\nexport interface Device {\n  type: string\n  os: string\n  osVersion: string\n  browser: string\n  browserVersion: string\n}\n\nexport interface RawEvent {\n  app?: string\n  ts?: string\n  event: string\n  projectId?: number\n  source: string\n  ident?: number\n  userId?: string\n  sessionId?: string\n  countryCode?: string\n  deviceType?: string\n  deviceOs?: string\n  deviceOsVersion?: string\n  deviceBrowser?: string\n  deviceBrowserVersion?: string\n  props?: {[key: string]: string}\n  nums?: {[key: string]: number}\n}\n\nexport interface Databeat {\n  ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>\n  version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>\n  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>\n  tick(args: TickArgs, headers?: object, signal?: AbortSignal): Promise<TickReturn>\n  rawEvents(args: RawEventsArgs, headers?: object, signal?: AbortSignal): Promise<RawEventsReturn>\n}\n\nexport interface PingArgs {\n}\n\nexport interface PingReturn {\n  status: boolean  \n}\nexport interface VersionArgs {\n}\n\nexport interface VersionReturn {\n  version: Version  \n}\nexport interface RuntimeStatusArgs {\n}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus  \n}\nexport interface TickArgs {\n  events: Array<Event>\n}\n\nexport interface TickReturn {\n  ok: boolean  \n}\nexport interface RawEventsArgs {\n  events: Array<RawEvent>\n}\n\nexport interface RawEventsReturn {\n  ok: boolean  \n}\n\nexport interface DatabeatAdmin {\n  listApps(headers?: object, signal?: AbortSignal): Promise<ListAppsReturn>\n  createApp(args: CreateAppArgs, headers?: object, signal?: AbortSignal): Promise<CreateAppReturn>\n  getApp(args: GetAppArgs, headers?: object, signal?: AbortSignal): Promise<GetAppReturn>\n  updateApp(args: UpdateAppArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAppReturn>\n  disableApp(args: DisableAppArgs, headers?: object, signal?: AbortSignal): Promise<DisableAppReturn>\n}\n\nexport interface ListAppsArgs {\n}\n\nexport interface ListAppsReturn {\n  apps: Array<App>  \n}\nexport interface CreateAppArgs {\n  uid: string\n  name: string\n  domains: Array<string>\n}\n\nexport interface CreateAppReturn {\n  app: App  \n}\nexport interface GetAppArgs {\n  appUid: string\n}\n\nexport interface GetAppReturn {\n  app: App  \n}\nexport interface UpdateAppArgs {\n  app: App\n}\n\nexport interface UpdateAppReturn {\n  updated: boolean  \n}\nexport interface DisableAppArgs {\n  appUid: string\n  disabled: boolean\n}\n\nexport interface DisableAppReturn {\n  disabled: boolean  \n}\n\n\n  \n//\n// Client\n//\nexport class Databeat implements Databeat {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Databeat/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  ping = (headers?: object, signal?: AbortSignal): Promise<PingReturn> => {\n    return this.fetch(\n      this.url('Ping'),\n      createHTTPRequest({}, headers, signal)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  version = (headers?: object, signal?: AbortSignal): Promise<VersionReturn> => {\n    return this.fetch(\n      this.url('Version'),\n      createHTTPRequest({}, headers, signal)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          version: <Version>(_data.version),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  runtimeStatus = (headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn> => {\n    return this.fetch(\n      this.url('RuntimeStatus'),\n      createHTTPRequest({}, headers, signal)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <RuntimeStatus>(_data.status),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  tick = (args: TickArgs, headers?: object, signal?: AbortSignal): Promise<TickReturn> => {\n    return this.fetch(\n      this.url('Tick'),\n      createHTTPRequest(args, headers, signal)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  rawEvents = (args: RawEventsArgs, headers?: object, signal?: AbortSignal): Promise<RawEventsReturn> => {\n    return this.fetch(\n      this.url('RawEvents'),\n      createHTTPRequest(args, headers, signal)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n}\nexport class DatabeatAdmin implements DatabeatAdmin {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/DatabeatAdmin/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  listApps = (headers?: object, signal?: AbortSignal): Promise<ListAppsReturn> => {\n    return this.fetch(\n      this.url('ListApps'),\n      createHTTPRequest({}, headers, signal)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          apps: <Array<App>>(_data.apps),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  createApp = (args: CreateAppArgs, headers?: object, signal?: AbortSignal): Promise<CreateAppReturn> => {\n    return this.fetch(\n      this.url('CreateApp'),\n      createHTTPRequest(args, headers, signal)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          app: <App>(_data.app),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  getApp = (args: GetAppArgs, headers?: object, signal?: AbortSignal): Promise<GetAppReturn> => {\n    return this.fetch(\n      this.url('GetApp'),\n      createHTTPRequest(args, headers, signal)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          app: <App>(_data.app),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  updateApp = (args: UpdateAppArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAppReturn> => {\n    return this.fetch(\n      this.url('UpdateApp'),\n      createHTTPRequest(args, headers, signal)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          updated: <boolean>(_data.updated),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n  disableApp = (args: DisableAppArgs, headers?: object, signal?: AbortSignal): Promise<DisableAppReturn> => {\n    return this.fetch(\n      this.url('DisableApp'),\n      createHTTPRequest(args, headers, signal)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          disabled: <boolean>(_data.disabled),\n        }\n      })\n    }, (error) => {\n      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ''}` })\n    })\n  }\n  \n}\n\n  const createHTTPRequest = (body: object = {}, headers: object = {}, signal: AbortSignal | null = null): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {}),\n    signal\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch(error) {\n      let message = ''\n      if (error instanceof Error)  {\n        message = error.message\n      }\n      throw WebrpcBadResponseError.new({\n        status: res.status,\n        cause: `JSON.parse(): ${message}: response text: ${text}`},\n      )\n    }\n    if (!res.ok) {\n      const code: number = (typeof data.code === 'number') ? data.code : 0\n      throw (webrpcErrorByCode[code] || WebrpcError).new(data)\n    }\n    return data\n  })\n}\n\n//\n// Errors\n//\n\nexport class WebrpcError extends Error {\n  name: string\n  code: number\n  message: string\n  status: number\n  cause?: string\n\n  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */\n  msg: string\n\n  constructor(name: string, code: number, message: string, status: number, cause?: string) {\n    super(message)\n    this.name = name || 'WebrpcError'\n    this.code = typeof code === 'number' ? code : 0\n    this.message = message || `endpoint error ${this.code}`\n    this.msg = this.message\n    this.status = typeof status === 'number' ? status : 0\n    this.cause = cause\n    Object.setPrototypeOf(this, WebrpcError.prototype)\n  }\n\n  static new(payload: any): WebrpcError {\n    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause)\n  }\n}\n\n// Webrpc errors\n\nexport class WebrpcEndpointError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcEndpoint',\n    code: number = 0,\n    message: string = 'endpoint error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)\n  }\n}\n\nexport class WebrpcRequestFailedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcRequestFailed',\n    code: number = -1,\n    message: string = 'request failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)\n  }\n}\n\nexport class WebrpcBadRouteError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRoute',\n    code: number = -2,\n    message: string = 'bad route',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)\n  }\n}\n\nexport class WebrpcBadMethodError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadMethod',\n    code: number = -3,\n    message: string = 'bad method',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)\n  }\n}\n\nexport class WebrpcBadRequestError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadRequest',\n    code: number = -4,\n    message: string = 'bad request',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)\n  }\n}\n\nexport class WebrpcBadResponseError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcBadResponse',\n    code: number = -5,\n    message: string = 'bad response',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)\n  }\n}\n\nexport class WebrpcServerPanicError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcServerPanic',\n    code: number = -6,\n    message: string = 'server panic',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)\n  }\n}\n\nexport class WebrpcInternalErrorError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcInternalError',\n    code: number = -7,\n    message: string = 'internal error',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)\n  }\n}\n\nexport class WebrpcClientDisconnectedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcClientDisconnected',\n    code: number = -8,\n    message: string = 'client disconnected',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype)\n  }\n}\n\nexport class WebrpcStreamLostError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamLost',\n    code: number = -9,\n    message: string = 'stream lost',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)\n  }\n}\n\nexport class WebrpcStreamFinishedError extends WebrpcError {\n  constructor(\n    name: string = 'WebrpcStreamFinished',\n    code: number = -10,\n    message: string = 'stream finished',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)\n  }\n}\n\n\n// Schema errors\n\nexport class UnauthorizedError extends WebrpcError {\n  constructor(\n    name: string = 'Unauthorized',\n    code: number = 1000,\n    message: string = 'Unauthorized access',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, UnauthorizedError.prototype)\n  }\n}\n\nexport class PermissionDeniedError extends WebrpcError {\n  constructor(\n    name: string = 'PermissionDenied',\n    code: number = 2000,\n    message: string = 'Permission denied',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, PermissionDeniedError.prototype)\n  }\n}\n\nexport class SessionExpiredError extends WebrpcError {\n  constructor(\n    name: string = 'SessionExpired',\n    code: number = 2001,\n    message: string = 'Session expired',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, SessionExpiredError.prototype)\n  }\n}\n\nexport class NotFoundError extends WebrpcError {\n  constructor(\n    name: string = 'NotFound',\n    code: number = 3000,\n    message: string = 'Resource not found',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, NotFoundError.prototype)\n  }\n}\n\nexport class InvalidAppKeyError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidAppKey',\n    code: number = 4000,\n    message: string = 'Invalid app key',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidAppKeyError.prototype)\n  }\n}\n\nexport class QueryFailedError extends WebrpcError {\n  constructor(\n    name: string = 'QueryFailed',\n    code: number = 4001,\n    message: string = 'DB query failed',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, QueryFailedError.prototype)\n  }\n}\n\nexport class InvalidProjectIdError extends WebrpcError {\n  constructor(\n    name: string = 'InvalidProjectId',\n    code: number = 4002,\n    message: string = 'Invalid project id',\n    status: number = 0,\n    cause?: string\n  ) {\n    super(name, code, message, status, cause)\n    Object.setPrototypeOf(this, InvalidProjectIdError.prototype)\n  }\n}\n\n\nexport enum errors {\n  WebrpcEndpoint = 'WebrpcEndpoint',\n  WebrpcRequestFailed = 'WebrpcRequestFailed',\n  WebrpcBadRoute = 'WebrpcBadRoute',\n  WebrpcBadMethod = 'WebrpcBadMethod',\n  WebrpcBadRequest = 'WebrpcBadRequest',\n  WebrpcBadResponse = 'WebrpcBadResponse',\n  WebrpcServerPanic = 'WebrpcServerPanic',\n  WebrpcInternalError = 'WebrpcInternalError',\n  WebrpcClientDisconnected = 'WebrpcClientDisconnected',\n  WebrpcStreamLost = 'WebrpcStreamLost',\n  WebrpcStreamFinished = 'WebrpcStreamFinished',\n  Unauthorized = 'Unauthorized',\n  PermissionDenied = 'PermissionDenied',\n  SessionExpired = 'SessionExpired',\n  NotFound = 'NotFound',\n  InvalidAppKey = 'InvalidAppKey',\n  QueryFailed = 'QueryFailed',\n  InvalidProjectId = 'InvalidProjectId',\n}\n\nconst webrpcErrorByCode: { [code: number]: any } = {\n  [0]: WebrpcEndpointError,\n  [-1]: WebrpcRequestFailedError,\n  [-2]: WebrpcBadRouteError,\n  [-3]: WebrpcBadMethodError,\n  [-4]: WebrpcBadRequestError,\n  [-5]: WebrpcBadResponseError,\n  [-6]: WebrpcServerPanicError,\n  [-7]: WebrpcInternalErrorError,\n  [-8]: WebrpcClientDisconnectedError,\n  [-9]: WebrpcStreamLostError,\n  [-10]: WebrpcStreamFinishedError,\n  [1000]: UnauthorizedError,\n  [2000]: PermissionDeniedError,\n  [2001]: SessionExpiredError,\n  [3000]: NotFoundError,\n  [4000]: InvalidAppKeyError,\n  [4001]: QueryFailedError,\n  [4002]: InvalidProjectIdError,\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n\n","import { Databeat as DatabeatRpc } from './databeat.gen'\nexport type { EventType, Event, Device, RawEvent } from './databeat.gen'\n\nexport interface Auth {\n  jwt?: string\n  headers?: { [key: string]: string }\n}\n\nexport class DatabeatRpcClient extends DatabeatRpc {\n  private _globalFetch: any\n\n  constructor(hostname: string, public auth?: Auth) {\n    const globalFetch = globalThis.fetch.bind(globalThis)\n\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, globalFetch)\n\n    this._globalFetch = globalFetch\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt auth header to requests\n    // if its been set on the api client\n    if (this.auth) {\n      let headers: { [key: string]: any } = {}\n      if (this.auth.jwt?.length > 0) {\n        headers['Authorization'] = `BEARER ${this.auth.jwt}`\n      }\n\n      // set other custom auth headers\n      if (this.auth.headers) {\n        headers = { ...headers, ...this.auth.headers }\n      }\n\n      // before the request is made\n      init!.headers = { ...init!.headers, ...headers }\n    }\n\n    return this._globalFetch(input, init)\n  }\n}\n","import { DatabeatRpcClient, Auth, Event as DatabeatEvent, EventType } from './rpc/proto'\n\nexport type { Auth }\n\nimport { sha256 } from '@noble/hashes/sha256'\nimport { bytesToHex } from '@noble/hashes/utils'\n\nexport interface Event<K extends string = any> extends DatabeatEvent {\n  event: keyof typeof EventType | K\n}\n\n// Databeat tracker options. See defaults below.\n//\n// Common setups:\n//   a.) privacy preserving with user-tracking disabled. All user events\n//       will be sent as hashed user-ids on the client-side.\n//      - options: <defaultDatabeatOptions>, see below\n//\n//   b.) dual mode, privacy preserving + user-tracking, where privacy\n//       preserving mode is used but tracks user-ids if user has permitted\n//       it via `allowTracking(true)`.\n//       - options: { ..., userIdentTracking: true }\n//\n//   c.) classic / traditional tracking mode, user must permit or\n//       no events are sent.\n//       - options: { ..., strictMode: true }\n//\nexport interface DatabeatOptions {\n  // defaultEnabled will enable tracking by default. This field\n  // does not inform privacy preserving mode or not, see below.\n  //\n  // Default: true\n  defaultEnabled?: boolean\n\n  // project id related to the databeat events. This can be set\n  // at the options level and always used, of passed directly to an event.\n  projectId?: number\n\n  // privacy options of the user_id field to offer privacy-preserving\n  // tracking features. NOTE: there is an additional privacy-preserving\n  // parameter available on the databeat-server itself called `server_user_id_salt`\n  // which adds extra salt + hashes value before ingesting into the sink\n  // on the server side.\n  //\n  // Default: all privacy options are enabled.\n  privacy?: PrivacyOptions\n\n  // userIdentTracking will enable user tracking if the user has\n  // allowed it (see allowTracking() method). When disabled, the ident\n  // of a user will always remain private even if allowTracking(true)\n  // is called.\n  //\n  // Default: false\n  userIdentTracking?: boolean\n\n  // strictMode will require allowTracking(true) call before any events\n  // will be sent, including privacy preserving events.\n  //\n  // Default: false\n  strictMode?: boolean\n\n  // flushInterval is the time in milliseconds to wait before sending\n  // events to the sink server.\n  //\n  // Default: 500\n  flushInterval?: number\n\n  // noop will inform the tracker to skip sending events to the sink.\n  // this is similar to enable/disable, but its not persisted in storage.\n  // it also acts as an override and takes precedence over enable/disable.\n  noop?: boolean\n\n  // initProps is a function that returns a map of properties to be\n  // set on all events. This is useful for setting properties that\n  // are common to all events.\n  //\n  // Default: {}\n  initProps?: () => {}\n}\n\nexport interface PrivacyOptions {\n  userIdHash?: boolean\n  userAgentSalt?: boolean\n  extraSalt?: string\n}\n\nexport enum Ident {\n  ANON = 0,\n  PRIVATE = 1,\n  USER = 2,\n}\n\nconst MAX_QUEUE_SIZE = 150\n\nconst defaultDatabeatOptions: DatabeatOptions = {\n  defaultEnabled: true,\n  noop: false,\n  privacy: { userIdHash: true, userAgentSalt: false },\n  userIdentTracking: false,\n  strictMode: false,\n  flushInterval: 500,\n  initProps: () => {\n    return {}\n  },\n}\n\nexport class Databeat<K extends string> {\n  private rpc: DatabeatRpcClient\n  private auth: Auth\n  private options: DatabeatOptions\n  private enabled: boolean\n  private ident: Ident\n  private userId: string | null\n  private sessionId: string | null\n  private allowUserTracking: boolean\n  private projectId: number | null\n  private queue: Event<K>[]\n  private flushTimeout: NodeJS.Timeout | null\n  private defaultProps: {}\n  private dedupeIdentKey: string | null\n  private dedupeViewKey: string | null\n  private ts?: number\n\n  constructor(host: string, auth: Auth | string, options?: DatabeatOptions) {\n    if (typeof auth === 'string') {\n      this.auth = { jwt: auth }\n    } else {\n      this.auth = auth\n    }\n    this.rpc = new DatabeatRpcClient(host, this.auth)\n    this.options = defaultDatabeatOptions\n    if (options) {\n      this.options = {\n        defaultEnabled: options.defaultEnabled || defaultDatabeatOptions.defaultEnabled,\n        projectId: options.projectId || null,\n        privacy: options.privacy || defaultDatabeatOptions.privacy,\n        userIdentTracking: options.userIdentTracking || defaultDatabeatOptions.userIdentTracking,\n        strictMode: options.strictMode || defaultDatabeatOptions.strictMode,\n        flushInterval: options.flushInterval || defaultDatabeatOptions.flushInterval,\n        noop: options.noop || false,\n        initProps: options.initProps || defaultDatabeatOptions.initProps,\n      }\n    }\n    this.init()\n  }\n\n  // init is called on load by the constructor and also by reset().\n  private init() {\n    this.enabled = isEnabled(this.options.defaultEnabled, this.auth)\n    this.projectId = this.options.projectId || null\n    this.userId = null\n    this.sessionId = genSessionId()\n    this.queue = []\n    this.flushTimeout = null\n    this.defaultProps = { ...getDefaultProps(), ...this.options.initProps() }\n    this.identify()\n  }\n\n  // reset will reset the user_id and session_id details. Similar to a \"logout\" action.\n  reset(skipInit?: boolean) {\n    this.enabled = isEnabled(this.options.defaultEnabled, this.auth)\n    if (this.userId && !this.isAnon()) {\n      this.userId = null\n    }\n    this.ident = Ident.ANON\n    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })\n\n    if (skipInit === true) {\n      return\n    }\n    this.init()\n  }\n\n  // identify can be called to seed the userId, where the behaviour changes\n  // depending on privacy or strict modes. identify is also called on init,\n  // where we load the data from localStorage.\n  identify(userId?: string, options?: PrivacyOptions & { allowTracking?: boolean }) {\n    // skip method when used with node\n    if (!isBrowser()) return\n\n    // check if allow tracking option passed, which is a syntax sugar to calling\n    // allowTracking(..) method.\n    if (options && options.allowTracking !== undefined) {\n      this.allowTracking(options.allowTracking)\n    }\n\n    // attempt to find userId if one isn't provided\n    if (!userId) {\n      const val = getStorageVal()\n      if (val !== null && val.id !== null) {\n        this.userId = val.id\n        this.ident = val.it\n        this.allowUserTracking = val.ut\n\n        // migrate from earlier when `val.it` didn't exist\n        if (val.it === undefined) {\n          if (this.userId.startsWith('anon:')) {\n            this.ident = Ident.ANON\n          } else {\n            this.ident = Ident.PRIVATE\n          }\n          this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })\n        } else {\n          this.ident = val.it\n        }\n      }\n    }\n\n    // update userId or gen new one\n    if (userId || this.userId === null) {\n      const v = genUserId(userId, this.allowUserTracking, this.options)\n      this.userId = v.userId\n      this.ident = v.ident\n      this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })\n    }\n\n    // simple dedupe of consecutive calls to identify()\n    const dedupeIdentKey = `${this.userId}:${this.sessionId}`\n    if (this.dedupeIdentKey === dedupeIdentKey) return\n    this.dedupeIdentKey = dedupeIdentKey\n\n\n    // track init and flush it right away\n    this.track({ event: 'INIT', source: getPagePath(), props: this.defaultProps })\n\n    // flush queued events\n    // NOTE: we do not call this.trackView() at this point, as we expect the webapp to do so.\n    this.flush()\n  }\n\n  // allowTracking is used by strict mode to enable/disable tracking.\n  allowTracking(allowTracking: boolean) {\n    this.allowUserTracking = allowTracking\n    setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })\n\n    // in strict mode, we enable/disable tracking\n    if (this.options.strictMode) {\n      if (allowTracking) {\n        this.enable()\n      } else {\n        this.disable()\n      }\n    }\n  }\n\n  async track(events: Event<K> | Event<K>[], options?: { flush?: boolean }) {\n    if (isBrowser() && this.userId === null) {\n      throw new Error('databeat: init first')\n    }\n\n    if (Array.isArray(events)) {\n      for (let i = 0; i < events.length; i++) {\n        events[i].ident = this.ident\n        events[i].userId = this.userId\n        events[i].sessionId = this.sessionId\n        if (!events[i].projectId && this.projectId) {\n          events[i].projectId = this.projectId\n        }\n      }\n      this.queue.push(...events)\n    } else {\n      events.ident = this.ident\n      events.userId = this.userId\n      events.sessionId = this.sessionId\n      if (!events.projectId && this.projectId) {\n        events.projectId = this.projectId\n      }\n      this.queue.push(events)\n    }\n\n    // Limit the queue size\n    if (this.queue.length > MAX_QUEUE_SIZE) {\n      this.queue = this.queue.splice(this.queue.length - MAX_QUEUE_SIZE)\n    }\n\n    // flush\n    if (!this.enabled) return\n    if (options && options.flush) {\n      // flush events right away\n      await this.flush()\n    } else if (this.flushTimeout === null) {\n      // flush events in the future (which will auto-batch)\n      this.flushTimeout = setTimeout(() => {\n        this.flush()\n      }, this.options.flushInterval)\n    }\n  }\n\n  trackView(props: { [key: string]: string } = {}) {\n    const eventProps = { ...this.defaultProps, ...props }\n    const eventSource = getPagePath()\n\n    // simple dedupe -- skip if we're already on this page\n    // NOTE: even though we dedupe in the flush() method, we do it here in case of timing\n    // between flushes on the same page.\n    const pageKey = `${eventSource}:${JSON.stringify(eventProps)}:${this.userId}:${this.sessionId}`\n    if (this.dedupeViewKey === pageKey) return\n    this.dedupeViewKey = pageKey\n\n    // track the page view\n    this.track({ event: 'VIEW', source: eventSource, props: eventProps })\n  }\n\n  flush = async () => {\n    if (this.flushTimeout !== null) {\n      clearTimeout(this.flushTimeout)\n      this.flushTimeout = null\n    }\n\n    if (!this.enabled) return\n    if (this.options.noop) return\n    if (this.options.strictMode && !this.allowUserTracking) return\n    if (this.queue.length === 0) return\n\n    // dedupe the queue\n    const events = this.dedupedQueue()\n    this.queue = []\n\n    // send the events\n    try {\n      await this.rpc.tick({ events: events })\n    } catch (err) {\n      console.warn(`databeat flush failed: ${err}`)\n    }\n  }\n\n  isEnabled() {\n    return this.enabled\n  }\n\n  isAnon() {\n    return this.ident === Ident.ANON\n  }\n\n  getIdent() {\n    return this.ident\n  }\n\n  getUserId() {\n    return this.userId\n  }\n\n  getSessionId() {\n    return this.sessionId\n  }\n\n  getStorageTS(): number | undefined {\n    if (this.ts) {\n      return this.ts\n    }\n    const val = getStorageVal()\n    if (val === undefined || val === null || val.id === null) {\n      return undefined\n    }\n    this.ts = val.ts\n    return this.ts\n  }\n\n  enable() {\n    if (!isAuthEnabled(this.auth)) {\n      this.enabled = false\n      return\n    }\n    if (!isBrowser()) return\n    this.enabled = true\n    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })\n    this.identify()\n  }\n\n  disable() {\n    if (!isBrowser()) return\n    this.enabled = false\n    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking })\n  }\n\n  private dedupedQueue = () => {\n    const uniqEvents = new Map()\n    for (let i = 0; i < this.queue.length; i++) {\n      const ev = this.queue[i]\n      const key = `${ev.event}:${ev.source}:${ev.userId}:${ev.sessionId}:${JSON.stringify(ev.props)}:${JSON.stringify(ev.nums)}`\n      if (!uniqEvents.has(key)) {\n        uniqEvents.set(key, ev)\n      }\n    }\n    return Array.from(uniqEvents.values())\n  }\n}\n\nexport const isBrowser = () => {\n  return (\n    typeof window === 'object' &&\n    typeof window.localStorage === 'object' &&\n    typeof window.localStorage.getItem === 'function' &&\n    typeof window.localStorage.setItem === 'function'\n  )\n}\n\nconst isEnabled = (defaultEnabled?: boolean, auth?: Auth) => {\n  if (!isAuthEnabled(auth)) {\n    return false\n  }\n  if (!isBrowser()) {\n    return true\n  }\n  const val = getStorageVal()\n  if (val === null) {\n    if (defaultEnabled !== null && defaultEnabled !== undefined) {\n      return defaultEnabled\n    } else {\n      return true\n    }\n  } else {\n    return val.on\n  }\n}\n\nconst isAuthEnabled = (auth?: Auth) => {\n  if (auth?.jwt?.length > 0) {\n    return true\n  }\n  if (auth?.headers && Object.keys(auth.headers).length > 0) {\n    return true\n  }\n  return false\n}\n\nconst getPagePath = () => {\n  try {\n    return window.location.pathname\n  } catch (err) {\n    return ''\n  }\n}\n\nconst getDefaultProps = () => {\n  if (!isBrowser()) return {}\n\n  const params = new URL(window.location.href).searchParams\n  const props = {}\n\n  props['origin'] = window.location.origin\n\n  if (params.get('ref') && params.get('ref') !== '') {\n    props['ref'] = params.get('ref') || ''\n  }\n  if (params.get('source') && params.get('source') !== '') {\n    props['source'] = params.get('source') || ''\n  }\n  if (params.get('utm_source') && params.get('utm_source') !== '') {\n    props['utmSource'] = params.get('utm_source') || ''\n  }\n  if (params.get('utm_campaign') && params.get('utm_campaign') !== '') {\n    props['utmCampaign'] = params.get('utm_campaign') || ''\n  }\n  if (params.get('utm_medium') && params.get('utm_medium') !== '') {\n    props['utmMedium'] = params.get('utm_medium') || ''\n  }\n  if (params.get('utm_content') && params.get('utm_content') !== '') {\n    props['utmContent'] = params.get('utm_content') || ''\n  }\n  if (params.get('utm_term') && params.get('utm_term') !== '') {\n    props['utmTerm'] = params.get('utm_term') || ''\n  }\n  if (document.referrer && document.referrer !== '') {\n    props['referrer'] = document.referrer\n  }\n  if (params.get('gclid') && params.get('gclid') !== '') {\n    props['gclid'] = params.get('gclid') || ''\n  }\n  if (params.get('wbraid') && params.get('wbraid') !== '') {\n    props['wbraid'] = params.get('wbraid') || ''\n  }\n\n  return props\n}\n\nconst storageKey = '_dbeat'\n\ninterface StorageVal {\n  on: boolean\n  id: string | null\n  it: Ident\n  ut: boolean | null\n  ts?: number\n}\n\nexport const getStorageVal = (): StorageVal | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(storageKey))\n  } catch (err) {\n    return null\n  }\n}\n\nconst setStorageVal = (val: StorageVal): number | undefined => {\n  try {\n    if (!val.ts) {\n      val.ts = Math.floor(Date.now() / 1000)\n    }\n    window.localStorage.setItem(storageKey, JSON.stringify(val))\n    return val.ts\n  } catch (err) {\n    return\n  }\n}\n\nexport const genUserId = (seed: string, allowUserTracking: boolean, options: DatabeatOptions) => {\n  // Generate user id based on random number\n  if (!seed || seed === null || seed === '') {\n    const id = Math.floor(Math.random() * 100000000000000)\n    return { userId: `${id}`, ident: Ident.ANON }\n  }\n\n  // in `userIdentTracking` mode when the user has allowed tracking,\n  // we can pass the user id as is, with ident of USER.\n  if (options.userIdentTracking && allowUserTracking) {\n    return { userId: seed, ident: Ident.USER }\n  }\n\n  // Generate user id based on hash of seed + optional extra salt\n  if (options.privacy.userIdHash === true || !options.userIdentTracking || !allowUserTracking) {\n    if (isBrowser() && options.privacy.userAgentSalt === true) {\n      seed = seed + ':' + navigator.userAgent\n    }\n    if (options.privacy.extraSalt && options.privacy.extraSalt.length > 0) {\n      seed = seed + ':' + options.privacy.extraSalt\n    }\n    return { userId: bytesToHex(sha256(seed)).substring(0, 50), ident: Ident.PRIVATE }\n  } else {\n    throw new Error('invalid configuration')\n  }\n}\n\nexport const genSessionId = () => {\n  const isSessionStorageAvail =\n    isBrowser() &&\n    typeof window.sessionStorage === 'object' &&\n    typeof window.sessionStorage.getItem === 'function' &&\n    typeof window.sessionStorage.setItem === 'function'\n\n  if (!isSessionStorageAvail) {\n    return genRandHex(16)\n  } else {\n    const sid = window.sessionStorage.getItem(storageKey)\n    if (!!sid && sid.length > 0) {\n      return sid\n    } else {\n      const sid = genRandHex(16)\n      window.sessionStorage.setItem(storageKey, sid)\n      return sid\n    }\n  }\n}\n\nconst genRandHex = (n: number) => {\n  let hexString = ''\n  for (let i = 0; i < n; i++) {\n    hexString += Math.floor(Math.random() * 16).toString(16)\n  }\n  return '0x' + hexString\n}\n\nif (typeof process === 'object' && process.version && process.version < 'v18') {\n  console.error(`ERROR! expecting node v18+ but your node version is reporting ${process.version}`)\n  if (process && process.exit) {\n    process.exit(1)\n  }\n}\n"]}