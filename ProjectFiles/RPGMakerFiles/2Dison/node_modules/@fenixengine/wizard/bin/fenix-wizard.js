#!/usr/bin/env node
import url, { fileURLToPath, pathToFileURL } from 'url';
import http from 'http';
import fs from 'fs-extra';
import path, { resolve } from 'path';
import nanoSpinner from 'nanospinner';
import PrettyError from 'pretty-error';
import readline from 'readline';
import { spawn } from 'cross-spawn';
import https from 'https';
import AdmZip from 'adm-zip';
import fs$1 from 'fs/promises';
import * as chokidar from 'chokidar';
import { rollup } from 'rollup';
import typescript from '@rollup/plugin-typescript';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import nodeResolve from '@rollup/plugin-node-resolve';
import jscc from '@fenixengine/rollup-plugin-jscc';
import { Transform } from 'stream';
import { WebSocketServer } from 'ws';
import prompts from 'prompts';
import { program } from 'commander';

function filterText (text, regex, action) {
  const result = [];
  let match;
  const re = regex;
  while (match = re.exec(text)) { // eslint-disable-line no-cond-assign
    if (action(match)) {
      result.push(match);
    }
  }
  return result
}

function parseShortPath (fullPath) {
  const cwd = process.cwd();
  fullPath = path.resolve(fullPath);

  if (fullPath.startsWith(cwd)) {
    return path.relative(cwd, fullPath)
  } else {
    return fullPath
  }
}

const isTest = process.env.NODE_ENV === 'test' || process.env.CI;

const __filename$1 = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename$1);

const rootDir = path.dirname(__dirname);

const rootPackage = JSON.parse(fs.readFileSync(`${rootDir}/package.json`));

const version = rootPackage.version;

var config$1 = {
  rootDir,
  rootPackage,
  isTest,
  version
};

function timestamp () {
  const options = { hour: '2-digit', minute: '2-digit', second: '2-digit' };
  const formatter = new Intl.DateTimeFormat('en-US', options);
  const formattedTime = formatter.format(new Date());
  return `[${formattedTime}]`
}

function Logger (options = {}) {
  const _options = Object.assign(options, {
    silent: false,
    logLevel: 4,
    timestamp: true,
    useSpinner: true
  });
  let _currentLine = 0;
  const _savedLines = [];
  const _currentTime = () => timestamp();
  const prettyError = new PrettyError();

  const getChalk = async () => {
    const chalk = (await import('chalk')).default;
    return chalk
  };

  const _spinner = nanoSpinner.createSpinner();

  const _timeLog = async () => {
    const chalk = await getChalk();
    return chalk.blue(_currentTime())
  };

  const _pathLog = async (filename, path) => {
    const chalk = await getChalk();
    return chalk.green(`${filename} -> ${parseShortPath(path)}`)
  };

  const _serverBadgeLog = async (target, port) => {
    const chalk = await getChalk();
    return `
  ===============================
  ${chalk.blue.bold('FeniXWizard')} v${config$1.version}\n
  Serving => ${parseShortPath(target)}\n
  ${chalk.bold('Game')} => ${chalk.blue.bold(`http://localhost:${port}`)}
  ===============================
  `
  };
  const _buildMessage = async (message, filename, path) => {
    const time = await _timeLog();
    const pathLog = await _pathLog(filename, path);
    return `${time} ${message} ${pathLog}`
  };

  function _saveLine () {
    _savedLines.push(_currentLine);
    return _currentLine
  }

  function _clearSavedLines () {
    _savedLines.forEach(line => {
      _clearLine(line);
      _savedLines.splice(_savedLines.indexOf(line), 1);
    });
  }

  function _clearLine (line) {
    if (line) {
      readline.moveCursor(process.stdout, 0, -1, () => {
        readline.clearScreenDown(process.stdout, () => {
          _currentLine--;
        });
      });
    }
  }

  function _write (message) {
    if (_options.silent) {
      return message
    }
    _clearSavedLines();
    _currentLine++;
    process.stdout.write(`${message}\n`);
    return message
  }

  return {
    get spinner () {
      if (!_options.useSpinner) {
        return {
          start: (options) => {
            this.log(options.text);
          },
          success: (options) => {
            this.log(options.text);
          },
          error: (options) => {
            this.log(options.text);
          }
        }
      }
      return _spinner
    },

    saveLog (message) {
      this.log(message);
      _saveLine();
    },

    setOptions (options) {
      Object.assign(_options, options);
    },

    hideCursor () {
      // cliCursor.hide()
    },

    clear () {
      console.clear();
    },

    async log (message) {
      if (_options.logLevel > 3) {
        const chalk = await getChalk();
        return _write(chalk.bold(message))
      }
    },

    async logServerBadge (target, port) {
      _write(await _serverBadgeLog(target, port));
    },

    async logBuild (filename, path, type = 'succeed') {
      const failedMessage = await _buildMessage('Failed', filename, path);
      const succeedMessage = await _buildMessage('Bundled', filename, path);

      switch (type) {
        case 'succeed':
          return _write(succeedMessage)
        case 'failed':
          _write(failedMessage);
      }
    },

    async warn (message, badge = true) {
      const chalk = await getChalk();
      const badgeMessage = badge ? 'Warning' : '';
      const styledMessage = `${chalk.black.bgYellow(badgeMessage)} ${chalk.yellow(message)}`;
      return _write(styledMessage)
    },

    error (message) {
      if (_options.logLevel > 1) {
        return _write(prettyError.render(new Error(message)))
      }
    }
  }
}

const logger = Logger();

/**
 * Retrieves a tag of choice from a plugins parameters by looking for a
 * match in the plugins Parameters.js file.
 *
 * Only works for single line tags like author, plugindesc and custom tags for
 * FeniXEngine.
 *
 * @export
 * @param {string} parameters - The raw string from the Parameters.js file.
 * @param {string} tag - The tag to extract from the plugins parameters.
 * @returns {string} The value of the tag
 */
async function getPluginTag (parameters, tag, onWarn) {
  try {
    const pattern = new RegExp(`@(${tag})([^\\r\\n]*)`, 'g');
    const match = filterText(parameters, pattern, match => match[1] === tag)[0];

    if (match) {
      return match[2].trim()
    } else {
      if (onWarn) {
        onWarn(`Tag @${tag} not found in Parameters.js`);
      }
    }
  } catch (error) {
    throw new Error(logger.error(error))
  }
}

function fastWalkDir (dir, exclusions = [], result) {
  const files = fs.readdirSync(dir);

  for (let i = 0; i < files.length; i++) {
    const file = path.join(dir, files[i]);

    if (fs.statSync(file).isDirectory()) {
      if (!exclusions.includes(path.basename(file))) {
        fastWalkDir(file, exclusions, result);
      }
    } else {
      result.push(file);
    }
  }
}

const toKebabCase = str => {
  return str && str
    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
    .map(x => x.toLowerCase())
    .join('-')
};

async function createPackageJson (options) {
  const packagePath = `${options.destination}/package.json`;
  try {
    const packageJsonExists = await fs.exists(packagePath);
    if (packageJsonExists) {
      return
    }
    await fs.writeJson(packagePath, {
      name: toKebabCase(options.name),
      description: options.description,
      author: options.author,
      version: '0.1.0',
      license: 'MIT',
      repository: { private: true },
      devDependencies: {},
      dependencies: {}
    }, { spaces: 4 });
  } catch (error) {
    throw new Error(error)
  }
}

async function createTsconfig (options) {
  const tsconfigPath = `${options.destination}/tsconfig.json`;
  try {
    const tsconfigExists = await fs.exists(tsconfigPath);
    if (tsconfigExists) {
      return
    }
    await fs.writeJson(tsconfigPath, {
      compilerOptions: {
        module: 'es6',
        moduleResolution: 'node',
        target: 'es6'
      },
      include: ['node_modules/@fenixengine/rmmz-ts/libs/**/*', 'src/**/*']
    }, { spaces: 4 });
  } catch (error) {
    throw new Error(error)
  }
}

async function pipeSpawn (command, params, options = {}) {
  return new Promise((resolve, reject) => {
    const cp = spawn(command, params, {
      env: process.env,
      shell: true,
      ...options
    });

    let stdoutData = '';
    let stderrData = '';

    cp.stdout.setEncoding('utf8').on('data', (data) => {
      stdoutData += data;
    });

    cp.stderr.setEncoding('utf8').on('data', async (data) => {
      stderrData += data;
    });

    cp.on('error', (err) => {
      reject(err);
    });

    cp.on('close', (code) => {
      if (code === 0) {
        resolve(stdoutData);
        return
      }
      reject(stderrData);
    });
  })
}

async function installPeerDeps (module, path) {
  try {
    const result = await pipeSpawn('npm', ['info', module, 'peerDependencies', '--json']);
    const peerDeps = JSON.parse(result);

    for (const dependency in peerDeps) {
      const module = `${dependency}@${peerDeps[dependency]}`;
      await pipeSpawn('npm', ['install', module, '--save-dev'], {
        cwd: path
      });
    }
  } catch (error) {
    throw new Error(logger.error(error))
  }
}

async function install (modules, options = {}) {
  const { saveDev = true, path = process.cwd(), peers = false } = options;
  const command = 'npm';
  const subCommand = 'install';
  const args = [];

  if (options.peers) {
    logger.spinner.start({
      text: `Installing peer dependencies for package(s) ${modules}`
    });
    await installPeerDeps(modules[0], path);
    logger.spinner.success({
      text: `Success installing peer dependencies for package(s) ${modules}`
    });
  }

  args.push(subCommand, ...modules);

  if (saveDev) {
    args.push(peers ? '-dev' : '-D');
  }

  logger.spinner.start({
    text: `Installing package(s) ${modules}`
  });
  try {
    await pipeSpawn(command, args, {
      cwd: path,
      ignoreWarnings: true,
      ignoreInfo: true
    });
    logger.spinner.success({
      text: `Success installing package(s) ${modules}`
    });
  } catch (error) {
    logger.spinner.error({
      text: `Failed installing package(s) ${modules}`
    });
    Promise.reject(logger.error(`Failed to install modules ${modules}`));
  }
}

function _packageToExtend (plugins) {
  return plugins.standard ? 'standard' : plugins.airbnb
    ? 'airbnb' : plugins.semistandard ? 'semistandard' : 'eslint:recommended'
}

function _isRpgmakerPlugin (plugins) {
  return typeof plugins['eslint-plugin-rpgmaker'] !== 'undefined'
}

async function configureEslint (destination, plugins) {
  const packagePath = `${destination}/package.json`;

  const pluginsObj = plugins.reduce((acc, cur) => {
    acc[cur.replace("'", '')] = true;
    return acc
  }, {});

  try {
    const packageData = await fs.readJson(packagePath);
    const isRpg = _isRpgmakerPlugin(pluginsObj);
    const extender = _packageToExtend(pluginsObj);

    await fs.writeJson(packagePath, Object.assign(packageData, {
      eslintConfig: {
        extends: extender,
        plugins: [isRpg ? 'rpgmaker' : ''],
        parserOptions: {
          ecmaVersion: 'latest',
          sourceType: 'module'
        },
        env: {
          'rpgmaker/mv': isRpg,
          'rpgmaker/mz': isRpg
        },
        globals: {},
        rules: {
          'camelcase': 'off'
        }
      },
      eslintIgnore: [
        '/games/'
      ]
    }), { spaces: '\t', EOL: '\n' });
  } catch (error) {
    throw new Error(error)
  }
}

async function initializeGit (options = {}) {
  try {
    const { path = process.cwd() } = options;
    const args = [];
    const command = 'git';
    const subCommand = 'init';
    const quietCommand = '--quiet';
    args.push(subCommand, quietCommand);

    await pipeSpawn(command, args, {
      cwd: path
    });

    await fs.writeFile(`${path}/.gitignore`, 'games\nnode_modules');

    logger.spinner.success({
      text: `Success initializing git`
    });
  } catch (error) {
    logger.spinner.error({
      text: `Failed initializing git`
    });
  }
}

async function downloadFile (config = {}) {
  return new Promise((resolve, reject) => {
    if (!config.url) {
      reject(new Error('A url is required to download a file'));
    }
    const downloadUrl = url.parse(config.url);
    const httpsConfig = {
      hostname: downloadUrl.hostname,
      port: config.port || 443,
      path: downloadUrl.href,
      protocol: downloadUrl.protocol,
      agent: config.agent || https.globalAgent
    };

    https.get(httpsConfig,
      (response) => {
        const chunks = [];
        const status = response.statusCode;

        if (status !== 200) {
          reject(new Error(`Failed to load, response status code is ${status}`));
        }

        response.on('data', (chunk) => chunks.push(chunk));
        response.on('end', () => resolve(Buffer.concat(chunks)));
        response.on('error', (err) => reject(err));
      });
  })
}

async function downloadAndExtract (url, destination, filename, renamedDir) {
  await fs.ensureDir(destination);
  logger.spinner.start({
    text: 'Downloading FeniX Lightweight MV demo'
  });
  const zipDirName = filename.replace('.zip', '');
  const demoData = await downloadFile({ url });
  // Extract downloaded zip
  const zip = new AdmZip(demoData);
  zip.extractAllTo(destination, true);

  if (renamedDir) {
    await fs.rename(`${destination}/${zipDirName}`, `${destination}/${renamedDir}`);
  }
  logger.spinner.success({
    text: `${filename} Download complete`
  });
}

var defaultConfig = {
  target: './src/',
  bundler: 'default',
  output: [
    {
      flags: ['free', 'mv'],
      skipIfMissingFlag: true,
      destination: 'games/',
      gameDir: 'mv',
      parameters: 'ParametersMV',
      affix: 'Free'
    },
    {
      flags: ['free', 'mz'],
      skipIfMissingFlag: true,
      destination: 'games/',
      gameDir: 'mz',
      parameters: 'Parameters',
      affix: 'Free'
    },
    {
      flags: ['pro', 'mv'],
      skipIfMissingFlag: true,
      destination: 'games/',
      gameDir: 'mv',
      parameters: 'ParametersMV'
    },
    {
      flags: ['pro', 'mz'],
      skipIfMissingFlag: false,
      destination: 'games/',
      gameDir: 'mz',
      parameters: 'Parameters'
    }
  ]
};

/**
 * Merges strings together connecting them together with a separator
 *
 * @param {Object} options
 * @param {string} ...strings
 * @returns {string}
 */
function mergeStrings (options, ...strings) {
  const defaultOptions = {
    separator: '_',
    allowEmpty: false,
    defaultValue: '',
    trim: true
  };

  const mergedOptions = { ...defaultOptions, ...options };

  const result = strings
    .filter(str => {
      if (typeof str !== 'string') {
        return false
      }
      if (mergedOptions.allowEmpty) return true
      return str !== ''
    })
    .map(str => mergedOptions.trim ? str.trim() : str)
    .join(mergedOptions.separator);

  return result || mergedOptions.defaultValue
}

async function getConfig (options = {}) {
  let configData = null;
  let configPath = null;

  if (typeof options === 'string') {
    configPath = resolve(options);
  } else if (options.config) {
    configPath = resolve(options.config);
  } else {
    configPath = undefined;
  }

  const loadConfig = async (filePath) => {
    const module = await import(pathToFileURL(filePath));
    if (module.default) {
      return module.default
    }
  };

  if (configPath) {
    const config = await loadConfig(`${configPath}/wizard.config.js`);
    configData = { ...options, ...config };
  } else {
    configData = { ...defaultConfig, ...options };
  }

  const configFlags = configData.output.map((config) => config.flags).flat();
  const flagsToMerge = options.flags
    ? options.flags.filter(flag => !configFlags.includes(flag))
    : [];

  const mergedOutputs = configData.output.map((output) => {
    const skipIfMissingFlag = options.skipIfMissingFlag ?? output.skipIfMissingFlag ?? false;
    const destination = options.destination ?? output.destination ?? './game/';
    const affix = mergeStrings(null, output.affix, options.affix);

    return {
      ...output,
      affix,
      skipIfMissingFlag,
      destination,
      flags: flagsToMerge ? [...output.flags, ...flagsToMerge] : output.flags || []
    }
  });

  const resolvedOutputs = mergedOutputs.map((output) => ({
    ...output,
    destination: resolve(output.destination)
  }));

  configData.target = resolve(configData.target);
  configData.output = resolvedOutputs;
  configData.configFilepath = resolve(`${configPath}/wizard.config.js`);

  return configData
}

async function fileExists (filePath) {
  try {
    await fs$1.stat(filePath);
    return true
  } catch (err) {
    if (err.code === 'ENOENT') {
      return false
    } else {
      console.error('Error checking file existence:', err.message);
    }
  }
}

async function getPluginData (parametersPath, onWarn) {
  let plugin = null;
  const paramsExist = await fileExists(parametersPath);
  if (!paramsExist) {
    return plugin
  }
  const parameters = await fs$1.readFile(parametersPath, 'utf8');

  try {
    plugin = {
      name: await getPluginTag(parameters, 'pluginname', onWarn) || 'FeniXPlugin',
      modulename: await getPluginTag(parameters, 'modulename', onWarn),
      external: await getPluginTag(parameters, 'external', onWarn) || [],
      parameters
    };
  } catch (error) {
    throw error
  }

  return plugin
}

let watcher$1 = null;
let fileChangeCount = 0;
const listeners = [];

function createFileWatcher (pathOrPaths, listener) {
  if (watcher$1) {
    watcher$1.close();
  }

  if (typeof listener === 'function') {
    listeners.push(listener);
  }

  const paths = Array.isArray(pathOrPaths) ? pathOrPaths : [pathOrPaths];

  watcher$1 = chokidar.watch(paths, {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: true,
    usePolling: true,
    ignored: [
      /node_modules/,
      /dist/,
      '**/*.log'
    ]
  });

  watcher$1.on('ready', () => {
    setTimeout(() => {
      logger.log('ðŸ‘ï¸ Watching for changes...');
    }, 1500);
  });

  watcher$1.on('change', async (path, stats) => {
    fileChangeCount++;
    if (fileChangeCount > 1) {
      return
    }
    if (listeners.length > 0) {
      logger.clear();
      for (const listener of listeners) {
        await listener(path, stats);
        logger.log('ðŸ‘ï¸ Watching for changes...');
      }
      fileChangeCount = 0;
    }
  });

  watcher$1.on('error', (error) => {
    logger.error(error);
  });

  return {
    addListener: (listener) => {
      if (typeof listener === 'function') {
        listeners.push(listener);
      }
    },
    removeListener: (listener) => {
      if (typeof listener === 'function') {
        listeners.splice(listeners.indexOf(listener), 1);
      }
    }
  }
}

function watch (path, listener) {
  const watcher = createFileWatcher(path, listener);
  return watcher
}

function convertToUpperCaseObject (array) {
  return array.reduce((acc, str) => {
    acc[`_${str.toUpperCase()}`] = true;
    return acc
  }, {})
}

function PluginRollup () {
  return {
    async bundle (options) {
      try {
        let shouldSkipBuild = false;
        const input = path.resolve(options.target);
        const plugin = options.plugin;
        const fileExtension = path.extname(input);
        const isTypeScript = fileExtension === '.ts';
        const isJSON = fileExtension === '.json';

        const external = ['fs', 'http', 'https', 'path', 'PIXI'].concat(plugin.external);
        const destination = `${options.destination}/${options.gameDir}`;
        const filename = options.affix
          ? `${destination}/js/plugins/${plugin.name}_${options.affix}.js`
          : `${destination}/js/plugins/${plugin.name}.js`;

        const generatePluginArray = (flags) => {
          const common = [
            nodeResolve({ module: true, preferBuiltins: false }),
            commonjs(),
            jscc({
              values: convertToUpperCaseObject(flags),
              asloader: false,
              onComplete (results) {
                const { foundExprs } = results;

                if (foundExprs && options.skipIfMissingFlag) {
                  shouldSkipBuild = options.flags.some(flag => {
                    return !foundExprs.has(`_${flag.toUpperCase()}`)
                  });
                }
              }
            })
          ];

          if (isTypeScript) {
            return [typescript()].concat(common)
          }

          if (isJSON) {
            return [json()].concat(common)
          }

          return common
        };

        const inputOptions = {
          input,
          external,
          plugins: generatePluginArray(options.flags),
          onwarn (warning) {
            if (warning.code === 'EVAL') {
              return
            }
            if (warning.code === 'UNRESOLVED_IMPORT') {
              if (process.env.CI) {
                throw new Error(warning.message)
              }
            }
            logger.warn(warning.message);
          }
        };

        const outputOptions = {
          file: filename.trim(),
          format: 'iife',
          name: plugin.modulename,
          footer: options.footer,
          banner: plugin.parameters,
          sourcemap: options.sourcemap,
          indent: false
        };

        const bundle = await rollup(inputOptions);
        await bundle.generate(outputOptions);

        if (shouldSkipBuild) {
          return { skipped: true, code: bundle, options }
        }

        await bundle.write(outputOptions);
        bundle.close();

        return { skipped: false, code: bundle }
      } catch (error) {
        if (error.frame) {
          logger.warn(`${error.name}: ${error.message}`, false);
          logger.log(error.frame);
        } else {
          logger.error(error);
        }
      }
    }
  }
}

let watcher = null;
let config = null;

async function buildFromDirectory (config) {
  const { exclusions = [] } = config;
  const defaultExclusions = [
    'node_modules',
    'dist',
    'games',
    '.vscode',
    '.git',
    'docs',
    ...exclusions
  ];

  const files = [];

  fastWalkDir(config.target, defaultExclusions, files);

  if (files.length === 0) {
    logger.warn(`No files found in ${config.target}.`);
  }

  const mainFilenames = ['main.js', 'main.ts'];
  const mainFiles = files.filter(file => mainFilenames.includes(path.basename(file)));

  if (mainFiles.length === 0) {
    logger.warn(`No main files found in ${config.target}.`);
  }

  for (const file of mainFiles) {
    const fileDir = path.dirname(file);
    if (config.only && !config.only.some(dir => fileDir.includes(dir))) {
      continue
    }
    await build({ ...config, target: file });
  }
}

async function build (config) {
  try {
    const fileExt = path.extname(config.target);
    for (const output of config.output) {
      const plugin = await getPluginData(
        `${path.dirname(config.target)}/${output.parameters}${fileExt}`,
        onPluginDataWarn
      );
      if (!plugin) {
        await logger.warn(`Plugin parameters not found, skipping ${output.flags} bundle ${config.target}.`);
        continue
      }
      const bundleOptions = { ...config, ...output, plugin };
      const result = await config.bundler().bundle(bundleOptions);
      const name = output.affix ? plugin.name + output.affix : plugin.name;
      const buildNumber = config.output.indexOf(output);

      if (result && result.skipped) {
        await logger.warn(`Missing flags ${output.flags}, skipping build #${buildNumber} for file ${name}`);
        continue
      }
      await logger.logBuild(name, output.destination);
    }
  } catch (error) {
    throw error
  }
}

async function builder (options) {
  if (!config) {
    config = await getConfig(options);
    if (config.bundler === 'default') {
      config.bundler = PluginRollup;
    }
  }

  if (!watcher && options.watch) {
    const target = options.only ? `${config.target}/${options.only}` : config.target;
    const paths = options.config ? [config.configFilepath, target] : [target];
    watcher = watch(paths);
    watcher.addListener(async (path, stats) => {
      if (path === config.configFilepath) {
        logger.log('Config file changed. Rebuilding...');
      }
      await builder(options);
    });
  }

  try {
    const targetStat = fs.statSync(config.target);

    if (targetStat.isDirectory()) {
      await buildFromDirectory(config);
    } else if (targetStat.isFile()) {
      await build(config);
    }
  } catch (error) {
    throw error
  }
}

function onPluginDataWarn (message) {
  if (message.includes('@external')) {
    return
  }
  logger.warn(message);
}

class Injector extends Transform {
  constructor (options) {
    super(options);
    this._options = options;
  }

  _transform (chunk, encoding, onComplete) {
    if (this._options.onTransform) {
      this._options.onTransform(chunk, this);
      onComplete();
    }
  }
}

function startServer (source = './src', options) {
  const publicDir = path.normalize(options.destination || `${process.cwd()}/games/`);
  const port = options.port || 1818;
  const socketPort = 9000;
  const hostname = 'localhost';
  const clientReloadPath = `${config$1.rootDir}/src/reload-client.js`;
  let fileStream = null;

  const app = http.createServer((request, response) => {
    try {
      const fileUrl = path.normalize(`${publicDir}${request.url}`);

      switch (request.url) {
        case '/':
          const indexPath = `${publicDir}index.html`;

          if (fs.existsSync(indexPath)) {
            fileStream = fs.createReadStream(indexPath);
            fileStream.pipe(new Injector({
              onTransform (chunk, stream) {
                const html = chunk.toString();
                const codeToInject = `<!-- Inserted by FeniXEngine MV Wizard -->
                <script type="text/javascript" src="/reload-client.js"></script>`;
                const injectedHtml = html.replace(`</body>`, `${codeToInject}\n  </body>`);

                stream.push(injectedHtml);
              }
            })).pipe(response);
          } else {
            response.writeHead(404);
            response.end();
            throw new Error(logger.error('Unable to start server, cannot find index.html in target directory'))
          }
          break
        case '/reload-client.js':
          fileStream = fs.createReadStream(clientReloadPath);
          fileStream.pipe(new Injector({
            onTransform (chunk, stream) {
              const js = chunk.toString();
              const codeToReplace = `const socketServerUrl = ''`;
              const codeToInject = `const socketServerUrl = 'ws://localhost:${socketPort}'`;
              const toInject = js.replace(codeToReplace, codeToInject);

              stream.push(toInject);
            }
          })).pipe(response);
          break

        default:
          fileStream = fs.createReadStream(fileUrl);
          fileStream.pipe(response);
          break
      }

      fileStream.on('open', (data) => {
        response.writeHead(200);
      });

      fileStream.on('error', () => {
        response.writeHead(404);
        response.end();
      });
    } catch (error) {
      response.writeHead(500);
      response.end();
      socketServer.close();
      app.close();
      logger.error(error);
    }
  });

  // Setup socket server
  const socketServer = new WebSocketServer({ port: socketPort });
  let socketEvent = null;

  // Start listening to server
  app.listen(port, hostname, async () => {
    await logger.logServerBadge(publicDir, port);
    const absoluteSourcePath = path.normalize(source);
    const watchDir = path.resolve(process.cwd(), absoluteSourcePath);
    createFileWatcher(watchDir, (path, stats) => {
      builder(options)
        .then(() => {
          if (socketEvent) {
            logger.saveLog('Reloading browser');
            socketEvent.send('reload');
          } else {
            logger.error('Unable to communicate with reload client');
          }
        })
        .catch(error => logger.error(error));
    });
  });

  socketServer.on('connection', ws => {
    ws.send(`FeniXWizard ðŸ§™ - Successfully Connected! ðŸ”Œ`);
    socketEvent = ws;
  });

  socketServer.on('error', error => logger.error(error));

  const closeServers = function () {
    app.close();
    socketServer.close();
  };

  // Ensure we close all servers before FeniXWizard is terminated
  process.on('beforeExit', closeServers);
  process.on('unhandledException', closeServers);
  process.on('SIGINT', () => {
    closeServers();
    process.exit(0);
  });

  return {
    app,
    socketServer
  }
}

function serverCommand (program) {
  program
    .command('serve')
    .description('Starts a server and syncs all changes')
    .argument('[source]', 'the source directory. defaults to ./src')
    .option('-d, --destination <path>', 'directory to serve from. defaults to ./games/')
    .option('-p, --port [number]', 'Choose which port to run the server on')
    .action(startServer);
}

function buildCommand (program) {
  program
    .command('build')
    .description(`Builds a plugin from it's source files`)
    .argument('[source]', 'the source directory. defaults to ./src')
    .argument('[desination]', 'the destination directory. defaults to ./games/[rpgmaker version]/js/plugins/')
    .option('-t, --target <path>', 'The target directory where your main.js and source code is.', './src')
    .option('-d, --destination <path>', 'The destination directory the final bundle will write to')
    .option('-c, --config [path]', 'Utilizes the config file at the root of the project or at <path>')
    .option('-a,--affix <affix>', 'Append an affix to the filename')
    .option('--tags <flags>', 'DEPRECATED: Enable conditional compilation for code under the flags', [])
    .option('-f,--flags <flags>', 'Enable conditional compilation for code under the flags', [])
    .option('-o, --only <dirs...>', 'Only build the specified project directory')
    .option('-w, --watch', 'Watches files to rebuild when changes occur')
    .option('-s, --sourcemap', 'choose to generate a sourcemap inline with the plugin')
    .option('-m, --skipMissingFlag', 'Skip a build if any flag is not included in the source code')
    .action((source, destination, options) => {
      if (options.config && typeof options.config === 'boolean') {
        options.config = '.';
      }
      if (options.skipMissingFlag) {
        options.skipIfMissingFlag = options.skipMissingFlag;
      }

      if (options.destination) {
        destination = options.destination;
      }

      if (options.target) {
        source = options.target;
      }

      /**
      * DEPRECATED tags option. For now we replace flags with tags if tags is an
      * option.
      */
      if (options.tags.length > 0) {
        logger.warn('DEPRECATED: --tags option is deprecated in favor of --flags or -f');
        options.flags = options.tags;
      }

      if (!Array.isArray(options.flags)) {
        options.flags.replace(',', ' ');
        options.flags = options.flags.split(' ');
        options.flags.map((flag, index) => {
          options.flags[index] = flag.trim();
        });
      }
      builder({
        target: source,
        destination,
        ...options
      });
    });
}

const CURR_DIR = process.cwd();
const MV_GAME_FILENAME$1 = 'fenix-lightweight-mv-game-v0.0.1.zip';
const MV_GAME_LINK$1 = `https://gitlab.com/FeniXEngineMV/fenix-lightweight-mv-game/-/archive/v0.0.1/${MV_GAME_FILENAME$1}`;
const MZ_GAME_FILENAME$1 = 'fenix-lightweight-mz-game-v0.0.1.zip';
const MZ_GAME_LINK$1 = `https://gitlab.com/FeniXEngineMV/fenix-lightweight-mz-game/-/archive/v0.0.1/${MZ_GAME_FILENAME$1}`;

async function copyTemplateFiles (options) {
  const { destination, language } = options;
  const templateDir = `${config$1.rootDir}/templates/base/`;

  try {
    const files = await fs.readdir(templateDir);
    await fs.ensureDir(`${destination}/src/`);

    for (const file of files) {
      if (language === 'ts' && file === 'Core.js') {
        continue
      }
      const fileDir = `${templateDir}/${file}`;
      const fileDestDir = `${destination}/src/${file}`;
      const fileExists = await fs.exists(fileDestDir);

      if (fileExists === false) {
        await fs.copyFile(fileDir, fileDestDir);
        if (language === 'ts' && file !== 'Core.ts') {
          await fs.rename(`${destination}/src/${file}`, `${destination}/src/${file.replace('.js', '.ts')}`);
        }
      }
    }
  } catch (error) {
    Promise.reject(logger.error(error));
  }
}

async function copyVsCodeLaunchJson (options) {
  const { destination } = options;
  try {
    await fs.copyFile(`${config$1.rootDir}/templates/base/vscode/launch.json`, `${destination}/.vscode/launch.json`);
  } catch (error) {
    Promise.reject(logger.error(error));
  }
}

async function injectParamterTags (options) {
  try {
    const { author, pluginname, destination, description, language } = options;
    const filename = language === 'ts' ? 'Parameters.ts' : 'Parameters.js';
    const parameterData = await fs.readFile(`${destination}/src/${filename}`, 'utf8');
    const authorTag = `@author ${author}`;
    const pluginnameTag = `@pluginname ${pluginname}`;
    const descriptionTag = `@plugindesc ${description}`;

    const newParameters = parameterData
      .replace(`@author`, `${authorTag}`)
      .replace(`@pluginname`, `${pluginnameTag}`)
      .replace(`@plugindesc`, `${descriptionTag}`);

    await fs.writeFile(`${destination}/src/${filename}`, newParameters);
  } catch (error) {
    throw new Error(logger.error(error))
  }
}

async function installLinterPackages (options) {
  if (options.linter === 'none' || !options.eslintPlugins) {
    return
  }
  const plugins = options.eslintPlugins;
  const destination = options.destination;
  try {
    await install([options.linter], { path: destination });

    for (const plugin of plugins) {
      if (plugin === 'standard') {
        await install(['eslint-config-standard'], { peers: true, path: destination });
      } else if (plugin === 'semistandard') {
        await install(['eslint-config-semistandard'], { peers: true, path: destination });
      } else if (plugin === 'airbnb') {
        await install(['airbnb'], { peers: true, path: destination });
      } else {
        await install([plugin], { path: destination });
      }
    }
    await configureEslint(destination, plugins);
  } catch (error) {
    Promise.reject(logger.error(error));
  }
}

async function downloadAndExtractMV (path) {
  await downloadAndExtract(MV_GAME_LINK$1, path, MV_GAME_FILENAME$1, 'mv');
}

async function downloadAndExtractMZ (path) {
  await downloadAndExtract(MZ_GAME_LINK$1, path, MZ_GAME_FILENAME$1, 'mz');
}

async function buildProjectBase (options) {
  try {
    if (fs.existsSync(options.destination)) {
      const stat = await fs.stat(options.destination);
      options.destination = stat.isDirectory() ? options.destination : `${CURR_DIR}/${options.destination}`;
    } else {
      await fs.ensureDir(options.destination);
    }

    const destination = options.destination;

    await createPackageJson({
      name: options.projectName,
      description: options.projectDescription,
      author: options.projectAuthor,
      destination
    });
    if (options.language === 'ts') {
      await createTsconfig({ destination });
    }
    await copyTemplateFiles(options);
    await injectParamterTags({
      author: options.projectAuthor,
      description: options.projectDescription,
      pluginname: options.projectName,
      language: options.language,
      destination
    });

    if (options.editor === 'vscode') {
      await copyVsCodeLaunchJson(options);
    }

    if (options.language === 'ts') {
      await install(['typescript'], { path: destination });
      await install(['@fenixengine/rmmz-ts'], { path: destination });
    }

    await installLinterPackages(options, destination);

    if (options.optionalPackages.length > 0) {
      await install(options.optionalPackages, { path: destination });
    }

    if (options.initializeGit) {
      initializeGit({ path: destination });
    }

    await fs.ensureDir(`${destination}/games`);
    if (options.downloadGames) {
      const gamesDestination = `${destination}/games/`;
      for (const game of options.downloadGames) {
        if (game === 'mv') {
          await downloadAndExtractMV(gamesDestination);
        }
        if (game === 'mz') {
          await downloadAndExtractMZ(gamesDestination);
        }
      }
    }
    await fs.ensureDir(`${destination}/games`);
    await fs.ensureDir(`${destination}/games/mv`);
    await fs.ensureDir(`${destination}/games/mv`);
  } catch (error) {
    Promise.reject(logger.error(error));
  }
}

async function startInit (options) {
  const chalk = (await import('chalk')).default;
  await logger.log(`
  ${chalk.blue('Welcome to FeniXWizard!')}
  FeniXWizard is a developer tool for creating an environment that makes developing
  RPG Maker MV plugins faster and easier.

  ${chalk.green('Follow the on-screen instructions to get started!.')}
  `)

  ;(async () => {
    const onCancel = (prompt, answers) => {
      answers.__cancelled__ = true;
      return false
    };

    const questions = [
      {
        type: 'text',
        name: 'destination',
        message: 'Where would you like to create the project',
        initial: './'
      },
      {
        type: 'select',
        name: 'language',
        initial: 0,
        message: 'Do you want to create a plugin using TypeScript or JavaScript',
        choices: [
          {
            value: 'js',
            title: 'JavaScript'
          },
          {
            value: 'ts',
            title: 'TypeScript (experimental)'
          }
        ]
      },
      {
        type: 'text',
        name: 'projectName',
        message: 'Plugin name',
        initial: 'GeneratedPlugin'
      },
      {
        type: 'text',
        name: 'projectDescription',
        initial: '',
        message: 'Project description'
      },
      {
        type: 'text',
        name: 'projectAuthor',
        initial: 'FeniXEngine Contributers',
        message: 'Author name'
      },
      {
        type: process.env.TERM_PROGRAM === 'vscode' ? null : 'confirm',
        name: 'editor',
        initial: true,
        message: 'Are you using VSCode?'
      },
      {
        type: 'select',
        name: 'linter',
        initial: 0,
        message: 'Choose a linter',
        choices: [
          {
            value: 'eslint',
            name: 'ESLint'
          },
          {
            value: 'xo',
            name: 'XO'
          },
          {
            value: 'jshint',
            name: 'JSHint'
          },
          {
            value: 'none',
            name: 'none'
          }
        ]
      },
      {
        type: prev => prev === 'eslint' ? 'multiselect' : null,
        name: 'eslintPlugins',
        initial: [1, 2],
        message: 'Which ESLint plugins would you like to install',
        choices: [
          {
            value: 'eslint-plugin-rpgmaker',
            name: 'RPG Maker MV Global Variables'
          },
          {
            value: 'standard',
            name: 'StandardJS Config'
          },
          {
            value: 'semistandard',
            name: 'StandardJS Config w/ Semicolons'
          },
          {
            value: 'airbnb',
            name: 'Airbnb Style'
          }
        ]
      },
      {
        type: 'multiselect',
        name: 'optionalPackages',
        initial: [1],
        message: 'Would you like to install other useful packages',
        choices: [
          {
            value: '@fenixengine/tools',
            name: 'FeniXTools - A modular RPG Maker MV plugin library'
          },
          {
            value: 'ava',
            name: 'AVA - Futuristic test runner'
          },
          {
            value: 'flow-bin',
            name: 'Flow - A static type checker for JavaScript'
          }
        ]
      },
      {
        type: 'confirm',
        name: 'initializeGit',
        initial: true,
        message: 'Would you like to initialize git for this project?'
      },
      {
        type: 'multiselect',
        initial: [1, 2],
        name: 'downloadGames',
        message: 'Which lightweight demo games would you like to download',
        choices: [
          {
            value: 'mv',
            name: 'Download FeniX Lightweight MV Demo'
          },
          {
            value: 'mz',
            name: 'Download FeniX Lightweight MZ Demo'
          }
        ]
      }];

    const response = await prompts(questions, { onCancel });

    if (response.__cancelled__) {
      return
    }

    if (!response.vscode && process.env.TERM_PROGRAM === 'vscode') {
      response.vscode = true;
    }

    buildProjectBase(response);
  })();
}

function initCommand (program) {
  program
    .command('init')
    .description('A guided setup for the setup of a plugin project')
    .action(startInit);
}

const MV_GAME_FILENAME = 'fenix-lightweight-mv-game-v0.0.1.zip';
const MV_GAME_LINK = `https://gitlab.com/FeniXEngineMV/fenix-lightweight-mv-game/-/archive/v0.0.1/${MV_GAME_FILENAME}`;
const MZ_GAME_FILENAME = 'fenix-lightweight-mz-game-v0.0.1.zip';
const MZ_GAME_LINK = `https://gitlab.com/FeniXEngineMV/fenix-lightweight-mz-game/-/archive/v0.0.1/${MZ_GAME_FILENAME}`;

function downloadCommand (program) {
  program
    .command('download')
    .description(`Downloads and extracts an RPG MAker demo game`)
    .argument('<engine>', 'engine to download, mv or mz')
    .option('-d, --destination <path>', 'the destination to extract the demo to')
    .action(async (engine, options) => {
      if (!options.destination) {
        logger.warn(`No destination specified, using default directory /games/`);
        options.destination = `./games/`;
      }

      switch (engine) {
        case 'mv':
          await downloadAndExtract(MV_GAME_LINK, options.destination, MV_GAME_FILENAME, engine);
          break

        case 'mz':
          await downloadAndExtract(MZ_GAME_LINK, options.destination, MZ_GAME_FILENAME, engine);
          break
      }
    });
}

function _loadCommands (program) {
  const commands = [serverCommand, buildCommand, initCommand, downloadCommand];
  commands.forEach(command => command(program));
}

_loadCommands(program);

const entryFile = process.argv?.[1];
const __filename = fileURLToPath(import.meta.url);

if (entryFile === __filename || process.argv.length > 1) {
  program
    .version(config$1.version)
    .action(() => {
      startInit();
    })
    .parse(process.argv);
}

// Expose to API
var main = { builder, buildProjectBase, downloadAndExtractMV, downloadAndExtractMZ };

export { main as default };
