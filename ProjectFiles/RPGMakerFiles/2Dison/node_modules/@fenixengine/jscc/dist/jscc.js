"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const parse_buffer_1 = __importDefault(require("./parse-buffer"));
const parse_options_1 = __importDefault(require("./parse-options"));
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const isFunction = (fn) => (!!fn && typeof fn === 'function');
/**
 * Preprocessor for conditional comments and compile-time variable
 * replacement replacement in text files (asynchronous version).
 *
 * The result is a plain JS object with a property `code`, a string with the
 * processed source, and a property `map`, with a raw sourcemap object, if
 * required by the `sourcemap` option.
 *
 * If a callback is provided, jscc will operate asynchronously and call the
 * callback with an error object, if any, or `null` in the first parameter
 * and the result in the second.
 *
 * @param source String to preprocess, in ascii or utf8 codification.
 * @param filename Absolute or relative to the current directory.
 * @param options User options
 * @param callback NodeJS style callback that receives the error and result as parameters.
 */
function jscc(source, filename, options, callback) {
    // Get the normalized options
    const props = parse_options_1.default(filename || '', options || {});
    // Run sync if not callback is given
    if (!isFunction(callback)) {
        return parse_buffer_1.default(source, props);
    }
    // With a callback mimic an async behavior
    process.nextTick(() => {
        try {
            const result = parse_buffer_1.default(source, props);
            callback(null, result);
        }
        catch (err) {
            callback(err);
        }
    });
    return undefined;
}
module.exports = jscc;
//# sourceMappingURL=jscc.js.map