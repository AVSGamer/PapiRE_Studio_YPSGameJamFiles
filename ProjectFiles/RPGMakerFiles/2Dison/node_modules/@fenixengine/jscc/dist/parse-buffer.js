"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const magic_string_1 = __importDefault(require("magic-string"));
const parse_chunks_1 = __importDefault(require("./parse-chunks"));
const parse_helper_1 = __importDefault(require("./parse-helper"));
const parser_1 = __importDefault(require("./parser"));
/**
 * Parse the received buffer and returns an object with the parsed code and its
 * sourceMap, if required by `props` and the buffer has changed.
 *
 * @param source Source code
 * @param props Parsed user options
 */
const parseBuffer = function _parseBuffer(source, props) {
    // Add a MagicString instance to the props and create the helpers.
    props.magicStr = new magic_string_1.default(source);
    const helper = new parse_helper_1.default(source, props);
    // Parse the buffer chunk by chunk and get the changed status.
    const changes = parse_chunks_1.default(new parser_1.default(props), source, helper);
    // In the result, if the buffer did not change return `source` untouched.
    const result = {
        code: changes ? props.magicStr.toString() : source,
    };
    // If required, add the source map, in `null` if there were no changes.
    if (props.sourceMap) {
        result.map = changes ? props.magicStr.generateMap({
            source: props.values._FILE || undefined,
            includeContent: props.mapContent,
            hires: props.mapHires,
        }) : null;
    }
    if (helper.getFoundExprs().size > 0) {
        result.foundExprs = helper.getFoundExprs();
    }
    return result;
};
module.exports = parseBuffer;
//# sourceMappingURL=parse-buffer.js.map