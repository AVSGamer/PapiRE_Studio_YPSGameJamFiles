"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const regexes_1 = __importDefault(require("./regexes"));
/**
 * Regex for replacing of jscc varnames ($1 = prefix, $2 = varname).
 */
const VARS_TO_EVL = RegExp(`${regexes_1.default.S_STRINGS}|${regexes_1.default.S_VARNAMES}`, 'g');
/**
 * Replacing function
 */
const _repVars = function (match, prech, vname) {
    return vname ? prech + (vname in this ? `this.${vname}` : `global.${vname}`) : match;
};
/**
 * Method to perform the evaluation of the given string using a function
 * instantiated dynamically.
 *
 * @param ctx Context with the current variables and the error handler
 * @param exprStr String to evaluate, can include other defined vars
 */
const evalExpr = function _evalExpr(ctx, exprStr) {
    const values = ctx.values;
    // var replacement
    const expr = exprStr
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(VARS_TO_EVL, _repVars.bind(values));
    let result;
    try {
        // The '\n' in the Function ctor will support single-line comments,
        // if required by a future version.
        // tslint:disable-next-line:function-constructor
        const fn = new Function('', `return (${expr}\n);`);
        result = fn.call(values);
    }
    catch (e) {
        result = exprStr;
        ctx.errorHandler(`${e.message} in expression "${expr}"`);
    }
    return result;
};
module.exports = evalExpr;
//# sourceMappingURL=eval-expr.js.map