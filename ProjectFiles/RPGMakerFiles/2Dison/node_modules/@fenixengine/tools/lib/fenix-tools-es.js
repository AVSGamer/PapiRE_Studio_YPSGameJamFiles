'use strict'

/**
 * Cleans the path by replacing two forward slashes with one.
 *
 * @function cleanPath
 * @since 1.0.0
 * @memberof module:File
 *
 * @param {string} path - The path you want to clean.
 * @return {string} The cleaned string.
 * @example
 * import { cleanPath } from 'fenix-tools'
 *
 * const badUrl = 'C://Path//to/something//'
 *
 * console.log(cleanPath(badUrl)) // => 'C:/Path/to/something/'
 */
function cleanPath (path) {
  return path.replace(/(\/)[(/)]/g, '/')
}

/**
 * An async function which determines if the current computer has internet
 * access by pinging to a server. If no url is provided it checks
 * navigator.online
 *
 * @function hasWebAccess
 * @async
 * @since 1.0.0
 * @memberof module:File
 *
 * @param {string} [url] A url to a server
 *
 * @return {promise} A promise that resolves to true or false
 * @example
 * import { hasWebAccess } from 'fenix-tools'
 *
 * const canDownload = await hasWebAccess('http://google.com')
 * console.log(canDownload) // => returns true
 *
 * hasWebAccess('http://google.com')
 * .then('Web connection is live!)
 */
async function hasWebAccess (url) {
  if (!url) { return navigator.onLine }
  const result = await window.fetch(url, {
    method: 'HEAD',
    cache: 'no-cache'
  }).then((response) => {
    return response.ok === true
  })
  return result
}

/**
 * An async function which downloads a file via node's http or https.
 *
 * @function downloadFile
 * @async
 * @since 1.0.0
 * @memberof module:File
 * @see {@link module:File.hasWebAccess|hasWebAccess}
 *
 * @param {object} config - A configuration object.
 * @param {string}  config.url - The url to the file you want to download
 * @param {number}  [config.port=443] - The port number to use
 * @param {object}  [config.agent=http.globalAgent] - How much gold the party starts with.
 *
 * @returns {Promise} - Returns a promise that resolves the file's data
 * from the url
 * @example
 * import {downloadFile, tryWriteFile} from 'fenix-tools'
 *
 * downloadFile({
 *  url: 'http://fenixenginemv.gitlab.io/img/fenix-logo-signature.png'
 * port: 80,
 * })
 * .then(data => {
 *   console.log(data) // => The downloaded file's data
 *   tryWriteFile('/', data) // => writes file to machine
 * })
 *
 */
async function downloadFile (config = {}) {
  if (!config.url) {
    return new Error('A url is required to download a file')
  }
  await hasWebAccess()
  const url = require('url')
  const downloadUrl = url.parse(config.url)
  const https = downloadUrl.protocol === 'https:' ? require('https') : require('http')
  const httpsConfig = {
    hostname: downloadUrl.hostname,
    port: config.port || 443,
    path: downloadUrl.href,
    protocol: downloadUrl.protocol,
    agent: config.agent || https.globalAgent
  }
  await new Promise((resolve, reject) => {
    https.get(httpsConfig,
      (response) => {
        const chunks = []
        const status = response.statusCode
        if (status !== 200) {
          throw new Error(`Failed to load, reasponse status code is ${status}`)
        }
        response.on('data', (chunk) => chunks.push(chunk))
        response.on('end', () => resolve(chunks.join('')))
        response.on('error', (err) => reject(err))
      })
  })
}

/**
 * Checks if file(s) exist on a local machine using node fs.
 *
 * @function localFileExists
 * @since 1.0.0
 * @memberof module:File
 *
 * @param {string|array} paths - A path or array of paths to check.
 *
 * @return {boolean} True if the file path or paths exist
 * @example
 * import {localFileExists} from 'fenix-tools'
 *
 * localFileExists('./img/pictures/myPicture.png') // => Returns true or false
 *
 */
function localFileExists (paths = []) {
  paths = typeof paths === 'string' ? [paths] : paths
  const fs = require('fs')
  return paths.every((path) => fs.existsSync(path))
}

/**
 * @author       LTNGames <ltngamesdevelopment@gmail.com>
 * @copyright    2018 FeniX Engine
 * @license      {@link https://gitlab.com/FeniXEngineMV/fenix-utils/blob/master/LICENSE|MIT License}
 */

/**
 * An async function for checking if a file exist on a server.
 *
 * @function webFileExists
 * @async
 * @since 1.0.0
 * @memberof module:File
 *
 * @param {string} url - The url to the file
 *
 * @returns {promise} Promise that resolves to true if the file exists.
 * @example
 * import { webFileExists } from 'fenix-tools'
 *
 * const file = 'http://example.com/file.png'
 *  const fileExists = await webFileExists(file)
 * console.log(fileExists)  // => returns true if file exists
 * // or
 * webFileExists(file)
 * .then(console.log('File exists!'))
 * .catch(console.log('Unable to get file))
 */
async function webFileExists (url) {
  try {
    const result = await window.fetch(url, {
      method: 'HEAD',
      cache: 'no-cache'
    }).then((response) => {
      return response.ok === true
    })
    return result
  } catch (error) {
    throw new Error(error)
  }
}

/**
 * Check if a file exists.
 *
 * @function fileExists
 * @since 1.0.0
 * @memberof module:File
 * @see {@link module:File.localFileExists|localFileExists}
 * @see {@link module:File.webFileExists|webFileExists}
 *
 * @param {string} path - The path to the file
 * @param {array} extensions -  the extension(s) of file you want to check
 *
 * @returns {Boolean} true if the file exists.
 * @example
 * import { fileExists } from 'fenix-tools'
 *
 * console.log(fileExists('./path/to/file')) // => returns true or false
 *
 */
function fileExists (url) {
  if (window.isNwjs()) {
    localFileExists(url)
  } else {
    webFileExists(url)
  }
}

/**
 * Load a file on the local machine.
 *
 * @function loadLocalFile
 * @since 1.0.0
 * @memberof module:File
 *
 * @param {string} path - Path to the file.
 * @param {string} [encoding='utf8'] - The type of file encoding
 *
 * @return {promise} A promise that resolves the data
 * @example
 * import {loadLocalFile} from 'fenix-tools'
 *
 * loadLocalFile('./img/pictures/character1.png)
 * .then(data => {
 *  // Local file loaded success
 *  console.log(data)  // => A parsed JSON object.
 * })
 *
 */
function loadLocalFile (path, encoding = 'utf8') {
  const fs = require('fs')
  return new Promise((resolve, reject) => {
    if (fs.existsSync(path)) {
      const contents = fs.readFileSync(path, encoding, err => reject(err))
      resolve(contents)
    }
    reject(new Error(`Cannot read file at ${path}`))
  })
}

/**
 * Loads a JSON file. and parses it Decides to use node or fetch based on platform.
 * If using nwjs it will use node else it falls back to fetch()
 *
 * @function loadJSON
 * @async
 * @since 1.0.0
 * @memberof module:File
 * @see {@link module:File.loadLocalFile|loadLocalFile}
 *
 * @param {any} path - The path to the JSON file.
 *
 * @returns {promise} promise - A promise that resolves the parsed JSON
 * @example
 * import {loadJSON} from 'fenix-tools'
 *
 * loadJSON('./data/highscores.json')
 * .then(data => {
 *   // success for parsing and loading JSON file
 *   console.log(data)  // => A parsed JSON object.
 * })
 *
 */
function loadJSON (path) {
  if (window.Utils.isNwjs()) {
    return new Promise((resolve, reject) => {
      loadLocalFile(`${path}`)
        .catch(err => reject(err))
        .then(response => resolve(JSON.parse(response)))
    })
  } else {
    return new Promise((resolve, reject) => {
      window.fetch(`${path}`)
        .then((response) => resolve(response.json()))
        .catch(err => reject(err))
    })
  }
}

/**
 * Gets the location of the current game.exe, a full root project path.
 *
 * @function projectPath
 * @since 1.0.0
 * @memberof module:File
 *
 * @return {string} The current project root path
 * @example
 * import {projectPath} from 'fenix-tools'
 *
 * projectPath() // => 'C:/fullpath/to/project'
 *
 */
function projectPath () {
  let path = window.location.pathname.replace(/\/[^/]*$/, '/')
  if (path.match(/^\/([A-Z]:)/)) {
    path = path.slice(1)
  }
  return decodeURIComponent(path)
}

/**
 * Attempts to write given data to a file.
 *
 * @function tryWriteFile
 * @since 1.0.0
 * @memberof module:File
 *
 * @param {string} filepath - Path to an existing or new file you want to write to
 * @param {string} data - The data you would like to write to the file
 * @param {string|object} [options='utf8'] - The options object or a string with the encoding
 *
 * @return {promise} A promise that resolves if successfully written to file
 * @example
 * import { tryWriteFile } from 'fenix-tools'
 *
 * tryWriteFile('path/to/file', 'Data to write to file', 'utf8')
 * .then(() => {
 *  // Success writing file to machine
 * })
 *
 */
function tryWriteFile (filepath, data, options = 'utf8') {
  const fs = require('fs')
  return new Promise((resolve, reject) => {
    try {
      fs.writeFile(filepath, data, options, (error) => {
        if (error !== 'undefined' && error !== null) {
          resolve()
        }
      })
    } catch (error) { reject(error) }
  })
}

/**
 * Recursive method that will convert all string values in an object to a more
 * appropriate type.
 *
 * In MV there are a lot of objects filled with strings of different values, a lot
 * of times we need to convert each value manually, instead use this to quickly
 * deep parse each value from string to the correct type.
 *
 * @function convertParameters
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @param {object} parameters - The string filled object you want converted
 *
 * @returns An object with it's string values converted
 * @example
 *
 * const myParams = { p1: '22', p2: 'true' }
 * convertParameters(myParams) // => { p1: 22, p2: true }
 *
 * const myParams = { p1: '{a: 1'1, c: '2'}', p2: '[{}, {}, {}]' }
 * convertParameters(myParams) // => { p1: {a: 1, c: 2}, p2: [{}, {}, {}] }
 *
 */
function convertParameters (parameters) {
  function parseParameters (string) {
    try {
      return JSON.parse(string, (key, value) => {
        try {
          return parseParameters(value)
        } catch (e) {
          return value
        }
      })
    } catch (e) {
      return string
    }
  }
  return parseParameters(JSON.stringify(parameters))
}

/**
 * Extracts the canvas data and returns base64 data generated by PIXI renderer
 * You can use this data in combination with {@link module:File:tryWriteFile|tryWriteFile}
 * to save a screenshot of the entire canvas.
 *
 * @function extractCanvasImage
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @param {number} [quality=0.1] - The quality of the image to produce
 *
 * @returns {string} returns the base64 data string.
 * @example
 * import {extractCanvasImage, tryWriteFile} from 'feni-tools'
 *
 * const canvasData = extractCanvasImage()
 *
 * // Now lets write the data to a file on the machine
 *
 * tryWriteFile(path/to/new/file, canvasData, 'base64')
 *   .then('Success writing screenshot')
 *
 *
 */
function extractCanvasImage (quality = 0.1) {
  const renderer = window.Graphics._renderer
  const stage = renderer._lastObjectRendered
  renderer.render(stage)
  const data = renderer.view.toDataURL('image/png', quality)
  return data
}

/**
 * Uses regex to recursively filter a string.
 *
 * @function filterText
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @param {string} text - The text you would like to filter
 * @param {regex} regex - The regex pattern to use for filtering
 * @param {function} action - The callback function to evaluate
 *
 * @returns {array} An array of groups that match the evaluation
 * @example
 * import {filterText} from 'fenix-tools'
 *
 * const re = /pattern/g
 * const matches = filterText(text, re, (match) => {
 *  console.log(match) // => The full match group returned from regex
 *  // Perform an evaluation to store specific matches
 * })
 *
 */
function filterText (text, regex, action) {
  const result = []
  let match
  const re = regex
  while (match = re.exec(text)) { // eslint-disable-line no-cond-assign
    if (action(match)) {
      result.push(match)
    }
  }
  return result
}

/**
 * Retrieves meta values from an RPG Maker MV object that contains the meta property.
 * Will work with any object that contains a meta property, like $dataWeapons,
 * $dataItems, etc
 *
 * @function getMetaData
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @param  {object} obj - The meta object you want to search through.
 * @param {string}  tag - The meta tag you want to search for.
 *
 * @returns {string} The value(s) of the notetag.
 * @example
 * import { getMetaData } from 'fenix-tools'
 *
 * // $dataActors[1].meta = {myTag: 'myTagValue'}
 *
 * const data = $dataActors[1]
 * const meta = getMetaData(data, 'myTag') // => 'myTagValue'
 *
 */
function getMetaData (obj, tag) {
  const meta = obj.meta
  const match = Object.keys(meta).filter((key) => key.toLowerCase() === tag.toLowerCase())
  const value = meta[match]
  return typeof value === 'string' ? value.trim() : value
}

/**
 * Finds and extracts a notetag from a multiline string of text and returns it's value
 *
 * @function getMultiLineTag
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @param {string} text - The text to evaluate
 * @param {string} tag - The tag to search for in the text
 *
 * @returns {array} - An array of matches containing the values between the tags
 * @example
 * import { getMultiLineTag } from 'fenix-tools'
 *
 * // $dataWeapons[1].note = '<myTag> opt1: value, opt2: value </myTag>'
 *
 * const myNotes = getMultiLineTag($dataWeapons[1].note, 'myTag') // => ['opt1: value, opt2: value']
 *
 */
function getMultiLineTag (text, tag) {
  const result = []
  const re = /<([^<>]+)>([\s\S]*?)<(\/[^<>]+)>/g
  const matches = filterText(text, re, (match) => match[1].toLowerCase() === tag.toLowerCase())
  matches.forEach(group => {
    result.push(group[2].trim())
  })
  return result
}

/**
 * Finds and extracts a notetag from a string of text and returns it's values.
 * Not much different from using {@link module:Utils.getMetaData|getMetaData}, but
 * if you need more control over the string then use this method.
 *
 * @function getTag
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @param {string} text - The text to be evaluated
 * @param {string} tag - The tag to search for in the text
 *
 * @returns {Array} - An array of parameters of the values within the tag <tag: value, value>
 * @example
 * import { getTag } from 'fenix-tools'
 *
 * // $dataActors[1].note = '<myTag: value, value2, value3>'
 *
 * const myTag = getTag($dataActors[1].note, 'myTag') // => 'value, value2, value3'
 *
 *
 */
function getTag (text, tag) {
  if (!text || !tag) { return }
  const result = []
  const re = /<([^<>:]+)(:?)([^>]*)>/g
  const matches = filterText(text, re, (match) => match[1].toLowerCase() === tag.toLowerCase())
  matches.forEach(group => {
    result.push(group[3].trim())
  })
  return result
}

/**
 * Scan all events on map and extract their comments. This can only be used when
 * the map data is available upon map load. It starts by looping through all events
 * in the current map and through each event page storing all comments.
 *
 * @function loadEventComments
 * @since 1.0.0
 * @memberof module:Utils
 *
 * @return {object} An object of all comments added together, sorted by eventId
 *
 * @example
 * const mapEventComments = loadEventComments()
 * // =>  *  // { 28: [param1, param2, param3] }
 *           // { 29: [param1, param2, param3] }
 *
 *
 */
function loadEventComments () {
  const allEvents = window.$dataMap.events
  const meta = {}

  allEvents.filter(event => event)
    .forEach(event => {
      const pages = event.pages
      const eventId = event.id
      const pageComments = []
      pages.forEach((page, index) => {
        const pageId = pages.indexOf(pages[index])
        if (pageId >= -1) {
          let comments = ''
          page.list.forEach(command => {
            if (command.code === 108 || command.code === 408) {
              comments += command.parameters[0]
            }
          })
          if (comments) { pageComments.push(comments) }
        }
      })
      if (pageComments.length > 0) { meta[eventId] = pageComments }
    })
  return meta
}

/** @module File */

export { cleanPath, downloadFile, fileExists, hasWebAccess, loadJSON, loadLocalFile, localFileExists, projectPath, tryWriteFile, webFileExists, convertParameters, extractCanvasImage, filterText, getMetaData, getMultiLineTag, getTag, loadEventComments }
