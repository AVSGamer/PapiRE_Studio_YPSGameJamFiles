import { commons } from '@0xsequence/core';
import { migrator } from '@0xsequence/migration';
import { ethers } from 'ethers';
import { ConfigTracker, PresignedConfig, PresignedConfigLink } from "../tracker.js";
export interface Options {
    readonly namespace?: string;
    readonly owners?: string[];
    readonly arweaveUrl?: string;
    readonly graphqlUrl?: string;
    readonly eip5719Provider?: ethers.Provider;
    readonly rateLimitRetryDelayMs?: number;
}
export declare const defaults: {
    namespace: string;
    owners: string[];
    arweaveUrl: string;
    graphqlUrl: string;
    eip5719Provider: undefined;
    rateLimitRetryDelayMs: number;
};
export declare class ArweaveReader implements ConfigTracker, migrator.PresignedMigrationTracker {
    readonly options: Options;
    private readonly configs;
    private readonly eip5719?;
    constructor(options?: Options);
    loadPresignedConfiguration(args: {
        wallet: string;
        fromImageHash: string;
        longestPath?: boolean;
    }): Promise<PresignedConfigLink[]>;
    savePresignedConfiguration(_args: PresignedConfig): Promise<void>;
    saveWitnesses(_args: {
        wallet: string;
        digest: string;
        chainId: ethers.BigNumberish;
        signatures: string[];
    }): Promise<void>;
    configOfImageHash(args: {
        imageHash: string;
        noCache?: boolean;
    }): Promise<commons.config.Config | undefined>;
    saveWalletConfig(_args: {
        config: commons.config.Config;
    }): Promise<void>;
    imageHashOfCounterfactualWallet(args: {
        wallet: string;
        noCache?: boolean;
    }): Promise<{
        imageHash: string;
        context: commons.context.WalletContext;
    } | undefined>;
    saveCounterfactualWallet(_args: {
        config: commons.config.Config;
        context: commons.context.WalletContext[];
    }): Promise<void>;
    walletsOfSigner(args: {
        signer: string;
        noCache?: boolean;
        allSignatures?: boolean;
    }): Promise<Array<{
        wallet: string;
        proof: {
            digest: string;
            chainId: bigint;
            signature: string;
        };
    }>>;
    getMigration(address: string, fromImageHash: string, fromVersion: number, chainId: ethers.BigNumberish): Promise<migrator.SignedMigration | undefined>;
    saveMigration(_address: string, _signed: migrator.SignedMigration, _contexts: commons.context.VersionedContext): Promise<void>;
}
