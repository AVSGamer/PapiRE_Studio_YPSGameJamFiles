import { sequence } from '0xsequence';
import { UserRejectedRequestError, getAddress } from 'viem';
import { createConnector } from 'wagmi';
import { LocalStorageKey } from '../../constants/localStorage';
sequenceWallet.type = 'sequence';
export function sequenceWallet(params) {
    const { defaultNetwork, connect, walletAppURL } = params;
    const { projectAccessKey } = connect;
    return createConnector(config => ({
        id: 'sequence',
        name: 'Sequence',
        type: sequenceWallet.type,
        params,
        setEmail(email) {
            if (params.connect.settings) {
                params.connect.settings.signInWithEmail = email;
            }
        },
        async setup() {
            const provider = await this.getProvider();
            provider.on('chainChanged', (chainIdHex) => {
                config.emitter.emit('change', { chainId: normalizeChainId(chainIdHex) });
            });
            provider.on('disconnect', () => {
                this.onDisconnect();
            });
        },
        async connect() {
            const provider = await this.getProvider();
            if (!provider.isConnected()) {
                const localStorageTheme = await config.storage?.getItem(LocalStorageKey.Theme);
                const ethAuthSettings = (await config.storage?.getItem(LocalStorageKey.EthAuthSettings)) ?? {};
                const connectOptionsWithTheme = {
                    authorize: true,
                    askForEmail: true,
                    ...ethAuthSettings,
                    ...connect,
                    settings: {
                        theme: localStorageTheme || 'dark',
                        ...connect?.settings
                    }
                };
                const e = await provider.connect(connectOptionsWithTheme);
                if (e.error) {
                    throw new UserRejectedRequestError(new Error(e.error));
                }
                if (!e.connected) {
                    throw new UserRejectedRequestError(new Error('Wallet connection rejected'));
                }
                const proofString = e.proof?.proofString;
                const proofTypedData = e.proof?.typedData;
                if (proofString && proofTypedData) {
                    const jsonEthAuthProof = {
                        proofString,
                        typedData: proofTypedData
                    };
                    await config.storage?.setItem(LocalStorageKey.EthAuthProof, jsonEthAuthProof);
                }
                // Save the email used to sign in
                await config.storage?.setItem(LocalStorageKey.WaasSignInEmail, e.email || null);
            }
            const accounts = await this.getAccounts();
            return {
                accounts: [...accounts],
                chainId: provider.getChainId()
            };
        },
        async disconnect() {
            const provider = await this.getProvider();
            provider.disconnect();
            await config.storage?.removeItem(LocalStorageKey.WaasSignInEmail);
        },
        async getAccounts() {
            const provider = await this.getProvider();
            const signer = provider.getSigner();
            const account = getAddress(await signer.getAddress());
            return [account];
        },
        async getProvider() {
            try {
                const provider = sequence.getWallet();
                return provider;
            }
            catch (err) {
                if (!projectAccessKey) {
                    throw 'projectAccessKey not found';
                }
                const provider = sequence.initWallet(projectAccessKey, {
                    defaultNetwork,
                    transports: {
                        walletAppURL: walletAppURL || 'https://sequence.app'
                    },
                    defaultEIP6492: true,
                    analytics: false
                });
                const chainId = provider.getChainId();
                config.emitter.emit('change', { chainId: normalizeChainId(chainId) });
                return provider;
            }
        },
        async isAuthorized() {
            try {
                const account = await this.getAccounts();
                return !!account;
            }
            catch (e) {
                return false;
            }
        },
        async switchChain({ chainId }) {
            const provider = await this.getProvider();
            const chain = config.chains.find(c => c.id === chainId) || config.chains[0];
            provider.setDefaultChainId(normalizeChainId(chainId));
            config.emitter.emit('change', { chainId });
            return chain;
        },
        async getChainId() {
            const provider = await this.getProvider();
            const chainId = provider.getChainId();
            return chainId;
        },
        async onAccountsChanged(accounts) {
            return { account: accounts[0] };
        },
        async onChainChanged(chain) {
            const provider = await this.getProvider();
            config.emitter.emit('change', { chainId: normalizeChainId(chain) });
            provider.setDefaultChainId(normalizeChainId(chain));
        },
        async onConnect(_connectinfo) { },
        async onDisconnect() {
            await config.storage?.removeItem(LocalStorageKey.EthAuthProof);
            config.emitter.emit('disconnect');
        }
    }));
}
function normalizeChainId(chainId) {
    if (typeof chainId === 'object')
        return normalizeChainId(chainId.chainId);
    if (typeof chainId === 'string')
        return Number.parseInt(chainId, chainId.trim().substring(0, 2) === '0x' ? 16 : 10);
    if (typeof chainId === 'bigint')
        return Number(chainId);
    return chainId;
}
//# sourceMappingURL=sequenceConnector.js.map