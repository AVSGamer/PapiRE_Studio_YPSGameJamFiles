'use client';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { sequence } from '0xsequence';
import { Box, Button, Card, Collapsible, Modal, ModalPrimitive, Text, ThemeProvider } from '@0xsequence/design-system';
import { ChainId } from '@0xsequence/network';
import { GoogleOAuthProvider } from '@react-oauth/google';
import { ethers } from 'ethers';
import { AnimatePresence } from 'framer-motion';
import { useState, useEffect } from 'react';
import { useAccount, useConfig, useConnections } from 'wagmi';
import { DEFAULT_SESSION_EXPIRATION, LocalStorageKey } from '../../constants';
import { AnalyticsContextProvider } from '../../contexts/Analytics';
import { ConnectModalContextProvider } from '../../contexts/ConnectModal';
import { KitConfigContextProvider } from '../../contexts/KitConfig';
import { ThemeContextProvider } from '../../contexts/Theme';
import { WalletConfigContextProvider } from '../../contexts/WalletSettings';
import { useStorage } from '../../hooks/useStorage';
import { useWaasConfirmationHandler } from '../../hooks/useWaasConfirmationHandler';
import { useEmailConflict } from '../../hooks/useWaasEmailConflict';
import { getModalPositionCss } from '../../utils/styling';
import { ConnectWalletContent } from '../Connect';
import { NetworkBadge } from '../NetworkBadge';
import { PageHeading } from '../PageHeading';
import { PoweredBySequence } from '../SequenceLogo';
import { TxnDetails } from '../TxnDetails';
export const KitProvider = (props) => {
    const { config, children } = props;
    const { defaultTheme = 'dark', signIn = {}, position = 'center', displayedAssets: displayedAssetsSetting = [], ethAuth = {}, disableAnalytics = false } = config;
    const defaultAppName = signIn.projectName || 'app';
    const { expiry = DEFAULT_SESSION_EXPIRATION, app = defaultAppName, origin, nonce } = ethAuth;
    const [openConnectModal, setOpenConnectModal] = useState(false);
    const [theme, setTheme] = useState(defaultTheme || 'dark');
    const [modalPosition, setModalPosition] = useState(position);
    const [displayedAssets, setDisplayedAssets] = useState(displayedAssetsSetting);
    const [analytics, setAnalytics] = useState();
    const { address, isConnected } = useAccount();
    const wagmiConfig = useConfig();
    const storage = useStorage();
    const connections = useConnections();
    const waasConnector = connections.find(c => c.connector.id.includes('waas'))?.connector;
    const [pendingRequestConfirmation, confirmPendingRequest, rejectPendingRequest] = useWaasConfirmationHandler(waasConnector);
    const googleWaasConnector = wagmiConfig.connectors.find(c => c.id === 'sequence-waas' && c._wallet.id === 'google-waas');
    const googleClientId = googleWaasConnector?.params?.googleClientId || '';
    const setupAnalytics = (projectAccessKey) => {
        const s = sequence.initWallet(projectAccessKey);
        const sequenceAnalytics = s.client.analytics;
        setAnalytics(sequenceAnalytics);
    };
    useEffect(() => {
        if (!isConnected) {
            analytics?.reset();
            return;
        }
        if (address) {
            analytics?.identify(address.toLowerCase());
        }
    }, [analytics, address, isConnected]);
    useEffect(() => {
        if (!disableAnalytics) {
            setupAnalytics(config.projectAccessKey);
        }
    }, []);
    useEffect(() => {
        if (theme !== defaultTheme) {
            setTheme(defaultTheme);
        }
    }, [defaultTheme]);
    useEffect(() => {
        if (modalPosition !== position) {
            setModalPosition(position);
        }
    }, [position]);
    // Write data in local storage for retrieval in connectors
    useEffect(() => {
        // Theme
        // TODO: set the sequence theme once it is added to connect options
        if (typeof theme === 'object') {
            // localStorage.setItem(LocalStorageKey.Theme, JSON.stringify(theme))
        }
        else {
            localStorage.setItem(LocalStorageKey.Theme, theme);
        }
        // EthAuth
        // note: keep an eye out for potential race-conditions, though they shouldn't occur.
        // If there are race conditions, the settings could be a function executed prior to being passed to wagmi
        storage?.setItem(LocalStorageKey.EthAuthSettings, {
            expiry,
            app,
            origin: origin || location.origin,
            nonce
        });
    }, [theme, ethAuth]);
    useEffect(() => {
        setDisplayedAssets(displayedAssets);
    }, [displayedAssetsSetting]);
    const { isEmailConflictOpen, emailConflictInfo, toggleEmailConflictModal } = useEmailConflict();
    return (_jsx(KitConfigContextProvider, { value: config, children: _jsx(ThemeContextProvider, { value: {
                theme,
                setTheme,
                position: modalPosition,
                setPosition: setModalPosition
            }, children: _jsx(GoogleOAuthProvider, { clientId: googleClientId, children: _jsx(ConnectModalContextProvider, { value: { setOpenConnectModal, openConnectModalState: openConnectModal }, children: _jsx(WalletConfigContextProvider, { value: { setDisplayedAssets, displayedAssets }, children: _jsxs(AnalyticsContextProvider, { value: { setAnalytics, analytics }, children: [_jsx("div", { id: "kit-provider", children: _jsx(ThemeProvider, { root: "#kit-provider", scope: "kit", theme: theme, children: _jsxs(AnimatePresence, { children: [openConnectModal && (_jsx(Modal, { scroll: false, backdropColor: "backgroundBackdrop", size: "sm", contentProps: {
                                                        style: {
                                                            maxWidth: '364px',
                                                            overflow: 'visible',
                                                            ...getModalPositionCss(position)
                                                        }
                                                    }, onClose: () => setOpenConnectModal(false), children: _jsx(ConnectWalletContent, { onClose: () => setOpenConnectModal(false), emailConflictInfo: emailConflictInfo, ...props }) })), pendingRequestConfirmation && (_jsx(Modal, { scroll: false, backdropColor: "backgroundBackdrop", size: "sm", contentProps: {
                                                        style: {
                                                            maxWidth: '364px',
                                                            ...getModalPositionCss(position)
                                                        }
                                                    }, isDismissible: false, onClose: () => {
                                                        rejectPendingRequest('');
                                                    }, children: _jsxs(Box, { paddingX: "4", paddingTop: "4", paddingBottom: "2", children: [_jsxs(Box, { flexDirection: "column", justifyContent: "center", color: "text100", alignItems: "center", fontWeight: "medium", style: {
                                                                    marginTop: '4px'
                                                                }, children: [_jsx(ModalPrimitive.Title, { asChild: true, children: _jsxs(Text, { as: "h1", variant: "large", marginBottom: "5", children: ["Confirm ", pendingRequestConfirmation.type === 'signMessage' ? 'signing message' : 'transaction'] }) }), pendingRequestConfirmation.type === 'signMessage' && (_jsxs(Box, { flexDirection: "column", width: "full", children: [_jsx(Text, { variant: "normal", color: "text50", fontWeight: "medium", children: "Message" }), _jsx(Card, { marginTop: "2", paddingY: "6", children: _jsx(Text, { variant: "normal", marginBottom: "4", children: ethers.toUtf8String(pendingRequestConfirmation.message ?? '') }) })] })), pendingRequestConfirmation.type === 'signTransaction' && (_jsxs(Box, { flexDirection: "column", width: "full", children: [_jsx(TxnDetails, { address: address ?? '', txs: pendingRequestConfirmation.txs ?? [], chainId: pendingRequestConfirmation.chainId ?? ChainId.POLYGON }), _jsx(Collapsible, { label: "Transaction data", marginTop: "4", children: _jsx(Card, { overflowX: "scroll", marginY: "3", children: _jsx(Text, { variant: "code", marginBottom: "4", children: JSON.stringify(pendingRequestConfirmation.txs, null, 2) }) }) })] })), pendingRequestConfirmation.chainId && (_jsxs(Box, { width: "full", marginTop: "3", justifyContent: "flex-end", alignItems: "center", children: [_jsx(Box, { width: "1/2", justifyContent: "flex-start", children: _jsx(Text, { variant: "small", color: "text50", children: "Network" }) }), _jsx(Box, { width: "1/2", justifyContent: "flex-end", children: _jsx(NetworkBadge, { chainId: pendingRequestConfirmation.chainId }) })] })), _jsxs(Box, { flexDirection: "row", gap: "2", width: "full", marginTop: "5", children: [_jsx(Button, { width: "full", shape: "square", size: "lg", label: "Reject", onClick: () => {
                                                                                    rejectPendingRequest(pendingRequestConfirmation?.id);
                                                                                } }), _jsx(Button, { alignItems: "center", textAlign: "center", width: "full", shape: "square", size: "lg", label: "Confirm", variant: "primary", onClick: () => {
                                                                                    confirmPendingRequest(pendingRequestConfirmation?.id);
                                                                                } })] })] }), _jsx(PoweredBySequence, {})] }) })), isEmailConflictOpen && emailConflictInfo && (_jsx(Modal, { size: "sm", scroll: false, onClose: () => toggleEmailConflictModal(false), children: _jsxs(Box, { padding: "4", children: [_jsx(ModalPrimitive.Title, { asChild: true, children: _jsx(PageHeading, { children: "Email already in use" }) }), _jsxs(Box, { children: [_jsxs(Text, { variant: "normal", color: "text80", textAlign: "center", children: ["Another account with this email address ", _jsxs(Text, { color: "text100", children: ["(", emailConflictInfo.email, ")"] }), ' ', "already exists with account type ", _jsxs(Text, { color: "text100", children: ["(", emailConflictInfo.type, ")"] }), ". Please sign in again with the correct account."] }), _jsx(Box, { marginTop: "4", gap: "2", alignItems: "center", justifyContent: "center", children: _jsx(Button, { label: "OK", onClick: () => toggleEmailConflictModal(false) }) })] })] }) }))] }) }) }), children] }) }) }) }) }) }));
};
//# sourceMappingURL=KitProvider.js.map