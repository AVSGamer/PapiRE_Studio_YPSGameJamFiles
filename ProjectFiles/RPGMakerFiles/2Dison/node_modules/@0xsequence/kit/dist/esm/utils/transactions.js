import { sequence } from '0xsequence';
import { TRANSACTION_CONFIRMATIONS_DEFAULT } from '../constants';
export const sendTransactions = async ({ chainId, senderAddress, publicClient, walletClient, connector, transactions, transactionConfirmations = TRANSACTION_CONFIRMATIONS_DEFAULT, waitConfirmationForLastTransaction = true }) => {
    const walletClientChainId = await walletClient.getChainId();
    if (walletClientChainId !== chainId) {
        throw new Error('The Wallet Client is using the wrong network');
    }
    if (publicClient.chain?.id !== chainId) {
        throw new Error('The Public Client is using the wrong network');
    }
    const sequenceWaaS = connector?.['sequenceWaas'];
    const isEmbeddedWallet = !!sequenceWaaS;
    const isSequenceUniversalWallet = !!connector?._wallet?.isSequenceBased;
    // Sequence WaaS
    if (isEmbeddedWallet) {
        // waas connector logic
        const resp = await sequenceWaaS.feeOptions({
            transactions: transactions,
            network: chainId
        });
        const transactionsFeeOption = resp.data.feeOptions[0];
        const transactionsFeeQuote = resp.data.feeQuote;
        const response = await sequenceWaaS.sendTransaction({
            transactions,
            transactionsFeeOption,
            transactionsFeeQuote,
            network: chainId
        });
        if (response.code === 'transactionFailed') {
            throw new Error(response.data.error);
        }
        const txnHash = response.data.txHash;
        if (waitConfirmationForLastTransaction) {
            await publicClient.waitForTransactionReceipt({
                hash: txnHash,
                confirmations: transactionConfirmations,
            });
        }
        return txnHash;
        // Sequence-Based Connector
    }
    else if (isSequenceUniversalWallet) {
        const wallet = sequence.getWallet();
        const signer = wallet.getSigner();
        const response = await signer.sendTransaction(transactions);
        if (waitConfirmationForLastTransaction) {
            await publicClient.waitForTransactionReceipt({
                hash: response.hash,
                confirmations: transactionConfirmations
            });
        }
        return response.hash;
        // Other connectors (metamask, eip-6963, etc...)
    }
    else {
        let txHash = '';
        // We fire the transactions one at a time since the cannot be batched
        for (const [index, transaction] of transactions.entries()) {
            const txnHash = await walletClient.sendTransaction({
                account: senderAddress,
                to: transaction.to,
                value: transaction?.value,
                data: transaction?.data,
                chain: undefined
            });
            const isLastTransaction = index === transactions.length - 1;
            if (!isLastTransaction || (isLastTransaction && waitConfirmationForLastTransaction)) {
                await publicClient.waitForTransactionReceipt({
                    hash: txnHash,
                    confirmations: transactionConfirmations
                });
            }
            // The transaction hash of the last transaction is the one that should be returned
            txHash = txnHash;
        }
        return txHash;
    }
};
//# sourceMappingURL=transactions.js.map