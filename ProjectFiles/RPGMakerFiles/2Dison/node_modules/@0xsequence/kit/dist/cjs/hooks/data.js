"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSwapQuote = exports.useSwapPrices = exports.useTransactionHistory = exports.getTransactionHistory = exports.useContractInfo = exports.useTokenMetadata = exports.useCollectiblePrices = exports.getCollectiblePrices = exports.useCoinPrices = exports.getCoinPrices = exports.useExchangeRate = exports.useCollectionBalance = exports.getCollectionBalance = exports.useCollectibleBalance = exports.useCoinBalance = exports.useBalances = exports.getBalances = exports.getTokenBalances = exports.getNativeTokenBalance = exports.time = void 0;
const indexer_1 = require("@0xsequence/indexer");
const network_1 = require("@0xsequence/network");
const react_query_1 = require("@tanstack/react-query");
const viem_1 = require("viem");
const helpers_1 = require("../utils/helpers");
const constants_1 = require("../constants");
const useAPIClient_1 = require("./useAPIClient");
const useIndexerClient_1 = require("./useIndexerClient");
const useMetadataClient_1 = require("./useMetadataClient");
exports.time = {
    oneSecond: 1 * 1000,
    oneMinute: 60 * 1000,
    oneHour: 60 * 60 * 1000
};
const getNativeTokenBalance = async (indexerClient, chainId, accountAddress) => {
    const res = await indexerClient.getEtherBalance({ accountAddress });
    const tokenBalance = {
        chainId,
        contractAddress: viem_1.zeroAddress,
        accountAddress,
        balance: res?.balance.balanceWei || '0',
        contractType: indexer_1.ContractType.UNKNOWN,
        blockHash: '',
        blockNumber: 0,
        tokenID: '',
        uniqueCollectibles: '',
        isSummary: false
    };
    return tokenBalance;
};
exports.getNativeTokenBalance = getNativeTokenBalance;
const getTokenBalances = async (indexerClient, args) => {
    const res = await indexerClient.getTokenBalances({
        accountAddress: args.accountAddress,
        includeMetadata: args.includeMetadata ?? true,
        metadataOptions: {
            verifiedOnly: args.verifiedOnly ?? true
        },
        ...(args.contractAddress && { contractAddress: args.contractAddress })
    });
    return res?.balances || [];
};
exports.getTokenBalances = getTokenBalances;
const getBalances = async (indexerClient, chainId, args) => {
    if (!args.accountAddress) {
        return [];
    }
    const balances = (await Promise.allSettled([
        (0, exports.getNativeTokenBalance)(indexerClient, chainId, args.accountAddress),
        (0, exports.getTokenBalances)(indexerClient, args)
    ]))
        .map(res => (res.status === 'fulfilled' ? res.value : []))
        .flat();
    return balances;
};
exports.getBalances = getBalances;
// Gets native and token balances
const useBalances = ({ chainIds, ...args }) => {
    const indexerClients = (0, useIndexerClient_1.useIndexerClients)(chainIds);
    return (0, react_query_1.useQuery)({
        queryKey: ['balances', chainIds, args],
        queryFn: async () => {
            const res = (await Promise.all(Array.from(indexerClients.entries()).map(([chainId, indexerClient]) => (0, exports.getBalances)(indexerClient, chainId, args)))).flat();
            return res;
        },
        retry: true,
        staleTime: exports.time.oneSecond * 30,
        enabled: chainIds.length > 0 && !!args.accountAddress
    });
};
exports.useBalances = useBalances;
const useCoinBalance = (args) => {
    const indexerClient = (0, useIndexerClient_1.useIndexerClient)(args.chainId);
    return (0, react_query_1.useQuery)({
        queryKey: ['coinBalance', args],
        queryFn: async () => {
            if ((0, helpers_1.compareAddress)(args?.contractAddress || '', viem_1.zeroAddress)) {
                const res = await (0, exports.getNativeTokenBalance)(indexerClient, args.chainId, args.accountAddress);
                return res;
            }
            else {
                const res = await (0, exports.getTokenBalances)(indexerClient, args);
                return res[0];
            }
        },
        retry: true,
        staleTime: exports.time.oneSecond * 30,
        enabled: !!args.chainId && !!args.accountAddress
    });
};
exports.useCoinBalance = useCoinBalance;
const useCollectibleBalance = (args) => {
    const indexerClient = (0, useIndexerClient_1.useIndexerClient)(args.chainId);
    return (0, react_query_1.useQuery)({
        queryKey: ['collectibleBalance', args],
        queryFn: async () => {
            const res = await indexerClient.getTokenBalances({
                accountAddress: args.accountAddress,
                contractAddress: args.contractAddress,
                tokenID: args.tokenId,
                includeMetadata: true,
                metadataOptions: {
                    verifiedOnly: args.verifiedOnly ?? true
                }
            });
            return res.balances[0];
        },
        retry: true,
        staleTime: exports.time.oneSecond * 30,
        enabled: !!args.chainId && !!args.accountAddress && !!args.contractAddress && !!args.tokenId
    });
};
exports.useCollectibleBalance = useCollectibleBalance;
const getCollectionBalance = async (indexerClient, args) => {
    const res = await indexerClient.getTokenBalances({
        accountAddress: args.accountAddress,
        contractAddress: args.contractAddress,
        includeMetadata: args.includeMetadata ?? true,
        metadataOptions: {
            verifiedOnly: args.verifiedOnly ?? true
        }
    });
    return res?.balances || [];
};
exports.getCollectionBalance = getCollectionBalance;
const useCollectionBalance = (args) => {
    const indexerClient = (0, useIndexerClient_1.useIndexerClient)(args.chainId);
    return (0, react_query_1.useQuery)({
        queryKey: ['collectionBalance', args],
        queryFn: () => (0, exports.getCollectionBalance)(indexerClient, args),
        retry: true,
        staleTime: exports.time.oneSecond * 30,
        enabled: !!args.chainId && !!args.accountAddress && !!args.contractAddress
    });
};
exports.useCollectionBalance = useCollectionBalance;
// From USD to another currency
const useExchangeRate = (toCurrency) => {
    const apiClient = (0, useAPIClient_1.useAPIClient)();
    return (0, react_query_1.useQuery)({
        queryKey: ['exchangeRate', toCurrency],
        queryFn: async () => {
            if (toCurrency === 'USD') {
                return 1;
            }
            const res = await apiClient.getExchangeRate({ toCurrency });
            return res.exchangeRate.value;
        },
        retry: true,
        staleTime: exports.time.oneMinute * 10
    });
};
exports.useExchangeRate = useExchangeRate;
const getCoinPrices = async (apiClient, tokens) => {
    if (tokens.length === 0) {
        return [];
    }
    const res = await apiClient.getCoinPrices({ tokens });
    return res?.tokenPrices || [];
};
exports.getCoinPrices = getCoinPrices;
const useCoinPrices = (tokens, disabled) => {
    const apiClient = (0, useAPIClient_1.useAPIClient)();
    return (0, react_query_1.useQuery)({
        queryKey: ['coinPrices', tokens],
        queryFn: () => (0, exports.getCoinPrices)(apiClient, tokens),
        retry: true,
        staleTime: exports.time.oneMinute,
        enabled: tokens.length > 0 && !disabled
    });
};
exports.useCoinPrices = useCoinPrices;
const getCollectiblePrices = async (apiClient, tokens) => {
    if (tokens.length === 0) {
        return [];
    }
    const res = await apiClient.getCollectiblePrices({ tokens });
    return res?.tokenPrices || [];
};
exports.getCollectiblePrices = getCollectiblePrices;
const useCollectiblePrices = (tokens) => {
    const apiClient = (0, useAPIClient_1.useAPIClient)();
    return (0, react_query_1.useQuery)({
        queryKey: ['useCollectiblePrices', tokens],
        queryFn: () => (0, exports.getCollectiblePrices)(apiClient, tokens),
        retry: true,
        staleTime: exports.time.oneMinute,
        enabled: tokens.length > 0
    });
};
exports.useCollectiblePrices = useCollectiblePrices;
const useTokenMetadata = (chainId, contractAddress, tokenIds, disabled) => {
    const metadataClient = (0, useMetadataClient_1.useMetadataClient)();
    return (0, react_query_1.useQuery)({
        queryKey: ['tokenMetadata', chainId, contractAddress, tokenIds],
        queryFn: async () => {
            const res = await metadataClient.getTokenMetadata({
                chainID: String(chainId),
                contractAddress,
                tokenIDs: tokenIds
            });
            return res.tokenMetadata;
        },
        retry: true,
        staleTime: exports.time.oneMinute * 10,
        enabled: !!chainId && !!contractAddress && !disabled
    });
};
exports.useTokenMetadata = useTokenMetadata;
const useContractInfo = (chainId, contractAddress, disabled) => {
    const metadataClient = (0, useMetadataClient_1.useMetadataClient)();
    return (0, react_query_1.useQuery)({
        queryKey: ['contractInfo', chainId, contractAddress],
        queryFn: async () => {
            const isNativeToken = (0, helpers_1.compareAddress)(viem_1.zeroAddress, contractAddress);
            const res = await metadataClient.getContractInfo({
                chainID: String(chainId),
                contractAddress
            });
            const network = (0, network_1.findSupportedNetwork)(chainId);
            return {
                ...res.contractInfo,
                ...(isNativeToken && network
                    ? {
                        ...network.nativeToken,
                        logoURI: network.logoURI
                    }
                    : {})
            };
        },
        retry: true,
        staleTime: exports.time.oneMinute * 10,
        enabled: !!chainId && !!contractAddress && !disabled
    });
};
exports.useContractInfo = useContractInfo;
const getTransactionHistory = async (indexerClient, { contractAddress, accountAddress, tokenId, page }) => {
    const res = indexerClient.getTransactionHistory({
        includeMetadata: true,
        page,
        filter: {
            accountAddress,
            contractAddress,
            tokenID: tokenId
        }
    });
    return res;
};
exports.getTransactionHistory = getTransactionHistory;
const useTransactionHistory = (args) => {
    const indexerClient = (0, useIndexerClient_1.useIndexerClient)(args.chainId);
    return (0, react_query_1.useInfiniteQuery)({
        queryKey: ['transactionHistory', args],
        queryFn: ({ pageParam }) => {
            return (0, exports.getTransactionHistory)(indexerClient, {
                ...args,
                page: { page: pageParam }
            });
        },
        getNextPageParam: ({ page }) => {
            // Note: must return undefined instead of null to stop the infinite scroll
            if (!page.more) {
                return undefined;
            }
            return page?.page || 1;
        },
        initialPageParam: 1,
        retry: true,
        staleTime: exports.time.oneSecond * 30,
        enabled: !!args.chainId && !!args.accountAddress
    });
};
exports.useTransactionHistory = useTransactionHistory;
const getSwapPrices = async (apiClient, metadataClient, indexerClient, args) => {
    if (!args.chainId || !args.userAddress || !args.buyCurrencyAddress || !args.buyAmount || args.buyAmount === '0') {
        return [];
    }
    try {
        const network = (0, network_1.findSupportedNetwork)(args.chainId);
        const { withContractInfo, ...swapPricesArgs } = args;
        const res = await apiClient.getSwapPrices({
            ...swapPricesArgs,
        });
        if (res.swapPrices === null) {
            return [];
        }
        const currencyInfoMap = new Map();
        if (withContractInfo) {
            res?.swapPrices.forEach(price => {
                const { currencyAddress } = price;
                const isNativeToken = (0, helpers_1.compareAddress)(currencyAddress, constants_1.NATIVE_TOKEN_ADDRESS_0X);
                if (currencyAddress && !currencyInfoMap.has(currencyAddress)) {
                    currencyInfoMap.set(currencyAddress, metadataClient
                        .getContractInfo({
                        chainID: String(args.chainId),
                        contractAddress: currencyAddress
                    })
                        .then(data => {
                        return ({
                            ...data.contractInfo,
                            ...(isNativeToken ? {
                                ...network?.nativeToken,
                                logoURI: network?.logoURI || ''
                            } : {})
                        });
                    }));
                }
            });
        }
        const currencyBalanceInfoMap = new Map();
        res?.swapPrices.forEach(price => {
            const { currencyAddress } = price;
            const isNativeToken = (0, helpers_1.compareAddress)(currencyAddress, constants_1.NATIVE_TOKEN_ADDRESS_0X);
            if (currencyAddress && !currencyBalanceInfoMap.has(currencyAddress)) {
                currencyBalanceInfoMap.set(currencyAddress, isNativeToken ?
                    indexerClient.getEtherBalance({
                        accountAddress: args.userAddress
                    }).then(res => ({
                        balance: res.balance.balanceWei
                    }))
                    :
                        indexerClient
                            .getTokenBalances({
                            accountAddress: args.userAddress,
                            contractAddress: currencyAddress,
                            includeMetadata: false,
                            metadataOptions: {
                                verifiedOnly: true
                            }
                        })
                            .then(balances => {
                            return ({
                                balance: balances.balances?.[0].balance || '0'
                            });
                        }));
            }
        });
        return Promise.all(res?.swapPrices.map(async (price) => ({
            price,
            info: (await currencyInfoMap.get(price.currencyAddress)) || undefined,
            balance: (await currencyBalanceInfoMap.get(price.currencyAddress)) || { balance: '0' }
        })) || []);
    }
    catch (e) {
        console.error(e);
        return [];
    }
};
const useSwapPrices = (args, options) => {
    const apiClient = (0, useAPIClient_1.useAPIClient)();
    const metadataClient = (0, useMetadataClient_1.useMetadataClient)();
    const indexerClient = (0, useIndexerClient_1.useIndexerClient)(args.chainId);
    const enabled = !!args.chainId && !!args.userAddress && !!args.buyCurrencyAddress && !!args.buyAmount && args.buyAmount !== '0' && !options.disabled;
    return (0, react_query_1.useQuery)({
        queryKey: ['swapPrices', args],
        queryFn: () => getSwapPrices(apiClient, metadataClient, indexerClient, args),
        retry: true,
        // We must keep a long staletime to avoid the list of quotes being refreshed while the user is doing the transactions
        // Instead, we will invalidate the query manually
        staleTime: exports.time.oneHour,
        enabled
    });
};
exports.useSwapPrices = useSwapPrices;
const useSwapQuote = (args, options) => {
    const apiClient = (0, useAPIClient_1.useAPIClient)();
    const { disabled = false } = options;
    return (0, react_query_1.useQuery)({
        queryKey: ['useSwapQuote', args],
        queryFn: async () => {
            const res = await apiClient.getSwapQuote(args);
            return res.swapQuote;
        },
        retry: true,
        staleTime: exports.time.oneMinute * 1,
        enabled: !disabled || !args.userAddress || !args.chainId || !args.buyCurrencyAddress
    });
};
exports.useSwapQuote = useSwapQuote;
//# sourceMappingURL=data.js.map