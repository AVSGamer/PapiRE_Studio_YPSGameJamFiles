"use client";
"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
const ReactDOM = require("react-dom");
const framerMotion = require("framer-motion");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
const ReactDOM__namespace = /* @__PURE__ */ _interopNamespaceDefault(ReactDOM);
const borderWidths = {
  none: "0",
  thin: "0.075rem",
  thick: "0.125rem"
};
const radii = {
  none: "0",
  xs: "0.25rem",
  // 4px
  sm: "0.5rem",
  // 8px
  md: "0.75rem",
  // 12px
  lg: "1rem",
  // 16px
  circle: "9999px"
};
const defaultColors = {
  black: "#000000",
  white: "#ffffff",
  inherit: "inherit",
  transparent: "transparent",
  positive: "#1FC266",
  negative: "#C2501F",
  info: "#0076CC",
  warning: "#F4B03E",
  gradientBackdrop: `linear-gradient(
    243.18deg, 
    rgba(86, 52, 189, 0.85) 0%, 
    rgba(49, 41, 223, 0.85) 63.54%, 
    rgba(7, 98, 149, 0.85) 100%
  )`,
  gradientPrimary: `linear-gradient(89.69deg, #4411E1 0.27%, #7537F9 99.73%)`,
  gradientSecondary: `linear-gradient(32.51deg, #951990 -15.23%, #3A35B1 48.55%, #20A8B0 100%)`,
  arbitrumDark: "#212D44",
  arbitrumLight: "#93D4FF",
  avalanceDark: "#810C0C",
  avalanceLight: "#FF8080",
  bscDark: "#584508",
  bscLight: "#FCCF43",
  ethereumDark: "#132362",
  ethereumLight: "#AABBFF",
  gnosisDark: "#084246",
  gnosisLight: "#8CF6FD",
  polygonDark: "#350881",
  polygonLight: "#C7A6FF"
};
const dark = {
  ...defaultColors,
  text100: "rgba(255, 255, 255, 1)",
  text80: "rgba(255, 255, 255, 0.8)",
  text50: "rgba(255, 255, 255, 0.5)",
  textInverse100: "rgba(0, 0, 0, 1)",
  backgroundPrimary: "rgba(0, 0, 0, 1)",
  backgroundSecondary: "rgba(255, 255, 255, 0.1)",
  backgroundContrast: "rgba(0, 0, 0, 0.5)",
  backgroundMuted: "rgba(255, 255, 255, 0.05)",
  backgroundControl: "rgba(255, 255, 255, 0.25)",
  backgroundInverse: "rgba(255, 255, 255, 1)",
  backgroundBackdrop: "rgba(34, 34, 34, 0.9)",
  backgroundOverlay: "rgba(0, 0, 0, 0.7)",
  backgroundRaised: "rgba(54, 54, 54, 0.7)",
  buttonGlass: "rgba(255, 255, 255, 0.15)",
  buttonEmphasis: "rgba(0, 0, 0, 0.5)",
  buttonInverse: "rgba(255, 255, 255, 0.8)",
  borderNormal: "rgba(255, 255, 255, 0.25)",
  borderFocus: "rgba(255, 255, 255, 0.5)"
};
const light = {
  ...defaultColors,
  text100: "rgba(0, 0, 0, 1)",
  text80: "rgba(0, 0, 0, 0.8)",
  text50: "rgba(0, 0, 0, 0.5)",
  textInverse100: "rgba(255, 255, 255, 1)",
  backgroundPrimary: "rgba(244, 244, 244, 1)",
  backgroundSecondary: "rgba(0, 0, 0, 0.1)",
  backgroundContrast: "rgba(244, 244, 244, 0.5)",
  backgroundMuted: "rgba(0, 0, 0, 0.05)",
  backgroundControl: "rgba(0, 0, 0, 0.25)",
  backgroundInverse: "rgba(0, 0, 0, 1)",
  backgroundBackdrop: "rgba(221, 221, 221, 0.9)",
  backgroundOverlay: "rgba(244, 244, 244, 0.7)",
  backgroundRaised: "rgba(192, 192, 192, 0.7)",
  buttonGlass: "rgba(0, 0, 0, 0.15)",
  buttonEmphasis: "rgba(255, 255, 255, 0.5)",
  buttonInverse: "rgba(0, 0, 0, 0.8)",
  borderNormal: "rgba(0, 0, 0, 0.25)",
  borderFocus: "rgba(0, 0, 0, 0.5)"
};
const palettes = {
  grey: {
    50: "#D1D1D1",
    100: "#B0B0B0",
    200: "#888888",
    300: "#6D6D6D",
    400: "#5D5D5D",
    500: "#4F4F4F",
    600: "#454545",
    700: "#3D3D3D",
    800: "#262626",
    900: "#1B1B1B",
    950: "#101010"
  },
  red: {
    50: "#FDF7EF",
    100: "#FBECD9",
    200: "#F6D7B2",
    300: "#F1BB80",
    400: "#EA954D",
    500: "#E5792A",
    600: "#D66020",
    700: "#C2501F",
    800: "#8E3B1E",
    900: "#72331C",
    950: "#3E170C"
  },
  green: {
    50: "#F0FDF5",
    100: "#DCFCE9",
    200: "#BAF8D4",
    300: "#85F0B3",
    400: "#48E089",
    500: "#1FC266",
    600: "#14A554",
    700: "#148144",
    800: "#156639",
    900: "#135431",
    950: "#042F19"
  },
  yellow: {
    50: "#FBFAEB",
    100: "#F6F2CB",
    200: "#EFE499",
    300: "#E5CE5F",
    400: "#DDB938",
    500: "#CDA125",
    600: "#B07E1E",
    700: "#8D5C1B",
    800: "#754A1E",
    900: "#653F1E",
    950: "#3A200E"
  },
  blue: {
    50: "#F0F8FF",
    100: "#E0F0FE",
    200: "#B9E0FE",
    300: "#7CC8FD",
    400: "#36AEFA",
    500: "#0C94EB",
    600: "#0076CC",
    700: "#015CA3",
    800: "#064F86",
    900: "#0B426F",
    950: "#072A4A"
  },
  indigo: {
    50: "#F2F2FF",
    100: "#E9E7FF",
    200: "#D3D1FF",
    300: "#B3ADFF",
    400: "#8E7EFF",
    500: "#6A4AFF",
    600: "#5826FF",
    700: "#4411E1",
    800: "#3D10C7",
    900: "#340FA3",
    950: "#1C066F"
  },
  violet: {
    50: "#F3F2FF",
    100: "#EBE8FF",
    200: "#D9D3FF",
    300: "#BDB0FF",
    400: "#9D84FF",
    500: "#7F52FF",
    600: "#7537F9",
    700: "#601CE5",
    800: "#5117C0",
    900: "#43159D",
    950: "#270A6B"
  }
};
const colors = {
  dark,
  light,
  palettes
};
const blur = {
  blur: "blur(12.5px)",
  none: "none"
};
const opacity = {
  "0": "0",
  "50": "0.5",
  "80": "0.8",
  "100": "1"
};
const space = {
  "0": "0",
  // 0px
  "0.25": "0.0625rem",
  // 1px
  "0.5": "0.125rem",
  // 2px
  "1": "0.25rem",
  // 4px
  "1.5": "0.375rem",
  // 6px
  "2": "0.5rem",
  // 8px
  "3": "0.75rem",
  // 12px
  "4": "1rem",
  // 16px
  "5": "1.25rem",
  // 20px
  "6": "1.5rem",
  // 24px
  "7": "1.75rem",
  // 28px
  "8": "2rem",
  // 32px
  "9": "2.25rem",
  // 36px
  "10": "2.5rem",
  // 40px
  "12": "3rem",
  // 48px
  "14": "3.5rem",
  // 56px
  "16": "4rem",
  // 64px
  "18": "4.5rem",
  // 72px
  "20": "5rem"
  // 80px
};
const fonts = {
  inherit: "inherit",
  body: `Inter, system-ui, Roboto, "Helvetica Neue", Arial`,
  mono: `"iAWriter Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`
};
const fontSizes = {
  inherit: "inherit",
  xsmall: "0.625rem",
  // 10px
  small: "0.75rem",
  // 12px
  normal: "0.875rem",
  // 14px
  medium: "1rem",
  // 16px
  large: "1.25rem",
  // 20px
  xlarge: "1.875rem"
  // 30px
};
const fontWeights = {
  inherit: "inherit",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700"
};
const letterSpacings = {
  inherit: "inherit",
  none: "0",
  normal: "0.01em",
  wide: "0.03em"
};
const lineHeights = {
  inherit: "inherit",
  "4": "1rem",
  // 16px
  "5": "1.25rem",
  // 20px
  "6": "1.5rem",
  // 24px
  "7": "1.75rem",
  // 28px
  "9": "2.25rem"
  // 36px
};
const text = {
  inherit: {
    fontFamily: "inherit",
    fontSize: "inherit",
    lineHeight: "inherit",
    letterSpacing: "inherit",
    fontWeight: "inherit"
  },
  xlarge: {
    fontFamily: "body",
    fontSize: "xlarge",
    lineHeight: "9",
    letterSpacing: "none",
    fontWeight: "bold"
  },
  large: {
    fontFamily: "body",
    fontSize: "large",
    lineHeight: "7",
    letterSpacing: "normal",
    fontWeight: "semibold"
  },
  medium: {
    fontFamily: "body",
    fontSize: "medium",
    lineHeight: "6",
    letterSpacing: "normal",
    fontWeight: "bold"
  },
  normal: {
    fontFamily: "body",
    fontSize: "normal",
    lineHeight: "5",
    letterSpacing: "wide",
    fontWeight: "normal"
  },
  small: {
    fontFamily: "body",
    fontSize: "small",
    lineHeight: "4",
    letterSpacing: "wide",
    fontWeight: "medium"
  },
  xsmall: {
    fontFamily: "body",
    fontSize: "xsmall",
    lineHeight: "4",
    letterSpacing: "wide",
    fontWeight: "bold"
  },
  code: {
    fontFamily: "mono",
    fontSize: "normal",
    lineHeight: "5",
    letterSpacing: "none",
    fontWeight: "normal"
  }
};
const zIndex = {
  "-1": "-1",
  "0": "0",
  "1": "1",
  "10": "10",
  "20": "20",
  "30": "30",
  "40": "40",
  "50": "50",
  auto: "auto"
};
const tokens = {
  blur,
  borderWidths,
  colors,
  fonts,
  fontSizes,
  fontWeights,
  letterSpacings,
  lineHeights,
  opacity,
  radii,
  space,
  zIndex
};
const breakpoints = {
  sm: 0,
  md: 480,
  lg: 769,
  xl: 1281
};
var reset = "sr8fck0";
const layers_css = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  reset
}, Symbol.toStringTag, { value: "Module" }));
var colorSchemeVars = { colors: { black: "var(--seq-colors-black)", white: "var(--seq-colors-white)", inherit: "var(--seq-colors-inherit)", transparent: "var(--seq-colors-transparent)", positive: "var(--seq-colors-positive)", negative: "var(--seq-colors-negative)", info: "var(--seq-colors-info)", warning: "var(--seq-colors-warning)", gradientBackdrop: "var(--seq-colors-gradient-backdrop)", gradientPrimary: "var(--seq-colors-gradient-primary)", gradientSecondary: "var(--seq-colors-gradient-secondary)", arbitrumDark: "var(--seq-colors-arbitrum-dark)", arbitrumLight: "var(--seq-colors-arbitrum-light)", avalanceDark: "var(--seq-colors-avalance-dark)", avalanceLight: "var(--seq-colors-avalance-light)", bscDark: "var(--seq-colors-bsc-dark)", bscLight: "var(--seq-colors-bsc-light)", ethereumDark: "var(--seq-colors-ethereum-dark)", ethereumLight: "var(--seq-colors-ethereum-light)", gnosisDark: "var(--seq-colors-gnosis-dark)", gnosisLight: "var(--seq-colors-gnosis-light)", polygonDark: "var(--seq-colors-polygon-dark)", polygonLight: "var(--seq-colors-polygon-light)", text100: "var(--seq-colors-text100)", text80: "var(--seq-colors-text80)", text50: "var(--seq-colors-text50)", textInverse100: "var(--seq-colors-text-inverse100)", backgroundPrimary: "var(--seq-colors-background-primary)", backgroundSecondary: "var(--seq-colors-background-secondary)", backgroundContrast: "var(--seq-colors-background-contrast)", backgroundMuted: "var(--seq-colors-background-muted)", backgroundControl: "var(--seq-colors-background-control)", backgroundInverse: "var(--seq-colors-background-inverse)", backgroundBackdrop: "var(--seq-colors-background-backdrop)", backgroundOverlay: "var(--seq-colors-background-overlay)", backgroundRaised: "var(--seq-colors-background-raised)", buttonGlass: "var(--seq-colors-button-glass)", buttonEmphasis: "var(--seq-colors-button-emphasis)", buttonInverse: "var(--seq-colors-button-inverse)", borderNormal: "var(--seq-colors-border-normal)", borderFocus: "var(--seq-colors-border-focus)" } };
var vars = { blur: { blur: "var(--seq-blur-blur)", none: "var(--seq-blur-none)" }, borderWidths: { none: "var(--seq-border-widths-none)", thin: "var(--seq-border-widths-thin)", thick: "var(--seq-border-widths-thick)" }, fonts: { inherit: "var(--seq-fonts-inherit)", body: "var(--seq-fonts-body)", mono: "var(--seq-fonts-mono)" }, fontSizes: { inherit: "var(--seq-font-sizes-inherit)", xsmall: "var(--seq-font-sizes-xsmall)", small: "var(--seq-font-sizes-small)", normal: "var(--seq-font-sizes-normal)", medium: "var(--seq-font-sizes-medium)", large: "var(--seq-font-sizes-large)", xlarge: "var(--seq-font-sizes-xlarge)" }, fontWeights: { inherit: "var(--seq-font-weights-inherit)", normal: "var(--seq-font-weights-normal)", medium: "var(--seq-font-weights-medium)", semibold: "var(--seq-font-weights-semibold)", bold: "var(--seq-font-weights-bold)" }, letterSpacings: { inherit: "var(--seq-letter-spacings-inherit)", none: "var(--seq-letter-spacings-none)", normal: "var(--seq-letter-spacings-normal)", wide: "var(--seq-letter-spacings-wide)" }, lineHeights: { "4": "var(--seq-line-heights-4)", "5": "var(--seq-line-heights-5)", "6": "var(--seq-line-heights-6)", "7": "var(--seq-line-heights-7)", "9": "var(--seq-line-heights-9)", inherit: "var(--seq-line-heights-inherit)" }, opacity: { "0": "var(--seq-opacity-0)", "50": "var(--seq-opacity-50)", "80": "var(--seq-opacity-80)", "100": "var(--seq-opacity-100)" }, radii: { none: "var(--seq-radii-none)", xs: "var(--seq-radii-xs)", sm: "var(--seq-radii-sm)", md: "var(--seq-radii-md)", lg: "var(--seq-radii-lg)", circle: "var(--seq-radii-circle)" }, space: { "0": "var(--seq-space-0)", "1": "var(--seq-space-1)", "2": "var(--seq-space-2)", "3": "var(--seq-space-3)", "4": "var(--seq-space-4)", "5": "var(--seq-space-5)", "6": "var(--seq-space-6)", "7": "var(--seq-space-7)", "8": "var(--seq-space-8)", "9": "var(--seq-space-9)", "10": "var(--seq-space-10)", "12": "var(--seq-space-12)", "14": "var(--seq-space-14)", "16": "var(--seq-space-16)", "18": "var(--seq-space-18)", "20": "var(--seq-space-20)", "0.25": "var(--seq-space-0_25)", "0.5": "var(--seq-space-0_5)", "1.5": "var(--seq-space-1_5)" }, zIndex: { "0": "var(--seq-z-index-0)", "1": "var(--seq-z-index-1)", "10": "var(--seq-z-index-10)", "20": "var(--seq-z-index-20)", "30": "var(--seq-z-index-30)", "40": "var(--seq-z-index-40)", "50": "var(--seq-z-index-50)", "-1": "var(--seq-z-index--1)", auto: "var(--seq-z-index-auto)" }, colors: { black: "var(--seq-colors-black)", white: "var(--seq-colors-white)", inherit: "var(--seq-colors-inherit)", transparent: "var(--seq-colors-transparent)", positive: "var(--seq-colors-positive)", negative: "var(--seq-colors-negative)", info: "var(--seq-colors-info)", warning: "var(--seq-colors-warning)", gradientBackdrop: "var(--seq-colors-gradient-backdrop)", gradientPrimary: "var(--seq-colors-gradient-primary)", gradientSecondary: "var(--seq-colors-gradient-secondary)", arbitrumDark: "var(--seq-colors-arbitrum-dark)", arbitrumLight: "var(--seq-colors-arbitrum-light)", avalanceDark: "var(--seq-colors-avalance-dark)", avalanceLight: "var(--seq-colors-avalance-light)", bscDark: "var(--seq-colors-bsc-dark)", bscLight: "var(--seq-colors-bsc-light)", ethereumDark: "var(--seq-colors-ethereum-dark)", ethereumLight: "var(--seq-colors-ethereum-light)", gnosisDark: "var(--seq-colors-gnosis-dark)", gnosisLight: "var(--seq-colors-gnosis-light)", polygonDark: "var(--seq-colors-polygon-dark)", polygonLight: "var(--seq-colors-polygon-light)", text100: "var(--seq-colors-text100)", text80: "var(--seq-colors-text80)", text50: "var(--seq-colors-text50)", textInverse100: "var(--seq-colors-text-inverse100)", backgroundPrimary: "var(--seq-colors-background-primary)", backgroundSecondary: "var(--seq-colors-background-secondary)", backgroundContrast: "var(--seq-colors-background-contrast)", backgroundMuted: "var(--seq-colors-background-muted)", backgroundControl: "var(--seq-colors-background-control)", backgroundInverse: "var(--seq-colors-background-inverse)", backgroundBackdrop: "var(--seq-colors-background-backdrop)", backgroundOverlay: "var(--seq-colors-background-overlay)", backgroundRaised: "var(--seq-colors-background-raised)", buttonGlass: "var(--seq-colors-button-glass)", buttonEmphasis: "var(--seq-colors-button-emphasis)", buttonInverse: "var(--seq-colors-button-inverse)", borderNormal: "var(--seq-colors-border-normal)", borderFocus: "var(--seq-colors-border-focus)" } };
function toPrimitive$1(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function toPropertyKey$1(t) {
  var i = toPrimitive$1(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty$1(obj, key, value) {
  key = toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$1(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2$1(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t), true).forEach(function(r3) {
      _defineProperty$1(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var createSprinkles$1 = (composeStyles2) => function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var sprinklesStyles = Object.assign({}, ...args.map((a) => a.styles));
  var sprinklesKeys = Object.keys(sprinklesStyles);
  var shorthandNames = sprinklesKeys.filter((property) => "mappings" in sprinklesStyles[property]);
  var sprinklesFn = (props) => {
    var classNames = [];
    var shorthands = {};
    var nonShorthands = _objectSpread2$1({}, props);
    var hasShorthands = false;
    for (var shorthand of shorthandNames) {
      var value = props[shorthand];
      if (value != null) {
        var sprinkle = sprinklesStyles[shorthand];
        hasShorthands = true;
        for (var propMapping of sprinkle.mappings) {
          shorthands[propMapping] = value;
          if (nonShorthands[propMapping] == null) {
            delete nonShorthands[propMapping];
          }
        }
      }
    }
    var finalProps = hasShorthands ? _objectSpread2$1(_objectSpread2$1({}, shorthands), nonShorthands) : props;
    var _loop = function _loop2() {
      var propValue = finalProps[prop];
      var sprinkle2 = sprinklesStyles[prop];
      try {
        if (sprinkle2.mappings) {
          return 1;
        }
        if (typeof propValue === "string" || typeof propValue === "number") {
          if (process.env.NODE_ENV !== "production") {
            if (!sprinkle2.values[propValue].defaultClass) {
              throw new Error();
            }
          }
          classNames.push(sprinkle2.values[propValue].defaultClass);
        } else if (Array.isArray(propValue)) {
          for (var responsiveIndex = 0; responsiveIndex < propValue.length; responsiveIndex++) {
            var responsiveValue = propValue[responsiveIndex];
            if (responsiveValue != null) {
              var conditionName = sprinkle2.responsiveArray[responsiveIndex];
              if (process.env.NODE_ENV !== "production") {
                if (!sprinkle2.values[responsiveValue].conditions[conditionName]) {
                  throw new Error();
                }
              }
              classNames.push(sprinkle2.values[responsiveValue].conditions[conditionName]);
            }
          }
        } else {
          for (var _conditionName in propValue) {
            var _value = propValue[_conditionName];
            if (_value != null) {
              if (process.env.NODE_ENV !== "production") {
                if (!sprinkle2.values[_value].conditions[_conditionName]) {
                  throw new Error();
                }
              }
              classNames.push(sprinkle2.values[_value].conditions[_conditionName]);
            }
          }
        }
      } catch (e) {
        if (process.env.NODE_ENV !== "production") {
          class SprinklesError extends Error {
            constructor(message) {
              super(message);
              this.name = "SprinklesError";
            }
          }
          var format = (v) => typeof v === "string" ? '"'.concat(v, '"') : v;
          var invalidPropValue = (prop2, value2, possibleValues) => {
            throw new SprinklesError('"'.concat(prop2, '" has no value ').concat(format(value2), ". Possible values are ").concat(Object.keys(possibleValues).map(format).join(", ")));
          };
          if (!sprinkle2) {
            throw new SprinklesError('"'.concat(prop, '" is not a valid sprinkle'));
          }
          if (typeof propValue === "string" || typeof propValue === "number") {
            if (!(propValue in sprinkle2.values)) {
              invalidPropValue(prop, propValue, sprinkle2.values);
            }
            if (!sprinkle2.values[propValue].defaultClass) {
              throw new SprinklesError('"'.concat(prop, '" has no default condition. You must specify which conditions to target explicitly. Possible options are ').concat(Object.keys(sprinkle2.values[propValue].conditions).map(format).join(", ")));
            }
          }
          if (typeof propValue === "object") {
            if (!("conditions" in sprinkle2.values[Object.keys(sprinkle2.values)[0]])) {
              throw new SprinklesError('"'.concat(prop, '" is not a conditional property'));
            }
            if (Array.isArray(propValue)) {
              if (!("responsiveArray" in sprinkle2)) {
                throw new SprinklesError('"'.concat(prop, '" does not support responsive arrays'));
              }
              var breakpointCount = sprinkle2.responsiveArray.length;
              if (breakpointCount < propValue.length) {
                throw new SprinklesError('"'.concat(prop, '" only supports up to ').concat(breakpointCount, " breakpoints. You passed ").concat(propValue.length));
              }
              for (var _responsiveValue of propValue) {
                if (!sprinkle2.values[_responsiveValue]) {
                  invalidPropValue(prop, _responsiveValue, sprinkle2.values);
                }
              }
            } else {
              for (var _conditionName2 in propValue) {
                var _value2 = propValue[_conditionName2];
                if (_value2 != null) {
                  if (!sprinkle2.values[_value2]) {
                    invalidPropValue(prop, _value2, sprinkle2.values);
                  }
                  if (!sprinkle2.values[_value2].conditions[_conditionName2]) {
                    throw new SprinklesError('"'.concat(prop, '" has no condition named ').concat(format(_conditionName2), ". Possible values are ").concat(Object.keys(sprinkle2.values[_value2].conditions).map(format).join(", ")));
                  }
                }
              }
            }
          }
        }
        throw e;
      }
    };
    for (var prop in finalProps) {
      if (_loop()) continue;
    }
    return composeStyles2(classNames.join(" "));
  };
  return Object.assign(sprinklesFn, {
    properties: new Set(sprinklesKeys)
  });
};
var composeStyles = (classList) => classList;
var createSprinkles = function createSprinkles2() {
  return createSprinkles$1(composeStyles)(...arguments);
};
var sprinkles = createSprinkles({ conditions: { defaultCondition: "sm", conditionNames: ["sm", "md", "lg", "xl"], responsiveArray: void 0 }, styles: { borderWidth: { mappings: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"] }, borderRadius: { mappings: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderLeftRadius: { mappings: ["borderBottomLeftRadius", "borderTopLeftRadius"] }, borderRightRadius: { mappings: ["borderBottomRightRadius", "borderTopRightRadius"] }, borderTopRadius: { mappings: ["borderTopLeftRadius", "borderTopRightRadius"] }, borderBottomRadius: { mappings: ["borderBottomLeftRadius", "borderBottomRightRadius"] }, margin: { mappings: ["marginTop", "marginBottom", "marginLeft", "marginRight"] }, marginX: { mappings: ["marginLeft", "marginRight"] }, marginY: { mappings: ["marginTop", "marginBottom"] }, overflow: { mappings: ["overflowX", "overflowY"] }, padding: { mappings: ["paddingTop", "paddingBottom", "paddingLeft", "paddingRight"] }, paddingX: { mappings: ["paddingLeft", "paddingRight"] }, paddingY: { mappings: ["paddingTop", "paddingBottom"] }, placeItems: { mappings: ["justifyContent", "alignItems"] }, inset: { mappings: ["top", "bottom", "left", "right"] }, width: { values: { "0": { conditions: { sm: "fyvr10", md: "fyvr11", lg: "fyvr12", xl: "fyvr13" }, defaultClass: "fyvr10" }, "1": { conditions: { sm: "fyvr14", md: "fyvr15", lg: "fyvr16", xl: "fyvr17" }, defaultClass: "fyvr14" }, "2": { conditions: { sm: "fyvr18", md: "fyvr19", lg: "fyvr1a", xl: "fyvr1b" }, defaultClass: "fyvr18" }, "3": { conditions: { sm: "fyvr1c", md: "fyvr1d", lg: "fyvr1e", xl: "fyvr1f" }, defaultClass: "fyvr1c" }, "4": { conditions: { sm: "fyvr1g", md: "fyvr1h", lg: "fyvr1i", xl: "fyvr1j" }, defaultClass: "fyvr1g" }, "5": { conditions: { sm: "fyvr1k", md: "fyvr1l", lg: "fyvr1m", xl: "fyvr1n" }, defaultClass: "fyvr1k" }, "6": { conditions: { sm: "fyvr1o", md: "fyvr1p", lg: "fyvr1q", xl: "fyvr1r" }, defaultClass: "fyvr1o" }, "7": { conditions: { sm: "fyvr1s", md: "fyvr1t", lg: "fyvr1u", xl: "fyvr1v" }, defaultClass: "fyvr1s" }, "8": { conditions: { sm: "fyvr1w", md: "fyvr1x", lg: "fyvr1y", xl: "fyvr1z" }, defaultClass: "fyvr1w" }, "9": { conditions: { sm: "fyvr110", md: "fyvr111", lg: "fyvr112", xl: "fyvr113" }, defaultClass: "fyvr110" }, "10": { conditions: { sm: "fyvr114", md: "fyvr115", lg: "fyvr116", xl: "fyvr117" }, defaultClass: "fyvr114" }, "12": { conditions: { sm: "fyvr118", md: "fyvr119", lg: "fyvr11a", xl: "fyvr11b" }, defaultClass: "fyvr118" }, "14": { conditions: { sm: "fyvr11c", md: "fyvr11d", lg: "fyvr11e", xl: "fyvr11f" }, defaultClass: "fyvr11c" }, "16": { conditions: { sm: "fyvr11g", md: "fyvr11h", lg: "fyvr11i", xl: "fyvr11j" }, defaultClass: "fyvr11g" }, "18": { conditions: { sm: "fyvr11k", md: "fyvr11l", lg: "fyvr11m", xl: "fyvr11n" }, defaultClass: "fyvr11k" }, "20": { conditions: { sm: "fyvr11o", md: "fyvr11p", lg: "fyvr11q", xl: "fyvr11r" }, defaultClass: "fyvr11o" }, "0.25": { conditions: { sm: "fyvr11s", md: "fyvr11t", lg: "fyvr11u", xl: "fyvr11v" }, defaultClass: "fyvr11s" }, "0.5": { conditions: { sm: "fyvr11w", md: "fyvr11x", lg: "fyvr11y", xl: "fyvr11z" }, defaultClass: "fyvr11w" }, "1.5": { conditions: { sm: "fyvr120", md: "fyvr121", lg: "fyvr122", xl: "fyvr123" }, defaultClass: "fyvr120" }, none: { conditions: { sm: "fyvr124", md: "fyvr125", lg: "fyvr126", xl: "fyvr127" }, defaultClass: "fyvr124" }, px: { conditions: { sm: "fyvr128", md: "fyvr129", lg: "fyvr12a", xl: "fyvr12b" }, defaultClass: "fyvr128" }, auto: { conditions: { sm: "fyvr12c", md: "fyvr12d", lg: "fyvr12e", xl: "fyvr12f" }, defaultClass: "fyvr12c" }, full: { conditions: { sm: "fyvr12g", md: "fyvr12h", lg: "fyvr12i", xl: "fyvr12j" }, defaultClass: "fyvr12g" }, "1/2": { conditions: { sm: "fyvr12k", md: "fyvr12l", lg: "fyvr12m", xl: "fyvr12n" }, defaultClass: "fyvr12k" }, "1/3": { conditions: { sm: "fyvr12o", md: "fyvr12p", lg: "fyvr12q", xl: "fyvr12r" }, defaultClass: "fyvr12o" }, "2/3": { conditions: { sm: "fyvr12s", md: "fyvr12t", lg: "fyvr12u", xl: "fyvr12v" }, defaultClass: "fyvr12s" }, "1/4": { conditions: { sm: "fyvr12w", md: "fyvr12x", lg: "fyvr12y", xl: "fyvr12z" }, defaultClass: "fyvr12w" }, "3/4": { conditions: { sm: "fyvr130", md: "fyvr131", lg: "fyvr132", xl: "fyvr133" }, defaultClass: "fyvr130" }, fit: { conditions: { sm: "fyvr134", md: "fyvr135", lg: "fyvr136", xl: "fyvr137" }, defaultClass: "fyvr134" }, max: { conditions: { sm: "fyvr138", md: "fyvr139", lg: "fyvr13a", xl: "fyvr13b" }, defaultClass: "fyvr138" }, min: { conditions: { sm: "fyvr13c", md: "fyvr13d", lg: "fyvr13e", xl: "fyvr13f" }, defaultClass: "fyvr13c" }, vw: { conditions: { sm: "fyvr13g", md: "fyvr13h", lg: "fyvr13i", xl: "fyvr13j" }, defaultClass: "fyvr13g" }, vh: { conditions: { sm: "fyvr13k", md: "fyvr13l", lg: "fyvr13m", xl: "fyvr13n" }, defaultClass: "fyvr13k" } } }, height: { values: { "0": { conditions: { sm: "fyvr13o", md: "fyvr13p", lg: "fyvr13q", xl: "fyvr13r" }, defaultClass: "fyvr13o" }, "1": { conditions: { sm: "fyvr13s", md: "fyvr13t", lg: "fyvr13u", xl: "fyvr13v" }, defaultClass: "fyvr13s" }, "2": { conditions: { sm: "fyvr13w", md: "fyvr13x", lg: "fyvr13y", xl: "fyvr13z" }, defaultClass: "fyvr13w" }, "3": { conditions: { sm: "fyvr140", md: "fyvr141", lg: "fyvr142", xl: "fyvr143" }, defaultClass: "fyvr140" }, "4": { conditions: { sm: "fyvr144", md: "fyvr145", lg: "fyvr146", xl: "fyvr147" }, defaultClass: "fyvr144" }, "5": { conditions: { sm: "fyvr148", md: "fyvr149", lg: "fyvr14a", xl: "fyvr14b" }, defaultClass: "fyvr148" }, "6": { conditions: { sm: "fyvr14c", md: "fyvr14d", lg: "fyvr14e", xl: "fyvr14f" }, defaultClass: "fyvr14c" }, "7": { conditions: { sm: "fyvr14g", md: "fyvr14h", lg: "fyvr14i", xl: "fyvr14j" }, defaultClass: "fyvr14g" }, "8": { conditions: { sm: "fyvr14k", md: "fyvr14l", lg: "fyvr14m", xl: "fyvr14n" }, defaultClass: "fyvr14k" }, "9": { conditions: { sm: "fyvr14o", md: "fyvr14p", lg: "fyvr14q", xl: "fyvr14r" }, defaultClass: "fyvr14o" }, "10": { conditions: { sm: "fyvr14s", md: "fyvr14t", lg: "fyvr14u", xl: "fyvr14v" }, defaultClass: "fyvr14s" }, "12": { conditions: { sm: "fyvr14w", md: "fyvr14x", lg: "fyvr14y", xl: "fyvr14z" }, defaultClass: "fyvr14w" }, "14": { conditions: { sm: "fyvr150", md: "fyvr151", lg: "fyvr152", xl: "fyvr153" }, defaultClass: "fyvr150" }, "16": { conditions: { sm: "fyvr154", md: "fyvr155", lg: "fyvr156", xl: "fyvr157" }, defaultClass: "fyvr154" }, "18": { conditions: { sm: "fyvr158", md: "fyvr159", lg: "fyvr15a", xl: "fyvr15b" }, defaultClass: "fyvr158" }, "20": { conditions: { sm: "fyvr15c", md: "fyvr15d", lg: "fyvr15e", xl: "fyvr15f" }, defaultClass: "fyvr15c" }, "0.25": { conditions: { sm: "fyvr15g", md: "fyvr15h", lg: "fyvr15i", xl: "fyvr15j" }, defaultClass: "fyvr15g" }, "0.5": { conditions: { sm: "fyvr15k", md: "fyvr15l", lg: "fyvr15m", xl: "fyvr15n" }, defaultClass: "fyvr15k" }, "1.5": { conditions: { sm: "fyvr15o", md: "fyvr15p", lg: "fyvr15q", xl: "fyvr15r" }, defaultClass: "fyvr15o" }, none: { conditions: { sm: "fyvr15s", md: "fyvr15t", lg: "fyvr15u", xl: "fyvr15v" }, defaultClass: "fyvr15s" }, px: { conditions: { sm: "fyvr15w", md: "fyvr15x", lg: "fyvr15y", xl: "fyvr15z" }, defaultClass: "fyvr15w" }, auto: { conditions: { sm: "fyvr160", md: "fyvr161", lg: "fyvr162", xl: "fyvr163" }, defaultClass: "fyvr160" }, full: { conditions: { sm: "fyvr164", md: "fyvr165", lg: "fyvr166", xl: "fyvr167" }, defaultClass: "fyvr164" }, "1/2": { conditions: { sm: "fyvr168", md: "fyvr169", lg: "fyvr16a", xl: "fyvr16b" }, defaultClass: "fyvr168" }, "1/3": { conditions: { sm: "fyvr16c", md: "fyvr16d", lg: "fyvr16e", xl: "fyvr16f" }, defaultClass: "fyvr16c" }, "2/3": { conditions: { sm: "fyvr16g", md: "fyvr16h", lg: "fyvr16i", xl: "fyvr16j" }, defaultClass: "fyvr16g" }, "1/4": { conditions: { sm: "fyvr16k", md: "fyvr16l", lg: "fyvr16m", xl: "fyvr16n" }, defaultClass: "fyvr16k" }, "3/4": { conditions: { sm: "fyvr16o", md: "fyvr16p", lg: "fyvr16q", xl: "fyvr16r" }, defaultClass: "fyvr16o" }, fit: { conditions: { sm: "fyvr16s", md: "fyvr16t", lg: "fyvr16u", xl: "fyvr16v" }, defaultClass: "fyvr16s" }, max: { conditions: { sm: "fyvr16w", md: "fyvr16x", lg: "fyvr16y", xl: "fyvr16z" }, defaultClass: "fyvr16w" }, min: { conditions: { sm: "fyvr170", md: "fyvr171", lg: "fyvr172", xl: "fyvr173" }, defaultClass: "fyvr170" }, vw: { conditions: { sm: "fyvr174", md: "fyvr175", lg: "fyvr176", xl: "fyvr177" }, defaultClass: "fyvr174" }, vh: { conditions: { sm: "fyvr178", md: "fyvr179", lg: "fyvr17a", xl: "fyvr17b" }, defaultClass: "fyvr178" } } }, maxWidth: { values: { "0": { conditions: { sm: "fyvr17c", md: "fyvr17d", lg: "fyvr17e", xl: "fyvr17f" }, defaultClass: "fyvr17c" }, "1": { conditions: { sm: "fyvr17g", md: "fyvr17h", lg: "fyvr17i", xl: "fyvr17j" }, defaultClass: "fyvr17g" }, "2": { conditions: { sm: "fyvr17k", md: "fyvr17l", lg: "fyvr17m", xl: "fyvr17n" }, defaultClass: "fyvr17k" }, "3": { conditions: { sm: "fyvr17o", md: "fyvr17p", lg: "fyvr17q", xl: "fyvr17r" }, defaultClass: "fyvr17o" }, "4": { conditions: { sm: "fyvr17s", md: "fyvr17t", lg: "fyvr17u", xl: "fyvr17v" }, defaultClass: "fyvr17s" }, "5": { conditions: { sm: "fyvr17w", md: "fyvr17x", lg: "fyvr17y", xl: "fyvr17z" }, defaultClass: "fyvr17w" }, "6": { conditions: { sm: "fyvr180", md: "fyvr181", lg: "fyvr182", xl: "fyvr183" }, defaultClass: "fyvr180" }, "7": { conditions: { sm: "fyvr184", md: "fyvr185", lg: "fyvr186", xl: "fyvr187" }, defaultClass: "fyvr184" }, "8": { conditions: { sm: "fyvr188", md: "fyvr189", lg: "fyvr18a", xl: "fyvr18b" }, defaultClass: "fyvr188" }, "9": { conditions: { sm: "fyvr18c", md: "fyvr18d", lg: "fyvr18e", xl: "fyvr18f" }, defaultClass: "fyvr18c" }, "10": { conditions: { sm: "fyvr18g", md: "fyvr18h", lg: "fyvr18i", xl: "fyvr18j" }, defaultClass: "fyvr18g" }, "12": { conditions: { sm: "fyvr18k", md: "fyvr18l", lg: "fyvr18m", xl: "fyvr18n" }, defaultClass: "fyvr18k" }, "14": { conditions: { sm: "fyvr18o", md: "fyvr18p", lg: "fyvr18q", xl: "fyvr18r" }, defaultClass: "fyvr18o" }, "16": { conditions: { sm: "fyvr18s", md: "fyvr18t", lg: "fyvr18u", xl: "fyvr18v" }, defaultClass: "fyvr18s" }, "18": { conditions: { sm: "fyvr18w", md: "fyvr18x", lg: "fyvr18y", xl: "fyvr18z" }, defaultClass: "fyvr18w" }, "20": { conditions: { sm: "fyvr190", md: "fyvr191", lg: "fyvr192", xl: "fyvr193" }, defaultClass: "fyvr190" }, "0.25": { conditions: { sm: "fyvr194", md: "fyvr195", lg: "fyvr196", xl: "fyvr197" }, defaultClass: "fyvr194" }, "0.5": { conditions: { sm: "fyvr198", md: "fyvr199", lg: "fyvr19a", xl: "fyvr19b" }, defaultClass: "fyvr198" }, "1.5": { conditions: { sm: "fyvr19c", md: "fyvr19d", lg: "fyvr19e", xl: "fyvr19f" }, defaultClass: "fyvr19c" }, none: { conditions: { sm: "fyvr19g", md: "fyvr19h", lg: "fyvr19i", xl: "fyvr19j" }, defaultClass: "fyvr19g" }, px: { conditions: { sm: "fyvr19k", md: "fyvr19l", lg: "fyvr19m", xl: "fyvr19n" }, defaultClass: "fyvr19k" }, auto: { conditions: { sm: "fyvr19o", md: "fyvr19p", lg: "fyvr19q", xl: "fyvr19r" }, defaultClass: "fyvr19o" }, full: { conditions: { sm: "fyvr19s", md: "fyvr19t", lg: "fyvr19u", xl: "fyvr19v" }, defaultClass: "fyvr19s" }, "1/2": { conditions: { sm: "fyvr19w", md: "fyvr19x", lg: "fyvr19y", xl: "fyvr19z" }, defaultClass: "fyvr19w" }, "1/3": { conditions: { sm: "fyvr1a0", md: "fyvr1a1", lg: "fyvr1a2", xl: "fyvr1a3" }, defaultClass: "fyvr1a0" }, "2/3": { conditions: { sm: "fyvr1a4", md: "fyvr1a5", lg: "fyvr1a6", xl: "fyvr1a7" }, defaultClass: "fyvr1a4" }, "1/4": { conditions: { sm: "fyvr1a8", md: "fyvr1a9", lg: "fyvr1aa", xl: "fyvr1ab" }, defaultClass: "fyvr1a8" }, "3/4": { conditions: { sm: "fyvr1ac", md: "fyvr1ad", lg: "fyvr1ae", xl: "fyvr1af" }, defaultClass: "fyvr1ac" }, fit: { conditions: { sm: "fyvr1ag", md: "fyvr1ah", lg: "fyvr1ai", xl: "fyvr1aj" }, defaultClass: "fyvr1ag" }, max: { conditions: { sm: "fyvr1ak", md: "fyvr1al", lg: "fyvr1am", xl: "fyvr1an" }, defaultClass: "fyvr1ak" }, min: { conditions: { sm: "fyvr1ao", md: "fyvr1ap", lg: "fyvr1aq", xl: "fyvr1ar" }, defaultClass: "fyvr1ao" }, vw: { conditions: { sm: "fyvr1as", md: "fyvr1at", lg: "fyvr1au", xl: "fyvr1av" }, defaultClass: "fyvr1as" }, vh: { conditions: { sm: "fyvr1aw", md: "fyvr1ax", lg: "fyvr1ay", xl: "fyvr1az" }, defaultClass: "fyvr1aw" } } }, maxHeight: { values: { "0": { conditions: { sm: "fyvr1b0", md: "fyvr1b1", lg: "fyvr1b2", xl: "fyvr1b3" }, defaultClass: "fyvr1b0" }, "1": { conditions: { sm: "fyvr1b4", md: "fyvr1b5", lg: "fyvr1b6", xl: "fyvr1b7" }, defaultClass: "fyvr1b4" }, "2": { conditions: { sm: "fyvr1b8", md: "fyvr1b9", lg: "fyvr1ba", xl: "fyvr1bb" }, defaultClass: "fyvr1b8" }, "3": { conditions: { sm: "fyvr1bc", md: "fyvr1bd", lg: "fyvr1be", xl: "fyvr1bf" }, defaultClass: "fyvr1bc" }, "4": { conditions: { sm: "fyvr1bg", md: "fyvr1bh", lg: "fyvr1bi", xl: "fyvr1bj" }, defaultClass: "fyvr1bg" }, "5": { conditions: { sm: "fyvr1bk", md: "fyvr1bl", lg: "fyvr1bm", xl: "fyvr1bn" }, defaultClass: "fyvr1bk" }, "6": { conditions: { sm: "fyvr1bo", md: "fyvr1bp", lg: "fyvr1bq", xl: "fyvr1br" }, defaultClass: "fyvr1bo" }, "7": { conditions: { sm: "fyvr1bs", md: "fyvr1bt", lg: "fyvr1bu", xl: "fyvr1bv" }, defaultClass: "fyvr1bs" }, "8": { conditions: { sm: "fyvr1bw", md: "fyvr1bx", lg: "fyvr1by", xl: "fyvr1bz" }, defaultClass: "fyvr1bw" }, "9": { conditions: { sm: "fyvr1c0", md: "fyvr1c1", lg: "fyvr1c2", xl: "fyvr1c3" }, defaultClass: "fyvr1c0" }, "10": { conditions: { sm: "fyvr1c4", md: "fyvr1c5", lg: "fyvr1c6", xl: "fyvr1c7" }, defaultClass: "fyvr1c4" }, "12": { conditions: { sm: "fyvr1c8", md: "fyvr1c9", lg: "fyvr1ca", xl: "fyvr1cb" }, defaultClass: "fyvr1c8" }, "14": { conditions: { sm: "fyvr1cc", md: "fyvr1cd", lg: "fyvr1ce", xl: "fyvr1cf" }, defaultClass: "fyvr1cc" }, "16": { conditions: { sm: "fyvr1cg", md: "fyvr1ch", lg: "fyvr1ci", xl: "fyvr1cj" }, defaultClass: "fyvr1cg" }, "18": { conditions: { sm: "fyvr1ck", md: "fyvr1cl", lg: "fyvr1cm", xl: "fyvr1cn" }, defaultClass: "fyvr1ck" }, "20": { conditions: { sm: "fyvr1co", md: "fyvr1cp", lg: "fyvr1cq", xl: "fyvr1cr" }, defaultClass: "fyvr1co" }, "0.25": { conditions: { sm: "fyvr1cs", md: "fyvr1ct", lg: "fyvr1cu", xl: "fyvr1cv" }, defaultClass: "fyvr1cs" }, "0.5": { conditions: { sm: "fyvr1cw", md: "fyvr1cx", lg: "fyvr1cy", xl: "fyvr1cz" }, defaultClass: "fyvr1cw" }, "1.5": { conditions: { sm: "fyvr1d0", md: "fyvr1d1", lg: "fyvr1d2", xl: "fyvr1d3" }, defaultClass: "fyvr1d0" }, none: { conditions: { sm: "fyvr1d4", md: "fyvr1d5", lg: "fyvr1d6", xl: "fyvr1d7" }, defaultClass: "fyvr1d4" }, px: { conditions: { sm: "fyvr1d8", md: "fyvr1d9", lg: "fyvr1da", xl: "fyvr1db" }, defaultClass: "fyvr1d8" }, auto: { conditions: { sm: "fyvr1dc", md: "fyvr1dd", lg: "fyvr1de", xl: "fyvr1df" }, defaultClass: "fyvr1dc" }, full: { conditions: { sm: "fyvr1dg", md: "fyvr1dh", lg: "fyvr1di", xl: "fyvr1dj" }, defaultClass: "fyvr1dg" }, "1/2": { conditions: { sm: "fyvr1dk", md: "fyvr1dl", lg: "fyvr1dm", xl: "fyvr1dn" }, defaultClass: "fyvr1dk" }, "1/3": { conditions: { sm: "fyvr1do", md: "fyvr1dp", lg: "fyvr1dq", xl: "fyvr1dr" }, defaultClass: "fyvr1do" }, "2/3": { conditions: { sm: "fyvr1ds", md: "fyvr1dt", lg: "fyvr1du", xl: "fyvr1dv" }, defaultClass: "fyvr1ds" }, "1/4": { conditions: { sm: "fyvr1dw", md: "fyvr1dx", lg: "fyvr1dy", xl: "fyvr1dz" }, defaultClass: "fyvr1dw" }, "3/4": { conditions: { sm: "fyvr1e0", md: "fyvr1e1", lg: "fyvr1e2", xl: "fyvr1e3" }, defaultClass: "fyvr1e0" }, fit: { conditions: { sm: "fyvr1e4", md: "fyvr1e5", lg: "fyvr1e6", xl: "fyvr1e7" }, defaultClass: "fyvr1e4" }, max: { conditions: { sm: "fyvr1e8", md: "fyvr1e9", lg: "fyvr1ea", xl: "fyvr1eb" }, defaultClass: "fyvr1e8" }, min: { conditions: { sm: "fyvr1ec", md: "fyvr1ed", lg: "fyvr1ee", xl: "fyvr1ef" }, defaultClass: "fyvr1ec" }, vw: { conditions: { sm: "fyvr1eg", md: "fyvr1eh", lg: "fyvr1ei", xl: "fyvr1ej" }, defaultClass: "fyvr1eg" }, vh: { conditions: { sm: "fyvr1ek", md: "fyvr1el", lg: "fyvr1em", xl: "fyvr1en" }, defaultClass: "fyvr1ek" } } }, minWidth: { values: { "0": { conditions: { sm: "fyvr1eo", md: "fyvr1ep", lg: "fyvr1eq", xl: "fyvr1er" }, defaultClass: "fyvr1eo" }, "1": { conditions: { sm: "fyvr1es", md: "fyvr1et", lg: "fyvr1eu", xl: "fyvr1ev" }, defaultClass: "fyvr1es" }, "2": { conditions: { sm: "fyvr1ew", md: "fyvr1ex", lg: "fyvr1ey", xl: "fyvr1ez" }, defaultClass: "fyvr1ew" }, "3": { conditions: { sm: "fyvr1f0", md: "fyvr1f1", lg: "fyvr1f2", xl: "fyvr1f3" }, defaultClass: "fyvr1f0" }, "4": { conditions: { sm: "fyvr1f4", md: "fyvr1f5", lg: "fyvr1f6", xl: "fyvr1f7" }, defaultClass: "fyvr1f4" }, "5": { conditions: { sm: "fyvr1f8", md: "fyvr1f9", lg: "fyvr1fa", xl: "fyvr1fb" }, defaultClass: "fyvr1f8" }, "6": { conditions: { sm: "fyvr1fc", md: "fyvr1fd", lg: "fyvr1fe", xl: "fyvr1ff" }, defaultClass: "fyvr1fc" }, "7": { conditions: { sm: "fyvr1fg", md: "fyvr1fh", lg: "fyvr1fi", xl: "fyvr1fj" }, defaultClass: "fyvr1fg" }, "8": { conditions: { sm: "fyvr1fk", md: "fyvr1fl", lg: "fyvr1fm", xl: "fyvr1fn" }, defaultClass: "fyvr1fk" }, "9": { conditions: { sm: "fyvr1fo", md: "fyvr1fp", lg: "fyvr1fq", xl: "fyvr1fr" }, defaultClass: "fyvr1fo" }, "10": { conditions: { sm: "fyvr1fs", md: "fyvr1ft", lg: "fyvr1fu", xl: "fyvr1fv" }, defaultClass: "fyvr1fs" }, "12": { conditions: { sm: "fyvr1fw", md: "fyvr1fx", lg: "fyvr1fy", xl: "fyvr1fz" }, defaultClass: "fyvr1fw" }, "14": { conditions: { sm: "fyvr1g0", md: "fyvr1g1", lg: "fyvr1g2", xl: "fyvr1g3" }, defaultClass: "fyvr1g0" }, "16": { conditions: { sm: "fyvr1g4", md: "fyvr1g5", lg: "fyvr1g6", xl: "fyvr1g7" }, defaultClass: "fyvr1g4" }, "18": { conditions: { sm: "fyvr1g8", md: "fyvr1g9", lg: "fyvr1ga", xl: "fyvr1gb" }, defaultClass: "fyvr1g8" }, "20": { conditions: { sm: "fyvr1gc", md: "fyvr1gd", lg: "fyvr1ge", xl: "fyvr1gf" }, defaultClass: "fyvr1gc" }, "0.25": { conditions: { sm: "fyvr1gg", md: "fyvr1gh", lg: "fyvr1gi", xl: "fyvr1gj" }, defaultClass: "fyvr1gg" }, "0.5": { conditions: { sm: "fyvr1gk", md: "fyvr1gl", lg: "fyvr1gm", xl: "fyvr1gn" }, defaultClass: "fyvr1gk" }, "1.5": { conditions: { sm: "fyvr1go", md: "fyvr1gp", lg: "fyvr1gq", xl: "fyvr1gr" }, defaultClass: "fyvr1go" }, none: { conditions: { sm: "fyvr1gs", md: "fyvr1gt", lg: "fyvr1gu", xl: "fyvr1gv" }, defaultClass: "fyvr1gs" }, px: { conditions: { sm: "fyvr1gw", md: "fyvr1gx", lg: "fyvr1gy", xl: "fyvr1gz" }, defaultClass: "fyvr1gw" }, auto: { conditions: { sm: "fyvr1h0", md: "fyvr1h1", lg: "fyvr1h2", xl: "fyvr1h3" }, defaultClass: "fyvr1h0" }, full: { conditions: { sm: "fyvr1h4", md: "fyvr1h5", lg: "fyvr1h6", xl: "fyvr1h7" }, defaultClass: "fyvr1h4" }, "1/2": { conditions: { sm: "fyvr1h8", md: "fyvr1h9", lg: "fyvr1ha", xl: "fyvr1hb" }, defaultClass: "fyvr1h8" }, "1/3": { conditions: { sm: "fyvr1hc", md: "fyvr1hd", lg: "fyvr1he", xl: "fyvr1hf" }, defaultClass: "fyvr1hc" }, "2/3": { conditions: { sm: "fyvr1hg", md: "fyvr1hh", lg: "fyvr1hi", xl: "fyvr1hj" }, defaultClass: "fyvr1hg" }, "1/4": { conditions: { sm: "fyvr1hk", md: "fyvr1hl", lg: "fyvr1hm", xl: "fyvr1hn" }, defaultClass: "fyvr1hk" }, "3/4": { conditions: { sm: "fyvr1ho", md: "fyvr1hp", lg: "fyvr1hq", xl: "fyvr1hr" }, defaultClass: "fyvr1ho" }, fit: { conditions: { sm: "fyvr1hs", md: "fyvr1ht", lg: "fyvr1hu", xl: "fyvr1hv" }, defaultClass: "fyvr1hs" }, max: { conditions: { sm: "fyvr1hw", md: "fyvr1hx", lg: "fyvr1hy", xl: "fyvr1hz" }, defaultClass: "fyvr1hw" }, min: { conditions: { sm: "fyvr1i0", md: "fyvr1i1", lg: "fyvr1i2", xl: "fyvr1i3" }, defaultClass: "fyvr1i0" }, vw: { conditions: { sm: "fyvr1i4", md: "fyvr1i5", lg: "fyvr1i6", xl: "fyvr1i7" }, defaultClass: "fyvr1i4" }, vh: { conditions: { sm: "fyvr1i8", md: "fyvr1i9", lg: "fyvr1ia", xl: "fyvr1ib" }, defaultClass: "fyvr1i8" } } }, minHeight: { values: { "0": { conditions: { sm: "fyvr1ic", md: "fyvr1id", lg: "fyvr1ie", xl: "fyvr1if" }, defaultClass: "fyvr1ic" }, "1": { conditions: { sm: "fyvr1ig", md: "fyvr1ih", lg: "fyvr1ii", xl: "fyvr1ij" }, defaultClass: "fyvr1ig" }, "2": { conditions: { sm: "fyvr1ik", md: "fyvr1il", lg: "fyvr1im", xl: "fyvr1in" }, defaultClass: "fyvr1ik" }, "3": { conditions: { sm: "fyvr1io", md: "fyvr1ip", lg: "fyvr1iq", xl: "fyvr1ir" }, defaultClass: "fyvr1io" }, "4": { conditions: { sm: "fyvr1is", md: "fyvr1it", lg: "fyvr1iu", xl: "fyvr1iv" }, defaultClass: "fyvr1is" }, "5": { conditions: { sm: "fyvr1iw", md: "fyvr1ix", lg: "fyvr1iy", xl: "fyvr1iz" }, defaultClass: "fyvr1iw" }, "6": { conditions: { sm: "fyvr1j0", md: "fyvr1j1", lg: "fyvr1j2", xl: "fyvr1j3" }, defaultClass: "fyvr1j0" }, "7": { conditions: { sm: "fyvr1j4", md: "fyvr1j5", lg: "fyvr1j6", xl: "fyvr1j7" }, defaultClass: "fyvr1j4" }, "8": { conditions: { sm: "fyvr1j8", md: "fyvr1j9", lg: "fyvr1ja", xl: "fyvr1jb" }, defaultClass: "fyvr1j8" }, "9": { conditions: { sm: "fyvr1jc", md: "fyvr1jd", lg: "fyvr1je", xl: "fyvr1jf" }, defaultClass: "fyvr1jc" }, "10": { conditions: { sm: "fyvr1jg", md: "fyvr1jh", lg: "fyvr1ji", xl: "fyvr1jj" }, defaultClass: "fyvr1jg" }, "12": { conditions: { sm: "fyvr1jk", md: "fyvr1jl", lg: "fyvr1jm", xl: "fyvr1jn" }, defaultClass: "fyvr1jk" }, "14": { conditions: { sm: "fyvr1jo", md: "fyvr1jp", lg: "fyvr1jq", xl: "fyvr1jr" }, defaultClass: "fyvr1jo" }, "16": { conditions: { sm: "fyvr1js", md: "fyvr1jt", lg: "fyvr1ju", xl: "fyvr1jv" }, defaultClass: "fyvr1js" }, "18": { conditions: { sm: "fyvr1jw", md: "fyvr1jx", lg: "fyvr1jy", xl: "fyvr1jz" }, defaultClass: "fyvr1jw" }, "20": { conditions: { sm: "fyvr1k0", md: "fyvr1k1", lg: "fyvr1k2", xl: "fyvr1k3" }, defaultClass: "fyvr1k0" }, "0.25": { conditions: { sm: "fyvr1k4", md: "fyvr1k5", lg: "fyvr1k6", xl: "fyvr1k7" }, defaultClass: "fyvr1k4" }, "0.5": { conditions: { sm: "fyvr1k8", md: "fyvr1k9", lg: "fyvr1ka", xl: "fyvr1kb" }, defaultClass: "fyvr1k8" }, "1.5": { conditions: { sm: "fyvr1kc", md: "fyvr1kd", lg: "fyvr1ke", xl: "fyvr1kf" }, defaultClass: "fyvr1kc" }, none: { conditions: { sm: "fyvr1kg", md: "fyvr1kh", lg: "fyvr1ki", xl: "fyvr1kj" }, defaultClass: "fyvr1kg" }, px: { conditions: { sm: "fyvr1kk", md: "fyvr1kl", lg: "fyvr1km", xl: "fyvr1kn" }, defaultClass: "fyvr1kk" }, auto: { conditions: { sm: "fyvr1ko", md: "fyvr1kp", lg: "fyvr1kq", xl: "fyvr1kr" }, defaultClass: "fyvr1ko" }, full: { conditions: { sm: "fyvr1ks", md: "fyvr1kt", lg: "fyvr1ku", xl: "fyvr1kv" }, defaultClass: "fyvr1ks" }, "1/2": { conditions: { sm: "fyvr1kw", md: "fyvr1kx", lg: "fyvr1ky", xl: "fyvr1kz" }, defaultClass: "fyvr1kw" }, "1/3": { conditions: { sm: "fyvr1l0", md: "fyvr1l1", lg: "fyvr1l2", xl: "fyvr1l3" }, defaultClass: "fyvr1l0" }, "2/3": { conditions: { sm: "fyvr1l4", md: "fyvr1l5", lg: "fyvr1l6", xl: "fyvr1l7" }, defaultClass: "fyvr1l4" }, "1/4": { conditions: { sm: "fyvr1l8", md: "fyvr1l9", lg: "fyvr1la", xl: "fyvr1lb" }, defaultClass: "fyvr1l8" }, "3/4": { conditions: { sm: "fyvr1lc", md: "fyvr1ld", lg: "fyvr1le", xl: "fyvr1lf" }, defaultClass: "fyvr1lc" }, fit: { conditions: { sm: "fyvr1lg", md: "fyvr1lh", lg: "fyvr1li", xl: "fyvr1lj" }, defaultClass: "fyvr1lg" }, max: { conditions: { sm: "fyvr1lk", md: "fyvr1ll", lg: "fyvr1lm", xl: "fyvr1ln" }, defaultClass: "fyvr1lk" }, min: { conditions: { sm: "fyvr1lo", md: "fyvr1lp", lg: "fyvr1lq", xl: "fyvr1lr" }, defaultClass: "fyvr1lo" }, vw: { conditions: { sm: "fyvr1ls", md: "fyvr1lt", lg: "fyvr1lu", xl: "fyvr1lv" }, defaultClass: "fyvr1ls" }, vh: { conditions: { sm: "fyvr1lw", md: "fyvr1lx", lg: "fyvr1ly", xl: "fyvr1lz" }, defaultClass: "fyvr1lw" } } }, top: { values: { "0": { conditions: { sm: "fyvr1m0", md: "fyvr1m1", lg: "fyvr1m2", xl: "fyvr1m3" }, defaultClass: "fyvr1m0" }, "1": { conditions: { sm: "fyvr1m4", md: "fyvr1m5", lg: "fyvr1m6", xl: "fyvr1m7" }, defaultClass: "fyvr1m4" }, "2": { conditions: { sm: "fyvr1m8", md: "fyvr1m9", lg: "fyvr1ma", xl: "fyvr1mb" }, defaultClass: "fyvr1m8" }, "3": { conditions: { sm: "fyvr1mc", md: "fyvr1md", lg: "fyvr1me", xl: "fyvr1mf" }, defaultClass: "fyvr1mc" }, "4": { conditions: { sm: "fyvr1mg", md: "fyvr1mh", lg: "fyvr1mi", xl: "fyvr1mj" }, defaultClass: "fyvr1mg" }, "5": { conditions: { sm: "fyvr1mk", md: "fyvr1ml", lg: "fyvr1mm", xl: "fyvr1mn" }, defaultClass: "fyvr1mk" }, "6": { conditions: { sm: "fyvr1mo", md: "fyvr1mp", lg: "fyvr1mq", xl: "fyvr1mr" }, defaultClass: "fyvr1mo" }, "7": { conditions: { sm: "fyvr1ms", md: "fyvr1mt", lg: "fyvr1mu", xl: "fyvr1mv" }, defaultClass: "fyvr1ms" }, "8": { conditions: { sm: "fyvr1mw", md: "fyvr1mx", lg: "fyvr1my", xl: "fyvr1mz" }, defaultClass: "fyvr1mw" }, "9": { conditions: { sm: "fyvr1n0", md: "fyvr1n1", lg: "fyvr1n2", xl: "fyvr1n3" }, defaultClass: "fyvr1n0" }, "10": { conditions: { sm: "fyvr1n4", md: "fyvr1n5", lg: "fyvr1n6", xl: "fyvr1n7" }, defaultClass: "fyvr1n4" }, "12": { conditions: { sm: "fyvr1n8", md: "fyvr1n9", lg: "fyvr1na", xl: "fyvr1nb" }, defaultClass: "fyvr1n8" }, "14": { conditions: { sm: "fyvr1nc", md: "fyvr1nd", lg: "fyvr1ne", xl: "fyvr1nf" }, defaultClass: "fyvr1nc" }, "16": { conditions: { sm: "fyvr1ng", md: "fyvr1nh", lg: "fyvr1ni", xl: "fyvr1nj" }, defaultClass: "fyvr1ng" }, "18": { conditions: { sm: "fyvr1nk", md: "fyvr1nl", lg: "fyvr1nm", xl: "fyvr1nn" }, defaultClass: "fyvr1nk" }, "20": { conditions: { sm: "fyvr1no", md: "fyvr1np", lg: "fyvr1nq", xl: "fyvr1nr" }, defaultClass: "fyvr1no" }, "0.25": { conditions: { sm: "fyvr1ns", md: "fyvr1nt", lg: "fyvr1nu", xl: "fyvr1nv" }, defaultClass: "fyvr1ns" }, "0.5": { conditions: { sm: "fyvr1nw", md: "fyvr1nx", lg: "fyvr1ny", xl: "fyvr1nz" }, defaultClass: "fyvr1nw" }, "1.5": { conditions: { sm: "fyvr1o0", md: "fyvr1o1", lg: "fyvr1o2", xl: "fyvr1o3" }, defaultClass: "fyvr1o0" }, auto: { conditions: { sm: "fyvr1o4", md: "fyvr1o5", lg: "fyvr1o6", xl: "fyvr1o7" }, defaultClass: "fyvr1o4" } } }, bottom: { values: { "0": { conditions: { sm: "fyvr1o8", md: "fyvr1o9", lg: "fyvr1oa", xl: "fyvr1ob" }, defaultClass: "fyvr1o8" }, "1": { conditions: { sm: "fyvr1oc", md: "fyvr1od", lg: "fyvr1oe", xl: "fyvr1of" }, defaultClass: "fyvr1oc" }, "2": { conditions: { sm: "fyvr1og", md: "fyvr1oh", lg: "fyvr1oi", xl: "fyvr1oj" }, defaultClass: "fyvr1og" }, "3": { conditions: { sm: "fyvr1ok", md: "fyvr1ol", lg: "fyvr1om", xl: "fyvr1on" }, defaultClass: "fyvr1ok" }, "4": { conditions: { sm: "fyvr1oo", md: "fyvr1op", lg: "fyvr1oq", xl: "fyvr1or" }, defaultClass: "fyvr1oo" }, "5": { conditions: { sm: "fyvr1os", md: "fyvr1ot", lg: "fyvr1ou", xl: "fyvr1ov" }, defaultClass: "fyvr1os" }, "6": { conditions: { sm: "fyvr1ow", md: "fyvr1ox", lg: "fyvr1oy", xl: "fyvr1oz" }, defaultClass: "fyvr1ow" }, "7": { conditions: { sm: "fyvr1p0", md: "fyvr1p1", lg: "fyvr1p2", xl: "fyvr1p3" }, defaultClass: "fyvr1p0" }, "8": { conditions: { sm: "fyvr1p4", md: "fyvr1p5", lg: "fyvr1p6", xl: "fyvr1p7" }, defaultClass: "fyvr1p4" }, "9": { conditions: { sm: "fyvr1p8", md: "fyvr1p9", lg: "fyvr1pa", xl: "fyvr1pb" }, defaultClass: "fyvr1p8" }, "10": { conditions: { sm: "fyvr1pc", md: "fyvr1pd", lg: "fyvr1pe", xl: "fyvr1pf" }, defaultClass: "fyvr1pc" }, "12": { conditions: { sm: "fyvr1pg", md: "fyvr1ph", lg: "fyvr1pi", xl: "fyvr1pj" }, defaultClass: "fyvr1pg" }, "14": { conditions: { sm: "fyvr1pk", md: "fyvr1pl", lg: "fyvr1pm", xl: "fyvr1pn" }, defaultClass: "fyvr1pk" }, "16": { conditions: { sm: "fyvr1po", md: "fyvr1pp", lg: "fyvr1pq", xl: "fyvr1pr" }, defaultClass: "fyvr1po" }, "18": { conditions: { sm: "fyvr1ps", md: "fyvr1pt", lg: "fyvr1pu", xl: "fyvr1pv" }, defaultClass: "fyvr1ps" }, "20": { conditions: { sm: "fyvr1pw", md: "fyvr1px", lg: "fyvr1py", xl: "fyvr1pz" }, defaultClass: "fyvr1pw" }, "0.25": { conditions: { sm: "fyvr1q0", md: "fyvr1q1", lg: "fyvr1q2", xl: "fyvr1q3" }, defaultClass: "fyvr1q0" }, "0.5": { conditions: { sm: "fyvr1q4", md: "fyvr1q5", lg: "fyvr1q6", xl: "fyvr1q7" }, defaultClass: "fyvr1q4" }, "1.5": { conditions: { sm: "fyvr1q8", md: "fyvr1q9", lg: "fyvr1qa", xl: "fyvr1qb" }, defaultClass: "fyvr1q8" }, auto: { conditions: { sm: "fyvr1qc", md: "fyvr1qd", lg: "fyvr1qe", xl: "fyvr1qf" }, defaultClass: "fyvr1qc" } } }, left: { values: { "0": { conditions: { sm: "fyvr1qg", md: "fyvr1qh", lg: "fyvr1qi", xl: "fyvr1qj" }, defaultClass: "fyvr1qg" }, "1": { conditions: { sm: "fyvr1qk", md: "fyvr1ql", lg: "fyvr1qm", xl: "fyvr1qn" }, defaultClass: "fyvr1qk" }, "2": { conditions: { sm: "fyvr1qo", md: "fyvr1qp", lg: "fyvr1qq", xl: "fyvr1qr" }, defaultClass: "fyvr1qo" }, "3": { conditions: { sm: "fyvr1qs", md: "fyvr1qt", lg: "fyvr1qu", xl: "fyvr1qv" }, defaultClass: "fyvr1qs" }, "4": { conditions: { sm: "fyvr1qw", md: "fyvr1qx", lg: "fyvr1qy", xl: "fyvr1qz" }, defaultClass: "fyvr1qw" }, "5": { conditions: { sm: "fyvr1r0", md: "fyvr1r1", lg: "fyvr1r2", xl: "fyvr1r3" }, defaultClass: "fyvr1r0" }, "6": { conditions: { sm: "fyvr1r4", md: "fyvr1r5", lg: "fyvr1r6", xl: "fyvr1r7" }, defaultClass: "fyvr1r4" }, "7": { conditions: { sm: "fyvr1r8", md: "fyvr1r9", lg: "fyvr1ra", xl: "fyvr1rb" }, defaultClass: "fyvr1r8" }, "8": { conditions: { sm: "fyvr1rc", md: "fyvr1rd", lg: "fyvr1re", xl: "fyvr1rf" }, defaultClass: "fyvr1rc" }, "9": { conditions: { sm: "fyvr1rg", md: "fyvr1rh", lg: "fyvr1ri", xl: "fyvr1rj" }, defaultClass: "fyvr1rg" }, "10": { conditions: { sm: "fyvr1rk", md: "fyvr1rl", lg: "fyvr1rm", xl: "fyvr1rn" }, defaultClass: "fyvr1rk" }, "12": { conditions: { sm: "fyvr1ro", md: "fyvr1rp", lg: "fyvr1rq", xl: "fyvr1rr" }, defaultClass: "fyvr1ro" }, "14": { conditions: { sm: "fyvr1rs", md: "fyvr1rt", lg: "fyvr1ru", xl: "fyvr1rv" }, defaultClass: "fyvr1rs" }, "16": { conditions: { sm: "fyvr1rw", md: "fyvr1rx", lg: "fyvr1ry", xl: "fyvr1rz" }, defaultClass: "fyvr1rw" }, "18": { conditions: { sm: "fyvr1s0", md: "fyvr1s1", lg: "fyvr1s2", xl: "fyvr1s3" }, defaultClass: "fyvr1s0" }, "20": { conditions: { sm: "fyvr1s4", md: "fyvr1s5", lg: "fyvr1s6", xl: "fyvr1s7" }, defaultClass: "fyvr1s4" }, "0.25": { conditions: { sm: "fyvr1s8", md: "fyvr1s9", lg: "fyvr1sa", xl: "fyvr1sb" }, defaultClass: "fyvr1s8" }, "0.5": { conditions: { sm: "fyvr1sc", md: "fyvr1sd", lg: "fyvr1se", xl: "fyvr1sf" }, defaultClass: "fyvr1sc" }, "1.5": { conditions: { sm: "fyvr1sg", md: "fyvr1sh", lg: "fyvr1si", xl: "fyvr1sj" }, defaultClass: "fyvr1sg" }, auto: { conditions: { sm: "fyvr1sk", md: "fyvr1sl", lg: "fyvr1sm", xl: "fyvr1sn" }, defaultClass: "fyvr1sk" } } }, right: { values: { "0": { conditions: { sm: "fyvr1so", md: "fyvr1sp", lg: "fyvr1sq", xl: "fyvr1sr" }, defaultClass: "fyvr1so" }, "1": { conditions: { sm: "fyvr1ss", md: "fyvr1st", lg: "fyvr1su", xl: "fyvr1sv" }, defaultClass: "fyvr1ss" }, "2": { conditions: { sm: "fyvr1sw", md: "fyvr1sx", lg: "fyvr1sy", xl: "fyvr1sz" }, defaultClass: "fyvr1sw" }, "3": { conditions: { sm: "fyvr1t0", md: "fyvr1t1", lg: "fyvr1t2", xl: "fyvr1t3" }, defaultClass: "fyvr1t0" }, "4": { conditions: { sm: "fyvr1t4", md: "fyvr1t5", lg: "fyvr1t6", xl: "fyvr1t7" }, defaultClass: "fyvr1t4" }, "5": { conditions: { sm: "fyvr1t8", md: "fyvr1t9", lg: "fyvr1ta", xl: "fyvr1tb" }, defaultClass: "fyvr1t8" }, "6": { conditions: { sm: "fyvr1tc", md: "fyvr1td", lg: "fyvr1te", xl: "fyvr1tf" }, defaultClass: "fyvr1tc" }, "7": { conditions: { sm: "fyvr1tg", md: "fyvr1th", lg: "fyvr1ti", xl: "fyvr1tj" }, defaultClass: "fyvr1tg" }, "8": { conditions: { sm: "fyvr1tk", md: "fyvr1tl", lg: "fyvr1tm", xl: "fyvr1tn" }, defaultClass: "fyvr1tk" }, "9": { conditions: { sm: "fyvr1to", md: "fyvr1tp", lg: "fyvr1tq", xl: "fyvr1tr" }, defaultClass: "fyvr1to" }, "10": { conditions: { sm: "fyvr1ts", md: "fyvr1tt", lg: "fyvr1tu", xl: "fyvr1tv" }, defaultClass: "fyvr1ts" }, "12": { conditions: { sm: "fyvr1tw", md: "fyvr1tx", lg: "fyvr1ty", xl: "fyvr1tz" }, defaultClass: "fyvr1tw" }, "14": { conditions: { sm: "fyvr1u0", md: "fyvr1u1", lg: "fyvr1u2", xl: "fyvr1u3" }, defaultClass: "fyvr1u0" }, "16": { conditions: { sm: "fyvr1u4", md: "fyvr1u5", lg: "fyvr1u6", xl: "fyvr1u7" }, defaultClass: "fyvr1u4" }, "18": { conditions: { sm: "fyvr1u8", md: "fyvr1u9", lg: "fyvr1ua", xl: "fyvr1ub" }, defaultClass: "fyvr1u8" }, "20": { conditions: { sm: "fyvr1uc", md: "fyvr1ud", lg: "fyvr1ue", xl: "fyvr1uf" }, defaultClass: "fyvr1uc" }, "0.25": { conditions: { sm: "fyvr1ug", md: "fyvr1uh", lg: "fyvr1ui", xl: "fyvr1uj" }, defaultClass: "fyvr1ug" }, "0.5": { conditions: { sm: "fyvr1uk", md: "fyvr1ul", lg: "fyvr1um", xl: "fyvr1un" }, defaultClass: "fyvr1uk" }, "1.5": { conditions: { sm: "fyvr1uo", md: "fyvr1up", lg: "fyvr1uq", xl: "fyvr1ur" }, defaultClass: "fyvr1uo" }, auto: { conditions: { sm: "fyvr1us", md: "fyvr1ut", lg: "fyvr1uu", xl: "fyvr1uv" }, defaultClass: "fyvr1us" } } }, paddingTop: { values: { "0": { conditions: { sm: "fyvr1uw", md: "fyvr1ux", lg: "fyvr1uy", xl: "fyvr1uz" }, defaultClass: "fyvr1uw" }, "1": { conditions: { sm: "fyvr1v0", md: "fyvr1v1", lg: "fyvr1v2", xl: "fyvr1v3" }, defaultClass: "fyvr1v0" }, "2": { conditions: { sm: "fyvr1v4", md: "fyvr1v5", lg: "fyvr1v6", xl: "fyvr1v7" }, defaultClass: "fyvr1v4" }, "3": { conditions: { sm: "fyvr1v8", md: "fyvr1v9", lg: "fyvr1va", xl: "fyvr1vb" }, defaultClass: "fyvr1v8" }, "4": { conditions: { sm: "fyvr1vc", md: "fyvr1vd", lg: "fyvr1ve", xl: "fyvr1vf" }, defaultClass: "fyvr1vc" }, "5": { conditions: { sm: "fyvr1vg", md: "fyvr1vh", lg: "fyvr1vi", xl: "fyvr1vj" }, defaultClass: "fyvr1vg" }, "6": { conditions: { sm: "fyvr1vk", md: "fyvr1vl", lg: "fyvr1vm", xl: "fyvr1vn" }, defaultClass: "fyvr1vk" }, "7": { conditions: { sm: "fyvr1vo", md: "fyvr1vp", lg: "fyvr1vq", xl: "fyvr1vr" }, defaultClass: "fyvr1vo" }, "8": { conditions: { sm: "fyvr1vs", md: "fyvr1vt", lg: "fyvr1vu", xl: "fyvr1vv" }, defaultClass: "fyvr1vs" }, "9": { conditions: { sm: "fyvr1vw", md: "fyvr1vx", lg: "fyvr1vy", xl: "fyvr1vz" }, defaultClass: "fyvr1vw" }, "10": { conditions: { sm: "fyvr1w0", md: "fyvr1w1", lg: "fyvr1w2", xl: "fyvr1w3" }, defaultClass: "fyvr1w0" }, "12": { conditions: { sm: "fyvr1w4", md: "fyvr1w5", lg: "fyvr1w6", xl: "fyvr1w7" }, defaultClass: "fyvr1w4" }, "14": { conditions: { sm: "fyvr1w8", md: "fyvr1w9", lg: "fyvr1wa", xl: "fyvr1wb" }, defaultClass: "fyvr1w8" }, "16": { conditions: { sm: "fyvr1wc", md: "fyvr1wd", lg: "fyvr1we", xl: "fyvr1wf" }, defaultClass: "fyvr1wc" }, "18": { conditions: { sm: "fyvr1wg", md: "fyvr1wh", lg: "fyvr1wi", xl: "fyvr1wj" }, defaultClass: "fyvr1wg" }, "20": { conditions: { sm: "fyvr1wk", md: "fyvr1wl", lg: "fyvr1wm", xl: "fyvr1wn" }, defaultClass: "fyvr1wk" }, "0.25": { conditions: { sm: "fyvr1wo", md: "fyvr1wp", lg: "fyvr1wq", xl: "fyvr1wr" }, defaultClass: "fyvr1wo" }, "0.5": { conditions: { sm: "fyvr1ws", md: "fyvr1wt", lg: "fyvr1wu", xl: "fyvr1wv" }, defaultClass: "fyvr1ws" }, "1.5": { conditions: { sm: "fyvr1ww", md: "fyvr1wx", lg: "fyvr1wy", xl: "fyvr1wz" }, defaultClass: "fyvr1ww" } } }, paddingBottom: { values: { "0": { conditions: { sm: "fyvr1x0", md: "fyvr1x1", lg: "fyvr1x2", xl: "fyvr1x3" }, defaultClass: "fyvr1x0" }, "1": { conditions: { sm: "fyvr1x4", md: "fyvr1x5", lg: "fyvr1x6", xl: "fyvr1x7" }, defaultClass: "fyvr1x4" }, "2": { conditions: { sm: "fyvr1x8", md: "fyvr1x9", lg: "fyvr1xa", xl: "fyvr1xb" }, defaultClass: "fyvr1x8" }, "3": { conditions: { sm: "fyvr1xc", md: "fyvr1xd", lg: "fyvr1xe", xl: "fyvr1xf" }, defaultClass: "fyvr1xc" }, "4": { conditions: { sm: "fyvr1xg", md: "fyvr1xh", lg: "fyvr1xi", xl: "fyvr1xj" }, defaultClass: "fyvr1xg" }, "5": { conditions: { sm: "fyvr1xk", md: "fyvr1xl", lg: "fyvr1xm", xl: "fyvr1xn" }, defaultClass: "fyvr1xk" }, "6": { conditions: { sm: "fyvr1xo", md: "fyvr1xp", lg: "fyvr1xq", xl: "fyvr1xr" }, defaultClass: "fyvr1xo" }, "7": { conditions: { sm: "fyvr1xs", md: "fyvr1xt", lg: "fyvr1xu", xl: "fyvr1xv" }, defaultClass: "fyvr1xs" }, "8": { conditions: { sm: "fyvr1xw", md: "fyvr1xx", lg: "fyvr1xy", xl: "fyvr1xz" }, defaultClass: "fyvr1xw" }, "9": { conditions: { sm: "fyvr1y0", md: "fyvr1y1", lg: "fyvr1y2", xl: "fyvr1y3" }, defaultClass: "fyvr1y0" }, "10": { conditions: { sm: "fyvr1y4", md: "fyvr1y5", lg: "fyvr1y6", xl: "fyvr1y7" }, defaultClass: "fyvr1y4" }, "12": { conditions: { sm: "fyvr1y8", md: "fyvr1y9", lg: "fyvr1ya", xl: "fyvr1yb" }, defaultClass: "fyvr1y8" }, "14": { conditions: { sm: "fyvr1yc", md: "fyvr1yd", lg: "fyvr1ye", xl: "fyvr1yf" }, defaultClass: "fyvr1yc" }, "16": { conditions: { sm: "fyvr1yg", md: "fyvr1yh", lg: "fyvr1yi", xl: "fyvr1yj" }, defaultClass: "fyvr1yg" }, "18": { conditions: { sm: "fyvr1yk", md: "fyvr1yl", lg: "fyvr1ym", xl: "fyvr1yn" }, defaultClass: "fyvr1yk" }, "20": { conditions: { sm: "fyvr1yo", md: "fyvr1yp", lg: "fyvr1yq", xl: "fyvr1yr" }, defaultClass: "fyvr1yo" }, "0.25": { conditions: { sm: "fyvr1ys", md: "fyvr1yt", lg: "fyvr1yu", xl: "fyvr1yv" }, defaultClass: "fyvr1ys" }, "0.5": { conditions: { sm: "fyvr1yw", md: "fyvr1yx", lg: "fyvr1yy", xl: "fyvr1yz" }, defaultClass: "fyvr1yw" }, "1.5": { conditions: { sm: "fyvr1z0", md: "fyvr1z1", lg: "fyvr1z2", xl: "fyvr1z3" }, defaultClass: "fyvr1z0" } } }, paddingLeft: { values: { "0": { conditions: { sm: "fyvr1z4", md: "fyvr1z5", lg: "fyvr1z6", xl: "fyvr1z7" }, defaultClass: "fyvr1z4" }, "1": { conditions: { sm: "fyvr1z8", md: "fyvr1z9", lg: "fyvr1za", xl: "fyvr1zb" }, defaultClass: "fyvr1z8" }, "2": { conditions: { sm: "fyvr1zc", md: "fyvr1zd", lg: "fyvr1ze", xl: "fyvr1zf" }, defaultClass: "fyvr1zc" }, "3": { conditions: { sm: "fyvr1zg", md: "fyvr1zh", lg: "fyvr1zi", xl: "fyvr1zj" }, defaultClass: "fyvr1zg" }, "4": { conditions: { sm: "fyvr1zk", md: "fyvr1zl", lg: "fyvr1zm", xl: "fyvr1zn" }, defaultClass: "fyvr1zk" }, "5": { conditions: { sm: "fyvr1zo", md: "fyvr1zp", lg: "fyvr1zq", xl: "fyvr1zr" }, defaultClass: "fyvr1zo" }, "6": { conditions: { sm: "fyvr1zs", md: "fyvr1zt", lg: "fyvr1zu", xl: "fyvr1zv" }, defaultClass: "fyvr1zs" }, "7": { conditions: { sm: "fyvr1zw", md: "fyvr1zx", lg: "fyvr1zy", xl: "fyvr1zz" }, defaultClass: "fyvr1zw" }, "8": { conditions: { sm: "fyvr1100", md: "fyvr1101", lg: "fyvr1102", xl: "fyvr1103" }, defaultClass: "fyvr1100" }, "9": { conditions: { sm: "fyvr1104", md: "fyvr1105", lg: "fyvr1106", xl: "fyvr1107" }, defaultClass: "fyvr1104" }, "10": { conditions: { sm: "fyvr1108", md: "fyvr1109", lg: "fyvr110a", xl: "fyvr110b" }, defaultClass: "fyvr1108" }, "12": { conditions: { sm: "fyvr110c", md: "fyvr110d", lg: "fyvr110e", xl: "fyvr110f" }, defaultClass: "fyvr110c" }, "14": { conditions: { sm: "fyvr110g", md: "fyvr110h", lg: "fyvr110i", xl: "fyvr110j" }, defaultClass: "fyvr110g" }, "16": { conditions: { sm: "fyvr110k", md: "fyvr110l", lg: "fyvr110m", xl: "fyvr110n" }, defaultClass: "fyvr110k" }, "18": { conditions: { sm: "fyvr110o", md: "fyvr110p", lg: "fyvr110q", xl: "fyvr110r" }, defaultClass: "fyvr110o" }, "20": { conditions: { sm: "fyvr110s", md: "fyvr110t", lg: "fyvr110u", xl: "fyvr110v" }, defaultClass: "fyvr110s" }, "0.25": { conditions: { sm: "fyvr110w", md: "fyvr110x", lg: "fyvr110y", xl: "fyvr110z" }, defaultClass: "fyvr110w" }, "0.5": { conditions: { sm: "fyvr1110", md: "fyvr1111", lg: "fyvr1112", xl: "fyvr1113" }, defaultClass: "fyvr1110" }, "1.5": { conditions: { sm: "fyvr1114", md: "fyvr1115", lg: "fyvr1116", xl: "fyvr1117" }, defaultClass: "fyvr1114" } } }, paddingRight: { values: { "0": { conditions: { sm: "fyvr1118", md: "fyvr1119", lg: "fyvr111a", xl: "fyvr111b" }, defaultClass: "fyvr1118" }, "1": { conditions: { sm: "fyvr111c", md: "fyvr111d", lg: "fyvr111e", xl: "fyvr111f" }, defaultClass: "fyvr111c" }, "2": { conditions: { sm: "fyvr111g", md: "fyvr111h", lg: "fyvr111i", xl: "fyvr111j" }, defaultClass: "fyvr111g" }, "3": { conditions: { sm: "fyvr111k", md: "fyvr111l", lg: "fyvr111m", xl: "fyvr111n" }, defaultClass: "fyvr111k" }, "4": { conditions: { sm: "fyvr111o", md: "fyvr111p", lg: "fyvr111q", xl: "fyvr111r" }, defaultClass: "fyvr111o" }, "5": { conditions: { sm: "fyvr111s", md: "fyvr111t", lg: "fyvr111u", xl: "fyvr111v" }, defaultClass: "fyvr111s" }, "6": { conditions: { sm: "fyvr111w", md: "fyvr111x", lg: "fyvr111y", xl: "fyvr111z" }, defaultClass: "fyvr111w" }, "7": { conditions: { sm: "fyvr1120", md: "fyvr1121", lg: "fyvr1122", xl: "fyvr1123" }, defaultClass: "fyvr1120" }, "8": { conditions: { sm: "fyvr1124", md: "fyvr1125", lg: "fyvr1126", xl: "fyvr1127" }, defaultClass: "fyvr1124" }, "9": { conditions: { sm: "fyvr1128", md: "fyvr1129", lg: "fyvr112a", xl: "fyvr112b" }, defaultClass: "fyvr1128" }, "10": { conditions: { sm: "fyvr112c", md: "fyvr112d", lg: "fyvr112e", xl: "fyvr112f" }, defaultClass: "fyvr112c" }, "12": { conditions: { sm: "fyvr112g", md: "fyvr112h", lg: "fyvr112i", xl: "fyvr112j" }, defaultClass: "fyvr112g" }, "14": { conditions: { sm: "fyvr112k", md: "fyvr112l", lg: "fyvr112m", xl: "fyvr112n" }, defaultClass: "fyvr112k" }, "16": { conditions: { sm: "fyvr112o", md: "fyvr112p", lg: "fyvr112q", xl: "fyvr112r" }, defaultClass: "fyvr112o" }, "18": { conditions: { sm: "fyvr112s", md: "fyvr112t", lg: "fyvr112u", xl: "fyvr112v" }, defaultClass: "fyvr112s" }, "20": { conditions: { sm: "fyvr112w", md: "fyvr112x", lg: "fyvr112y", xl: "fyvr112z" }, defaultClass: "fyvr112w" }, "0.25": { conditions: { sm: "fyvr1130", md: "fyvr1131", lg: "fyvr1132", xl: "fyvr1133" }, defaultClass: "fyvr1130" }, "0.5": { conditions: { sm: "fyvr1134", md: "fyvr1135", lg: "fyvr1136", xl: "fyvr1137" }, defaultClass: "fyvr1134" }, "1.5": { conditions: { sm: "fyvr1138", md: "fyvr1139", lg: "fyvr113a", xl: "fyvr113b" }, defaultClass: "fyvr1138" } } }, marginTop: { values: { "0": { conditions: { sm: "fyvr113c", md: "fyvr113d", lg: "fyvr113e", xl: "fyvr113f" }, defaultClass: "fyvr113c" }, "1": { conditions: { sm: "fyvr113g", md: "fyvr113h", lg: "fyvr113i", xl: "fyvr113j" }, defaultClass: "fyvr113g" }, "2": { conditions: { sm: "fyvr113k", md: "fyvr113l", lg: "fyvr113m", xl: "fyvr113n" }, defaultClass: "fyvr113k" }, "3": { conditions: { sm: "fyvr113o", md: "fyvr113p", lg: "fyvr113q", xl: "fyvr113r" }, defaultClass: "fyvr113o" }, "4": { conditions: { sm: "fyvr113s", md: "fyvr113t", lg: "fyvr113u", xl: "fyvr113v" }, defaultClass: "fyvr113s" }, "5": { conditions: { sm: "fyvr113w", md: "fyvr113x", lg: "fyvr113y", xl: "fyvr113z" }, defaultClass: "fyvr113w" }, "6": { conditions: { sm: "fyvr1140", md: "fyvr1141", lg: "fyvr1142", xl: "fyvr1143" }, defaultClass: "fyvr1140" }, "7": { conditions: { sm: "fyvr1144", md: "fyvr1145", lg: "fyvr1146", xl: "fyvr1147" }, defaultClass: "fyvr1144" }, "8": { conditions: { sm: "fyvr1148", md: "fyvr1149", lg: "fyvr114a", xl: "fyvr114b" }, defaultClass: "fyvr1148" }, "9": { conditions: { sm: "fyvr114c", md: "fyvr114d", lg: "fyvr114e", xl: "fyvr114f" }, defaultClass: "fyvr114c" }, "10": { conditions: { sm: "fyvr114g", md: "fyvr114h", lg: "fyvr114i", xl: "fyvr114j" }, defaultClass: "fyvr114g" }, "12": { conditions: { sm: "fyvr114k", md: "fyvr114l", lg: "fyvr114m", xl: "fyvr114n" }, defaultClass: "fyvr114k" }, "14": { conditions: { sm: "fyvr114o", md: "fyvr114p", lg: "fyvr114q", xl: "fyvr114r" }, defaultClass: "fyvr114o" }, "16": { conditions: { sm: "fyvr114s", md: "fyvr114t", lg: "fyvr114u", xl: "fyvr114v" }, defaultClass: "fyvr114s" }, "18": { conditions: { sm: "fyvr114w", md: "fyvr114x", lg: "fyvr114y", xl: "fyvr114z" }, defaultClass: "fyvr114w" }, "20": { conditions: { sm: "fyvr1150", md: "fyvr1151", lg: "fyvr1152", xl: "fyvr1153" }, defaultClass: "fyvr1150" }, "0.25": { conditions: { sm: "fyvr1154", md: "fyvr1155", lg: "fyvr1156", xl: "fyvr1157" }, defaultClass: "fyvr1154" }, "0.5": { conditions: { sm: "fyvr1158", md: "fyvr1159", lg: "fyvr115a", xl: "fyvr115b" }, defaultClass: "fyvr1158" }, "1.5": { conditions: { sm: "fyvr115c", md: "fyvr115d", lg: "fyvr115e", xl: "fyvr115f" }, defaultClass: "fyvr115c" }, auto: { conditions: { sm: "fyvr115g", md: "fyvr115h", lg: "fyvr115i", xl: "fyvr115j" }, defaultClass: "fyvr115g" } } }, marginBottom: { values: { "0": { conditions: { sm: "fyvr115k", md: "fyvr115l", lg: "fyvr115m", xl: "fyvr115n" }, defaultClass: "fyvr115k" }, "1": { conditions: { sm: "fyvr115o", md: "fyvr115p", lg: "fyvr115q", xl: "fyvr115r" }, defaultClass: "fyvr115o" }, "2": { conditions: { sm: "fyvr115s", md: "fyvr115t", lg: "fyvr115u", xl: "fyvr115v" }, defaultClass: "fyvr115s" }, "3": { conditions: { sm: "fyvr115w", md: "fyvr115x", lg: "fyvr115y", xl: "fyvr115z" }, defaultClass: "fyvr115w" }, "4": { conditions: { sm: "fyvr1160", md: "fyvr1161", lg: "fyvr1162", xl: "fyvr1163" }, defaultClass: "fyvr1160" }, "5": { conditions: { sm: "fyvr1164", md: "fyvr1165", lg: "fyvr1166", xl: "fyvr1167" }, defaultClass: "fyvr1164" }, "6": { conditions: { sm: "fyvr1168", md: "fyvr1169", lg: "fyvr116a", xl: "fyvr116b" }, defaultClass: "fyvr1168" }, "7": { conditions: { sm: "fyvr116c", md: "fyvr116d", lg: "fyvr116e", xl: "fyvr116f" }, defaultClass: "fyvr116c" }, "8": { conditions: { sm: "fyvr116g", md: "fyvr116h", lg: "fyvr116i", xl: "fyvr116j" }, defaultClass: "fyvr116g" }, "9": { conditions: { sm: "fyvr116k", md: "fyvr116l", lg: "fyvr116m", xl: "fyvr116n" }, defaultClass: "fyvr116k" }, "10": { conditions: { sm: "fyvr116o", md: "fyvr116p", lg: "fyvr116q", xl: "fyvr116r" }, defaultClass: "fyvr116o" }, "12": { conditions: { sm: "fyvr116s", md: "fyvr116t", lg: "fyvr116u", xl: "fyvr116v" }, defaultClass: "fyvr116s" }, "14": { conditions: { sm: "fyvr116w", md: "fyvr116x", lg: "fyvr116y", xl: "fyvr116z" }, defaultClass: "fyvr116w" }, "16": { conditions: { sm: "fyvr1170", md: "fyvr1171", lg: "fyvr1172", xl: "fyvr1173" }, defaultClass: "fyvr1170" }, "18": { conditions: { sm: "fyvr1174", md: "fyvr1175", lg: "fyvr1176", xl: "fyvr1177" }, defaultClass: "fyvr1174" }, "20": { conditions: { sm: "fyvr1178", md: "fyvr1179", lg: "fyvr117a", xl: "fyvr117b" }, defaultClass: "fyvr1178" }, "0.25": { conditions: { sm: "fyvr117c", md: "fyvr117d", lg: "fyvr117e", xl: "fyvr117f" }, defaultClass: "fyvr117c" }, "0.5": { conditions: { sm: "fyvr117g", md: "fyvr117h", lg: "fyvr117i", xl: "fyvr117j" }, defaultClass: "fyvr117g" }, "1.5": { conditions: { sm: "fyvr117k", md: "fyvr117l", lg: "fyvr117m", xl: "fyvr117n" }, defaultClass: "fyvr117k" }, auto: { conditions: { sm: "fyvr117o", md: "fyvr117p", lg: "fyvr117q", xl: "fyvr117r" }, defaultClass: "fyvr117o" } } }, marginLeft: { values: { "0": { conditions: { sm: "fyvr117s", md: "fyvr117t", lg: "fyvr117u", xl: "fyvr117v" }, defaultClass: "fyvr117s" }, "1": { conditions: { sm: "fyvr117w", md: "fyvr117x", lg: "fyvr117y", xl: "fyvr117z" }, defaultClass: "fyvr117w" }, "2": { conditions: { sm: "fyvr1180", md: "fyvr1181", lg: "fyvr1182", xl: "fyvr1183" }, defaultClass: "fyvr1180" }, "3": { conditions: { sm: "fyvr1184", md: "fyvr1185", lg: "fyvr1186", xl: "fyvr1187" }, defaultClass: "fyvr1184" }, "4": { conditions: { sm: "fyvr1188", md: "fyvr1189", lg: "fyvr118a", xl: "fyvr118b" }, defaultClass: "fyvr1188" }, "5": { conditions: { sm: "fyvr118c", md: "fyvr118d", lg: "fyvr118e", xl: "fyvr118f" }, defaultClass: "fyvr118c" }, "6": { conditions: { sm: "fyvr118g", md: "fyvr118h", lg: "fyvr118i", xl: "fyvr118j" }, defaultClass: "fyvr118g" }, "7": { conditions: { sm: "fyvr118k", md: "fyvr118l", lg: "fyvr118m", xl: "fyvr118n" }, defaultClass: "fyvr118k" }, "8": { conditions: { sm: "fyvr118o", md: "fyvr118p", lg: "fyvr118q", xl: "fyvr118r" }, defaultClass: "fyvr118o" }, "9": { conditions: { sm: "fyvr118s", md: "fyvr118t", lg: "fyvr118u", xl: "fyvr118v" }, defaultClass: "fyvr118s" }, "10": { conditions: { sm: "fyvr118w", md: "fyvr118x", lg: "fyvr118y", xl: "fyvr118z" }, defaultClass: "fyvr118w" }, "12": { conditions: { sm: "fyvr1190", md: "fyvr1191", lg: "fyvr1192", xl: "fyvr1193" }, defaultClass: "fyvr1190" }, "14": { conditions: { sm: "fyvr1194", md: "fyvr1195", lg: "fyvr1196", xl: "fyvr1197" }, defaultClass: "fyvr1194" }, "16": { conditions: { sm: "fyvr1198", md: "fyvr1199", lg: "fyvr119a", xl: "fyvr119b" }, defaultClass: "fyvr1198" }, "18": { conditions: { sm: "fyvr119c", md: "fyvr119d", lg: "fyvr119e", xl: "fyvr119f" }, defaultClass: "fyvr119c" }, "20": { conditions: { sm: "fyvr119g", md: "fyvr119h", lg: "fyvr119i", xl: "fyvr119j" }, defaultClass: "fyvr119g" }, "0.25": { conditions: { sm: "fyvr119k", md: "fyvr119l", lg: "fyvr119m", xl: "fyvr119n" }, defaultClass: "fyvr119k" }, "0.5": { conditions: { sm: "fyvr119o", md: "fyvr119p", lg: "fyvr119q", xl: "fyvr119r" }, defaultClass: "fyvr119o" }, "1.5": { conditions: { sm: "fyvr119s", md: "fyvr119t", lg: "fyvr119u", xl: "fyvr119v" }, defaultClass: "fyvr119s" }, auto: { conditions: { sm: "fyvr119w", md: "fyvr119x", lg: "fyvr119y", xl: "fyvr119z" }, defaultClass: "fyvr119w" } } }, marginRight: { values: { "0": { conditions: { sm: "fyvr11a0", md: "fyvr11a1", lg: "fyvr11a2", xl: "fyvr11a3" }, defaultClass: "fyvr11a0" }, "1": { conditions: { sm: "fyvr11a4", md: "fyvr11a5", lg: "fyvr11a6", xl: "fyvr11a7" }, defaultClass: "fyvr11a4" }, "2": { conditions: { sm: "fyvr11a8", md: "fyvr11a9", lg: "fyvr11aa", xl: "fyvr11ab" }, defaultClass: "fyvr11a8" }, "3": { conditions: { sm: "fyvr11ac", md: "fyvr11ad", lg: "fyvr11ae", xl: "fyvr11af" }, defaultClass: "fyvr11ac" }, "4": { conditions: { sm: "fyvr11ag", md: "fyvr11ah", lg: "fyvr11ai", xl: "fyvr11aj" }, defaultClass: "fyvr11ag" }, "5": { conditions: { sm: "fyvr11ak", md: "fyvr11al", lg: "fyvr11am", xl: "fyvr11an" }, defaultClass: "fyvr11ak" }, "6": { conditions: { sm: "fyvr11ao", md: "fyvr11ap", lg: "fyvr11aq", xl: "fyvr11ar" }, defaultClass: "fyvr11ao" }, "7": { conditions: { sm: "fyvr11as", md: "fyvr11at", lg: "fyvr11au", xl: "fyvr11av" }, defaultClass: "fyvr11as" }, "8": { conditions: { sm: "fyvr11aw", md: "fyvr11ax", lg: "fyvr11ay", xl: "fyvr11az" }, defaultClass: "fyvr11aw" }, "9": { conditions: { sm: "fyvr11b0", md: "fyvr11b1", lg: "fyvr11b2", xl: "fyvr11b3" }, defaultClass: "fyvr11b0" }, "10": { conditions: { sm: "fyvr11b4", md: "fyvr11b5", lg: "fyvr11b6", xl: "fyvr11b7" }, defaultClass: "fyvr11b4" }, "12": { conditions: { sm: "fyvr11b8", md: "fyvr11b9", lg: "fyvr11ba", xl: "fyvr11bb" }, defaultClass: "fyvr11b8" }, "14": { conditions: { sm: "fyvr11bc", md: "fyvr11bd", lg: "fyvr11be", xl: "fyvr11bf" }, defaultClass: "fyvr11bc" }, "16": { conditions: { sm: "fyvr11bg", md: "fyvr11bh", lg: "fyvr11bi", xl: "fyvr11bj" }, defaultClass: "fyvr11bg" }, "18": { conditions: { sm: "fyvr11bk", md: "fyvr11bl", lg: "fyvr11bm", xl: "fyvr11bn" }, defaultClass: "fyvr11bk" }, "20": { conditions: { sm: "fyvr11bo", md: "fyvr11bp", lg: "fyvr11bq", xl: "fyvr11br" }, defaultClass: "fyvr11bo" }, "0.25": { conditions: { sm: "fyvr11bs", md: "fyvr11bt", lg: "fyvr11bu", xl: "fyvr11bv" }, defaultClass: "fyvr11bs" }, "0.5": { conditions: { sm: "fyvr11bw", md: "fyvr11bx", lg: "fyvr11by", xl: "fyvr11bz" }, defaultClass: "fyvr11bw" }, "1.5": { conditions: { sm: "fyvr11c0", md: "fyvr11c1", lg: "fyvr11c2", xl: "fyvr11c3" }, defaultClass: "fyvr11c0" }, auto: { conditions: { sm: "fyvr11c4", md: "fyvr11c5", lg: "fyvr11c6", xl: "fyvr11c7" }, defaultClass: "fyvr11c4" } } }, gap: { values: { "0": { conditions: { sm: "fyvr11c8", md: "fyvr11c9", lg: "fyvr11ca", xl: "fyvr11cb" }, defaultClass: "fyvr11c8" }, "1": { conditions: { sm: "fyvr11cc", md: "fyvr11cd", lg: "fyvr11ce", xl: "fyvr11cf" }, defaultClass: "fyvr11cc" }, "2": { conditions: { sm: "fyvr11cg", md: "fyvr11ch", lg: "fyvr11ci", xl: "fyvr11cj" }, defaultClass: "fyvr11cg" }, "3": { conditions: { sm: "fyvr11ck", md: "fyvr11cl", lg: "fyvr11cm", xl: "fyvr11cn" }, defaultClass: "fyvr11ck" }, "4": { conditions: { sm: "fyvr11co", md: "fyvr11cp", lg: "fyvr11cq", xl: "fyvr11cr" }, defaultClass: "fyvr11co" }, "5": { conditions: { sm: "fyvr11cs", md: "fyvr11ct", lg: "fyvr11cu", xl: "fyvr11cv" }, defaultClass: "fyvr11cs" }, "6": { conditions: { sm: "fyvr11cw", md: "fyvr11cx", lg: "fyvr11cy", xl: "fyvr11cz" }, defaultClass: "fyvr11cw" }, "7": { conditions: { sm: "fyvr11d0", md: "fyvr11d1", lg: "fyvr11d2", xl: "fyvr11d3" }, defaultClass: "fyvr11d0" }, "8": { conditions: { sm: "fyvr11d4", md: "fyvr11d5", lg: "fyvr11d6", xl: "fyvr11d7" }, defaultClass: "fyvr11d4" }, "9": { conditions: { sm: "fyvr11d8", md: "fyvr11d9", lg: "fyvr11da", xl: "fyvr11db" }, defaultClass: "fyvr11d8" }, "10": { conditions: { sm: "fyvr11dc", md: "fyvr11dd", lg: "fyvr11de", xl: "fyvr11df" }, defaultClass: "fyvr11dc" }, "12": { conditions: { sm: "fyvr11dg", md: "fyvr11dh", lg: "fyvr11di", xl: "fyvr11dj" }, defaultClass: "fyvr11dg" }, "14": { conditions: { sm: "fyvr11dk", md: "fyvr11dl", lg: "fyvr11dm", xl: "fyvr11dn" }, defaultClass: "fyvr11dk" }, "16": { conditions: { sm: "fyvr11do", md: "fyvr11dp", lg: "fyvr11dq", xl: "fyvr11dr" }, defaultClass: "fyvr11do" }, "18": { conditions: { sm: "fyvr11ds", md: "fyvr11dt", lg: "fyvr11du", xl: "fyvr11dv" }, defaultClass: "fyvr11ds" }, "20": { conditions: { sm: "fyvr11dw", md: "fyvr11dx", lg: "fyvr11dy", xl: "fyvr11dz" }, defaultClass: "fyvr11dw" }, "0.25": { conditions: { sm: "fyvr11e0", md: "fyvr11e1", lg: "fyvr11e2", xl: "fyvr11e3" }, defaultClass: "fyvr11e0" }, "0.5": { conditions: { sm: "fyvr11e4", md: "fyvr11e5", lg: "fyvr11e6", xl: "fyvr11e7" }, defaultClass: "fyvr11e4" }, "1.5": { conditions: { sm: "fyvr11e8", md: "fyvr11e9", lg: "fyvr11ea", xl: "fyvr11eb" }, defaultClass: "fyvr11e8" } } }, borderBottomWidth: { values: { none: { conditions: { sm: "fyvr11ec", md: "fyvr11ed", lg: "fyvr11ee", xl: "fyvr11ef" }, defaultClass: "fyvr11ec" }, thin: { conditions: { sm: "fyvr11eg", md: "fyvr11eh", lg: "fyvr11ei", xl: "fyvr11ej" }, defaultClass: "fyvr11eg" }, thick: { conditions: { sm: "fyvr11ek", md: "fyvr11el", lg: "fyvr11em", xl: "fyvr11en" }, defaultClass: "fyvr11ek" } } }, borderLeftWidth: { values: { none: { conditions: { sm: "fyvr11eo", md: "fyvr11ep", lg: "fyvr11eq", xl: "fyvr11er" }, defaultClass: "fyvr11eo" }, thin: { conditions: { sm: "fyvr11es", md: "fyvr11et", lg: "fyvr11eu", xl: "fyvr11ev" }, defaultClass: "fyvr11es" }, thick: { conditions: { sm: "fyvr11ew", md: "fyvr11ex", lg: "fyvr11ey", xl: "fyvr11ez" }, defaultClass: "fyvr11ew" } } }, borderRightWidth: { values: { none: { conditions: { sm: "fyvr11f0", md: "fyvr11f1", lg: "fyvr11f2", xl: "fyvr11f3" }, defaultClass: "fyvr11f0" }, thin: { conditions: { sm: "fyvr11f4", md: "fyvr11f5", lg: "fyvr11f6", xl: "fyvr11f7" }, defaultClass: "fyvr11f4" }, thick: { conditions: { sm: "fyvr11f8", md: "fyvr11f9", lg: "fyvr11fa", xl: "fyvr11fb" }, defaultClass: "fyvr11f8" } } }, borderTopWidth: { values: { none: { conditions: { sm: "fyvr11fc", md: "fyvr11fd", lg: "fyvr11fe", xl: "fyvr11ff" }, defaultClass: "fyvr11fc" }, thin: { conditions: { sm: "fyvr11fg", md: "fyvr11fh", lg: "fyvr11fi", xl: "fyvr11fj" }, defaultClass: "fyvr11fg" }, thick: { conditions: { sm: "fyvr11fk", md: "fyvr11fl", lg: "fyvr11fm", xl: "fyvr11fn" }, defaultClass: "fyvr11fk" } } }, borderBottomLeftRadius: { values: { none: { conditions: { sm: "fyvr11fo", md: "fyvr11fp", lg: "fyvr11fq", xl: "fyvr11fr" }, defaultClass: "fyvr11fo" }, xs: { conditions: { sm: "fyvr11fs", md: "fyvr11ft", lg: "fyvr11fu", xl: "fyvr11fv" }, defaultClass: "fyvr11fs" }, sm: { conditions: { sm: "fyvr11fw", md: "fyvr11fx", lg: "fyvr11fy", xl: "fyvr11fz" }, defaultClass: "fyvr11fw" }, md: { conditions: { sm: "fyvr11g0", md: "fyvr11g1", lg: "fyvr11g2", xl: "fyvr11g3" }, defaultClass: "fyvr11g0" }, lg: { conditions: { sm: "fyvr11g4", md: "fyvr11g5", lg: "fyvr11g6", xl: "fyvr11g7" }, defaultClass: "fyvr11g4" }, circle: { conditions: { sm: "fyvr11g8", md: "fyvr11g9", lg: "fyvr11ga", xl: "fyvr11gb" }, defaultClass: "fyvr11g8" } } }, borderBottomRightRadius: { values: { none: { conditions: { sm: "fyvr11gc", md: "fyvr11gd", lg: "fyvr11ge", xl: "fyvr11gf" }, defaultClass: "fyvr11gc" }, xs: { conditions: { sm: "fyvr11gg", md: "fyvr11gh", lg: "fyvr11gi", xl: "fyvr11gj" }, defaultClass: "fyvr11gg" }, sm: { conditions: { sm: "fyvr11gk", md: "fyvr11gl", lg: "fyvr11gm", xl: "fyvr11gn" }, defaultClass: "fyvr11gk" }, md: { conditions: { sm: "fyvr11go", md: "fyvr11gp", lg: "fyvr11gq", xl: "fyvr11gr" }, defaultClass: "fyvr11go" }, lg: { conditions: { sm: "fyvr11gs", md: "fyvr11gt", lg: "fyvr11gu", xl: "fyvr11gv" }, defaultClass: "fyvr11gs" }, circle: { conditions: { sm: "fyvr11gw", md: "fyvr11gx", lg: "fyvr11gy", xl: "fyvr11gz" }, defaultClass: "fyvr11gw" } } }, borderTopLeftRadius: { values: { none: { conditions: { sm: "fyvr11h0", md: "fyvr11h1", lg: "fyvr11h2", xl: "fyvr11h3" }, defaultClass: "fyvr11h0" }, xs: { conditions: { sm: "fyvr11h4", md: "fyvr11h5", lg: "fyvr11h6", xl: "fyvr11h7" }, defaultClass: "fyvr11h4" }, sm: { conditions: { sm: "fyvr11h8", md: "fyvr11h9", lg: "fyvr11ha", xl: "fyvr11hb" }, defaultClass: "fyvr11h8" }, md: { conditions: { sm: "fyvr11hc", md: "fyvr11hd", lg: "fyvr11he", xl: "fyvr11hf" }, defaultClass: "fyvr11hc" }, lg: { conditions: { sm: "fyvr11hg", md: "fyvr11hh", lg: "fyvr11hi", xl: "fyvr11hj" }, defaultClass: "fyvr11hg" }, circle: { conditions: { sm: "fyvr11hk", md: "fyvr11hl", lg: "fyvr11hm", xl: "fyvr11hn" }, defaultClass: "fyvr11hk" } } }, borderTopRightRadius: { values: { none: { conditions: { sm: "fyvr11ho", md: "fyvr11hp", lg: "fyvr11hq", xl: "fyvr11hr" }, defaultClass: "fyvr11ho" }, xs: { conditions: { sm: "fyvr11hs", md: "fyvr11ht", lg: "fyvr11hu", xl: "fyvr11hv" }, defaultClass: "fyvr11hs" }, sm: { conditions: { sm: "fyvr11hw", md: "fyvr11hx", lg: "fyvr11hy", xl: "fyvr11hz" }, defaultClass: "fyvr11hw" }, md: { conditions: { sm: "fyvr11i0", md: "fyvr11i1", lg: "fyvr11i2", xl: "fyvr11i3" }, defaultClass: "fyvr11i0" }, lg: { conditions: { sm: "fyvr11i4", md: "fyvr11i5", lg: "fyvr11i6", xl: "fyvr11i7" }, defaultClass: "fyvr11i4" }, circle: { conditions: { sm: "fyvr11i8", md: "fyvr11i9", lg: "fyvr11ia", xl: "fyvr11ib" }, defaultClass: "fyvr11i8" } } }, fontSize: { values: { inherit: { conditions: { sm: "fyvr11ic", md: "fyvr11id", lg: "fyvr11ie", xl: "fyvr11if" }, defaultClass: "fyvr11ic" }, xsmall: { conditions: { sm: "fyvr11ig", md: "fyvr11ih", lg: "fyvr11ii", xl: "fyvr11ij" }, defaultClass: "fyvr11ig" }, small: { conditions: { sm: "fyvr11ik", md: "fyvr11il", lg: "fyvr11im", xl: "fyvr11in" }, defaultClass: "fyvr11ik" }, normal: { conditions: { sm: "fyvr11io", md: "fyvr11ip", lg: "fyvr11iq", xl: "fyvr11ir" }, defaultClass: "fyvr11io" }, medium: { conditions: { sm: "fyvr11is", md: "fyvr11it", lg: "fyvr11iu", xl: "fyvr11iv" }, defaultClass: "fyvr11is" }, large: { conditions: { sm: "fyvr11iw", md: "fyvr11ix", lg: "fyvr11iy", xl: "fyvr11iz" }, defaultClass: "fyvr11iw" }, xlarge: { conditions: { sm: "fyvr11j0", md: "fyvr11j1", lg: "fyvr11j2", xl: "fyvr11j3" }, defaultClass: "fyvr11j0" } } }, fontWeight: { values: { inherit: { conditions: { sm: "fyvr11j4", md: "fyvr11j5", lg: "fyvr11j6", xl: "fyvr11j7" }, defaultClass: "fyvr11j4" }, normal: { conditions: { sm: "fyvr11j8", md: "fyvr11j9", lg: "fyvr11ja", xl: "fyvr11jb" }, defaultClass: "fyvr11j8" }, medium: { conditions: { sm: "fyvr11jc", md: "fyvr11jd", lg: "fyvr11je", xl: "fyvr11jf" }, defaultClass: "fyvr11jc" }, semibold: { conditions: { sm: "fyvr11jg", md: "fyvr11jh", lg: "fyvr11ji", xl: "fyvr11jj" }, defaultClass: "fyvr11jg" }, bold: { conditions: { sm: "fyvr11jk", md: "fyvr11jl", lg: "fyvr11jm", xl: "fyvr11jn" }, defaultClass: "fyvr11jk" } } }, letterSpacing: { values: { inherit: { conditions: { sm: "fyvr11jo", md: "fyvr11jp", lg: "fyvr11jq", xl: "fyvr11jr" }, defaultClass: "fyvr11jo" }, none: { conditions: { sm: "fyvr11js", md: "fyvr11jt", lg: "fyvr11ju", xl: "fyvr11jv" }, defaultClass: "fyvr11js" }, normal: { conditions: { sm: "fyvr11jw", md: "fyvr11jx", lg: "fyvr11jy", xl: "fyvr11jz" }, defaultClass: "fyvr11jw" }, wide: { conditions: { sm: "fyvr11k0", md: "fyvr11k1", lg: "fyvr11k2", xl: "fyvr11k3" }, defaultClass: "fyvr11k0" } } }, lineHeight: { values: { "4": { conditions: { sm: "fyvr11k4", md: "fyvr11k5", lg: "fyvr11k6", xl: "fyvr11k7" }, defaultClass: "fyvr11k4" }, "5": { conditions: { sm: "fyvr11k8", md: "fyvr11k9", lg: "fyvr11ka", xl: "fyvr11kb" }, defaultClass: "fyvr11k8" }, "6": { conditions: { sm: "fyvr11kc", md: "fyvr11kd", lg: "fyvr11ke", xl: "fyvr11kf" }, defaultClass: "fyvr11kc" }, "7": { conditions: { sm: "fyvr11kg", md: "fyvr11kh", lg: "fyvr11ki", xl: "fyvr11kj" }, defaultClass: "fyvr11kg" }, "9": { conditions: { sm: "fyvr11kk", md: "fyvr11kl", lg: "fyvr11km", xl: "fyvr11kn" }, defaultClass: "fyvr11kk" }, inherit: { conditions: { sm: "fyvr11ko", md: "fyvr11kp", lg: "fyvr11kq", xl: "fyvr11kr" }, defaultClass: "fyvr11ko" } } }, textAlign: { values: { center: { conditions: { sm: "fyvr11ks", md: "fyvr11kt", lg: "fyvr11ku", xl: "fyvr11kv" }, defaultClass: "fyvr11ks" }, left: { conditions: { sm: "fyvr11kw", md: "fyvr11kx", lg: "fyvr11ky", xl: "fyvr11kz" }, defaultClass: "fyvr11kw" }, right: { conditions: { sm: "fyvr11l0", md: "fyvr11l1", lg: "fyvr11l2", xl: "fyvr11l3" }, defaultClass: "fyvr11l0" } } }, display: { values: { block: { conditions: { sm: "fyvr11l4", md: "fyvr11l5", lg: "fyvr11l6", xl: "fyvr11l7" }, defaultClass: "fyvr11l4" }, flex: { conditions: { sm: "fyvr11l8", md: "fyvr11l9", lg: "fyvr11la", xl: "fyvr11lb" }, defaultClass: "fyvr11l8" }, grid: { conditions: { sm: "fyvr11lc", md: "fyvr11ld", lg: "fyvr11le", xl: "fyvr11lf" }, defaultClass: "fyvr11lc" }, "inline-block": { conditions: { sm: "fyvr11lg", md: "fyvr11lh", lg: "fyvr11li", xl: "fyvr11lj" }, defaultClass: "fyvr11lg" }, "inline-flex": { conditions: { sm: "fyvr11lk", md: "fyvr11ll", lg: "fyvr11lm", xl: "fyvr11ln" }, defaultClass: "fyvr11lk" }, none: { conditions: { sm: "fyvr11lo", md: "fyvr11lp", lg: "fyvr11lq", xl: "fyvr11lr" }, defaultClass: "fyvr11lo" }, contents: { conditions: { sm: "fyvr11ls", md: "fyvr11lt", lg: "fyvr11lu", xl: "fyvr11lv" }, defaultClass: "fyvr11ls" } } }, position: { values: { absolute: { conditions: { sm: "fyvr11lw", md: "fyvr11lx", lg: "fyvr11ly", xl: "fyvr11lz" }, defaultClass: "fyvr11lw" }, fixed: { conditions: { sm: "fyvr11m0", md: "fyvr11m1", lg: "fyvr11m2", xl: "fyvr11m3" }, defaultClass: "fyvr11m0" }, relative: { conditions: { sm: "fyvr11m4", md: "fyvr11m5", lg: "fyvr11m6", xl: "fyvr11m7" }, defaultClass: "fyvr11m4" }, sticky: { conditions: { sm: "fyvr11m8", md: "fyvr11m9", lg: "fyvr11ma", xl: "fyvr11mb" }, defaultClass: "fyvr11m8" } } }, flexDirection: { values: { column: { conditions: { sm: "fyvr11mc", md: "fyvr11md", lg: "fyvr11me", xl: "fyvr11mf" }, defaultClass: "fyvr11mc" }, "column-reverse": { conditions: { sm: "fyvr11mg", md: "fyvr11mh", lg: "fyvr11mi", xl: "fyvr11mj" }, defaultClass: "fyvr11mg" }, row: { conditions: { sm: "fyvr11mk", md: "fyvr11ml", lg: "fyvr11mm", xl: "fyvr11mn" }, defaultClass: "fyvr11mk" }, "row-reverse": { conditions: { sm: "fyvr11mo", md: "fyvr11mp", lg: "fyvr11mq", xl: "fyvr11mr" }, defaultClass: "fyvr11mo" } } }, flexShrink: { values: { "0": { conditions: { sm: "fyvr11ms", md: "fyvr11mt", lg: "fyvr11mu", xl: "fyvr11mv" }, defaultClass: "fyvr11ms" }, "1": { conditions: { sm: "fyvr11mw", md: "fyvr11mx", lg: "fyvr11my", xl: "fyvr11mz" }, defaultClass: "fyvr11mw" } } }, flexGrow: { values: { "0": { conditions: { sm: "fyvr11n0", md: "fyvr11n1", lg: "fyvr11n2", xl: "fyvr11n3" }, defaultClass: "fyvr11n0" }, "1": { conditions: { sm: "fyvr11n4", md: "fyvr11n5", lg: "fyvr11n6", xl: "fyvr11n7" }, defaultClass: "fyvr11n4" } } }, flexWrap: { values: { nowrap: { conditions: { sm: "fyvr11n8", md: "fyvr11n9", lg: "fyvr11na", xl: "fyvr11nb" }, defaultClass: "fyvr11n8" }, wrap: { conditions: { sm: "fyvr11nc", md: "fyvr11nd", lg: "fyvr11ne", xl: "fyvr11nf" }, defaultClass: "fyvr11nc" }, "wrap-reverse": { conditions: { sm: "fyvr11ng", md: "fyvr11nh", lg: "fyvr11ni", xl: "fyvr11nj" }, defaultClass: "fyvr11ng" } } }, justifyContent: { values: { "flex-start": { conditions: { sm: "fyvr11nk", md: "fyvr11nl", lg: "fyvr11nm", xl: "fyvr11nn" }, defaultClass: "fyvr11nk" }, center: { conditions: { sm: "fyvr11no", md: "fyvr11np", lg: "fyvr11nq", xl: "fyvr11nr" }, defaultClass: "fyvr11no" }, "flex-end": { conditions: { sm: "fyvr11ns", md: "fyvr11nt", lg: "fyvr11nu", xl: "fyvr11nv" }, defaultClass: "fyvr11ns" }, stretch: { conditions: { sm: "fyvr11nw", md: "fyvr11nx", lg: "fyvr11ny", xl: "fyvr11nz" }, defaultClass: "fyvr11nw" }, "space-around": { conditions: { sm: "fyvr11o0", md: "fyvr11o1", lg: "fyvr11o2", xl: "fyvr11o3" }, defaultClass: "fyvr11o0" }, "space-between": { conditions: { sm: "fyvr11o4", md: "fyvr11o5", lg: "fyvr11o6", xl: "fyvr11o7" }, defaultClass: "fyvr11o4" }, "space-evenly": { conditions: { sm: "fyvr11o8", md: "fyvr11o9", lg: "fyvr11oa", xl: "fyvr11ob" }, defaultClass: "fyvr11o8" } } }, justifySelf: { values: { "flex-start": { conditions: { sm: "fyvr11oc", md: "fyvr11od", lg: "fyvr11oe", xl: "fyvr11of" }, defaultClass: "fyvr11oc" }, center: { conditions: { sm: "fyvr11og", md: "fyvr11oh", lg: "fyvr11oi", xl: "fyvr11oj" }, defaultClass: "fyvr11og" }, "flex-end": { conditions: { sm: "fyvr11ok", md: "fyvr11ol", lg: "fyvr11om", xl: "fyvr11on" }, defaultClass: "fyvr11ok" }, stretch: { conditions: { sm: "fyvr11oo", md: "fyvr11op", lg: "fyvr11oq", xl: "fyvr11or" }, defaultClass: "fyvr11oo" } } }, alignItems: { values: { "flex-start": { conditions: { sm: "fyvr11os", md: "fyvr11ot", lg: "fyvr11ou", xl: "fyvr11ov" }, defaultClass: "fyvr11os" }, center: { conditions: { sm: "fyvr11ow", md: "fyvr11ox", lg: "fyvr11oy", xl: "fyvr11oz" }, defaultClass: "fyvr11ow" }, "flex-end": { conditions: { sm: "fyvr11p0", md: "fyvr11p1", lg: "fyvr11p2", xl: "fyvr11p3" }, defaultClass: "fyvr11p0" }, stretch: { conditions: { sm: "fyvr11p4", md: "fyvr11p5", lg: "fyvr11p6", xl: "fyvr11p7" }, defaultClass: "fyvr11p4" }, baseline: { conditions: { sm: "fyvr11p8", md: "fyvr11p9", lg: "fyvr11pa", xl: "fyvr11pb" }, defaultClass: "fyvr11p8" } } }, alignSelf: { values: { "flex-start": { conditions: { sm: "fyvr11pc", md: "fyvr11pd", lg: "fyvr11pe", xl: "fyvr11pf" }, defaultClass: "fyvr11pc" }, center: { conditions: { sm: "fyvr11pg", md: "fyvr11ph", lg: "fyvr11pi", xl: "fyvr11pj" }, defaultClass: "fyvr11pg" }, "flex-end": { conditions: { sm: "fyvr11pk", md: "fyvr11pl", lg: "fyvr11pm", xl: "fyvr11pn" }, defaultClass: "fyvr11pk" }, stretch: { conditions: { sm: "fyvr11po", md: "fyvr11pp", lg: "fyvr11pq", xl: "fyvr11pr" }, defaultClass: "fyvr11po" }, baseline: { conditions: { sm: "fyvr11ps", md: "fyvr11pt", lg: "fyvr11pu", xl: "fyvr11pv" }, defaultClass: "fyvr11ps" } } }, overflowX: { values: { auto: { conditions: { sm: "fyvr11pw", md: "fyvr11px", lg: "fyvr11py", xl: "fyvr11pz" }, defaultClass: "fyvr11pw" }, hidden: { conditions: { sm: "fyvr11q0", md: "fyvr11q1", lg: "fyvr11q2", xl: "fyvr11q3" }, defaultClass: "fyvr11q0" }, scroll: { conditions: { sm: "fyvr11q4", md: "fyvr11q5", lg: "fyvr11q6", xl: "fyvr11q7" }, defaultClass: "fyvr11q4" }, visible: { conditions: { sm: "fyvr11q8", md: "fyvr11q9", lg: "fyvr11qa", xl: "fyvr11qb" }, defaultClass: "fyvr11q8" } } }, overflowY: { values: { auto: { conditions: { sm: "fyvr11qc", md: "fyvr11qd", lg: "fyvr11qe", xl: "fyvr11qf" }, defaultClass: "fyvr11qc" }, hidden: { conditions: { sm: "fyvr11qg", md: "fyvr11qh", lg: "fyvr11qi", xl: "fyvr11qj" }, defaultClass: "fyvr11qg" }, scroll: { conditions: { sm: "fyvr11qk", md: "fyvr11ql", lg: "fyvr11qm", xl: "fyvr11qn" }, defaultClass: "fyvr11qk" }, visible: { conditions: { sm: "fyvr11qo", md: "fyvr11qp", lg: "fyvr11qq", xl: "fyvr11qr" }, defaultClass: "fyvr11qo" } } }, visibility: { values: { hidden: { conditions: { sm: "fyvr11qs", md: "fyvr11qt", lg: "fyvr11qu", xl: "fyvr11qv" }, defaultClass: "fyvr11qs" }, visible: { conditions: { sm: "fyvr11qw", md: "fyvr11qx", lg: "fyvr11qy", xl: "fyvr11qz" }, defaultClass: "fyvr11qw" } } } } }, { conditions: void 0, styles: { backdropFilter: { values: { blur: { defaultClass: "fyvr11r0" }, none: { defaultClass: "fyvr11r1" } } }, fontFamily: { values: { inherit: { defaultClass: "fyvr11r2" }, body: { defaultClass: "fyvr11r3" }, mono: { defaultClass: "fyvr11r4" } } }, textOverflow: { values: { ellipsis: { defaultClass: "fyvr11r5" }, clip: { defaultClass: "fyvr11r6" } } }, textTransform: { values: { capitalize: { defaultClass: "fyvr11r7" }, lowercase: { defaultClass: "fyvr11r8" }, uppercase: { defaultClass: "fyvr11r9" } } }, textDecoration: { values: { none: { defaultClass: "fyvr11ra" }, underline: { defaultClass: "fyvr11rb" } } }, userSelect: { values: { none: { defaultClass: "fyvr11rc" }, text: { defaultClass: "fyvr11rd" }, all: { defaultClass: "fyvr11re" }, auto: { defaultClass: "fyvr11rf" } } }, whiteSpace: { values: { normal: { defaultClass: "fyvr11rg" }, nowrap: { defaultClass: "fyvr11rh" }, initial: { defaultClass: "fyvr11ri" }, inherit: { defaultClass: "fyvr11rj" } } }, wordBreak: { values: { "break-word": { defaultClass: "fyvr11rk" } } }, wordWrap: { values: { normal: { defaultClass: "fyvr11rl" }, "break-word": { defaultClass: "fyvr11rm" }, initial: { defaultClass: "fyvr11rn" }, inherit: { defaultClass: "fyvr11ro" } } }, zIndex: { values: { "0": { defaultClass: "fyvr11rp" }, "1": { defaultClass: "fyvr11rq" }, "10": { defaultClass: "fyvr11rr" }, "20": { defaultClass: "fyvr11rs" }, "30": { defaultClass: "fyvr11rt" }, "40": { defaultClass: "fyvr11ru" }, "50": { defaultClass: "fyvr11rv" }, "-1": { defaultClass: "fyvr11rw" }, auto: { defaultClass: "fyvr11rx" } } }, aspectRatio: { values: { "1/1": { defaultClass: "fyvr11ry" }, "16/9": { defaultClass: "fyvr11rz" }, "4/3": { defaultClass: "fyvr11s0" }, "3/1": { defaultClass: "fyvr11s1" }, auto: { defaultClass: "fyvr11s2" } } } } }, { conditions: { defaultCondition: "base", conditionNames: ["base", "active", "disabled", "focus", "hover", "checked"], responsiveArray: void 0 }, styles: { borderColor: { mappings: ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"] }, borderStyle: { mappings: ["borderTopStyle", "borderRightStyle", "borderBottomStyle", "borderLeftStyle"] }, focusRing: { mappings: ["boxShadow", "outline"] }, background: { values: { black: { conditions: { base: "fyvr11s3", active: "fyvr11s4", disabled: "fyvr11s5", focus: "fyvr11s6", hover: "fyvr11s7", checked: "fyvr11s8" }, defaultClass: "fyvr11s3" }, white: { conditions: { base: "fyvr11s9", active: "fyvr11sa", disabled: "fyvr11sb", focus: "fyvr11sc", hover: "fyvr11sd", checked: "fyvr11se" }, defaultClass: "fyvr11s9" }, inherit: { conditions: { base: "fyvr11sf", active: "fyvr11sg", disabled: "fyvr11sh", focus: "fyvr11si", hover: "fyvr11sj", checked: "fyvr11sk" }, defaultClass: "fyvr11sf" }, transparent: { conditions: { base: "fyvr11sl", active: "fyvr11sm", disabled: "fyvr11sn", focus: "fyvr11so", hover: "fyvr11sp", checked: "fyvr11sq" }, defaultClass: "fyvr11sl" }, positive: { conditions: { base: "fyvr11sr", active: "fyvr11ss", disabled: "fyvr11st", focus: "fyvr11su", hover: "fyvr11sv", checked: "fyvr11sw" }, defaultClass: "fyvr11sr" }, negative: { conditions: { base: "fyvr11sx", active: "fyvr11sy", disabled: "fyvr11sz", focus: "fyvr11t0", hover: "fyvr11t1", checked: "fyvr11t2" }, defaultClass: "fyvr11sx" }, info: { conditions: { base: "fyvr11t3", active: "fyvr11t4", disabled: "fyvr11t5", focus: "fyvr11t6", hover: "fyvr11t7", checked: "fyvr11t8" }, defaultClass: "fyvr11t3" }, warning: { conditions: { base: "fyvr11t9", active: "fyvr11ta", disabled: "fyvr11tb", focus: "fyvr11tc", hover: "fyvr11td", checked: "fyvr11te" }, defaultClass: "fyvr11t9" }, gradientBackdrop: { conditions: { base: "fyvr11tf", active: "fyvr11tg", disabled: "fyvr11th", focus: "fyvr11ti", hover: "fyvr11tj", checked: "fyvr11tk" }, defaultClass: "fyvr11tf" }, gradientPrimary: { conditions: { base: "fyvr11tl", active: "fyvr11tm", disabled: "fyvr11tn", focus: "fyvr11to", hover: "fyvr11tp", checked: "fyvr11tq" }, defaultClass: "fyvr11tl" }, gradientSecondary: { conditions: { base: "fyvr11tr", active: "fyvr11ts", disabled: "fyvr11tt", focus: "fyvr11tu", hover: "fyvr11tv", checked: "fyvr11tw" }, defaultClass: "fyvr11tr" }, arbitrumDark: { conditions: { base: "fyvr11tx", active: "fyvr11ty", disabled: "fyvr11tz", focus: "fyvr11u0", hover: "fyvr11u1", checked: "fyvr11u2" }, defaultClass: "fyvr11tx" }, arbitrumLight: { conditions: { base: "fyvr11u3", active: "fyvr11u4", disabled: "fyvr11u5", focus: "fyvr11u6", hover: "fyvr11u7", checked: "fyvr11u8" }, defaultClass: "fyvr11u3" }, avalanceDark: { conditions: { base: "fyvr11u9", active: "fyvr11ua", disabled: "fyvr11ub", focus: "fyvr11uc", hover: "fyvr11ud", checked: "fyvr11ue" }, defaultClass: "fyvr11u9" }, avalanceLight: { conditions: { base: "fyvr11uf", active: "fyvr11ug", disabled: "fyvr11uh", focus: "fyvr11ui", hover: "fyvr11uj", checked: "fyvr11uk" }, defaultClass: "fyvr11uf" }, bscDark: { conditions: { base: "fyvr11ul", active: "fyvr11um", disabled: "fyvr11un", focus: "fyvr11uo", hover: "fyvr11up", checked: "fyvr11uq" }, defaultClass: "fyvr11ul" }, bscLight: { conditions: { base: "fyvr11ur", active: "fyvr11us", disabled: "fyvr11ut", focus: "fyvr11uu", hover: "fyvr11uv", checked: "fyvr11uw" }, defaultClass: "fyvr11ur" }, ethereumDark: { conditions: { base: "fyvr11ux", active: "fyvr11uy", disabled: "fyvr11uz", focus: "fyvr11v0", hover: "fyvr11v1", checked: "fyvr11v2" }, defaultClass: "fyvr11ux" }, ethereumLight: { conditions: { base: "fyvr11v3", active: "fyvr11v4", disabled: "fyvr11v5", focus: "fyvr11v6", hover: "fyvr11v7", checked: "fyvr11v8" }, defaultClass: "fyvr11v3" }, gnosisDark: { conditions: { base: "fyvr11v9", active: "fyvr11va", disabled: "fyvr11vb", focus: "fyvr11vc", hover: "fyvr11vd", checked: "fyvr11ve" }, defaultClass: "fyvr11v9" }, gnosisLight: { conditions: { base: "fyvr11vf", active: "fyvr11vg", disabled: "fyvr11vh", focus: "fyvr11vi", hover: "fyvr11vj", checked: "fyvr11vk" }, defaultClass: "fyvr11vf" }, polygonDark: { conditions: { base: "fyvr11vl", active: "fyvr11vm", disabled: "fyvr11vn", focus: "fyvr11vo", hover: "fyvr11vp", checked: "fyvr11vq" }, defaultClass: "fyvr11vl" }, polygonLight: { conditions: { base: "fyvr11vr", active: "fyvr11vs", disabled: "fyvr11vt", focus: "fyvr11vu", hover: "fyvr11vv", checked: "fyvr11vw" }, defaultClass: "fyvr11vr" }, text100: { conditions: { base: "fyvr11vx", active: "fyvr11vy", disabled: "fyvr11vz", focus: "fyvr11w0", hover: "fyvr11w1", checked: "fyvr11w2" }, defaultClass: "fyvr11vx" }, text80: { conditions: { base: "fyvr11w3", active: "fyvr11w4", disabled: "fyvr11w5", focus: "fyvr11w6", hover: "fyvr11w7", checked: "fyvr11w8" }, defaultClass: "fyvr11w3" }, text50: { conditions: { base: "fyvr11w9", active: "fyvr11wa", disabled: "fyvr11wb", focus: "fyvr11wc", hover: "fyvr11wd", checked: "fyvr11we" }, defaultClass: "fyvr11w9" }, textInverse100: { conditions: { base: "fyvr11wf", active: "fyvr11wg", disabled: "fyvr11wh", focus: "fyvr11wi", hover: "fyvr11wj", checked: "fyvr11wk" }, defaultClass: "fyvr11wf" }, backgroundPrimary: { conditions: { base: "fyvr11wl", active: "fyvr11wm", disabled: "fyvr11wn", focus: "fyvr11wo", hover: "fyvr11wp", checked: "fyvr11wq" }, defaultClass: "fyvr11wl" }, backgroundSecondary: { conditions: { base: "fyvr11wr", active: "fyvr11ws", disabled: "fyvr11wt", focus: "fyvr11wu", hover: "fyvr11wv", checked: "fyvr11ww" }, defaultClass: "fyvr11wr" }, backgroundContrast: { conditions: { base: "fyvr11wx", active: "fyvr11wy", disabled: "fyvr11wz", focus: "fyvr11x0", hover: "fyvr11x1", checked: "fyvr11x2" }, defaultClass: "fyvr11wx" }, backgroundMuted: { conditions: { base: "fyvr11x3", active: "fyvr11x4", disabled: "fyvr11x5", focus: "fyvr11x6", hover: "fyvr11x7", checked: "fyvr11x8" }, defaultClass: "fyvr11x3" }, backgroundControl: { conditions: { base: "fyvr11x9", active: "fyvr11xa", disabled: "fyvr11xb", focus: "fyvr11xc", hover: "fyvr11xd", checked: "fyvr11xe" }, defaultClass: "fyvr11x9" }, backgroundInverse: { conditions: { base: "fyvr11xf", active: "fyvr11xg", disabled: "fyvr11xh", focus: "fyvr11xi", hover: "fyvr11xj", checked: "fyvr11xk" }, defaultClass: "fyvr11xf" }, backgroundBackdrop: { conditions: { base: "fyvr11xl", active: "fyvr11xm", disabled: "fyvr11xn", focus: "fyvr11xo", hover: "fyvr11xp", checked: "fyvr11xq" }, defaultClass: "fyvr11xl" }, backgroundOverlay: { conditions: { base: "fyvr11xr", active: "fyvr11xs", disabled: "fyvr11xt", focus: "fyvr11xu", hover: "fyvr11xv", checked: "fyvr11xw" }, defaultClass: "fyvr11xr" }, backgroundRaised: { conditions: { base: "fyvr11xx", active: "fyvr11xy", disabled: "fyvr11xz", focus: "fyvr11y0", hover: "fyvr11y1", checked: "fyvr11y2" }, defaultClass: "fyvr11xx" }, buttonGlass: { conditions: { base: "fyvr11y3", active: "fyvr11y4", disabled: "fyvr11y5", focus: "fyvr11y6", hover: "fyvr11y7", checked: "fyvr11y8" }, defaultClass: "fyvr11y3" }, buttonEmphasis: { conditions: { base: "fyvr11y9", active: "fyvr11ya", disabled: "fyvr11yb", focus: "fyvr11yc", hover: "fyvr11yd", checked: "fyvr11ye" }, defaultClass: "fyvr11y9" }, buttonInverse: { conditions: { base: "fyvr11yf", active: "fyvr11yg", disabled: "fyvr11yh", focus: "fyvr11yi", hover: "fyvr11yj", checked: "fyvr11yk" }, defaultClass: "fyvr11yf" }, borderNormal: { conditions: { base: "fyvr11yl", active: "fyvr11ym", disabled: "fyvr11yn", focus: "fyvr11yo", hover: "fyvr11yp", checked: "fyvr11yq" }, defaultClass: "fyvr11yl" }, borderFocus: { conditions: { base: "fyvr11yr", active: "fyvr11ys", disabled: "fyvr11yt", focus: "fyvr11yu", hover: "fyvr11yv", checked: "fyvr11yw" }, defaultClass: "fyvr11yr" } } }, borderBottomColor: { values: { black: { conditions: { base: "fyvr11yx", active: "fyvr11yy", disabled: "fyvr11yz", focus: "fyvr11z0", hover: "fyvr11z1", checked: "fyvr11z2" }, defaultClass: "fyvr11yx" }, white: { conditions: { base: "fyvr11z3", active: "fyvr11z4", disabled: "fyvr11z5", focus: "fyvr11z6", hover: "fyvr11z7", checked: "fyvr11z8" }, defaultClass: "fyvr11z3" }, inherit: { conditions: { base: "fyvr11z9", active: "fyvr11za", disabled: "fyvr11zb", focus: "fyvr11zc", hover: "fyvr11zd", checked: "fyvr11ze" }, defaultClass: "fyvr11z9" }, transparent: { conditions: { base: "fyvr11zf", active: "fyvr11zg", disabled: "fyvr11zh", focus: "fyvr11zi", hover: "fyvr11zj", checked: "fyvr11zk" }, defaultClass: "fyvr11zf" }, positive: { conditions: { base: "fyvr11zl", active: "fyvr11zm", disabled: "fyvr11zn", focus: "fyvr11zo", hover: "fyvr11zp", checked: "fyvr11zq" }, defaultClass: "fyvr11zl" }, negative: { conditions: { base: "fyvr11zr", active: "fyvr11zs", disabled: "fyvr11zt", focus: "fyvr11zu", hover: "fyvr11zv", checked: "fyvr11zw" }, defaultClass: "fyvr11zr" }, info: { conditions: { base: "fyvr11zx", active: "fyvr11zy", disabled: "fyvr11zz", focus: "fyvr1200", hover: "fyvr1201", checked: "fyvr1202" }, defaultClass: "fyvr11zx" }, warning: { conditions: { base: "fyvr1203", active: "fyvr1204", disabled: "fyvr1205", focus: "fyvr1206", hover: "fyvr1207", checked: "fyvr1208" }, defaultClass: "fyvr1203" }, gradientBackdrop: { conditions: { base: "fyvr1209", active: "fyvr120a", disabled: "fyvr120b", focus: "fyvr120c", hover: "fyvr120d", checked: "fyvr120e" }, defaultClass: "fyvr1209" }, gradientPrimary: { conditions: { base: "fyvr120f", active: "fyvr120g", disabled: "fyvr120h", focus: "fyvr120i", hover: "fyvr120j", checked: "fyvr120k" }, defaultClass: "fyvr120f" }, gradientSecondary: { conditions: { base: "fyvr120l", active: "fyvr120m", disabled: "fyvr120n", focus: "fyvr120o", hover: "fyvr120p", checked: "fyvr120q" }, defaultClass: "fyvr120l" }, arbitrumDark: { conditions: { base: "fyvr120r", active: "fyvr120s", disabled: "fyvr120t", focus: "fyvr120u", hover: "fyvr120v", checked: "fyvr120w" }, defaultClass: "fyvr120r" }, arbitrumLight: { conditions: { base: "fyvr120x", active: "fyvr120y", disabled: "fyvr120z", focus: "fyvr1210", hover: "fyvr1211", checked: "fyvr1212" }, defaultClass: "fyvr120x" }, avalanceDark: { conditions: { base: "fyvr1213", active: "fyvr1214", disabled: "fyvr1215", focus: "fyvr1216", hover: "fyvr1217", checked: "fyvr1218" }, defaultClass: "fyvr1213" }, avalanceLight: { conditions: { base: "fyvr1219", active: "fyvr121a", disabled: "fyvr121b", focus: "fyvr121c", hover: "fyvr121d", checked: "fyvr121e" }, defaultClass: "fyvr1219" }, bscDark: { conditions: { base: "fyvr121f", active: "fyvr121g", disabled: "fyvr121h", focus: "fyvr121i", hover: "fyvr121j", checked: "fyvr121k" }, defaultClass: "fyvr121f" }, bscLight: { conditions: { base: "fyvr121l", active: "fyvr121m", disabled: "fyvr121n", focus: "fyvr121o", hover: "fyvr121p", checked: "fyvr121q" }, defaultClass: "fyvr121l" }, ethereumDark: { conditions: { base: "fyvr121r", active: "fyvr121s", disabled: "fyvr121t", focus: "fyvr121u", hover: "fyvr121v", checked: "fyvr121w" }, defaultClass: "fyvr121r" }, ethereumLight: { conditions: { base: "fyvr121x", active: "fyvr121y", disabled: "fyvr121z", focus: "fyvr1220", hover: "fyvr1221", checked: "fyvr1222" }, defaultClass: "fyvr121x" }, gnosisDark: { conditions: { base: "fyvr1223", active: "fyvr1224", disabled: "fyvr1225", focus: "fyvr1226", hover: "fyvr1227", checked: "fyvr1228" }, defaultClass: "fyvr1223" }, gnosisLight: { conditions: { base: "fyvr1229", active: "fyvr122a", disabled: "fyvr122b", focus: "fyvr122c", hover: "fyvr122d", checked: "fyvr122e" }, defaultClass: "fyvr1229" }, polygonDark: { conditions: { base: "fyvr122f", active: "fyvr122g", disabled: "fyvr122h", focus: "fyvr122i", hover: "fyvr122j", checked: "fyvr122k" }, defaultClass: "fyvr122f" }, polygonLight: { conditions: { base: "fyvr122l", active: "fyvr122m", disabled: "fyvr122n", focus: "fyvr122o", hover: "fyvr122p", checked: "fyvr122q" }, defaultClass: "fyvr122l" }, text100: { conditions: { base: "fyvr122r", active: "fyvr122s", disabled: "fyvr122t", focus: "fyvr122u", hover: "fyvr122v", checked: "fyvr122w" }, defaultClass: "fyvr122r" }, text80: { conditions: { base: "fyvr122x", active: "fyvr122y", disabled: "fyvr122z", focus: "fyvr1230", hover: "fyvr1231", checked: "fyvr1232" }, defaultClass: "fyvr122x" }, text50: { conditions: { base: "fyvr1233", active: "fyvr1234", disabled: "fyvr1235", focus: "fyvr1236", hover: "fyvr1237", checked: "fyvr1238" }, defaultClass: "fyvr1233" }, textInverse100: { conditions: { base: "fyvr1239", active: "fyvr123a", disabled: "fyvr123b", focus: "fyvr123c", hover: "fyvr123d", checked: "fyvr123e" }, defaultClass: "fyvr1239" }, backgroundPrimary: { conditions: { base: "fyvr123f", active: "fyvr123g", disabled: "fyvr123h", focus: "fyvr123i", hover: "fyvr123j", checked: "fyvr123k" }, defaultClass: "fyvr123f" }, backgroundSecondary: { conditions: { base: "fyvr123l", active: "fyvr123m", disabled: "fyvr123n", focus: "fyvr123o", hover: "fyvr123p", checked: "fyvr123q" }, defaultClass: "fyvr123l" }, backgroundContrast: { conditions: { base: "fyvr123r", active: "fyvr123s", disabled: "fyvr123t", focus: "fyvr123u", hover: "fyvr123v", checked: "fyvr123w" }, defaultClass: "fyvr123r" }, backgroundMuted: { conditions: { base: "fyvr123x", active: "fyvr123y", disabled: "fyvr123z", focus: "fyvr1240", hover: "fyvr1241", checked: "fyvr1242" }, defaultClass: "fyvr123x" }, backgroundControl: { conditions: { base: "fyvr1243", active: "fyvr1244", disabled: "fyvr1245", focus: "fyvr1246", hover: "fyvr1247", checked: "fyvr1248" }, defaultClass: "fyvr1243" }, backgroundInverse: { conditions: { base: "fyvr1249", active: "fyvr124a", disabled: "fyvr124b", focus: "fyvr124c", hover: "fyvr124d", checked: "fyvr124e" }, defaultClass: "fyvr1249" }, backgroundBackdrop: { conditions: { base: "fyvr124f", active: "fyvr124g", disabled: "fyvr124h", focus: "fyvr124i", hover: "fyvr124j", checked: "fyvr124k" }, defaultClass: "fyvr124f" }, backgroundOverlay: { conditions: { base: "fyvr124l", active: "fyvr124m", disabled: "fyvr124n", focus: "fyvr124o", hover: "fyvr124p", checked: "fyvr124q" }, defaultClass: "fyvr124l" }, backgroundRaised: { conditions: { base: "fyvr124r", active: "fyvr124s", disabled: "fyvr124t", focus: "fyvr124u", hover: "fyvr124v", checked: "fyvr124w" }, defaultClass: "fyvr124r" }, buttonGlass: { conditions: { base: "fyvr124x", active: "fyvr124y", disabled: "fyvr124z", focus: "fyvr1250", hover: "fyvr1251", checked: "fyvr1252" }, defaultClass: "fyvr124x" }, buttonEmphasis: { conditions: { base: "fyvr1253", active: "fyvr1254", disabled: "fyvr1255", focus: "fyvr1256", hover: "fyvr1257", checked: "fyvr1258" }, defaultClass: "fyvr1253" }, buttonInverse: { conditions: { base: "fyvr1259", active: "fyvr125a", disabled: "fyvr125b", focus: "fyvr125c", hover: "fyvr125d", checked: "fyvr125e" }, defaultClass: "fyvr1259" }, borderNormal: { conditions: { base: "fyvr125f", active: "fyvr125g", disabled: "fyvr125h", focus: "fyvr125i", hover: "fyvr125j", checked: "fyvr125k" }, defaultClass: "fyvr125f" }, borderFocus: { conditions: { base: "fyvr125l", active: "fyvr125m", disabled: "fyvr125n", focus: "fyvr125o", hover: "fyvr125p", checked: "fyvr125q" }, defaultClass: "fyvr125l" } } }, borderBottomStyle: { values: { solid: { conditions: { base: "fyvr125r", active: "fyvr125s", disabled: "fyvr125t", focus: "fyvr125u", hover: "fyvr125v", checked: "fyvr125w" }, defaultClass: "fyvr125r" }, dashed: { conditions: { base: "fyvr125x", active: "fyvr125y", disabled: "fyvr125z", focus: "fyvr1260", hover: "fyvr1261", checked: "fyvr1262" }, defaultClass: "fyvr125x" }, dotted: { conditions: { base: "fyvr1263", active: "fyvr1264", disabled: "fyvr1265", focus: "fyvr1266", hover: "fyvr1267", checked: "fyvr1268" }, defaultClass: "fyvr1263" } } }, borderLeftColor: { values: { black: { conditions: { base: "fyvr1269", active: "fyvr126a", disabled: "fyvr126b", focus: "fyvr126c", hover: "fyvr126d", checked: "fyvr126e" }, defaultClass: "fyvr1269" }, white: { conditions: { base: "fyvr126f", active: "fyvr126g", disabled: "fyvr126h", focus: "fyvr126i", hover: "fyvr126j", checked: "fyvr126k" }, defaultClass: "fyvr126f" }, inherit: { conditions: { base: "fyvr126l", active: "fyvr126m", disabled: "fyvr126n", focus: "fyvr126o", hover: "fyvr126p", checked: "fyvr126q" }, defaultClass: "fyvr126l" }, transparent: { conditions: { base: "fyvr126r", active: "fyvr126s", disabled: "fyvr126t", focus: "fyvr126u", hover: "fyvr126v", checked: "fyvr126w" }, defaultClass: "fyvr126r" }, positive: { conditions: { base: "fyvr126x", active: "fyvr126y", disabled: "fyvr126z", focus: "fyvr1270", hover: "fyvr1271", checked: "fyvr1272" }, defaultClass: "fyvr126x" }, negative: { conditions: { base: "fyvr1273", active: "fyvr1274", disabled: "fyvr1275", focus: "fyvr1276", hover: "fyvr1277", checked: "fyvr1278" }, defaultClass: "fyvr1273" }, info: { conditions: { base: "fyvr1279", active: "fyvr127a", disabled: "fyvr127b", focus: "fyvr127c", hover: "fyvr127d", checked: "fyvr127e" }, defaultClass: "fyvr1279" }, warning: { conditions: { base: "fyvr127f", active: "fyvr127g", disabled: "fyvr127h", focus: "fyvr127i", hover: "fyvr127j", checked: "fyvr127k" }, defaultClass: "fyvr127f" }, gradientBackdrop: { conditions: { base: "fyvr127l", active: "fyvr127m", disabled: "fyvr127n", focus: "fyvr127o", hover: "fyvr127p", checked: "fyvr127q" }, defaultClass: "fyvr127l" }, gradientPrimary: { conditions: { base: "fyvr127r", active: "fyvr127s", disabled: "fyvr127t", focus: "fyvr127u", hover: "fyvr127v", checked: "fyvr127w" }, defaultClass: "fyvr127r" }, gradientSecondary: { conditions: { base: "fyvr127x", active: "fyvr127y", disabled: "fyvr127z", focus: "fyvr1280", hover: "fyvr1281", checked: "fyvr1282" }, defaultClass: "fyvr127x" }, arbitrumDark: { conditions: { base: "fyvr1283", active: "fyvr1284", disabled: "fyvr1285", focus: "fyvr1286", hover: "fyvr1287", checked: "fyvr1288" }, defaultClass: "fyvr1283" }, arbitrumLight: { conditions: { base: "fyvr1289", active: "fyvr128a", disabled: "fyvr128b", focus: "fyvr128c", hover: "fyvr128d", checked: "fyvr128e" }, defaultClass: "fyvr1289" }, avalanceDark: { conditions: { base: "fyvr128f", active: "fyvr128g", disabled: "fyvr128h", focus: "fyvr128i", hover: "fyvr128j", checked: "fyvr128k" }, defaultClass: "fyvr128f" }, avalanceLight: { conditions: { base: "fyvr128l", active: "fyvr128m", disabled: "fyvr128n", focus: "fyvr128o", hover: "fyvr128p", checked: "fyvr128q" }, defaultClass: "fyvr128l" }, bscDark: { conditions: { base: "fyvr128r", active: "fyvr128s", disabled: "fyvr128t", focus: "fyvr128u", hover: "fyvr128v", checked: "fyvr128w" }, defaultClass: "fyvr128r" }, bscLight: { conditions: { base: "fyvr128x", active: "fyvr128y", disabled: "fyvr128z", focus: "fyvr1290", hover: "fyvr1291", checked: "fyvr1292" }, defaultClass: "fyvr128x" }, ethereumDark: { conditions: { base: "fyvr1293", active: "fyvr1294", disabled: "fyvr1295", focus: "fyvr1296", hover: "fyvr1297", checked: "fyvr1298" }, defaultClass: "fyvr1293" }, ethereumLight: { conditions: { base: "fyvr1299", active: "fyvr129a", disabled: "fyvr129b", focus: "fyvr129c", hover: "fyvr129d", checked: "fyvr129e" }, defaultClass: "fyvr1299" }, gnosisDark: { conditions: { base: "fyvr129f", active: "fyvr129g", disabled: "fyvr129h", focus: "fyvr129i", hover: "fyvr129j", checked: "fyvr129k" }, defaultClass: "fyvr129f" }, gnosisLight: { conditions: { base: "fyvr129l", active: "fyvr129m", disabled: "fyvr129n", focus: "fyvr129o", hover: "fyvr129p", checked: "fyvr129q" }, defaultClass: "fyvr129l" }, polygonDark: { conditions: { base: "fyvr129r", active: "fyvr129s", disabled: "fyvr129t", focus: "fyvr129u", hover: "fyvr129v", checked: "fyvr129w" }, defaultClass: "fyvr129r" }, polygonLight: { conditions: { base: "fyvr129x", active: "fyvr129y", disabled: "fyvr129z", focus: "fyvr12a0", hover: "fyvr12a1", checked: "fyvr12a2" }, defaultClass: "fyvr129x" }, text100: { conditions: { base: "fyvr12a3", active: "fyvr12a4", disabled: "fyvr12a5", focus: "fyvr12a6", hover: "fyvr12a7", checked: "fyvr12a8" }, defaultClass: "fyvr12a3" }, text80: { conditions: { base: "fyvr12a9", active: "fyvr12aa", disabled: "fyvr12ab", focus: "fyvr12ac", hover: "fyvr12ad", checked: "fyvr12ae" }, defaultClass: "fyvr12a9" }, text50: { conditions: { base: "fyvr12af", active: "fyvr12ag", disabled: "fyvr12ah", focus: "fyvr12ai", hover: "fyvr12aj", checked: "fyvr12ak" }, defaultClass: "fyvr12af" }, textInverse100: { conditions: { base: "fyvr12al", active: "fyvr12am", disabled: "fyvr12an", focus: "fyvr12ao", hover: "fyvr12ap", checked: "fyvr12aq" }, defaultClass: "fyvr12al" }, backgroundPrimary: { conditions: { base: "fyvr12ar", active: "fyvr12as", disabled: "fyvr12at", focus: "fyvr12au", hover: "fyvr12av", checked: "fyvr12aw" }, defaultClass: "fyvr12ar" }, backgroundSecondary: { conditions: { base: "fyvr12ax", active: "fyvr12ay", disabled: "fyvr12az", focus: "fyvr12b0", hover: "fyvr12b1", checked: "fyvr12b2" }, defaultClass: "fyvr12ax" }, backgroundContrast: { conditions: { base: "fyvr12b3", active: "fyvr12b4", disabled: "fyvr12b5", focus: "fyvr12b6", hover: "fyvr12b7", checked: "fyvr12b8" }, defaultClass: "fyvr12b3" }, backgroundMuted: { conditions: { base: "fyvr12b9", active: "fyvr12ba", disabled: "fyvr12bb", focus: "fyvr12bc", hover: "fyvr12bd", checked: "fyvr12be" }, defaultClass: "fyvr12b9" }, backgroundControl: { conditions: { base: "fyvr12bf", active: "fyvr12bg", disabled: "fyvr12bh", focus: "fyvr12bi", hover: "fyvr12bj", checked: "fyvr12bk" }, defaultClass: "fyvr12bf" }, backgroundInverse: { conditions: { base: "fyvr12bl", active: "fyvr12bm", disabled: "fyvr12bn", focus: "fyvr12bo", hover: "fyvr12bp", checked: "fyvr12bq" }, defaultClass: "fyvr12bl" }, backgroundBackdrop: { conditions: { base: "fyvr12br", active: "fyvr12bs", disabled: "fyvr12bt", focus: "fyvr12bu", hover: "fyvr12bv", checked: "fyvr12bw" }, defaultClass: "fyvr12br" }, backgroundOverlay: { conditions: { base: "fyvr12bx", active: "fyvr12by", disabled: "fyvr12bz", focus: "fyvr12c0", hover: "fyvr12c1", checked: "fyvr12c2" }, defaultClass: "fyvr12bx" }, backgroundRaised: { conditions: { base: "fyvr12c3", active: "fyvr12c4", disabled: "fyvr12c5", focus: "fyvr12c6", hover: "fyvr12c7", checked: "fyvr12c8" }, defaultClass: "fyvr12c3" }, buttonGlass: { conditions: { base: "fyvr12c9", active: "fyvr12ca", disabled: "fyvr12cb", focus: "fyvr12cc", hover: "fyvr12cd", checked: "fyvr12ce" }, defaultClass: "fyvr12c9" }, buttonEmphasis: { conditions: { base: "fyvr12cf", active: "fyvr12cg", disabled: "fyvr12ch", focus: "fyvr12ci", hover: "fyvr12cj", checked: "fyvr12ck" }, defaultClass: "fyvr12cf" }, buttonInverse: { conditions: { base: "fyvr12cl", active: "fyvr12cm", disabled: "fyvr12cn", focus: "fyvr12co", hover: "fyvr12cp", checked: "fyvr12cq" }, defaultClass: "fyvr12cl" }, borderNormal: { conditions: { base: "fyvr12cr", active: "fyvr12cs", disabled: "fyvr12ct", focus: "fyvr12cu", hover: "fyvr12cv", checked: "fyvr12cw" }, defaultClass: "fyvr12cr" }, borderFocus: { conditions: { base: "fyvr12cx", active: "fyvr12cy", disabled: "fyvr12cz", focus: "fyvr12d0", hover: "fyvr12d1", checked: "fyvr12d2" }, defaultClass: "fyvr12cx" } } }, borderLeftStyle: { values: { solid: { conditions: { base: "fyvr12d3", active: "fyvr12d4", disabled: "fyvr12d5", focus: "fyvr12d6", hover: "fyvr12d7", checked: "fyvr12d8" }, defaultClass: "fyvr12d3" }, dashed: { conditions: { base: "fyvr12d9", active: "fyvr12da", disabled: "fyvr12db", focus: "fyvr12dc", hover: "fyvr12dd", checked: "fyvr12de" }, defaultClass: "fyvr12d9" }, dotted: { conditions: { base: "fyvr12df", active: "fyvr12dg", disabled: "fyvr12dh", focus: "fyvr12di", hover: "fyvr12dj", checked: "fyvr12dk" }, defaultClass: "fyvr12df" } } }, borderRightColor: { values: { black: { conditions: { base: "fyvr12dl", active: "fyvr12dm", disabled: "fyvr12dn", focus: "fyvr12do", hover: "fyvr12dp", checked: "fyvr12dq" }, defaultClass: "fyvr12dl" }, white: { conditions: { base: "fyvr12dr", active: "fyvr12ds", disabled: "fyvr12dt", focus: "fyvr12du", hover: "fyvr12dv", checked: "fyvr12dw" }, defaultClass: "fyvr12dr" }, inherit: { conditions: { base: "fyvr12dx", active: "fyvr12dy", disabled: "fyvr12dz", focus: "fyvr12e0", hover: "fyvr12e1", checked: "fyvr12e2" }, defaultClass: "fyvr12dx" }, transparent: { conditions: { base: "fyvr12e3", active: "fyvr12e4", disabled: "fyvr12e5", focus: "fyvr12e6", hover: "fyvr12e7", checked: "fyvr12e8" }, defaultClass: "fyvr12e3" }, positive: { conditions: { base: "fyvr12e9", active: "fyvr12ea", disabled: "fyvr12eb", focus: "fyvr12ec", hover: "fyvr12ed", checked: "fyvr12ee" }, defaultClass: "fyvr12e9" }, negative: { conditions: { base: "fyvr12ef", active: "fyvr12eg", disabled: "fyvr12eh", focus: "fyvr12ei", hover: "fyvr12ej", checked: "fyvr12ek" }, defaultClass: "fyvr12ef" }, info: { conditions: { base: "fyvr12el", active: "fyvr12em", disabled: "fyvr12en", focus: "fyvr12eo", hover: "fyvr12ep", checked: "fyvr12eq" }, defaultClass: "fyvr12el" }, warning: { conditions: { base: "fyvr12er", active: "fyvr12es", disabled: "fyvr12et", focus: "fyvr12eu", hover: "fyvr12ev", checked: "fyvr12ew" }, defaultClass: "fyvr12er" }, gradientBackdrop: { conditions: { base: "fyvr12ex", active: "fyvr12ey", disabled: "fyvr12ez", focus: "fyvr12f0", hover: "fyvr12f1", checked: "fyvr12f2" }, defaultClass: "fyvr12ex" }, gradientPrimary: { conditions: { base: "fyvr12f3", active: "fyvr12f4", disabled: "fyvr12f5", focus: "fyvr12f6", hover: "fyvr12f7", checked: "fyvr12f8" }, defaultClass: "fyvr12f3" }, gradientSecondary: { conditions: { base: "fyvr12f9", active: "fyvr12fa", disabled: "fyvr12fb", focus: "fyvr12fc", hover: "fyvr12fd", checked: "fyvr12fe" }, defaultClass: "fyvr12f9" }, arbitrumDark: { conditions: { base: "fyvr12ff", active: "fyvr12fg", disabled: "fyvr12fh", focus: "fyvr12fi", hover: "fyvr12fj", checked: "fyvr12fk" }, defaultClass: "fyvr12ff" }, arbitrumLight: { conditions: { base: "fyvr12fl", active: "fyvr12fm", disabled: "fyvr12fn", focus: "fyvr12fo", hover: "fyvr12fp", checked: "fyvr12fq" }, defaultClass: "fyvr12fl" }, avalanceDark: { conditions: { base: "fyvr12fr", active: "fyvr12fs", disabled: "fyvr12ft", focus: "fyvr12fu", hover: "fyvr12fv", checked: "fyvr12fw" }, defaultClass: "fyvr12fr" }, avalanceLight: { conditions: { base: "fyvr12fx", active: "fyvr12fy", disabled: "fyvr12fz", focus: "fyvr12g0", hover: "fyvr12g1", checked: "fyvr12g2" }, defaultClass: "fyvr12fx" }, bscDark: { conditions: { base: "fyvr12g3", active: "fyvr12g4", disabled: "fyvr12g5", focus: "fyvr12g6", hover: "fyvr12g7", checked: "fyvr12g8" }, defaultClass: "fyvr12g3" }, bscLight: { conditions: { base: "fyvr12g9", active: "fyvr12ga", disabled: "fyvr12gb", focus: "fyvr12gc", hover: "fyvr12gd", checked: "fyvr12ge" }, defaultClass: "fyvr12g9" }, ethereumDark: { conditions: { base: "fyvr12gf", active: "fyvr12gg", disabled: "fyvr12gh", focus: "fyvr12gi", hover: "fyvr12gj", checked: "fyvr12gk" }, defaultClass: "fyvr12gf" }, ethereumLight: { conditions: { base: "fyvr12gl", active: "fyvr12gm", disabled: "fyvr12gn", focus: "fyvr12go", hover: "fyvr12gp", checked: "fyvr12gq" }, defaultClass: "fyvr12gl" }, gnosisDark: { conditions: { base: "fyvr12gr", active: "fyvr12gs", disabled: "fyvr12gt", focus: "fyvr12gu", hover: "fyvr12gv", checked: "fyvr12gw" }, defaultClass: "fyvr12gr" }, gnosisLight: { conditions: { base: "fyvr12gx", active: "fyvr12gy", disabled: "fyvr12gz", focus: "fyvr12h0", hover: "fyvr12h1", checked: "fyvr12h2" }, defaultClass: "fyvr12gx" }, polygonDark: { conditions: { base: "fyvr12h3", active: "fyvr12h4", disabled: "fyvr12h5", focus: "fyvr12h6", hover: "fyvr12h7", checked: "fyvr12h8" }, defaultClass: "fyvr12h3" }, polygonLight: { conditions: { base: "fyvr12h9", active: "fyvr12ha", disabled: "fyvr12hb", focus: "fyvr12hc", hover: "fyvr12hd", checked: "fyvr12he" }, defaultClass: "fyvr12h9" }, text100: { conditions: { base: "fyvr12hf", active: "fyvr12hg", disabled: "fyvr12hh", focus: "fyvr12hi", hover: "fyvr12hj", checked: "fyvr12hk" }, defaultClass: "fyvr12hf" }, text80: { conditions: { base: "fyvr12hl", active: "fyvr12hm", disabled: "fyvr12hn", focus: "fyvr12ho", hover: "fyvr12hp", checked: "fyvr12hq" }, defaultClass: "fyvr12hl" }, text50: { conditions: { base: "fyvr12hr", active: "fyvr12hs", disabled: "fyvr12ht", focus: "fyvr12hu", hover: "fyvr12hv", checked: "fyvr12hw" }, defaultClass: "fyvr12hr" }, textInverse100: { conditions: { base: "fyvr12hx", active: "fyvr12hy", disabled: "fyvr12hz", focus: "fyvr12i0", hover: "fyvr12i1", checked: "fyvr12i2" }, defaultClass: "fyvr12hx" }, backgroundPrimary: { conditions: { base: "fyvr12i3", active: "fyvr12i4", disabled: "fyvr12i5", focus: "fyvr12i6", hover: "fyvr12i7", checked: "fyvr12i8" }, defaultClass: "fyvr12i3" }, backgroundSecondary: { conditions: { base: "fyvr12i9", active: "fyvr12ia", disabled: "fyvr12ib", focus: "fyvr12ic", hover: "fyvr12id", checked: "fyvr12ie" }, defaultClass: "fyvr12i9" }, backgroundContrast: { conditions: { base: "fyvr12if", active: "fyvr12ig", disabled: "fyvr12ih", focus: "fyvr12ii", hover: "fyvr12ij", checked: "fyvr12ik" }, defaultClass: "fyvr12if" }, backgroundMuted: { conditions: { base: "fyvr12il", active: "fyvr12im", disabled: "fyvr12in", focus: "fyvr12io", hover: "fyvr12ip", checked: "fyvr12iq" }, defaultClass: "fyvr12il" }, backgroundControl: { conditions: { base: "fyvr12ir", active: "fyvr12is", disabled: "fyvr12it", focus: "fyvr12iu", hover: "fyvr12iv", checked: "fyvr12iw" }, defaultClass: "fyvr12ir" }, backgroundInverse: { conditions: { base: "fyvr12ix", active: "fyvr12iy", disabled: "fyvr12iz", focus: "fyvr12j0", hover: "fyvr12j1", checked: "fyvr12j2" }, defaultClass: "fyvr12ix" }, backgroundBackdrop: { conditions: { base: "fyvr12j3", active: "fyvr12j4", disabled: "fyvr12j5", focus: "fyvr12j6", hover: "fyvr12j7", checked: "fyvr12j8" }, defaultClass: "fyvr12j3" }, backgroundOverlay: { conditions: { base: "fyvr12j9", active: "fyvr12ja", disabled: "fyvr12jb", focus: "fyvr12jc", hover: "fyvr12jd", checked: "fyvr12je" }, defaultClass: "fyvr12j9" }, backgroundRaised: { conditions: { base: "fyvr12jf", active: "fyvr12jg", disabled: "fyvr12jh", focus: "fyvr12ji", hover: "fyvr12jj", checked: "fyvr12jk" }, defaultClass: "fyvr12jf" }, buttonGlass: { conditions: { base: "fyvr12jl", active: "fyvr12jm", disabled: "fyvr12jn", focus: "fyvr12jo", hover: "fyvr12jp", checked: "fyvr12jq" }, defaultClass: "fyvr12jl" }, buttonEmphasis: { conditions: { base: "fyvr12jr", active: "fyvr12js", disabled: "fyvr12jt", focus: "fyvr12ju", hover: "fyvr12jv", checked: "fyvr12jw" }, defaultClass: "fyvr12jr" }, buttonInverse: { conditions: { base: "fyvr12jx", active: "fyvr12jy", disabled: "fyvr12jz", focus: "fyvr12k0", hover: "fyvr12k1", checked: "fyvr12k2" }, defaultClass: "fyvr12jx" }, borderNormal: { conditions: { base: "fyvr12k3", active: "fyvr12k4", disabled: "fyvr12k5", focus: "fyvr12k6", hover: "fyvr12k7", checked: "fyvr12k8" }, defaultClass: "fyvr12k3" }, borderFocus: { conditions: { base: "fyvr12k9", active: "fyvr12ka", disabled: "fyvr12kb", focus: "fyvr12kc", hover: "fyvr12kd", checked: "fyvr12ke" }, defaultClass: "fyvr12k9" } } }, borderRightStyle: { values: { solid: { conditions: { base: "fyvr12kf", active: "fyvr12kg", disabled: "fyvr12kh", focus: "fyvr12ki", hover: "fyvr12kj", checked: "fyvr12kk" }, defaultClass: "fyvr12kf" }, dashed: { conditions: { base: "fyvr12kl", active: "fyvr12km", disabled: "fyvr12kn", focus: "fyvr12ko", hover: "fyvr12kp", checked: "fyvr12kq" }, defaultClass: "fyvr12kl" }, dotted: { conditions: { base: "fyvr12kr", active: "fyvr12ks", disabled: "fyvr12kt", focus: "fyvr12ku", hover: "fyvr12kv", checked: "fyvr12kw" }, defaultClass: "fyvr12kr" } } }, borderTopColor: { values: { black: { conditions: { base: "fyvr12kx", active: "fyvr12ky", disabled: "fyvr12kz", focus: "fyvr12l0", hover: "fyvr12l1", checked: "fyvr12l2" }, defaultClass: "fyvr12kx" }, white: { conditions: { base: "fyvr12l3", active: "fyvr12l4", disabled: "fyvr12l5", focus: "fyvr12l6", hover: "fyvr12l7", checked: "fyvr12l8" }, defaultClass: "fyvr12l3" }, inherit: { conditions: { base: "fyvr12l9", active: "fyvr12la", disabled: "fyvr12lb", focus: "fyvr12lc", hover: "fyvr12ld", checked: "fyvr12le" }, defaultClass: "fyvr12l9" }, transparent: { conditions: { base: "fyvr12lf", active: "fyvr12lg", disabled: "fyvr12lh", focus: "fyvr12li", hover: "fyvr12lj", checked: "fyvr12lk" }, defaultClass: "fyvr12lf" }, positive: { conditions: { base: "fyvr12ll", active: "fyvr12lm", disabled: "fyvr12ln", focus: "fyvr12lo", hover: "fyvr12lp", checked: "fyvr12lq" }, defaultClass: "fyvr12ll" }, negative: { conditions: { base: "fyvr12lr", active: "fyvr12ls", disabled: "fyvr12lt", focus: "fyvr12lu", hover: "fyvr12lv", checked: "fyvr12lw" }, defaultClass: "fyvr12lr" }, info: { conditions: { base: "fyvr12lx", active: "fyvr12ly", disabled: "fyvr12lz", focus: "fyvr12m0", hover: "fyvr12m1", checked: "fyvr12m2" }, defaultClass: "fyvr12lx" }, warning: { conditions: { base: "fyvr12m3", active: "fyvr12m4", disabled: "fyvr12m5", focus: "fyvr12m6", hover: "fyvr12m7", checked: "fyvr12m8" }, defaultClass: "fyvr12m3" }, gradientBackdrop: { conditions: { base: "fyvr12m9", active: "fyvr12ma", disabled: "fyvr12mb", focus: "fyvr12mc", hover: "fyvr12md", checked: "fyvr12me" }, defaultClass: "fyvr12m9" }, gradientPrimary: { conditions: { base: "fyvr12mf", active: "fyvr12mg", disabled: "fyvr12mh", focus: "fyvr12mi", hover: "fyvr12mj", checked: "fyvr12mk" }, defaultClass: "fyvr12mf" }, gradientSecondary: { conditions: { base: "fyvr12ml", active: "fyvr12mm", disabled: "fyvr12mn", focus: "fyvr12mo", hover: "fyvr12mp", checked: "fyvr12mq" }, defaultClass: "fyvr12ml" }, arbitrumDark: { conditions: { base: "fyvr12mr", active: "fyvr12ms", disabled: "fyvr12mt", focus: "fyvr12mu", hover: "fyvr12mv", checked: "fyvr12mw" }, defaultClass: "fyvr12mr" }, arbitrumLight: { conditions: { base: "fyvr12mx", active: "fyvr12my", disabled: "fyvr12mz", focus: "fyvr12n0", hover: "fyvr12n1", checked: "fyvr12n2" }, defaultClass: "fyvr12mx" }, avalanceDark: { conditions: { base: "fyvr12n3", active: "fyvr12n4", disabled: "fyvr12n5", focus: "fyvr12n6", hover: "fyvr12n7", checked: "fyvr12n8" }, defaultClass: "fyvr12n3" }, avalanceLight: { conditions: { base: "fyvr12n9", active: "fyvr12na", disabled: "fyvr12nb", focus: "fyvr12nc", hover: "fyvr12nd", checked: "fyvr12ne" }, defaultClass: "fyvr12n9" }, bscDark: { conditions: { base: "fyvr12nf", active: "fyvr12ng", disabled: "fyvr12nh", focus: "fyvr12ni", hover: "fyvr12nj", checked: "fyvr12nk" }, defaultClass: "fyvr12nf" }, bscLight: { conditions: { base: "fyvr12nl", active: "fyvr12nm", disabled: "fyvr12nn", focus: "fyvr12no", hover: "fyvr12np", checked: "fyvr12nq" }, defaultClass: "fyvr12nl" }, ethereumDark: { conditions: { base: "fyvr12nr", active: "fyvr12ns", disabled: "fyvr12nt", focus: "fyvr12nu", hover: "fyvr12nv", checked: "fyvr12nw" }, defaultClass: "fyvr12nr" }, ethereumLight: { conditions: { base: "fyvr12nx", active: "fyvr12ny", disabled: "fyvr12nz", focus: "fyvr12o0", hover: "fyvr12o1", checked: "fyvr12o2" }, defaultClass: "fyvr12nx" }, gnosisDark: { conditions: { base: "fyvr12o3", active: "fyvr12o4", disabled: "fyvr12o5", focus: "fyvr12o6", hover: "fyvr12o7", checked: "fyvr12o8" }, defaultClass: "fyvr12o3" }, gnosisLight: { conditions: { base: "fyvr12o9", active: "fyvr12oa", disabled: "fyvr12ob", focus: "fyvr12oc", hover: "fyvr12od", checked: "fyvr12oe" }, defaultClass: "fyvr12o9" }, polygonDark: { conditions: { base: "fyvr12of", active: "fyvr12og", disabled: "fyvr12oh", focus: "fyvr12oi", hover: "fyvr12oj", checked: "fyvr12ok" }, defaultClass: "fyvr12of" }, polygonLight: { conditions: { base: "fyvr12ol", active: "fyvr12om", disabled: "fyvr12on", focus: "fyvr12oo", hover: "fyvr12op", checked: "fyvr12oq" }, defaultClass: "fyvr12ol" }, text100: { conditions: { base: "fyvr12or", active: "fyvr12os", disabled: "fyvr12ot", focus: "fyvr12ou", hover: "fyvr12ov", checked: "fyvr12ow" }, defaultClass: "fyvr12or" }, text80: { conditions: { base: "fyvr12ox", active: "fyvr12oy", disabled: "fyvr12oz", focus: "fyvr12p0", hover: "fyvr12p1", checked: "fyvr12p2" }, defaultClass: "fyvr12ox" }, text50: { conditions: { base: "fyvr12p3", active: "fyvr12p4", disabled: "fyvr12p5", focus: "fyvr12p6", hover: "fyvr12p7", checked: "fyvr12p8" }, defaultClass: "fyvr12p3" }, textInverse100: { conditions: { base: "fyvr12p9", active: "fyvr12pa", disabled: "fyvr12pb", focus: "fyvr12pc", hover: "fyvr12pd", checked: "fyvr12pe" }, defaultClass: "fyvr12p9" }, backgroundPrimary: { conditions: { base: "fyvr12pf", active: "fyvr12pg", disabled: "fyvr12ph", focus: "fyvr12pi", hover: "fyvr12pj", checked: "fyvr12pk" }, defaultClass: "fyvr12pf" }, backgroundSecondary: { conditions: { base: "fyvr12pl", active: "fyvr12pm", disabled: "fyvr12pn", focus: "fyvr12po", hover: "fyvr12pp", checked: "fyvr12pq" }, defaultClass: "fyvr12pl" }, backgroundContrast: { conditions: { base: "fyvr12pr", active: "fyvr12ps", disabled: "fyvr12pt", focus: "fyvr12pu", hover: "fyvr12pv", checked: "fyvr12pw" }, defaultClass: "fyvr12pr" }, backgroundMuted: { conditions: { base: "fyvr12px", active: "fyvr12py", disabled: "fyvr12pz", focus: "fyvr12q0", hover: "fyvr12q1", checked: "fyvr12q2" }, defaultClass: "fyvr12px" }, backgroundControl: { conditions: { base: "fyvr12q3", active: "fyvr12q4", disabled: "fyvr12q5", focus: "fyvr12q6", hover: "fyvr12q7", checked: "fyvr12q8" }, defaultClass: "fyvr12q3" }, backgroundInverse: { conditions: { base: "fyvr12q9", active: "fyvr12qa", disabled: "fyvr12qb", focus: "fyvr12qc", hover: "fyvr12qd", checked: "fyvr12qe" }, defaultClass: "fyvr12q9" }, backgroundBackdrop: { conditions: { base: "fyvr12qf", active: "fyvr12qg", disabled: "fyvr12qh", focus: "fyvr12qi", hover: "fyvr12qj", checked: "fyvr12qk" }, defaultClass: "fyvr12qf" }, backgroundOverlay: { conditions: { base: "fyvr12ql", active: "fyvr12qm", disabled: "fyvr12qn", focus: "fyvr12qo", hover: "fyvr12qp", checked: "fyvr12qq" }, defaultClass: "fyvr12ql" }, backgroundRaised: { conditions: { base: "fyvr12qr", active: "fyvr12qs", disabled: "fyvr12qt", focus: "fyvr12qu", hover: "fyvr12qv", checked: "fyvr12qw" }, defaultClass: "fyvr12qr" }, buttonGlass: { conditions: { base: "fyvr12qx", active: "fyvr12qy", disabled: "fyvr12qz", focus: "fyvr12r0", hover: "fyvr12r1", checked: "fyvr12r2" }, defaultClass: "fyvr12qx" }, buttonEmphasis: { conditions: { base: "fyvr12r3", active: "fyvr12r4", disabled: "fyvr12r5", focus: "fyvr12r6", hover: "fyvr12r7", checked: "fyvr12r8" }, defaultClass: "fyvr12r3" }, buttonInverse: { conditions: { base: "fyvr12r9", active: "fyvr12ra", disabled: "fyvr12rb", focus: "fyvr12rc", hover: "fyvr12rd", checked: "fyvr12re" }, defaultClass: "fyvr12r9" }, borderNormal: { conditions: { base: "fyvr12rf", active: "fyvr12rg", disabled: "fyvr12rh", focus: "fyvr12ri", hover: "fyvr12rj", checked: "fyvr12rk" }, defaultClass: "fyvr12rf" }, borderFocus: { conditions: { base: "fyvr12rl", active: "fyvr12rm", disabled: "fyvr12rn", focus: "fyvr12ro", hover: "fyvr12rp", checked: "fyvr12rq" }, defaultClass: "fyvr12rl" } } }, borderTopStyle: { values: { solid: { conditions: { base: "fyvr12rr", active: "fyvr12rs", disabled: "fyvr12rt", focus: "fyvr12ru", hover: "fyvr12rv", checked: "fyvr12rw" }, defaultClass: "fyvr12rr" }, dashed: { conditions: { base: "fyvr12rx", active: "fyvr12ry", disabled: "fyvr12rz", focus: "fyvr12s0", hover: "fyvr12s1", checked: "fyvr12s2" }, defaultClass: "fyvr12rx" }, dotted: { conditions: { base: "fyvr12s3", active: "fyvr12s4", disabled: "fyvr12s5", focus: "fyvr12s6", hover: "fyvr12s7", checked: "fyvr12s8" }, defaultClass: "fyvr12s3" } } }, border: { values: { none: { conditions: { base: "fyvr12s9", active: "fyvr12sa", disabled: "fyvr12sb", focus: "fyvr12sc", hover: "fyvr12sd", checked: "fyvr12se" }, defaultClass: "fyvr12s9" } } }, color: { values: { black: { conditions: { base: "fyvr12sf", active: "fyvr12sg", disabled: "fyvr12sh", focus: "fyvr12si", hover: "fyvr12sj", checked: "fyvr12sk" }, defaultClass: "fyvr12sf" }, white: { conditions: { base: "fyvr12sl", active: "fyvr12sm", disabled: "fyvr12sn", focus: "fyvr12so", hover: "fyvr12sp", checked: "fyvr12sq" }, defaultClass: "fyvr12sl" }, inherit: { conditions: { base: "fyvr12sr", active: "fyvr12ss", disabled: "fyvr12st", focus: "fyvr12su", hover: "fyvr12sv", checked: "fyvr12sw" }, defaultClass: "fyvr12sr" }, transparent: { conditions: { base: "fyvr12sx", active: "fyvr12sy", disabled: "fyvr12sz", focus: "fyvr12t0", hover: "fyvr12t1", checked: "fyvr12t2" }, defaultClass: "fyvr12sx" }, positive: { conditions: { base: "fyvr12t3", active: "fyvr12t4", disabled: "fyvr12t5", focus: "fyvr12t6", hover: "fyvr12t7", checked: "fyvr12t8" }, defaultClass: "fyvr12t3" }, negative: { conditions: { base: "fyvr12t9", active: "fyvr12ta", disabled: "fyvr12tb", focus: "fyvr12tc", hover: "fyvr12td", checked: "fyvr12te" }, defaultClass: "fyvr12t9" }, info: { conditions: { base: "fyvr12tf", active: "fyvr12tg", disabled: "fyvr12th", focus: "fyvr12ti", hover: "fyvr12tj", checked: "fyvr12tk" }, defaultClass: "fyvr12tf" }, warning: { conditions: { base: "fyvr12tl", active: "fyvr12tm", disabled: "fyvr12tn", focus: "fyvr12to", hover: "fyvr12tp", checked: "fyvr12tq" }, defaultClass: "fyvr12tl" }, gradientBackdrop: { conditions: { base: "fyvr12tr", active: "fyvr12ts", disabled: "fyvr12tt", focus: "fyvr12tu", hover: "fyvr12tv", checked: "fyvr12tw" }, defaultClass: "fyvr12tr" }, gradientPrimary: { conditions: { base: "fyvr12tx", active: "fyvr12ty", disabled: "fyvr12tz", focus: "fyvr12u0", hover: "fyvr12u1", checked: "fyvr12u2" }, defaultClass: "fyvr12tx" }, gradientSecondary: { conditions: { base: "fyvr12u3", active: "fyvr12u4", disabled: "fyvr12u5", focus: "fyvr12u6", hover: "fyvr12u7", checked: "fyvr12u8" }, defaultClass: "fyvr12u3" }, arbitrumDark: { conditions: { base: "fyvr12u9", active: "fyvr12ua", disabled: "fyvr12ub", focus: "fyvr12uc", hover: "fyvr12ud", checked: "fyvr12ue" }, defaultClass: "fyvr12u9" }, arbitrumLight: { conditions: { base: "fyvr12uf", active: "fyvr12ug", disabled: "fyvr12uh", focus: "fyvr12ui", hover: "fyvr12uj", checked: "fyvr12uk" }, defaultClass: "fyvr12uf" }, avalanceDark: { conditions: { base: "fyvr12ul", active: "fyvr12um", disabled: "fyvr12un", focus: "fyvr12uo", hover: "fyvr12up", checked: "fyvr12uq" }, defaultClass: "fyvr12ul" }, avalanceLight: { conditions: { base: "fyvr12ur", active: "fyvr12us", disabled: "fyvr12ut", focus: "fyvr12uu", hover: "fyvr12uv", checked: "fyvr12uw" }, defaultClass: "fyvr12ur" }, bscDark: { conditions: { base: "fyvr12ux", active: "fyvr12uy", disabled: "fyvr12uz", focus: "fyvr12v0", hover: "fyvr12v1", checked: "fyvr12v2" }, defaultClass: "fyvr12ux" }, bscLight: { conditions: { base: "fyvr12v3", active: "fyvr12v4", disabled: "fyvr12v5", focus: "fyvr12v6", hover: "fyvr12v7", checked: "fyvr12v8" }, defaultClass: "fyvr12v3" }, ethereumDark: { conditions: { base: "fyvr12v9", active: "fyvr12va", disabled: "fyvr12vb", focus: "fyvr12vc", hover: "fyvr12vd", checked: "fyvr12ve" }, defaultClass: "fyvr12v9" }, ethereumLight: { conditions: { base: "fyvr12vf", active: "fyvr12vg", disabled: "fyvr12vh", focus: "fyvr12vi", hover: "fyvr12vj", checked: "fyvr12vk" }, defaultClass: "fyvr12vf" }, gnosisDark: { conditions: { base: "fyvr12vl", active: "fyvr12vm", disabled: "fyvr12vn", focus: "fyvr12vo", hover: "fyvr12vp", checked: "fyvr12vq" }, defaultClass: "fyvr12vl" }, gnosisLight: { conditions: { base: "fyvr12vr", active: "fyvr12vs", disabled: "fyvr12vt", focus: "fyvr12vu", hover: "fyvr12vv", checked: "fyvr12vw" }, defaultClass: "fyvr12vr" }, polygonDark: { conditions: { base: "fyvr12vx", active: "fyvr12vy", disabled: "fyvr12vz", focus: "fyvr12w0", hover: "fyvr12w1", checked: "fyvr12w2" }, defaultClass: "fyvr12vx" }, polygonLight: { conditions: { base: "fyvr12w3", active: "fyvr12w4", disabled: "fyvr12w5", focus: "fyvr12w6", hover: "fyvr12w7", checked: "fyvr12w8" }, defaultClass: "fyvr12w3" }, text100: { conditions: { base: "fyvr12w9", active: "fyvr12wa", disabled: "fyvr12wb", focus: "fyvr12wc", hover: "fyvr12wd", checked: "fyvr12we" }, defaultClass: "fyvr12w9" }, text80: { conditions: { base: "fyvr12wf", active: "fyvr12wg", disabled: "fyvr12wh", focus: "fyvr12wi", hover: "fyvr12wj", checked: "fyvr12wk" }, defaultClass: "fyvr12wf" }, text50: { conditions: { base: "fyvr12wl", active: "fyvr12wm", disabled: "fyvr12wn", focus: "fyvr12wo", hover: "fyvr12wp", checked: "fyvr12wq" }, defaultClass: "fyvr12wl" }, textInverse100: { conditions: { base: "fyvr12wr", active: "fyvr12ws", disabled: "fyvr12wt", focus: "fyvr12wu", hover: "fyvr12wv", checked: "fyvr12ww" }, defaultClass: "fyvr12wr" }, backgroundPrimary: { conditions: { base: "fyvr12wx", active: "fyvr12wy", disabled: "fyvr12wz", focus: "fyvr12x0", hover: "fyvr12x1", checked: "fyvr12x2" }, defaultClass: "fyvr12wx" }, backgroundSecondary: { conditions: { base: "fyvr12x3", active: "fyvr12x4", disabled: "fyvr12x5", focus: "fyvr12x6", hover: "fyvr12x7", checked: "fyvr12x8" }, defaultClass: "fyvr12x3" }, backgroundContrast: { conditions: { base: "fyvr12x9", active: "fyvr12xa", disabled: "fyvr12xb", focus: "fyvr12xc", hover: "fyvr12xd", checked: "fyvr12xe" }, defaultClass: "fyvr12x9" }, backgroundMuted: { conditions: { base: "fyvr12xf", active: "fyvr12xg", disabled: "fyvr12xh", focus: "fyvr12xi", hover: "fyvr12xj", checked: "fyvr12xk" }, defaultClass: "fyvr12xf" }, backgroundControl: { conditions: { base: "fyvr12xl", active: "fyvr12xm", disabled: "fyvr12xn", focus: "fyvr12xo", hover: "fyvr12xp", checked: "fyvr12xq" }, defaultClass: "fyvr12xl" }, backgroundInverse: { conditions: { base: "fyvr12xr", active: "fyvr12xs", disabled: "fyvr12xt", focus: "fyvr12xu", hover: "fyvr12xv", checked: "fyvr12xw" }, defaultClass: "fyvr12xr" }, backgroundBackdrop: { conditions: { base: "fyvr12xx", active: "fyvr12xy", disabled: "fyvr12xz", focus: "fyvr12y0", hover: "fyvr12y1", checked: "fyvr12y2" }, defaultClass: "fyvr12xx" }, backgroundOverlay: { conditions: { base: "fyvr12y3", active: "fyvr12y4", disabled: "fyvr12y5", focus: "fyvr12y6", hover: "fyvr12y7", checked: "fyvr12y8" }, defaultClass: "fyvr12y3" }, backgroundRaised: { conditions: { base: "fyvr12y9", active: "fyvr12ya", disabled: "fyvr12yb", focus: "fyvr12yc", hover: "fyvr12yd", checked: "fyvr12ye" }, defaultClass: "fyvr12y9" }, buttonGlass: { conditions: { base: "fyvr12yf", active: "fyvr12yg", disabled: "fyvr12yh", focus: "fyvr12yi", hover: "fyvr12yj", checked: "fyvr12yk" }, defaultClass: "fyvr12yf" }, buttonEmphasis: { conditions: { base: "fyvr12yl", active: "fyvr12ym", disabled: "fyvr12yn", focus: "fyvr12yo", hover: "fyvr12yp", checked: "fyvr12yq" }, defaultClass: "fyvr12yl" }, buttonInverse: { conditions: { base: "fyvr12yr", active: "fyvr12ys", disabled: "fyvr12yt", focus: "fyvr12yu", hover: "fyvr12yv", checked: "fyvr12yw" }, defaultClass: "fyvr12yr" }, borderNormal: { conditions: { base: "fyvr12yx", active: "fyvr12yy", disabled: "fyvr12yz", focus: "fyvr12z0", hover: "fyvr12z1", checked: "fyvr12z2" }, defaultClass: "fyvr12yx" }, borderFocus: { conditions: { base: "fyvr12z3", active: "fyvr12z4", disabled: "fyvr12z5", focus: "fyvr12z6", hover: "fyvr12z7", checked: "fyvr12z8" }, defaultClass: "fyvr12z3" } } }, cursor: { values: { "default": { conditions: { base: "fyvr12z9", active: "fyvr12za", disabled: "fyvr12zb", focus: "fyvr12zc", hover: "fyvr12zd", checked: "fyvr12ze" }, defaultClass: "fyvr12z9" }, pointer: { conditions: { base: "fyvr12zf", active: "fyvr12zg", disabled: "fyvr12zh", focus: "fyvr12zi", hover: "fyvr12zj", checked: "fyvr12zk" }, defaultClass: "fyvr12zf" }, text: { conditions: { base: "fyvr12zl", active: "fyvr12zm", disabled: "fyvr12zn", focus: "fyvr12zo", hover: "fyvr12zp", checked: "fyvr12zq" }, defaultClass: "fyvr12zl" } } }, opacity: { values: { "0": { conditions: { base: "fyvr12zr", active: "fyvr12zs", disabled: "fyvr12zt", focus: "fyvr12zu", hover: "fyvr12zv", checked: "fyvr12zw" }, defaultClass: "fyvr12zr" }, "50": { conditions: { base: "fyvr12zx", active: "fyvr12zy", disabled: "fyvr12zz", focus: "fyvr1300", hover: "fyvr1301", checked: "fyvr1302" }, defaultClass: "fyvr12zx" }, "80": { conditions: { base: "fyvr1303", active: "fyvr1304", disabled: "fyvr1305", focus: "fyvr1306", hover: "fyvr1307", checked: "fyvr1308" }, defaultClass: "fyvr1303" }, "100": { conditions: { base: "fyvr1309", active: "fyvr130a", disabled: "fyvr130b", focus: "fyvr130c", hover: "fyvr130d", checked: "fyvr130e" }, defaultClass: "fyvr1309" } } }, pointerEvents: { values: { none: { conditions: { base: "fyvr130f", active: "fyvr130g", disabled: "fyvr130h", focus: "fyvr130i", hover: "fyvr130j", checked: "fyvr130k" }, defaultClass: "fyvr130f" }, auto: { conditions: { base: "fyvr130l", active: "fyvr130m", disabled: "fyvr130n", focus: "fyvr130o", hover: "fyvr130p", checked: "fyvr130q" }, defaultClass: "fyvr130l" } } }, outline: { values: { none: { conditions: { base: "fyvr130r", active: "fyvr130s", disabled: "fyvr130t", focus: "fyvr130u", hover: "fyvr130v", checked: "fyvr130w" }, defaultClass: "fyvr130r" } } }, boxShadow: { values: { none: { conditions: { base: "fyvr130x", active: "fyvr130y", disabled: "fyvr130z", focus: "fyvr1310", hover: "fyvr1311", checked: "fyvr1312" }, defaultClass: "fyvr130x" } } } } });
const FLEX_PROPS = [
  "alignItems",
  "alignSelf",
  "flexDirection",
  "gap",
  "justifyContent",
  "justifySelf",
  "placeItems"
];
const atoms = (props) => {
  props.display || (props.display = Object.keys(props).some((prop) => FLEX_PROPS.includes(prop)) ? "flex" : void 0);
  return sprinkles(props);
};
atoms.properties = sprinkles.properties;
var focusRing = "_4efw240";
const compareAddress = (a, b) => {
  return !!a && !!b && a.toLowerCase() === b.toLowerCase();
};
const truncateAddress = (address, minPrefix = 20, minSuffix = 3) => {
  if (minPrefix + minSuffix >= 40) {
    return address;
  } else {
    return `${address.substring(0, 2 + minPrefix)}…${address.substring(address.length - minSuffix)}`;
  }
};
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const SEQUENCE_ASSETS_URL_PREFIX = "https://assets.sequence.info/";
const VERSION = 5;
const sizes = {
  xs: "small",
  sm: "small",
  md: "medium",
  lg: "large",
  xl: "large"
};
const getSize = (size2) => size2 ? sizes[size2] || size2 : "medium";
const replaceSize = (url, size2) => {
  return url.replace(/\/(small|medium|large)\//, `/${getSize(size2)}/`);
};
const tokenImageUrl = (chainId, contractAddress, size2) => {
  return SEQUENCE_ASSETS_URL_PREFIX + `images/tokens/${getSize(
    size2
  )}/${chainId}/${contractAddress.toLowerCase()}.webp?v${VERSION}`;
};
const nativeTokenImageUrl = (chainId, size2) => tokenImageUrl(chainId, ZERO_ADDRESS, size2);
const networkImageUrl = (chainId, size2) => {
  return SEQUENCE_ASSETS_URL_PREFIX + `images/networks/${getSize(size2)}/${chainId}.webp?v${VERSION}`;
};
const isTruthy = (value) => Boolean(value);
const pluralize = (count2, singular, plural) => {
  return count2 === 1 ? singular : plural;
};
const capitalize = (s) => {
  if (s === "") {
    return "";
  }
  return s[0].toUpperCase() + s.slice(1);
};
const kebabize = (str) => str.replace(
  /[A-Z]+(?![a-z])|[A-Z]/g,
  ($, ofs) => (ofs ? "-" : "") + $.toLowerCase()
);
const responsiveStyle = (rules) => {
  return Object.entries(rules).reduce((acc, [key, value]) => {
    return {
      ...acc,
      [`screen and (min-width: ${breakpoints[key]}px)`]: value
    };
  }, {});
};
const selectorize = (classNames) => "." + classNames.split(" ").join(".");
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
const Box = React.forwardRef(
  (props, ref) => {
    const { as = "div", sx = {}, className, ...restProps } = props;
    const atomProps = {};
    const nativeProps = {};
    for (const key in restProps) {
      if (atoms.properties.has(key)) {
        atomProps[key] = restProps[key];
      } else {
        nativeProps[key] = restProps[key];
      }
    }
    const atomicClasses = atoms({
      ...atomProps,
      ...sx
    });
    return React.createElement(as, {
      className: clsx(atomicClasses, className),
      ...nativeProps,
      ref
    });
  }
);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React$1 = React;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item2) {
            return String(item2);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
function toPrimitive(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function mapValues(input2, fn) {
  var result = {};
  for (var _key in input2) {
    result[_key] = fn(input2[_key], _key);
  }
  return result;
}
var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
  for (var key of Object.keys(compoundCheck)) {
    var _selections$key;
    if (compoundCheck[key] !== ((_selections$key = selections[key]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key])) {
      return false;
    }
  }
  return true;
};
var createRuntimeFn = (config) => {
  var runtimeFn = (options) => {
    var className = config.defaultClassName;
    var selections = _objectSpread2(_objectSpread2({}, config.defaultVariants), options);
    for (var variantName in selections) {
      var _selections$variantNa;
      var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];
      if (variantSelection != null) {
        var selection = variantSelection;
        if (typeof selection === "boolean") {
          selection = selection === true ? "true" : "false";
        }
        var selectionClassName = (
          // @ts-expect-error
          config.variantClassNames[variantName][selection]
        );
        if (selectionClassName) {
          className += " " + selectionClassName;
        }
      }
    }
    for (var [compoundCheck, compoundClassName] of config.compoundVariants) {
      if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) {
        className += " " + compoundClassName;
      }
    }
    return className;
  };
  runtimeFn.variants = () => Object.keys(config.variantClassNames);
  runtimeFn.classNames = {
    get base() {
      return config.defaultClassName.split(" ")[0];
    },
    get variants() {
      return mapValues(config.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
    }
  };
  return runtimeFn;
};
var badgeVariants = createRuntimeFn({ defaultClassName: "_2q9vfj7", variantClassNames: { variant: { info: "_2q9vfj8 _2q9vfj0 fyvr11t3", warning: "_2q9vfj9 _2q9vfj1 fyvr11t9", success: "_2q9vfja _2q9vfj2 fyvr11sr", error: "_2q9vfjb _2q9vfj3 fyvr11sx" }, size: { sm: "_2q9vfjc _1qxj1ib9 _1qxj1ibf _1qxj1ib5 fyvr11r3 fyvr11ik fyvr11k4 fyvr11k0 fyvr11jc _2q9vfj4 fyvr1zc fyvr111g fyvr144 fyvr1f4", md: "_2q9vfjd _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _2q9vfj5 fyvr1zg fyvr111k fyvr148 fyvr1f8", lg: "_2q9vfje _1qxj1ib9 _1qxj1ibd _1qxj1ib3 fyvr11r3 fyvr11is fyvr11kc fyvr11jw fyvr11jk _2q9vfj6 fyvr1zk fyvr111o fyvr14c fyvr1fc" } }, defaultVariants: {}, compoundVariants: [] });
const Badge = (props) => {
  const { className, value, variant = "info", size: size2 = "md", ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: clsx(className, badgeVariants({ variant, size: size2 })),
      display: "inline-flex",
      flexShrink: "0",
      placeItems: "center",
      borderRadius: "circle",
      color: "white",
      whiteSpace: "nowrap",
      ...rest,
      children: value
    }
  );
};
const Divider = (props) => {
  const { color = "borderNormal", marginY = "4", ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: "hr",
      marginY,
      background: color,
      height: "px",
      borderWidth: "none",
      ...rest
    }
  );
};
var textVariants = createRuntimeFn({ defaultClassName: "_1qxj1ib9", variantClassNames: { variant: { inherit: "_1qxj1iba _1qxj1ib0 fyvr11r2 fyvr11ic fyvr11ko fyvr11jo fyvr11j4", xlarge: "_1qxj1ibb _1qxj1ib1 fyvr11r3 fyvr11j0 fyvr11kk fyvr11js fyvr11jk", large: "_1qxj1ibc _1qxj1ib2 fyvr11r3 fyvr11iw fyvr11kg fyvr11jw fyvr11jg", medium: "_1qxj1ibd _1qxj1ib3 fyvr11r3 fyvr11is fyvr11kc fyvr11jw fyvr11jk", normal: "_1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8", small: "_1qxj1ibf _1qxj1ib5 fyvr11r3 fyvr11ik fyvr11k4 fyvr11k0 fyvr11jc", xsmall: "_1qxj1ibg _1qxj1ib6 fyvr11r3 fyvr11ig fyvr11k4 fyvr11k0 fyvr11jk", code: "_1qxj1ibh _1qxj1ib7 fyvr11r4 fyvr11io fyvr11k8 fyvr11js fyvr11j8" }, ellipsis: { true: "_1qxj1ibi _1qxj1ib8 fyvr11q0 fyvr11qg fyvr11rh fyvr11r5" }, italic: { true: "_1qxj1ibj" }, underline: { true: "_1qxj1ibk" }, uppercase: { true: "_1qxj1ibl" }, capitalize: { true: "_1qxj1ibm" }, hidden: { true: "_1qxj1ibn" } }, defaultVariants: {}, compoundVariants: [] });
const Text = React.forwardRef(
  (props, ref) => {
    const {
      as = "span",
      variant = "inherit",
      className,
      hidden,
      italic,
      underline,
      children,
      ellipsis,
      uppercase,
      capitalize: capitalize2,
      ...boxProps
    } = props;
    const textVariantProps = text[variant];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as,
        className: clsx(
          className,
          textVariants({
            hidden,
            ellipsis,
            italic,
            underline,
            uppercase,
            capitalize: capitalize2
          })
        ),
        ref,
        ...textVariantProps,
        ...boxProps,
        children
      }
    );
  }
);
const Breadcrumbs = (props) => {
  const { paths, excludeDivider = false, renderLink, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ...rest, children: [
    paths.map((path, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      BreadcrumbSegment,
      {
        path,
        active: idx === paths.length - 1,
        renderLink
      },
      idx
    )),
    !excludeDivider && /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {})
  ] });
};
const defaultRenderLink = (path, children) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "a", href: path.url, textDecoration: "none", children });
const BreadcrumbSegment = (props) => {
  const { path, active, renderLink = defaultRenderLink } = props;
  return active ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Text,
    {
      variant: "small",
      fontWeight: "medium",
      color: "text100",
      whiteSpace: "nowrap",
      capitalize: true,
      children: path.label
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    renderLink(
      path,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Text,
        {
          variant: "small",
          fontWeight: "medium",
          color: "text50",
          whiteSpace: "nowrap",
          capitalize: true,
          opacity: { hover: "80" },
          children: path.label
        }
      )
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", fontWeight: "medium", color: "text50", children: " / " })
  ] });
};
var buttonVariants = createRuntimeFn({ defaultClassName: "_140wn8ni _140wn8n0 fyvr11q0 fyvr11qg fyvr11rh fyvr11ow fyvr12s9 fyvr11ra fyvr11l8 _4efw240", variantClassNames: { variant: { base: "_140wn8nj _140wn8n1 fyvr11sl fyvr12w9", ghost: "_140wn8nk _140wn8n2 fyvr11sl fyvr12w9", feature: "_140wn8nl _140wn8n3 fyvr11tr fyvr12sl", primary: "_140wn8nm _140wn8n4 fyvr11tl fyvr12sl", glass: "_140wn8nn _140wn8n5 fyvr11y3 fyvr12w9", emphasis: "_140wn8no _140wn8n6 fyvr11y9 fyvr12w9", raised: "_140wn8np _140wn8n7 fyvr11xx fyvr12w9", danger: "_140wn8nq _140wn8n8 fyvr11sx fyvr12sl", text: "_140wn8nr _1qxj1ib9 _1qxj1ibf _1qxj1ib5 fyvr11r3 fyvr11ik fyvr11k4 fyvr11k0 fyvr11jc _140wn8n9 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr11sl fyvr12wl" }, shape: { circle: "_140wn8ns _140wn8na fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw", square: "_140wn8nt _140wn8nb fyvr11h8 fyvr11hw fyvr11fw fyvr11gk" }, disabled: { true: "_140wn8nu _140wn8nc fyvr12z9 fyvr12zx", false: "_140wn8nv _140wn8nd fyvr12zf fyvr1309 fyvr1307" }, size: { xs: "_140wn8nw _1qxj1ib9 _1qxj1ibg _1qxj1ib6 fyvr11r3 fyvr11ig fyvr11k4 fyvr11k0 fyvr11jk _140wn8ne fyvr1zg fyvr111k", sm: "_140wn8nx _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _140wn8nf fyvr1zk fyvr111o", md: "_140wn8ny _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _140wn8ng fyvr1zo fyvr111s", lg: "_140wn8nz _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _140wn8nh fyvr1zo fyvr111s" }, iconOnly: { true: "_140wn8n10" }, hasLeftIcon: { true: "_140wn8n11" }, hasRightIcon: { true: "_140wn8n12" }, activeOutline: { light: "_140wn8n13", bold: "_140wn8n14" } }, defaultVariants: {}, compoundVariants: [[{ iconOnly: true, size: "xs" }, "_140wn8n15"], [{ iconOnly: true, size: "sm" }, "_140wn8n16"], [{ iconOnly: true, size: "md" }, "_140wn8n17"], [{ iconOnly: true, size: "lg" }, "_140wn8n18"], [{ iconOnly: false, hasLeftIcon: true, size: "xs" }, "_140wn8n19"], [{ iconOnly: false, hasLeftIcon: true, size: "sm" }, "_140wn8n1a"], [{ iconOnly: false, hasLeftIcon: true, size: "md" }, "_140wn8n1b"], [{ iconOnly: false, hasRightIcon: true, size: "xs" }, "_140wn8n1c"], [{ iconOnly: false, hasRightIcon: true, size: "sm" }, "_140wn8n1d"], [{ iconOnly: false, hasRightIcon: true, size: "md" }, "_140wn8n1e"]] });
const Button = React.forwardRef(
  (props, ref) => {
    const {
      as = "button",
      activeOutline,
      className,
      disabled = false,
      display = "inline-flex",
      fontWeight = "bold",
      pending = false,
      label,
      leftIcon: LeftIcon,
      rightIcon: RightIcon,
      size: size2 = "md",
      variant = "glass",
      width = "fit",
      shape = "circle",
      type = "button",
      ...restProps
    } = props;
    const hasLeftIcon = LeftIcon !== void 0 && label !== void 0;
    const hasRightIcon = RightIcon !== void 0 && label !== void 0;
    const iconOnly = LeftIcon !== void 0 && label === void 0;
    const iconSize = size2 === "xs" ? "xs" : "sm";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as,
        className: clsx(
          className,
          buttonVariants({
            activeOutline,
            disabled: disabled || pending,
            hasLeftIcon,
            hasRightIcon,
            iconOnly,
            size: variant === "text" ? void 0 : size2,
            shape: variant === "text" ? void 0 : shape,
            variant
          })
        ),
        disabled: disabled || pending,
        display,
        fontWeight,
        ref,
        type,
        width,
        ...restProps,
        children: iconOnly ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: iconSize }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            width: "full",
            height: "full",
            justifyContent: "space-between",
            alignItems: "center",
            gap: size2 === "xs" ? "1" : "2",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  justifyContent: "flex-start",
                  alignItems: "center",
                  gap: size2 === "xs" ? "1" : "2",
                  children: [
                    LeftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: iconSize }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: label })
                  ]
                }
              ),
              RightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RightIcon, { size: iconSize })
            ]
          }
        )
      }
    );
  }
);
var cardVariants = createRuntimeFn({ defaultClassName: "rhmai63", variantClassNames: { clickable: { true: "rhmai64 rhmai60 fyvr11ec fyvr11eo fyvr11f0 fyvr11fc fyvr1307 fyvr12zf _4efw240" }, disabled: { true: "rhmai65" }, outlined: { true: "rhmai66 rhmai61 fyvr11eg fyvr11es fyvr11f4 fyvr11fg fyvr12rf fyvr12k3 fyvr125f fyvr12cr fyvr12rr fyvr12kf fyvr125r fyvr12d3" }, blur: { true: "rhmai67 rhmai62 fyvr11r0" } }, defaultVariants: {}, compoundVariants: [] });
const Card = React.forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      clickable,
      outlined,
      disabled,
      blur: blur2,
      width = "full",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: clsx(
          className,
          cardVariants({ clickable, outlined, disabled, blur: blur2 })
        ),
        background: outlined ? "transparent" : "backgroundSecondary",
        overflow: "hidden",
        borderRadius: "md",
        padding: "4",
        width,
        ref,
        ...rest,
        children
      }
    );
  }
);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return React__namespace.useCallback(composeRefs(...refs), refs);
}
function createContext2(rootComponentName, defaultContext) {
  const Context = React__namespace.createContext(defaultContext);
  function Provider2(props) {
    const { children, ...context } = props;
    const value = React__namespace.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  }
  function useContext2(consumerName) {
    const context = React__namespace.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider2.displayName = rootComponentName + "Provider";
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React__namespace.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = React__namespace.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = React__namespace.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React__namespace.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React__namespace.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React__namespace.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function useCallbackRef$1(callback) {
  const callbackRef = React__namespace.useRef(callback);
  React__namespace.useEffect(() => {
    callbackRef.current = callback;
  });
  return React__namespace.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = React__namespace.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React__namespace.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React__namespace.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  React__namespace.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = React__namespace.useRef({ value, previous: value });
  return React__namespace.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React__namespace.useLayoutEffect : () => {
};
function useSize(element) {
  const [size2, setSize] = React__namespace.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
function useStateMachine(initialState, machine) {
  return React__namespace.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React__namespace.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef$1(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React__namespace.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React__namespace.useState();
  const stylesRef = React__namespace.useRef({});
  const prevPresentRef = React__namespace.useRef(present);
  const prevAnimationNameRef = React__namespace.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React__namespace.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          ReactDOM__namespace.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React__namespace.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef$1(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var Slot = React__namespace.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React__namespace.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React__namespace.Children.count(newElement) > 1) return React__namespace.Children.only(null);
        return React__namespace.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React__namespace.isValidElement(newElement) ? React__namespace.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React__namespace.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React__namespace.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React__namespace.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React__namespace.Children.count(children) > 1 ? React__namespace.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return React__namespace.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React__namespace.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM__namespace.flushSync(() => target.dispatchEvent(event));
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      ...checkboxProps
    } = props;
    const [button, setButton] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React__namespace.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = React__namespace.useRef(checked);
    React__namespace.useEffect(() => {
      const form = button == null ? void 0 : button.form;
      if (form) {
        const reset2 = () => setChecked(initialCheckedStateRef.current);
        form.addEventListener("reset", reset2);
        return () => form.removeEventListener("reset", reset2);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState$4(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate$1(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$2,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME$3 = "CheckboxIndicator";
var CheckboxIndicator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME$3, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isIndeterminate$1(context.state) || context.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$4(context.state),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME$3;
var BubbleInput$2 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = React__namespace.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React__namespace.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input2.indeterminate = isIndeterminate$1(checked);
      setChecked.call(input2, isIndeterminate$1(checked) ? false : checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: isIndeterminate$1(checked) ? false : checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function isIndeterminate$1(checked) {
  return checked === "indeterminate";
}
function getState$4(checked) {
  return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$8 = Checkbox$1;
var Indicator$2 = CheckboxIndicator;
var labelVariants = createRuntimeFn({ defaultClassName: "_43lu9r4", variantClassNames: { labelLocation: { top: "_43lu9r5 _43lu9r0 fyvr11p4 fyvr11mc fyvr11ck fyvr11l8", left: "_43lu9r6 _43lu9r1 fyvr11ow fyvr11mk fyvr11ck fyvr11l8", right: "_43lu9r7 _43lu9r2 fyvr11ow fyvr11mk fyvr11ck fyvr11l8", hidden: "_43lu9r8 _43lu9r3 fyvr11c8 fyvr11l8" } }, defaultVariants: {}, compoundVariants: [] });
const Field = (props) => {
  const {
    id,
    label,
    description,
    labelLocation = "top",
    children,
    ...rest
  } = props;
  const renderLabel = () => label || description ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "column", gap: "0.5", children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        variant: "small",
        color: "text100",
        hidden: labelLocation === "hidden",
        children: label
      }
    ),
    description && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Text,
      {
        variant: "small",
        color: "text50",
        hidden: labelLocation === "hidden",
        children: description
      }
    )
  ] }) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      as: "label",
      className: labelVariants({ labelLocation }),
      htmlFor: id,
      ...rest,
      children: [
        ["left", "top", "hidden"].includes(labelLocation) && renderLabel(),
        children,
        labelLocation === "right" && renderLabel()
      ]
    }
  );
};
var iconVariants = createRuntimeFn({ defaultClassName: "_1dizidw0", variantClassNames: { size: { xs: "_1dizidw1", sm: "_1dizidw2", md: "_1dizidw3", lg: "_1dizidw4", xl: "_1dizidw5" } }, defaultVariants: {}, compoundVariants: [] });
const Svg$17 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M11.168 9.25V2.929h-1.5V9.25h-6.32v1.5h6.32v6.321h1.5V10.75h6.321v-1.5h-6.32Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgAddIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$17,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$16 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M10 1.6a6.886 6.886 0 0 0-6.886 6.885c0 .058.018.116.055.165l4.077 5.431v4.32h5.508v-4.32l4.077-5.43a.275.275 0 0 0 .055-.166A6.886 6.886 0 0 0 10 1.6Zm0 4.957a1.928 1.928 0 0 0-1.928 1.928h.005c.345 1.725 1.097 5.509 1.097 5.509h1.652s.752-3.784 1.097-5.509h.005A1.928 1.928 0 0 0 10 6.557Zm-2.135 7.437-4.2-5.608c0-1.065.863-1.829 1.928-1.829s1.928.863 1.928 1.928c0 0 .751 3.784 1.096 5.509h-.752Zm4.27 0 4.2-5.608c0-1.065-.863-1.829-1.928-1.829a1.928 1.928 0 0 0-1.928 1.928s-.751 3.784-1.096 5.509h.752Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgAirDropperIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$16,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$15 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M13.548 10.997c-.015-1.645 1.344-2.435 1.405-2.474-.764-1.119-1.954-1.271-2.378-1.29-1.011-.102-1.974.597-2.488.597s-1.306-.581-2.145-.565c-1.104.017-2.122.641-2.69 1.63-1.147 1.987-.294 4.934.824 6.549.546.789 1.196 1.677 2.052 1.644.825-.032 1.136-.533 2.13-.533.995 0 1.276.534 2.146.517.885-.018 1.447-.807 1.99-1.598.625-.916.884-1.803.899-1.85-.02-.007-1.727-.661-1.745-2.627ZM11.912 6.166c.454-.55.76-1.315.677-2.077-.655.027-1.446.437-1.915.986-.42.486-.789 1.264-.689 2.011.728.057 1.473-.372 1.927-.92Z"
      }
    )
  }
);
const SvgAppleIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$15,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$14 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M5.479 9.94 4.419 11l5.53 5.53 5.53-5.53-1.06-1.06-3.72 3.72V3.47h-1.5v10.19l-3.72-3.72Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgArrowDownIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$14,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$13 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m10.888 14.47 1.06 1.06L17.48 10l-5.53-5.53-1.06 1.06 3.719 3.72H4.418v1.5h10.19l-3.72 3.72Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgArrowRightIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$13,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$12 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M5.668 7.898c-.728.93-1.792 1.705-3.25 1.705v-1.5c1.05 0 1.848-.675 2.426-1.654.582-.987.824-2.102.824-2.575h1.5c0 .473.242 1.588.825 2.575.578.979 1.375 1.654 2.425 1.654 1.05 0 1.848-.675 2.426-1.654.583-.987.824-2.102.824-2.575h1.5c0 .473.242 1.588.825 2.575.577.979 1.376 1.654 2.425 1.654v1.5c-1.457 0-2.521-.776-3.25-1.705v3.273h3.25v1.5h-3.25v3.455h-1.5V12.67h-6.5v3.456h-1.5V12.67h-3.25v-1.5h3.25V7.899Zm1.5 0v3.273h6.5V7.898c-.728.93-1.792 1.705-3.25 1.705-1.457 0-2.521-.776-3.25-1.705Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgBridgeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$12,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$11 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        stroke: "currentColor",
        strokeWidth: 1.5,
        d: "m4.304 10.232 4.263 4.79 7.13-11.238"
      }
    )
  }
);
const SvgCheckmarkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$11,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$10 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m3.888 7.53 1.06-1.06 5.47 5.47 5.47-5.47 1.06 1.06-6.53 6.53-6.53-6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronDownIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$10,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$$ = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m12.888 3.47 1.06 1.06L8.48 10l5.47 5.47-1.061 1.06L6.358 10l6.53-6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronLeftIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$$,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$_ = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m7.949 16.53-1.061-1.06 5.47-5.47-5.47-5.47 1.06-1.06L14.48 10l-6.53 6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronRightIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$_,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$Z = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m16.949 12.47-1.061 1.06-5.47-5.47-5.47 5.47-1.06-1.06 6.53-6.53 6.53 6.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgChevronUpIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$Z,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$Y = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m10.418 11.06 4.47 4.47 1.06-1.06L11.48 10l4.47-4.47-1.06-1.06-4.47 4.47-4.47-4.47-1.06 1.06L9.357 10l-4.47 4.47 1.06 1.06 4.47-4.47Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCloseIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$Y,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$X = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M9.528 7.898a2.89 2.89 0 0 1-2.882 2.899 2.89 2.89 0 0 1-2.882-2.899A2.89 2.89 0 0 1 6.646 5a2.89 2.89 0 0 1 2.882 2.898ZM9.053 12.275a5.998 5.998 0 0 0-2.407-.493c-2.827 0-5.121 1.885-5.146 4.217h5.708v-.01c.016-1.507.737-2.795 1.845-3.714ZM16.236 7.899a2.89 2.89 0 0 1-2.882 2.898 2.89 2.89 0 0 1-2.882-2.898A2.89 2.89 0 0 1 13.354 5a2.89 2.89 0 0 1 2.882 2.898Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M18.5 16H8.208c.025-2.333 2.32-4.217 5.146-4.217 2.827 0 5.121 1.884 5.146 4.217Z",
          clipRule: "evenodd"
        }
      )
    ]
  }
);
const SvgContactsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$X,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$W = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.597 10a1.388 1.388 0 1 1-2.776 0 1.388 1.388 0 0 1 2.776 0Zm5.21 0a1.388 1.388 0 1 1-2.777 0 1.388 1.388 0 0 1 2.776 0Zm3.82 1.388a1.388 1.388 0 1 0 0-2.776 1.388 1.388 0 0 0 0 2.776Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgContextMenuIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$W,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$V = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.317 17H7V9.396a1.25 1.25 0 1 1 1 0v5.028l2.733-1.024v-1.012a1.25 1.25 0 1 1 1 .015v1.69L8 15.492V17h8V8.146h-5.545V3H4V17h2.317Zm9.614-9.843-4.42-4.093.055 4.093h4.365Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgContractIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$V,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$U = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M14.918 4.5h-6V6h4.5v6.5h1.5v-8Zm-1.5 9.5v3h-9V6h3V3h9v11h-3Zm-7.5 1.5v-8h6v8h-6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCopyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$U,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$T = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M5 6.714 3.618 3.547H2.5L4.158 7.02H2.98v.69h1.494v.663H2.981v.69h1.494v1.484h1.036V9.063h1.46v-.69h-1.46v-.66l.001-.003h1.46v-.69h-1.13L7.5 3.547H6.383L5 6.714Zm4.747 8.232v-.788a2.887 2.887 0 0 1-1.04-.249 2.04 2.04 0 0 1-.863-.727 2.213 2.213 0 0 1-.344-1.125h1.017c.02.26.098.476.236.65.14.171.319.299.535.383.144.054.297.09.46.109V10.81l-.319-.093c-.538-.157-.964-.388-1.28-.693-.312-.304-.469-.707-.469-1.209 0-.415.105-.777.315-1.086.21-.31.495-.55.853-.72.273-.133.573-.215.9-.246v-.817h.537v.81c.365.023.692.106.981.249.35.17.626.406.827.706.201.298.306.64.315 1.027h-.978a1.04 1.04 0 0 0-.433-.774 1.47 1.47 0 0 0-.712-.264v2.253l.283.079c.214.056.434.132.659.228a2.6 2.6 0 0 1 .627.38c.192.157.347.351.466.583.12.232.18.51.18.834 0 .407-.098.77-.295 1.086a2.006 2.006 0 0 1-.85.749c-.304.15-.66.239-1.07.265v.79h-.538Zm1.024-1.877c-.148.064-.31.106-.486.128v-2.23c.216.064.41.136.584.218.193.089.345.201.457.337.113.136.17.31.17.524 0 .234-.065.44-.194.615-.129.174-.306.31-.531.408ZM9.747 7.706v2.095a4.605 4.605 0 0 1-.246-.086 2.195 2.195 0 0 1-.4-.207 1.038 1.038 0 0 1-.299-.313.847.847 0 0 1-.111-.443.94.94 0 0 1 .164-.545c.112-.162.268-.288.47-.38.126-.059.267-.099.422-.12Zm7.677 10.086h-4.9v-.897h.34a.342.342 0 0 0 .29-.186c.068-.117.114-.254.137-.411.023-.16.032-.304.028-.432l-.027-.779H12.5v-.896h.76l-.043-1.262c-.018-.472.073-.866.273-1.183.203-.317.473-.555.809-.715.335-.16.697-.24 1.084-.24.346 0 .656.056.931.166.278.11.511.26.7.452.191.188.328.404.41.647.081.243.097.498.048.766l-1.01-.156c.023-.22-.014-.403-.11-.55a.891.891 0 0 0-.395-.33 1.31 1.31 0 0 0-1.102.024c-.177.09-.322.227-.434.411-.11.185-.164.42-.164.708l.048 1.261h1.649v.897H14.34l.029.752c.014.29-.025.55-.116.78-.04.1-.096.193-.166.276h3.337v.897Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgCurrencyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$T,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$S = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "circle",
      {
        cx: 10,
        cy: 10,
        r: 8,
        stroke: "currentColor",
        strokeDasharray: "2 4",
        strokeLinecap: "round",
        strokeWidth: 1.5
      }
    )
  }
);
const SvgDashedCircleIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$S,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$R = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M10.105 13.232a.996.996 0 0 1-1.348-.057l-1.932-1.932a.997.997 0 0 1-.057-1.349l.03-.034c.34-.403.794-.937 1.285-1.51l.303-.353.37-.43c.969-1.121 1.958-2.244 2.466-2.751 1.816-1.816 3.689-3.04 6.132-3.01a.849.849 0 0 1 .84.84c.03 2.443-1.194 4.316-3.01 6.132-.507.507-1.63 1.497-2.752 2.466a273.04 273.04 0 0 1-2.327 1.988Zm5.076-6.501a1.352 1.352 0 1 1-1.912-1.912 1.352 1.352 0 0 1 1.912 1.912Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M2.785 13.821a.4.4 0 1 0 .566.566l2.152-2.152a.4.4 0 0 0-.566-.566l-2.152 2.152ZM2.207 17.227a.4.4 0 0 0 .566.566l4.144-4.144a.4.4 0 1 0-.566-.566l-4.144 4.144ZM5.613 17.215a.4.4 0 0 1 0-.566l2.152-2.152a.4.4 0 0 1 .566.566l-2.152 2.152a.4.4 0 0 1-.566 0ZM2.005 9.902c1.6-1.6 3.611-2.442 5.46-2.462.032 0 .05.037.029.061a336.915 336.915 0 0 0-1.914 2.25l-.169.2a5.92 5.92 0 0 0-3.335.061c-.067.023-.12-.06-.07-.11ZM10.047 14.593v-.002l.001-.002.001-.001.2-.168a309.141 309.141 0 0 0 2.25-1.914.037.037 0 0 1 .06.029c-.019 1.849-.862 3.86-2.46 5.46-.05.05-.134-.005-.112-.071a5.92 5.92 0 0 0 .06-3.331Z"
        }
      )
    ]
  }
);
const SvgDeployIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$R,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$Q = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.543 5.188h6.914v11.617H6.543V5.188ZM5 18.497v-15h10v15H5Zm7-12H8v1.46h4v-1.46Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgDeviceIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$Q,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$P = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M14.852 5.095c-.893-.46-1.85-.8-2.85-.994-.018-.003-.037.006-.046.025-.123.246-.26.567-.355.82a9.492 9.492 0 0 0-3.2 0 8.758 8.758 0 0 0-.36-.82.043.043 0 0 0-.046-.025c-1 .194-1.957.533-2.85.994a.042.042 0 0 0-.019.018c-1.815 3.05-2.312 6.024-2.068 8.961a.056.056 0 0 0 .018.037 11.168 11.168 0 0 0 3.496 1.987c.018.007.037 0 .049-.018.27-.413.51-.85.715-1.308.012-.027 0-.059-.024-.07a7.303 7.303 0 0 1-1.092-.585c-.028-.018-.03-.062-.005-.083.074-.062.147-.127.217-.192a.04.04 0 0 1 .046-.006c2.29 1.176 4.771 1.176 7.035 0a.04.04 0 0 1 .046.006c.07.065.144.13.218.192.025.02.023.065-.004.083-.349.23-.712.423-1.093.585-.025.01-.036.043-.024.07.21.458.45.894.715 1.308.011.017.03.025.05.018a11.13 11.13 0 0 0 3.5-1.987.052.052 0 0 0 .019-.036c.292-3.396-.49-6.346-2.07-8.961a.038.038 0 0 0-.018-.019Zm-7.174 7.19c-.69 0-1.258-.712-1.258-1.586 0-.875.558-1.587 1.258-1.587.707 0 1.27.719 1.259 1.587 0 .874-.558 1.587-1.259 1.587Zm4.652 0c-.69 0-1.258-.712-1.258-1.586 0-.875.557-1.587 1.258-1.587.707 0 1.27.719 1.258 1.587 0 .874-.551 1.587-1.258 1.587Z"
      }
    )
  }
);
const SvgDiscordIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$P,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$O = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M14.648 8.35 10.797 4.5h-.047v3.85h3.898ZM9.25 4.5H5.918v11h9V9.85H9.25V4.5ZM16.418 8l-5-5h-7v14h12V8Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgDocsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$O,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$N = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M3 12.25V18h13.5v-5.75H15v4.25H4.5v-4.25H3Zm11.28-2.47-1.06-1.06-2.72 2.72V3.25H9v8.19L6.28 8.72 5.22 9.78l4.53 4.53 4.53-4.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgDownloadIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$N,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$M = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M7.572 7.014a1.438 1.438 0 1 0 0-2.877 1.438 1.438 0 0 0 0 2.877ZM7.572 11.94a1.438 1.438 0 1 0 0-2.877 1.438 1.438 0 0 0 0 2.876ZM7.572 16.864a1.438 1.438 0 1 0 0-2.876 1.438 1.438 0 0 0 0 2.876ZM12.89 7.014a1.438 1.438 0 1 0 0-2.877 1.438 1.438 0 0 0 0 2.877ZM12.89 11.94a1.438 1.438 0 1 0 0-2.877 1.438 1.438 0 0 0 0 2.876ZM12.89 16.864a1.438 1.438 0 1 0 0-2.876 1.438 1.438 0 0 0 0 2.876Z"
      }
    )
  }
);
const SvgDragIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$M,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$L = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "m5.285 12.883 6.53-6.53 2.254 2.253-6.531 6.531-2.878.618.625-2.872ZM14.674 8.001l-2.253-2.253 1.502-1.503L16.176 6.5 14.674 8Z"
      }
    )
  }
);
const SvgEditIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$L,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$K = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M15.01 6.1H4.99L10 9.68 15.01 6.1ZM3.5 6.88v7.22h13V6.88L10 11.521 3.5 6.88ZM2 15.6v-11h16v11H2Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgEmailIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$K,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$J = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m6.98 5.703 7.937 7.937v-3.19h1.5v5.75h-5.75v-1.5h3.19L5.92 6.764v3.189h-1.5v-5.75h5.75v1.5H6.98Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgExpandIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$J,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$I = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M12.608 6.75h-5.19v-1.5h7.75V13h-1.5V7.81l-7.72 7.72-1.06-1.06 7.72-7.72Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgExternalLinkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$I,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$H = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M12.42 5.797c-.93 0-1.194.413-1.194 1.322v1.5H13.7l-.244 2.432h-2.23v7.368h-2.96V11.05H6.268V8.619h1.997V7.161c0-2.453.984-3.742 3.742-3.742.592 0 1.3.046 1.724.106v2.282"
      }
    )
  }
);
const SvgFacebookIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$H,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$G = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M4.51 3C3.675 3 3 3.692 3 4.545V16.6c0 .455.36.824.805.824h6.238a.815.815 0 0 0 .806-.824v-6.006c1.175 0 2.128.937 2.128 2.093v2.335c0 1.092.9 1.978 2.011 1.978C16.1 17 17 16.114 17 15.022V8.24c0-.832-.336-1.631-.935-2.22L13.64 3.636l-.55.542 1.845 1.814c-.754.133-1.33.832-1.33 1.675 0 .937.712 1.697 1.591 1.697.39 0 .748-.15 1.024-.399v6.057c0 .67-.552 1.212-1.233 1.212-.68 0-1.232-.542-1.232-1.212v-2.335c0-1.579-1.302-2.859-2.908-2.859V4.545C10.848 3.692 10.173 3 9.34 3H4.51Zm.805 1.485a.826.826 0 0 0-.83.821v1.54c0 .453.372.82.83.82h3.218c.459 0 .83-.367.83-.82v-1.54a.826.826 0 0 0-.83-.821H5.315Zm9.882 3.962c-.404 0-.732-.35-.732-.78 0-.431.328-.78.732-.78.404 0 .732.349.732.78 0 .43-.328.78-.732.78Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgGasTankIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$G,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$F = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M9.5 10.575v1.742a9.655 9.655 0 0 0-2.367.383 8.593 8.593 0 0 1-.355-2.125H9.5Zm-2.005 3.061a8.685 8.685 0 0 1 2.005-.318v2.672c-.697-.457-1.462-1.21-2.005-2.354Zm-1.718-3.061c.04.93.19 1.75.416 2.472a7.188 7.188 0 0 0-1.45.852 6.465 6.465 0 0 1-1.224-3.324h2.258Zm.775 3.407c-.44.199-.825.43-1.158.679a6.494 6.494 0 0 0 2.934 1.697 6.874 6.874 0 0 1-1.776-2.377Zm5.953-.346a8.686 8.686 0 0 0-2.005-.318v2.672c.697-.457 1.462-1.21 2.005-2.354Zm-2.005-1.32c.884.038 1.67.176 2.367.384.19-.617.317-1.323.355-2.125H10.5v1.742Zm1.172 4.041a6.874 6.874 0 0 0 1.776-2.375c.44.199.825.43 1.158.679a6.493 6.493 0 0 1-2.934 1.696Zm2.135-3.31a7.185 7.185 0 0 1 1.45.852 6.465 6.465 0 0 0 1.224-3.324h-2.258c-.04.93-.19 1.75-.416 2.472Zm-.585-3.472H10.5V7.833a9.655 9.655 0 0 0 2.367-.384c.19.618.317 1.323.355 2.126Zm-.717-3.062a8.683 8.683 0 0 1-2.005.319V4.159c.697.457 1.462 1.21 2.005 2.354Zm.943-.345a6.873 6.873 0 0 0-1.776-2.376c1.128.3 2.135.894 2.934 1.697a6.19 6.19 0 0 1-1.158.679Zm.359.935a7.184 7.184 0 0 0 1.45-.852 6.466 6.466 0 0 1 1.224 3.324h-2.258c-.04-.93-.19-1.75-.416-2.472ZM9.5 6.832V4.159c-.697.457-1.462 1.21-2.005 2.354.588.17 1.254.284 2.005.319Zm0 1.001a9.654 9.654 0 0 1-2.367-.384 8.594 8.594 0 0 0-.355 2.126H9.5V7.833Zm-3.307-.73a9.587 9.587 0 0 0-.416 2.472H3.52A6.465 6.465 0 0 1 4.743 6.25c.417.317.899.608 1.45.852Zm.36-.935c-.442-.2-.826-.43-1.16-.68a6.493 6.493 0 0 1 2.935-1.696 6.874 6.874 0 0 0-1.776 2.376ZM10 18.075a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgGlobeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$F,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$E = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M12.603 7.94c-.67-.644-1.517-.975-2.466-.975-1.678 0-3.1 1.143-3.608 2.687-.13.39-.204.807-.204 1.24 0 .434.07.851.204 1.241.509 1.544 1.93 2.687 3.608 2.687.868 0 1.603-.239 2.182-.629a3.02 3.02 0 0 0 1.287-1.939h-3.47V9.81h6.06c.063.396.101.802.101 1.23 0 1.977-.697 3.645-1.909 4.777-1.061.992-2.514 1.577-4.251 1.577-2.515 0-4.686-1.463-5.742-3.586a6.479 6.479 0 0 1 0-5.829c1.056-2.123 3.227-3.585 5.742-3.585 1.737 0 3.19.644 4.3 1.695L12.603 7.94Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgGoogleIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$E,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$D = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M3 4.6A1.6 1.6 0 0 1 4.6 3H7a1.6 1.6 0 0 1 1.6 1.6V7A1.6 1.6 0 0 1 7 8.6H4.6A1.6 1.6 0 0 1 3 7V4.6ZM3 13a1.6 1.6 0 0 1 1.6-1.6H7A1.6 1.6 0 0 1 8.6 13v2.4A1.6 1.6 0 0 1 7 17H4.6A1.6 1.6 0 0 1 3 15.4V13ZM11.4 4.6A1.6 1.6 0 0 1 13 3h2.4A1.6 1.6 0 0 1 17 4.6V7a1.6 1.6 0 0 1-1.6 1.6H13A1.6 1.6 0 0 1 11.4 7V4.6ZM11.4 13a1.6 1.6 0 0 1 1.6-1.6h2.4A1.6 1.6 0 0 1 17 13v2.4a1.6 1.6 0 0 1-1.6 1.6H13a1.6 1.6 0 0 1-1.6-1.6V13Z"
      }
    )
  }
);
const SvgGridIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$D,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$C = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.918 10a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0Zm1.5 0a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-9 1.469v.133h1.48v-.133c.003-.255.036-.47.098-.645a1.3 1.3 0 0 1 .293-.46c.133-.134.303-.261.508-.384.245-.145.457-.308.637-.488.18-.182.319-.39.418-.625.101-.237.152-.508.152-.812 0-.456-.113-.845-.34-1.168a2.131 2.131 0 0 0-.937-.739c-.399-.171-.857-.257-1.375-.257-.471 0-.902.084-1.293.254-.39.166-.704.42-.941.761-.237.339-.362.768-.375 1.29h1.593c.008-.214.06-.393.157-.536a.917.917 0 0 1 .37-.328 1.06 1.06 0 0 1 .481-.113c.175 0 .333.036.477.11a.858.858 0 0 1 .347.312.863.863 0 0 1 .13.472c0 .17-.039.323-.114.461-.076.136-.177.26-.305.371a3.69 3.69 0 0 1-.433.325 2.69 2.69 0 0 0-.555.453c-.154.166-.27.385-.352.656-.078.27-.118.634-.12 1.09Zm.106 2.36a.917.917 0 0 0 .668.273c.166 0 .32-.042.46-.125.141-.086.255-.2.34-.34a.897.897 0 0 0-.149-1.129.907.907 0 0 0-.651-.274.917.917 0 0 0-.668.274.882.882 0 0 0-.27.656.899.899 0 0 0 .27.664Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgHelpIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$C,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$B = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M11.425 5.189c-.466-.06-.942-.092-1.425-.092-3.564 0-6.716 1.703-8.445 4.296l-.277.416.277.416c1.141 1.712 2.902 3.035 4.991 3.737l.744-1.336c-1.727-.522-3.19-1.527-4.187-2.817C4.59 7.887 7.11 6.597 10 6.597c.212 0 .422.007.63.02l.795-1.428Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M10.179 7.43a2.385 2.385 0 0 0-2.105 3.786l2.105-3.786Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "m5.979 17.041.874.486 1.722-3.097c.466.06.942.091 1.425.091 3.564 0 6.716-1.702 8.445-4.296l.277-.416-.277-.416c-1.141-1.711-2.902-3.035-4.991-3.737l1.5-2.697-.875-.486-8.1 14.568ZM12.71 6.993l-.783 1.41a2.386 2.386 0 0 1-2.105 3.786L9.368 13c.208.014.419.02.631.02 2.89 0 5.41-1.29 6.897-3.212-.998-1.29-2.46-2.294-4.187-2.816Z",
          clipRule: "evenodd"
        }
      )
    ]
  }
);
const SvgHiddenIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$B,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$A = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 21 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M11.506 14.123v-3.574a.44.44 0 0 0-.463-.463H8.811a.44.44 0 0 0-.469.463v3.574h3.164Zm-6.996.164V10.14l5.039-4.23c.254-.212.506-.212.756 0l5.033 4.23v4.148c0 .45-.139.803-.416 1.06-.274.262-.645.393-1.113.393H6.045c-.473 0-.848-.13-1.125-.392-.274-.258-.41-.612-.41-1.06ZM2.494 8.955c0-.23.102-.432.305-.603l6.105-5.127c.313-.262.655-.393 1.026-.393.375 0 .716.13 1.025.393l6.1 5.12c.199.169.299.376.299.622a.664.664 0 0 1-.217.521.775.775 0 0 1-.545.194.747.747 0 0 1-.317-.07 1.508 1.508 0 0 1-.287-.188l-5.73-4.81a.502.502 0 0 0-.328-.135.496.496 0 0 0-.323.134l-5.742 4.81a1.51 1.51 0 0 1-.287.188.747.747 0 0 1-.316.07c-.235 0-.422-.068-.563-.204a.719.719 0 0 1-.205-.522ZM13.41 5.773V4.391c0-.137.041-.246.123-.329a.464.464 0 0 1 .334-.123h1.078c.137 0 .246.041.328.123a.443.443 0 0 1 .123.329v3.04L13.41 5.774Z"
      }
    )
  }
);
const SvgHomeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$A,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$z = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", d: "M2.5 2.5h3.571v3.571H2.5z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          stroke: "currentColor",
          d: "M8.214 2.5h3.571v3.571H8.214z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          d: "M13.929 2.5H17.5v3.571h-3.571zM2.5 8.214h3.571v3.571H2.5zM8.214 8.214h3.571v3.571H8.214z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          stroke: "currentColor",
          d: "M13.929 8.214H17.5v3.571h-3.571zM2.5 13.929h3.571V17.5H2.5z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          d: "M8.214 13.929h3.571V17.5H8.214zM13.929 13.929H17.5V17.5h-3.571z"
        }
      )
    ]
  }
);
const SvgIndexerIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$z,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$y = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M9.214 1.588c.615 0 1.192.116 1.73.349a4.424 4.424 0 0 1 1.428.957c.41.405.73.88.957 1.421.232.538.349 1.115.349 1.73 0 .925-.276 1.764-.827 2.516-.547.747-1.333 1.337-2.359 1.77l1.695 1.702c.096.1.144.212.144.335a.428.428 0 0 1-.137.328l-1.743 1.737 1.251 1.237a.462.462 0 0 1 .137.328.435.435 0 0 1-.137.335l-2.16 2.16a.395.395 0 0 1-.321.123.446.446 0 0 1-.294-.123l-1.183-1.155a.749.749 0 0 1-.164-.24.748.748 0 0 1-.048-.273v-6.63a4.503 4.503 0 0 1-1.483-.971 4.47 4.47 0 0 1-1.306-3.179 4.404 4.404 0 0 1 1.299-3.158c.41-.41.884-.73 1.422-.957a4.471 4.471 0 0 1 1.75-.342Zm0 4.15c.328 0 .61-.117.848-.35.237-.236.355-.521.355-.854 0-.328-.118-.61-.355-.847a1.157 1.157 0 0 0-.848-.356 1.15 1.15 0 0 0-.855.356 1.154 1.154 0 0 0-.348.847c0 .333.116.618.348.855.237.232.522.348.855.348Z"
      }
    )
  }
);
const SvgKeyIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$y,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$x = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeWidth: 1.5,
          d: "M10.906 8.966c1.459 1.316 1.459 3.45 0 4.765l-2.53 2.282c-1.459 1.316-3.824 1.316-5.282 0-1.459-1.315-1.459-3.449 0-4.764l1.265-1.142"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeWidth: 1.5,
          d: "M8.094 11c-1.459-1.316-1.459-3.449 0-4.765l2.53-2.282c1.459-1.316 3.823-1.316 5.282 0s1.459 3.449 0 4.765l-1.265 1.14"
        }
      )
    ]
  }
);
const SvgLinkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$x,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$w = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M2 6a2 2 0 0 1 2-2h12a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2ZM2 14a2 2 0 0 1 2-2h12a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2Z"
      }
    )
  }
);
const SvgListIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$w,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$v = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m17 7.862-1.78-4.45H4.78L3 7.862v.08c0 .34.099.841.407 1.27.113.155.25.298.417.419v6.957h12.353V9.631a1.85 1.85 0 0 0 .416-.42A2.25 2.25 0 0 0 17 7.941v-.08Zm-1.647 2.105a2.489 2.489 0 0 1-.412.033c-.789 0-1.323-.336-1.647-.782-.324.446-.858.782-1.647.782-.79 0-1.323-.336-1.647-.782-.324.446-.858.782-1.647.782-.79 0-1.323-.336-1.647-.782-.324.446-.858.782-1.647.782a2.49 2.49 0 0 1-.412-.033v3.431h10.706V9.968ZM13.706 7.94c0 .209.066.53.252.789.17.237.459.446.983.446.525 0 .813-.209.984-.446.165-.23.235-.51.249-.716l-.03-.073h-2.438Zm.956-3.706 1.153 2.883h-2.19l-.641-2.883h1.678Zm-1.881 2.883-.64-2.883h-1.73v2.883h2.37Zm-5.562 0 .64-2.883h1.73v2.883h-2.37Zm-.203-2.883-.64 2.883H4.185l1.153-2.883h1.678Zm-3.19 3.78.03-.074h2.438c0 .209-.066.53-.252.789-.17.237-.459.446-.983.446-.525 0-.813-.209-.984-.446a1.431 1.431 0 0 1-.249-.716Zm5.51.715a1.43 1.43 0 0 0 .252-.789h-2.47c0 .209.066.53.251.789.171.237.46.446.984.446.525 0 .813-.209.983-.446Zm3.294 0c.186-.258.252-.58.252-.789h-2.47c0 .209.066.53.252.789.17.237.458.446.983.446.525 0 .813-.209.983-.446Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgMarketplacesIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$v,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$u = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M4.868 6.582h11.1v1.5h-11.1v-1.5Zm0 3.377h11.1v1.5h-11.1v-1.5Zm11.1 3.377h-11.1v1.5h11.1v-1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgMenuIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$u,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$t = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M3.362 5.144 7.874 2.54l4.089 7.083-4.512 2.605z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.5, d: "m9.92 6.08 7.332-4.233" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M3.977 15.387 2 13.41h13.615l-.723 1.977h-1.346c-.33 0-.989.198-.989.989 0 .79.66.988.989.988h.597v1.483h-8.83v-1.483H6.41c.79 0 .988-.659.988-.988 0-.33-.198-.989-.988-.989H3.977Z"
        }
      )
    ]
  }
);
const SvgMinterIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$t,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$s = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M15.918 14.994v.752A7.003 7.003 0 0 1 6.968 5.05a7.003 7.003 0 0 1 8.95-.796v.752a4.979 4.979 0 0 0-3.293 1.459 5 5 0 0 0 3.293 8.53Zm-4.353-.398c.329.329.684.615 1.059.859a5.5 5.5 0 1 1 0-10.91 6.5 6.5 0 0 0-1.06 10.051Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgMoonIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$s,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$r = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M13.283 6.175a4.643 4.643 0 1 0-6.566 6.567l-.708.707a5.644 5.644 0 1 1 7.982 0l-.708-.707a4.644 4.644 0 0 0 0-6.567Zm-5.097 1.47a2.565 2.565 0 0 1 3.628 3.627l.707.707a3.565 3.565 0 1 0-5.042 0l.707-.707a2.565 2.565 0 0 1 0-3.627ZM10 10.959a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Zm0 .667-1.5 6h3l-1.5-6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgNetworkIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$r,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$q = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        stroke: "currentColor",
        strokeWidth: 1.5,
        d: "M16 6.5 10 3 4 6.5m12 0v7L10 17m6-10.5L10 10m0 7-6-3.5v-7M10 17v-7M4 6.5l6 3.5"
      }
    )
  }
);
const SvgNodeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$q,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$p = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.899 5.261a1 1 0 0 1 1 1v.729H2.102v2.055h15.797v4.694a1 1 0 0 1-1 1H3.102a1 1 0 0 1-1-1V6.261a1 1 0 0 1 1-1h13.797Zm-7.13 7.284h7v1h-7v-1Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgPaymentsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$p,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$o = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M11.882 15.626a2.896 2.896 0 0 0 .241-3.821l3.896-5.009.957.957L18 6.73 13.27 2l-1.024 1.024.958.957-5.009 3.896a2.896 2.896 0 0 0-3.82.242l7.507 7.507ZM3.536 15.44C2.716 16.26 2.17 17.489 2 18c.512-.17 1.74-.717 2.56-1.536l3.129-3.13-1.024-1.023-3.13 3.13Z"
      }
    )
  }
);
const SvgPinIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$o,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$n = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: 10, cy: 7.361, r: 3.361, fill: "currentColor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M16 16.755H4c.029-2.705 2.704-4.89 6-4.89s5.971 2.185 6 4.89Z",
          clipRule: "evenodd"
        }
      )
    ]
  }
);
const SvgProfileIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$n,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$m = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M6.418 3.6h-2.5v2.5h2.5V3.6Zm0-1.5h1.5v5.5h-5.5V2.1h4Zm0 12h-2.5v2.5h2.5v-2.5Zm0-1.5h1.5v5.5h-5.5v-5.5h4Zm8-9h2.5v2.5h-2.5V3.6Zm4-1.5h-5.5v5.5h5.5V2.1Zm-1.5 12h-2.5v2.5h2.5v-2.5Zm0-1.5h1.5v5.5h-5.5v-5.5h4ZM9.668 2.1v7.25h-7.25v1.5h8.75V2.1h-1.5Zm1.5 10.5v5.5h-1.5v-5.5h1.5Zm1.75-1.75h5.5v-1.5h-5.5v1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgQrCodeIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$m,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$l = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M3.668 11.418v5.75h13.5v-5.75h-1.5v4.25h-10.5v-4.25h-1.5Zm11.28-2.47-1.06-1.06-2.72 2.72v-8.19h-1.5v8.19l-2.72-2.72-1.06 1.06 4.53 4.53 4.53-4.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgReceiveIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$l,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$k = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M2 10.046 3.975 3l1.864 2.016a7.458 7.458 0 1 1-2.586 7.787l1.762-.354.03.099a5.666 5.666 0 1 0 2.017-6.211l2.117 2.289L2 10.046Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgRefreshIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$k,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$j = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M16.365 2.635a2.17 2.17 0 1 1-3.068 3.068 2.17 2.17 0 0 1 3.068-3.068ZM6.788 14.008a2.17 2.17 0 1 1-3.067 3.067 2.17 2.17 0 0 1 3.067-3.067Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          stroke: "currentColor",
          strokeWidth: 1.5,
          d: "M10.736 4.015h-2.08c-2.763 0-3.498 1.274-3.498 3.498v4.44"
        }
      )
    ]
  }
);
const SvgRelayerIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$j,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$i = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M2.418 7h1.5V3.5h3.5V2h-5v5Zm11-5v1.5h3.5V7h1.5V2h-5Zm-9.5 11h-1.5v5h5v-1.5h-3.5V13Zm9.5 5v-1.5h3.5V13h1.5v5h-5Zm-3.75-4v-3.25h-3.25v-1.5h3.25V6h1.5v3.25h3.25v1.5h-3.25V14h-1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgScanIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$i,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$h = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M13.918 9.5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-.677 4.383a5.5 5.5 0 1 1 1.06-1.06l2.648 2.647-1.061 1.06-2.647-2.647Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSearchIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$h,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$g = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M11.529 15.925 9.419 11 4.493 8.89 2.418 8l2.142-.714 11.08-3.693L17.418 3l-.593 1.779-3.693 11.08L12.418 18l-.89-2.075Zm-1.71-6.386L6.635 8.175l6.82-2.273-3.638 3.637Zm1.06 1.061 1.364 3.183 2.273-6.82L10.88 10.6Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSendIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$g,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$f = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M2.418 6.374v7.252c0 1.48 1.218 2.68 2.72 2.68h10.56c1.503 0 2.72-1.2 2.72-2.68V6.374c0-1.48-1.217-2.68-2.72-2.68H5.138c-1.502 0-2.72 1.2-2.72 2.68Zm4 .473a.794.794 0 0 0-.8-.789c-.442 0-.8.353-.8.789 0 .435.359.788.8.788.442 0 .8-.353.8-.788Zm-.8 5.513c.442 0 .8.353.8.788a.794.794 0 0 1-.8.789.794.794 0 0 1-.8-.789c0-.435.359-.788.8-.788Zm10.4-2.36a.794.794 0 0 0-.8-.788c-.441 0-.8.353-.8.788 0 .435.359.788.8.788.442 0 .8-.353.8-.788Zm-7.2-3.942h6.4c.442 0 .8.353.8.789a.794.794 0 0 1-.8.788h-6.4a.794.794 0 0 1-.8-.788c0-.436.359-.789.8-.789Zm6.4 6.302h-6.4c-.441 0-.8.353-.8.788 0 .436.359.789.8.789h6.4c.442 0 .8-.353.8-.789a.794.794 0 0 0-.8-.788Zm-9.6-3.148h6.4c.442 0 .8.353.8.788a.794.794 0 0 1-.8.788h-6.4a.794.794 0 0 1-.8-.788c0-.435.359-.788.8-.788Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSequenceIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$f,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$e = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M12.775 5.204a5.465 5.465 0 0 0-1.341-.537L11 2.5H9l-.443 2.214c-.444.128-.866.31-1.257.54L5.404 3.99 3.99 5.404l1.283 1.925c-.212.38-.38.787-.497 1.216L2.5 9v2l2.276.455c.118.429.285.836.497 1.216L3.99 14.596l1.414 1.414L7.3 14.746c.391.23.813.412 1.257.54L9 17.5h2l.434-2.167c.474-.12.925-.302 1.341-.537l1.821 1.214 1.414-1.414-1.195-1.793c.253-.427.45-.891.581-1.382L17.5 11V9l-2.104-.42a5.467 5.467 0 0 0-.581-1.383l1.195-1.793-1.414-1.414-1.82 1.214Zm-.59 2.692a2.976 2.976 0 1 0-4.208 4.208 2.976 2.976 0 0 0 4.209-4.208Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSettingsIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$e,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$d = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M4 6.234a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5V10.5L14 9v5.734a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h5.769l-1.516 1.5H4Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.25, d: "M11 3h5v5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: 1.5, d: "m16 3-8 8" })
    ]
  }
);
const SvgShareIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$d,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$c = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M15.668 3.959h-10.5v6.75c0 1.653.47 3.021 1.358 4.141.877 1.106 2.123 1.92 3.598 2.549l.294.125.295-.125c1.474-.63 2.72-1.443 3.598-2.549.888-1.12 1.357-2.488 1.357-4.141v-6.75Zm-9 6.75v-5.25h3.75v10.43c-1.191-.544-2.097-1.19-2.717-1.971-.658-.83-1.033-1.862-1.033-3.209Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgShieldIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$c,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$b = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M9.418 3.25h-5.75v13.5h5.75v-1.5h-4.25V4.75h4.25v-1.5Zm4.53 11.28-1.06-1.06 2.72-2.72h-8.19v-1.5h8.19l-2.72-2.72 1.06-1.06L18.48 10l-4.53 4.53Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSignoutIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$b,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$a = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M16.539 10.75H4.298v-1.5h12.24v1.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSubtractIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$a,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$9 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M4.633 10.75a5.878 5.878 0 0 1 .008-1.5H2.202v1.5h2.431ZM5.814 6.456A5.854 5.854 0 0 1 6.88 5.401L5.139 3.66l-1.06 1.06 1.735 1.736ZM4.078 15.28l1.711-1.711c.306.398.662.755 1.058 1.063L5.14 16.34l-1.06-1.06ZM9.668 15.802v2.414h1.5V15.8a5.876 5.876 0 0 1-1.5.003ZM13.98 14.623l1.718 1.717 1.06-1.06-1.721-1.723c-.305.4-.66.758-1.056 1.066ZM16.184 10.75h2.45v-1.5h-2.457a5.882 5.882 0 0 1 .007 1.5ZM15.012 6.467l1.747-1.747-1.061-1.06-1.75 1.75c.399.305.756.66 1.064 1.057ZM11.168 4.258V1.784h-1.5v2.472a5.875 5.875 0 0 1 1.5.002Z"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M10.418 12.504a2.504 2.504 0 1 0 0-5.008 2.504 2.504 0 0 0 0 5.008Zm0 1.5a4.004 4.004 0 1 0 0-8.008 4.004 4.004 0 0 0 0 8.008Z",
          clipRule: "evenodd"
        }
      )
    ]
  }
);
const SvgSunIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$9,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$8 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M14.668 4.75h-5.25v-1.5h6.75V12h2.25l-1.125 1.5-.937 1.25-.938 1.25-.937-1.25-.938-1.25-1.125-1.5h2.25V4.75ZM5.418 4l.938 1.25.937 1.25L8.418 8h-2.25v7.25h5.25v1.5h-6.75V8h-2.25l1.125-1.5.938-1.25L5.418 4Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgSwapIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$8,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$7 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m12.28 2.856-6.71 8.887h4.134l-1.424 6.2 6.887-8.71h-4.322l1.435-6.377Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgTransactionIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$7,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$6 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M7.271 3.521c-.376.377-.521.902-.521 1.479H3v1h14V5h-3.75c0-.577-.145-1.102-.521-1.479C12.352 3.145 11.827 3 11.25 3h-2.5c-.577 0-1.102.145-1.479.521Zm.708.708c-.124.123-.229.348-.229.771h4.5c0-.423-.105-.648-.229-.771-.123-.124-.348-.229-.771-.229h-2.5c-.423 0-.648.105-.771.229ZM5.5 18l-1-11h11l-1 11h-9Zm7.58-10.006a.5.5 0 0 1 .47.53l-.489 8.022a.5.5 0 0 1-.998-.061l.488-8.022a.5.5 0 0 1 .53-.47Zm-6.629.53a.5.5 0 0 1 .998-.061l.488 8.022a.5.5 0 0 1-.998.06L6.45 8.524ZM10 7.993a.5.5 0 0 1 .5.5v8.021a.5.5 0 0 1-1 0v-8.02a.5.5 0 0 1 .5-.5Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgTrashIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$6,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$5 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "m4.662 2.789-.985 2.515v10.281h3.5v1.86h1.97l1.859-1.86h2.844l3.827-3.828V2.79H4.662ZM16.365 11.1l-2.188 2.187h-3.5l-1.86 1.86v-1.86H5.866V4.101h10.5v7Zm-2.188-4.484v3.828h-1.312V6.617h1.312Zm-3.5 0v3.828H9.365V6.617h1.312Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgTwitchIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$5,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$4 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M4 11.444v5.112h12v-5.112h-1.333v3.778H5.333v-3.777H4Zm1.973-3.973.943.943 2.418-2.417v7.28h1.333v-7.28l2.417 2.417.943-.943L10 3.444 5.973 7.471Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgUploadIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$4,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$3 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          fillRule: "evenodd",
          d: "M3.103 10.154C4.59 12.077 7.11 13.366 10 13.366c2.89 0 5.41-1.29 6.897-3.212C15.41 8.232 12.89 6.942 10 6.942c-2.89 0-5.41 1.29-6.897 3.212Zm-1.548-.416C3.285 7.145 6.436 5.442 10 5.442s6.716 1.703 8.445 4.296l.277.416-.277.416c-1.73 2.594-4.881 4.296-8.445 4.296s-6.716-1.702-8.445-4.296l-.277-.416.277-.416Z",
          clipRule: "evenodd"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          d: "M12.386 10.154a2.386 2.386 0 1 1-4.772 0 2.386 2.386 0 0 1 4.772 0Z"
        }
      )
    ]
  }
);
const SvgVisibleIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$3,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$2 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 480 332",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        d: "M126.613 93.984c62.622-61.312 164.152-61.312 226.775 0l7.536 7.379a7.735 7.735 0 0 1 0 11.102l-25.781 25.242a4.07 4.07 0 0 1-5.67 0l-10.371-10.154c-43.687-42.773-114.517-42.773-158.204 0l-11.107 10.874a4.069 4.069 0 0 1-5.669 0l-25.781-25.242a7.733 7.733 0 0 1 0-11.102zm280.093 52.204 22.946 22.465a7.735 7.735 0 0 1 0 11.102L326.189 281.056c-3.131 3.065-8.208 3.065-11.339 0l-73.432-71.896a2.034 2.034 0 0 0-2.835 0l-73.43 71.896c-3.131 3.065-8.208 3.065-11.339 0L50.348 179.754a7.735 7.735 0 0 1 0-11.102l22.946-22.466c3.131-3.065 8.208-3.065 11.339 0l73.433 71.897a2.033 2.033 0 0 0 2.834 0l73.429-71.897c3.131-3.065 8.208-3.065 11.339 0l73.433 71.897a2.034 2.034 0 0 0 2.835 0l73.431-71.895c3.132-3.066 8.208-3.066 11.339 0z"
      }
    )
  }
);
const SvgWalletConnectIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$2,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M5 6.05c0 .443.39.802.87.802H17V16H5.495C4.117 16 3 14.97 3 13.698V6.302C3 5.031 4.117 4 5.495 4H14.5v1.247H5.87c-.48 0-.87.36-.87.802Zm7 5.45a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgWalletIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg$1,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
const Svg = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 20 20",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: "currentColor",
        fillRule: "evenodd",
        d: "M18 16.427 10 2.57 2 16.427h16Zm-7.322-4.333v-5.77H9.216v5.77h1.462Zm-.731 3.087a1.089 1.089 0 1 0 0-2.178 1.089 1.089 0 0 0 0 2.178Z",
        clipRule: "evenodd"
      }
    )
  }
);
const SvgWarningIcon = ({ size: size2 = "sm", ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    as: Svg,
    className: iconVariants({
      size: size2
    }),
    ...props
  }
);
var checkboxVariants = createRuntimeFn({ defaultClassName: "_1c9x66f1 _1c9x66f0 fyvr11eg fyvr11es fyvr11f4 fyvr11fg fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr12rl fyvr12k9 fyvr125l fyvr12cx fyvr12rr fyvr12kf fyvr125r fyvr12d3 fyvr11l8 fyvr11ow fyvr11no fyvr11sl fyvr1309 fyvr1307 fyvr12zz fyvr12zf fyvr12zb _4efw240", variantClassNames: { size: { sm: "_1c9x66f2", lg: "_1c9x66f3" } }, defaultVariants: {}, compoundVariants: [] });
var indicator$1 = "_1c9x66f4 fyvr12w9 fyvr11l8 fyvr11ow fyvr11no fyvr12g fyvr164";
const Indicator$1 = ({ size: size2 = "sm" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$2, { className: indicator$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, { size: size2 === "lg" ? "sm" : "xs" }) });
const Checkbox = React.forwardRef(
  (props, ref) => {
    const {
      disabled = false,
      id,
      name,
      label = "",
      labelLocation = "left",
      size: size2 = "sm",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field,
      {
        disabled,
        display: "flex",
        id: id ?? name,
        label,
        labelLocation,
        whiteSpace: "nowrap",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$8,
          {
            className: checkboxVariants({ size: size2 }),
            disabled,
            id: id ?? name,
            name,
            ref,
            ...rest,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator$1, { size: size2 })
          }
        )
      }
    );
  }
);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
const isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject(data))) {
    copy = isArray ? [] : {};
    if (!isArray && !isPlainObject(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get$1 = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input2) => compact(input2.replace(/["|']|\]/g, "").split(/\.|\[/));
var set = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const HookFormContext = React.createContext(null);
const useFormContext = () => React.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = React.useRef(props);
  _props.current = props;
  React.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _mounted = React.useRef(true);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: (value) => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value
    }),
    subject: control._subjects.state
  });
  React.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return getProxyFormState(formState, control, _localProxyFormState.current, false);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get$1(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get$1(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = React.useState(control._getWatch(name, defaultValue));
  React.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get$1(control._formValues, name, get$1(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _registerProps = React.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  React.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name2, value2) => {
      const field = get$1(control._fields, name2);
      if (field && field._f) {
        field._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get$1(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get$1(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React.useEffect(() => {
    if (get$1(control._fields, name)) {
      control._updateDisabledField({
        disabled,
        fields: control._fields,
        name,
        value: get$1(control._fields, name)._f.value
      });
    }
  }, [disabled, name, control]);
  return {
    field: {
      name,
      value,
      ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
      onChange: React.useCallback((event) => _registerProps.current.onChange({
        target: {
          value: getEventValue(event),
          name
        },
        type: EVENTS.CHANGE
      }), [name]),
      onBlur: React.useCallback(() => _registerProps.current.onBlur({
        target: {
          value: get$1(control._formValues, name),
          name
        },
        type: EVENTS.BLUR
      }), [name, control]),
      ref: React.useCallback((elm) => {
        const field = get$1(control._fields, name);
        if (field && elm) {
          field._f.ref = {
            focus: () => elm.focus(),
            select: () => elm.select(),
            setCustomValidity: (message) => elm.setCustomValidity(message),
            reportValidity: () => elm.reportValidity()
          };
        }
      }, [control._fields, name])
    },
    formState,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: true,
        get: () => !!get$1(formState.errors, name)
      },
      isDirty: {
        enumerable: true,
        get: () => !!get$1(formState.dirtyFields, name)
      },
      isTouched: {
        enumerable: true,
        get: () => !!get$1(formState.touchedFields, name)
      },
      isValidating: {
        enumerable: true,
        get: () => !!get$1(formState.validatingFields, name)
      },
      error: {
        enumerable: true,
        get: () => get$1(formState.errors, name)
      }
    })
  };
}
const Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message || true
  }
} : {};
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get$1(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get$1(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement$2 = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value) => isString(value);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value) => value instanceof RegExp;
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;
  const inputValue = get$1(formValues, name);
  if (!mount || disabled) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement$2(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index2 = paths.length - 1;
  const key = paths[index2];
  if (childObject) {
    delete childObject[key];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var createSubject = () => {
  let _observers = [];
  const next = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o) => o !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual$1(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual$1(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement$2(ref) && ref.isConnected;
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual$1(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (_f.refs ? _f.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get$1(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
const ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => (!fieldReference || !fieldReference.validate) && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get$1(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get$1(_fields, fieldName);
    const foundError = get$1(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get$1(ref, name)).length && unset(ref, name);
const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (_proxyFormState.isValid || shouldUpdateValid) {
      const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid !== _formState.isValid) {
        _subjects.state.next({
          isValid
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (_proxyFormState.isValidating || _proxyFormState.validatingFields) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get$1(_fields, name))) {
        const fieldValues = method(get$1(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get$1(_formState.errors, name))) {
        const errors = method(get$1(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get$1(_formState.touchedFields, name))) {
        const touchedFields = method(get$1(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get$1(_fields, name);
    if (field) {
      const defaultValue = get$1(_formValues, name, isUndefined(value) ? get$1(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    const disabledField = !!(get$1(_fields, name) && get$1(_fields, name)._f && get$1(_fields, name)._f.disabled);
    if (!isBlurEvent || shouldDirty) {
      if (_proxyFormState.isDirty) {
        isPreviousDirty = _formState.isDirty;
        _formState.isDirty = output.isDirty = _getDirty();
        shouldUpdateField = isPreviousDirty !== output.isDirty;
      }
      const isCurrentFieldPristine = disabledField || deepEqual$1(get$1(_defaultValues, name), fieldValue);
      isPreviousDirty = !!(!disabledField && get$1(_formState.dirtyFields, name));
      isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
    }
    if (isBlurEvent) {
      const isPreviousFieldTouched = get$1(_formState.touchedFields, name);
      if (!isPreviousFieldTouched) {
        set(_formState.touchedFields, name, isBlurEvent);
        output.touchedFields = _formState.touchedFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
      }
    }
    shouldUpdateField && shouldRender && _subjects.state.next(output);
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid, error, fieldState) => {
    const previousFieldError = get$1(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;
    if (props.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual$1(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid) ? { isValid } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema(names);
    if (names) {
      for (const name of names) {
        const error = get$1(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get$1(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get$1(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => (name && data && set(_formValues, name, data), !deepEqual$1(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get$1(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get$1(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get$1(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement$2(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger2(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get$1(_fields, fieldName);
      (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get$1(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name : void 0,
      values: { ..._formValues }
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get$1(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || deepEqual$1(fieldValue, get$1(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get$1(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get$1(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (props.mode === "onBlur") {
            if (isBlurEvent) {
              _updateValid();
            }
          } else {
            _updateValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid = false;
          } else if (_proxyFormState.isValid) {
            isValid = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger2(field._f.deps);
        shouldRenderByError(name, isValid, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get$1(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger2 = async (name, options = {}) => {
    let isValid;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get$1(errors, name2)) : isValid;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get$1(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get$1(values, fieldNames) : fieldNames.map((name) => get$1(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get$1((formState || _formState).errors, name),
    isDirty: !!get$1((formState || _formState).dirtyFields, name),
    error: get$1((formState || _formState).errors, name),
    isValidating: !!get$1(_formState.validatingFields, name),
    isTouched: !!get$1((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get$1(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get$1(_formState.errors, name) || {};
    const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = ({ disabled, name, field, fields, value }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled) {
      const inputValue = disabled ? void 0 : isUndefined(value) ? getFieldValue(field ? field._f : get$1(fields, name)._f) : value;
      set(_formValues, name, inputValue);
      updateTouchAndDirty(name, inputValue, false, false, true);
    }
  };
  const register = (name, options = {}) => {
    let field = get$1(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(props.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
        name,
        value: options.value
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || props.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get$1(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get$1(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get$1(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get$1(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e) => {
    let onValidError = void 0;
    if (e) {
      e.preventDefault && e.preventDefault();
      e.persist && e.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get$1(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get$1(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get$1(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        for (const fieldName of _names.mount) {
          get$1(_formState.dirtyFields, fieldName) ? set(values, fieldName, get$1(_formValues, fieldName)) : setValue(fieldName, get$1(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get$1(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement$2(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.values.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual$1(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset2 = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get$1(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset2(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger: trigger2,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset: reset2,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef();
  const _values = React.useRef();
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  React.useEffect(() => {
    if (props.values && !deepEqual$1(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  React.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  React.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  React.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
const ControlledCheckbox = ({
  control,
  defaultChecked,
  onCheckedChange,
  name,
  rules,
  ...checkboxProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue: defaultChecked,
    name,
    control,
    rules,
    render: ({ field: { ref: _, ...fieldProps } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        onCheckedChange,
        defaultChecked,
        ...fieldProps,
        ...checkboxProps
      }
    )
  }
);
var useReactId = React__namespace["useId".toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id, setId] = React__namespace.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}
var COLLAPSIBLE_NAME = "Collapsible";
var [createCollapsibleContext, createCollapsibleScope] = createContextScope(COLLAPSIBLE_NAME);
var [CollapsibleProvider, useCollapsibleContext] = createCollapsibleContext(COLLAPSIBLE_NAME);
var Collapsible$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCollapsible,
      open: openProp,
      defaultOpen,
      disabled,
      onOpenChange,
      ...collapsibleProps
    } = props;
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollapsibleProvider,
      {
        scope: __scopeCollapsible,
        disabled,
        contentId: useId(),
        open,
        onOpenToggle: React__namespace.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-state": getState$3(open),
            "data-disabled": disabled ? "" : void 0,
            ...collapsibleProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Collapsible$1.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$5 = "CollapsibleTrigger";
var CollapsibleTrigger = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = useCollapsibleContext(TRIGGER_NAME$5, __scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-controls": context.contentId,
        "aria-expanded": context.open || false,
        "data-state": getState$3(context.open),
        "data-disabled": context.disabled ? "" : void 0,
        disabled: context.disabled,
        ...triggerProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
CollapsibleTrigger.displayName = TRIGGER_NAME$5;
var CONTENT_NAME$7 = "CollapsibleContent";
var CollapsibleContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = useCollapsibleContext(CONTENT_NAME$7, props.__scopeCollapsible);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentImpl, { ...contentProps, ref: forwardedRef, present }) });
  }
);
CollapsibleContent.displayName = CONTENT_NAME$7;
var CollapsibleContentImpl = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeCollapsible, present, children, ...contentProps } = props;
  const context = useCollapsibleContext(CONTENT_NAME$7, __scopeCollapsible);
  const [isPresent, setIsPresent] = React__namespace.useState(present);
  const ref = React__namespace.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const heightRef = React__namespace.useRef(0);
  const height = heightRef.current;
  const widthRef = React__namespace.useRef(0);
  const width = widthRef.current;
  const isOpen = context.open || isPresent;
  const isMountAnimationPreventedRef = React__namespace.useRef(isOpen);
  const originalStylesRef = React__namespace.useRef();
  React__namespace.useEffect(() => {
    const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
    return () => cancelAnimationFrame(rAF);
  }, []);
  useLayoutEffect2(() => {
    const node = ref.current;
    if (node) {
      originalStylesRef.current = originalStylesRef.current || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      heightRef.current = rect.height;
      widthRef.current = rect.width;
      if (!isMountAnimationPreventedRef.current) {
        node.style.transitionDuration = originalStylesRef.current.transitionDuration;
        node.style.animationName = originalStylesRef.current.animationName;
      }
      setIsPresent(present);
    }
  }, [context.open, present]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-state": getState$3(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen,
      ...contentProps,
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      },
      children: isOpen && children
    }
  );
});
function getState$3(open) {
  return open ? "open" : "closed";
}
var Root$7 = Collapsible$1;
var Trigger$5 = CollapsibleTrigger;
var Content$3 = CollapsibleContent;
const index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Collapsible: Collapsible$1,
  CollapsibleContent,
  CollapsibleTrigger,
  Content: Content$3,
  Root: Root$7,
  Trigger: Trigger$5,
  createCollapsibleScope
}, Symbol.toStringTag, { value: "Module" }));
var COLLAPSED_HEIGHT = "64px";
var root$4 = "_4j62fl0";
var trigger$1 = "_4j62fl2 _4j62fl1 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr11l8 fyvr11ow fyvr11sl fyvr12g fyvr12zf fyvr11rc _4efw240";
var content$3 = "_4j62fl4 _4j62fl3 fyvr1zk fyvr111o fyvr1uw fyvr1xg fyvr12g";
var icon = "_4j62fl5";
const Collapsible = (props) => {
  const {
    className,
    children,
    defaultOpen,
    open,
    onOpenChange,
    label,
    ...rest
  } = props;
  const [expanded, toggleExpanded] = React.useState(defaultOpen);
  const isOpen = open ?? expanded;
  const handleSetExpanded = (isExpanded) => {
    if (open !== void 0) {
      return;
    }
    toggleExpanded(isExpanded);
  };
  const handleOpenChange = (isOpen2) => {
    handleSetExpanded(isOpen2);
    onOpenChange == null ? void 0 : onOpenChange(isOpen2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root$7,
    {
      open: isOpen,
      defaultOpen,
      onOpenChange: handleOpenChange,
      asChild: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          as: framerMotion.motion.div,
          className: clsx(className, root$4),
          initial: { height: isOpen ? "auto" : COLLAPSED_HEIGHT },
          animate: { height: isOpen ? "auto" : COLLAPSED_HEIGHT },
          transition: { ease: "easeOut", duration: 0.3 },
          borderRadius: "md",
          background: "backgroundSecondary",
          position: "relative",
          overflow: "hidden",
          width: "full",
          ...rest,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Trigger$5, { className: trigger$1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { as: "div", variant: "normal", fontWeight: "bold", color: "text80", children: label }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  as: framerMotion.motion.div,
                  position: "absolute",
                  right: "0",
                  marginRight: "4",
                  initial: { rotate: isOpen ? 180 : 0 },
                  animate: { rotate: isOpen ? 180 : 0 },
                  transition: { ease: "linear", duration: 0.1 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgChevronDownIcon, { className: icon, color: "text50" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(framerMotion.AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content$3,
              {
                className: content$3,
                asChild: true,
                forceMount: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  framerMotion.motion.div,
                  {
                    initial: { opacity: isOpen ? 1 : 0 },
                    animate: { opacity: 1 },
                    exit: { opacity: 0 },
                    transition: { ease: "easeOut", duration: 0.3 },
                    children
                  }
                )
              }
            ) })
          ]
        }
      )
    }
  );
};
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = React__namespace.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React__namespace.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React__namespace.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React__namespace.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React__namespace.useContext(DismissableLayerContext);
    const [node, setNode] = React__namespace.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React__namespace.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React__namespace.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React__namespace.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React__namespace.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React__namespace.forwardRef((props, forwardedRef) => {
  const context = React__namespace.useContext(DismissableLayerContext);
  const ref = React__namespace.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React__namespace.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React__namespace.useRef(false);
  const handleClickRef = React__namespace.useRef(() => {
  });
  React__namespace.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React__namespace.useRef(false);
  React__namespace.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$6 = DismissableLayer;
var Branch = DismissableLayerBranch;
var count = 0;
function useFocusGuards() {
  React__namespace.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React__namespace.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React__namespace.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React__namespace.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React__namespace.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React__namespace.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$3(removeLinks(getTabbableCandidates$1(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React__namespace.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$3(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates$1(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item2) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item2);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item2) => item2.tagName !== "A");
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list2 = list2.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list2 = list2.concat(list2.map(getOppositeAlignmentPlacement));
    }
  }
  return list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$4 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector2) => {
    try {
      return element.matches(selector2);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isTopLayer(currentNode)) {
      return null;
    }
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll2.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll2.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll2 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll2.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll2.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll2.scrollLeft - offsets.x;
  const y = rect.top + scroll2.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$3 = arrow$4;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$4 = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React__namespace.useRef(value);
  index$4(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React__namespace.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React__namespace.useState(null);
  const [_floating, _setFloating] = React__namespace.useState(null);
  const setReference = React__namespace.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React__namespace.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React__namespace.useRef(null);
  const floatingRef = React__namespace.useRef(null);
  const dataRef = React__namespace.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const update = React__namespace.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM__namespace.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$4(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React__namespace.useRef(false);
  index$4(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$4(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React__namespace.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React__namespace.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React__namespace.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React__namespace.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$3({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$3({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow$2 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root$5 = Arrow$1;
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React__namespace.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React__namespace.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$6 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$6);
var PopperContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$6, __scopePopper);
    const [content2, setContent] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow2, setArrow] = React__namespace.useState(null);
    const arrowSize = useSize(arrow2);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle2 = elements.floating.style;
            contentStyle2.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle2.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle2.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle2.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow2 && arrow$2({ element: arrow2, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a = middlewareData.arrow) == null ? void 0 : _a.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React__namespace.useState();
    useLayoutEffect2(() => {
      if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
    }, [content2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$6;
var ARROW_NAME$4 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React__namespace.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$4, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$4;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper;
var Anchor = PopperAnchor;
var Content$2 = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$4 = "Portal";
var Portal$3 = React__namespace.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React__namespace.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$4;
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$3,
  [createCollectionScope$3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = React__namespace.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = React__namespace.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = React__namespace.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$3(__scopeRovingFocusGroup);
  const isClickFocusRef = React__namespace.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = React__namespace.useState(0);
  React__namespace.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: React__namespace.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: React__namespace.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: React__namespace.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: React__namespace.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item2) => item2.focusable);
                const activeItem = items.find((item2) => item2.active);
                const currentItem = items.find((item2) => item2.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item2) => item2.ref.current);
                focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$4 = "RovingFocusGroupItem";
var RovingFocusGroupItem = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$4, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection$3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    React__namespace.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item2) => item2.focusable);
                let candidateNodes = items.map((item2) => item2.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$2(candidateNodes));
              }
            })
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$4;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$2(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root$4 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = React.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React__namespace.useLayoutEffect : React__namespace.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item2 = middleware(data, assigned);
      buffer.push(item2);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item2;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React__namespace.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React__namespace.forwardRef(function(props, parentRef) {
  var ref = React__namespace.useRef(null);
  var _a = React__namespace.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React__namespace.createElement(
    React__namespace.Fragment,
    null,
    enabled && React__namespace.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React__namespace.cloneElement(React__namespace.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React__namespace.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React__namespace.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React__namespace.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React__namespace.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React__namespace.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React__namespace.useRef([]);
  var touchStartRef = React__namespace.useRef([0, 0]);
  var activeAxis = React__namespace.useRef();
  var id = React__namespace.useState(idCounter++)[0];
  var Style2 = React__namespace.useState(styleSingleton)[0];
  var lastProps = React__namespace.useRef(props);
  React__namespace.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React__namespace.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React__namespace.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React__namespace.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React__namespace.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React__namespace.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React__namespace.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React__namespace.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React__namespace.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React__namespace.createElement(
    React__namespace.Fragment,
    null,
    inert ? React__namespace.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React__namespace.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React__namespace.forwardRef(function(props, ref) {
  return React__namespace.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS$1, "ArrowRight"],
  rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope$2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$2 = createPopperScope();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$2(__scopeMenu);
  const [content2, setContent] = React__namespace.useState(null);
  const isUsingKeyboardRef = React__namespace.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  React__namespace.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content: content2,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: React__namespace.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME = "MenuAnchor";
var MenuAnchor = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME;
var PORTAL_NAME$3 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME$3, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$5 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$5);
var MenuContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React__namespace.useEffect(() => {
      const content2 = ref.current;
      if (content2) return hideOthers(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = React__namespace.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var MenuContentImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME$5, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, __scopeMenu);
    const popperScope = usePopperScope$2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const getItems = useCollection$2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = React__namespace.useState(null);
    const contentRef = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = React__namespace.useRef(0);
    const searchRef = React__namespace.useRef("");
    const pointerGraceTimerRef = React__namespace.useRef(0);
    const pointerGraceIntentRef = React__namespace.useRef(null);
    const pointerDirRef = React__namespace.useRef("right");
    const lastPointerXRef = React__namespace.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : React__namespace.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _a, _b;
      const search = searchRef.current + key;
      const items = getItems().filter((item2) => !item2.disabled);
      const currentItem = document.activeElement;
      const currentMatch = (_a = items.find((item2) => item2.ref.current === currentItem)) == null ? void 0 : _a.textValue;
      const values = items.map((item2) => item2.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = (_b = items.find((item2) => item2.textValue === nextMatch)) == null ? void 0 : _b.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    React__namespace.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = React__namespace.useCallback((event) => {
      var _a, _b;
      const isMovingTowards = pointerDirRef.current === ((_a = pointerGraceIntentRef.current) == null ? void 0 : _a.side);
      return isMovingTowards && isPointerInGraceArea(event, (_b = pointerGraceIntentRef.current) == null ? void 0 : _b.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: React__namespace.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: React__namespace.useCallback(
          (event) => {
            var _a;
            if (isPointerMovingToSubmenu(event)) return;
            (_a = contentRef.current) == null ? void 0 : _a.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: React__namespace.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: React__namespace.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              var _a;
              event.preventDefault();
              (_a = contentRef.current) == null ? void 0 : _a.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$4,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content$2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content2 = contentRef.current;
                          if (event.target !== content2) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item2) => !item2.disabled);
                          const candidateNodes = items.map((item2) => item2.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst$1(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$5;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = React__namespace.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$3, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = React__namespace.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect == null ? void 0 : onSelect(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          var _a;
          (_a = props.onPointerDown) == null ? void 0 : _a.call(props, event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          var _a;
          if (!isPointerDownRef.current) (_a = event.currentTarget) == null ? void 0 : _a.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS$1.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$3;
var MenuItemImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = React__namespace.useState(false);
    const [textContent, setTextContent] = React__namespace.useState("");
    React__namespace.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item2 = event.currentTarget;
                    item2.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
var MenuCheckboxItem = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange == null ? void 0 : onCheckedChange(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
var [RadioGroupProvider$1, useRadioGroupContext$1] = createMenuContext(
  RADIO_GROUP_NAME$2,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider$1, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$1 = "MenuRadioItem";
var MenuRadioItem = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext$1(RADIO_ITEM_NAME$1, props.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => {
            var _a;
            return (_a = context.onValueChange) == null ? void 0 : _a.call(context, value);
          },
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME$1,
  { checked: false }
);
var MenuItemIndicator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "MenuSeparator";
var MenuSeparator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$3 = "MenuArrow";
var MenuArrow = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);
  const popperScope = usePopperScope$2(__scopeMenu);
  const [trigger2, setTrigger] = React__namespace.useState(null);
  const [content2, setContent] = React__namespace.useState(null);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  React__namespace.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content: content2,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger: trigger2,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
var MenuSubTrigger = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const openTimerRef = React__namespace.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = React__namespace.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    React__namespace.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    React__namespace.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          var _a;
          (_a = props.onClick) == null ? void 0 : _a.call(props, event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            var _a, _b;
            clearOpenTimer();
            const contentRect = (_a = context.content) == null ? void 0 : _a.getBoundingClientRect();
            if (contentRect) {
              const side = (_b = context.content) == null ? void 0 : _b.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a;
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            (_a = context.content) == null ? void 0 : _a.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent";
var MenuSubContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME$5, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$5, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props.__scopeMenu);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          var _a;
          if (rootContext.isUsingKeyboardRef.current) (_a = ref.current) == null ? void 0 : _a.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          var _a;
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            (_a = subContext.trigger) == null ? void 0 : _a.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$1(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray$1(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2 = MenuAnchor;
var Portal$2 = MenuPortal;
var Content2$3 = MenuContent;
var Group$1 = MenuGroup;
var Label = MenuLabel;
var Item2$2 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup$2 = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator = MenuSeparator;
var Arrow2$2 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = React__namespace.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React__namespace.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$4 = "DropdownMenuTrigger";
var DropdownMenuTrigger$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME$4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger$1.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$2 = "DropdownMenuPortal";
var DropdownMenuPortal$1 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { ...menuScope, ...portalProps });
};
DropdownMenuPortal$1.displayName = PORTAL_NAME$2;
var CONTENT_NAME$4 = "DropdownMenuContent";
var DropdownMenuContent$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME$4, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = React__namespace.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$3,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          if (!hasInteractedOutsideRef.current) (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent$1.displayName = CONTENT_NAME$4;
var GROUP_NAME$1 = "DropdownMenuGroup";
var DropdownMenuGroup = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group$1, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "DropdownMenuLabel";
var DropdownMenuLabel = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$2 = "DropdownMenuItem";
var DropdownMenuItem$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$2, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem$1.displayName = ITEM_NAME$2;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME$1 = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup$2, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup$1.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME$2 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator$1.displayName = INDICATOR_NAME$2;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$2 = "DropdownMenuArrow";
var DropdownMenuArrow$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow$1.displayName = ARROW_NAME$2;
var DropdownMenuSub = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME;
var Root2$4 = DropdownMenu;
var Trigger$4 = DropdownMenuTrigger$1;
var Portal2 = DropdownMenuPortal$1;
var Content2$2 = DropdownMenuContent$1;
var Group2 = DropdownMenuGroup;
var Label2 = DropdownMenuLabel;
var Item2$1 = DropdownMenuItem$1;
var CheckboxItem2 = DropdownMenuCheckboxItem$1;
var RadioGroup2 = DropdownMenuRadioGroup$1;
var RadioItem2 = DropdownMenuRadioItem$1;
var ItemIndicator2 = DropdownMenuItemIndicator$1;
var Separator2 = DropdownMenuSeparator$1;
var Arrow2$1 = DropdownMenuArrow$1;
var Sub2 = DropdownMenuSub;
var SubTrigger2 = DropdownMenuSubTrigger;
var SubContent2 = DropdownMenuSubContent;
const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arrow: Arrow2$1,
  CheckboxItem: CheckboxItem2,
  Content: Content2$2,
  DropdownMenu,
  DropdownMenuArrow: DropdownMenuArrow$1,
  DropdownMenuCheckboxItem: DropdownMenuCheckboxItem$1,
  DropdownMenuContent: DropdownMenuContent$1,
  DropdownMenuGroup,
  DropdownMenuItem: DropdownMenuItem$1,
  DropdownMenuItemIndicator: DropdownMenuItemIndicator$1,
  DropdownMenuLabel,
  DropdownMenuPortal: DropdownMenuPortal$1,
  DropdownMenuRadioGroup: DropdownMenuRadioGroup$1,
  DropdownMenuRadioItem: DropdownMenuRadioItem$1,
  DropdownMenuSeparator: DropdownMenuSeparator$1,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger: DropdownMenuTrigger$1,
  Group: Group2,
  Item: Item2$1,
  ItemIndicator: ItemIndicator2,
  Label: Label2,
  Portal: Portal2,
  RadioGroup: RadioGroup2,
  RadioItem: RadioItem2,
  Root: Root2$4,
  Separator: Separator2,
  Sub: Sub2,
  SubContent: SubContent2,
  SubTrigger: SubTrigger2,
  Trigger: Trigger$4,
  createDropdownMenuScope
}, Symbol.toStringTag, { value: "Module" }));
var content$2 = "_1k2mbvi1 _1k2mbvi0 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr1v4 fyvr1x8 fyvr1zc fyvr111g fyvr11r0 fyvr11xx";
var arrow = "_1k2mbvi2";
var item = "_1k2mbvi4 _1k2mbvi3 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr1zs fyvr111g fyvr1v0 fyvr1x4 fyvr1310 fyvr130u fyvr11l8 fyvr11ow fyvr11o4 fyvr12zf fyvr11rc fyvr11m4 fyvr12wf";
var indicator = "_1k2mbvi5";
var separator = "_1k2mbvi6";
const DropdownMenuRoot = Root2$4;
const DropdownMenuTrigger = Trigger$4;
const DropdownMenuPortal = Portal2;
const DropdownMenuContent = ({
  className,
  children,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2$2,
  {
    className: clsx(content$2, className),
    side: "bottom",
    sideOffset: 4,
    align: "center",
    ...rest,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuArrow, {})
    ]
  }
);
const DropdownMenuArrow = () => /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2$1, { className: arrow });
const DropdownMenuItem = ({
  className,
  children,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Item2$1,
  {
    className: clsx(item, className),
    asChild: true,
    ...rest,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children }) })
  }
);
const DropdownMenuItemIndicator = ({
  children
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: indicator, children });
const DropdownMenuSeparator = () => /* @__PURE__ */ jsxRuntimeExports.jsx(Separator2, { className: separator, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { marginTop: "1", marginBottom: "1" }) });
const DropdownMenuCheckboxItem = React.forwardRef(({ className, children, ...rest }, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CheckboxItem2,
    {
      className: clsx(item, className),
      ...rest,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, { size: "xs" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children })
      ]
    }
  );
});
const DropdownMenuRadioGroup = RadioGroup2;
const DropdownMenuRadioItem = React.forwardRef(({ className, children, ...rest }, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    RadioItem2,
    {
      className: clsx(item, className),
      ...rest,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { className: indicator, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: "•" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", children })
      ]
    }
  );
});
const IconButton = React.forwardRef(
  (props, ref) => {
    const { icon: icon2, size: size2 = "md", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        leftIcon: icon2,
        size: size2,
        flexShrink: "0",
        ref,
        ...rest
      }
    );
  }
);
const useCombinedRefs = (...refs) => (element) => refs.forEach((ref) => {
  if (!ref) {
    return;
  }
  if (typeof ref === "function") {
    ref(element);
  } else {
    ref.current = element;
  }
});
var wrap$1 = "_1hq71vk1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _1hq71vk0 fyvr11eg fyvr11es fyvr11f4 fyvr11fg fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr12rf fyvr12k3 fyvr125f fyvr12cr fyvr12rx fyvr12kl fyvr125x fyvr12d9 fyvr11ow fyvr11lk fyvr11mk fyvr11nk fyvr1h4 fyvr11m4";
var wrapVariants$1 = createRuntimeFn({ defaultClassName: "_1hq71vk5", variantClassNames: { borderRadius: { xs: "_1hq71vk6 _1hq71vk2 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg", sm: "_1hq71vk7 _1hq71vk3 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk", md: "_1hq71vk8 _1hq71vk4 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go" } }, defaultVariants: {}, compoundVariants: [] });
var input$1 = "_1hq71vka _1hq71vk9 fyvr130x fyvr130r fyvr11lw fyvr12zr fyvr1m0 fyvr1qg fyvr1o8 fyvr1so";
const MIME_TYPES = {
  png: ".png,image/png",
  jpeg: ".jpeg,image/jpeg",
  jpg: ".jpg,image/jpg",
  images: "image/*, video/*",
  pdf: ".pdf,application/pdf",
  mp4: ".mp4,video/mp4",
  csv: ".csv,text/csv",
  json: ".json,application/json"
};
const FileInput = React.forwardRef(
  (props, ref) => {
    const {
      borderRadius = "md",
      description,
      disabled = false,
      id,
      label = "",
      labelLocation = "hidden",
      name,
      onValueChange,
      placeholder = "Upload a file",
      validExtensions,
      ...rest
    } = props;
    const inputRef = React.useRef(null);
    const combinedRef = useCombinedRefs(inputRef, ref);
    const [fileData, setFileData] = React.useState(null);
    const handleChange = (e) => {
      const filelist = e.currentTarget.files;
      if (!filelist || !filelist[0]) {
        return;
      }
      const file = filelist[0];
      const filename = file.name;
      const filesize = file.size / 1e3;
      setFileData({
        name: filename,
        size: filesize,
        extension: filename.split(".").pop() ?? ""
      });
      onValueChange == null ? void 0 : onValueChange(file);
    };
    const accept = validExtensions.map((ext) => MIME_TYPES[ext]).join(",");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field,
      {
        description,
        disabled,
        display: "grid",
        id: id ?? name,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            width: "full",
            minWidth: "0",
            justifyContent: fileData ? "space-between" : "flex-start",
            gap: "2",
            color: fileData ? "text100" : "text50",
            className: clsx(wrap$1, wrapVariants$1({ borderRadius })),
            children: [
              fileData ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "row", gap: "2", alignItems: "center", minWidth: "0", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ellipsis: true, children: fileData.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { color: "text50", variant: "xsmall", whiteSpace: "nowrap", children: [
                  fileData.size.toFixed(2),
                  " kb"
                ] })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { ellipsis: true, children: placeholder }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  accept,
                  as: "input",
                  className: input$1,
                  cursor: "pointer",
                  disabled,
                  id: id ?? name,
                  name,
                  onChange: handleChange,
                  ref: combinedRef,
                  type: "file",
                  ...rest
                }
              ),
              fileData && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  cursor: "pointer",
                  icon: SvgCloseIcon,
                  size: "xs",
                  onClick: (ev) => {
                    var _a;
                    ev.preventDefault();
                    ev.stopPropagation();
                    ((_a = inputRef.current) == null ? void 0 : _a.value) && (inputRef.current.value = "");
                    onValueChange == null ? void 0 : onValueChange(null);
                    setFileData(null);
                  },
                  zIndex: "10"
                }
              )
            ]
          }
        )
      }
    );
  }
);
const ControlledFileInput = ({
  defaultValue,
  name,
  control,
  rules,
  ...inputProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue,
    name,
    control,
    rules,
    render: ({ field: { value: _v, onChange: _c, ...fieldProps } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(FileInput, { ...fieldProps, ...inputProps })
  }
);
const Form = ({ children, defaultValues = {}, onSubmit }) => {
  const methods = useForm({ defaultValues });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: methods.handleSubmit(onSubmit), children: children(methods) });
};
var avatar = createRuntimeFn({ defaultClassName: "_1bhyzin0", variantClassNames: { size: { xs: "_1bhyzin1", sm: "_1bhyzin2", md: "_1bhyzin3", lg: "_1bhyzin4", xl: "_1bhyzin5" } }, defaultVariants: {}, compoundVariants: [] });
const MOD = 1e3;
const SIZE = 64;
const RADIUS = SIZE / 2;
const scaledMod = (value, mod = MOD) => {
  return value % mod / (MOD / SIZE);
};
const cyrb53 = (str, seed = 0) => {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
const createGradient = (a, b, c) => {
  const hueA = a % 360;
  const hueB = (a + 120) % 360;
  const hueC = c % 360;
  return {
    a: `hsl(${hueA}deg 100% 40%)`,
    b: `hsl(${hueB}deg 100% 50%)`,
    c: `hsl(${hueC}deg 100% 50%)`
  };
};
const createGradients = (address, complexity) => {
  const hashes = [];
  for (let i = 0; i < complexity; i++) {
    const offset2 = i * 6;
    hashes.push({
      a: cyrb53(address + "a", offset2),
      b: cyrb53(address + "b", offset2 + 1),
      c: cyrb53(address + "c", offset2 + 2),
      x: cyrb53(address + "d", offset2 + 3),
      y: cyrb53(address + "e", offset2 + 4),
      r: cyrb53(address + "f", offset2 + 5)
    });
  }
  return hashes.map((hash, idx) => {
    const r2 = SIZE / 10 + scaledMod(hash.r, MOD * 1.5 / (idx + 1));
    return {
      ...createGradient(hash.a, hash.b, hash.c),
      x: scaledMod(hash.x),
      //clampGradientPosition(hash.x % SIZE, -r / 3),
      y: scaledMod(hash.y),
      //clampGradientPosition(hash.y % SIZE, -r / 3),
      r: r2
    };
  });
};
const GradientAvatar = React.memo((props) => {
  const { className, address, size: size2 = "md", complexity = 1, ...rest } = props;
  const gradients = createGradients(address, complexity);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      as: "svg",
      className: clsx(className, avatar({ size: size2 })),
      viewBox: `0 0 ${SIZE} ${SIZE}`,
      version: "1.1",
      flexShrink: "0",
      borderRadius: "circle",
      overflow: "hidden",
      xmlns: "http://www.w3.org/2000/svg",
      ...rest,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "circle-clip", children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: RADIUS, cy: RADIUS, r: RADIUS }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "filter",
            {
              id: "blur",
              x: "-10%",
              y: "-10%",
              width: "120%",
              height: "120%",
              filterUnits: "userSpaceOnUse",
              colorInterpolationFilters: "sRGB",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "feBlend",
                  {
                    mode: "normal",
                    in: "SourceGraphic",
                    in2: "BackgroundImageFix",
                    result: "shape"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "feGaussianBlur",
                  {
                    stdDeviation: SIZE / 10,
                    result: "effect1_foregroundBlur"
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "linearGradient",
            {
              id: `gradient-background-${address}`,
              x1: "0",
              y1: "0",
              x2: "1",
              y2: "1",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradients[0].c }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradients[0].a })
              ]
            }
          ),
          gradients.map((gradient, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: `gradient-primary-${address}-${idx}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradient.a }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradient.b })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("radialGradient", { id: `gradient-secondary-${address}-${idx}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0", stopColor: gradient.c }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: gradient.b })
            ] })
          ] }, idx))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#circle-clip)", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              width: "100%",
              height: "100%",
              fill: `url(#gradient-background-${address})`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { filter: "url(#blur)", children: gradients.map((gradient, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                fill: `url(#gradient-primary-${address}-${idx})`,
                cx: gradient.x,
                cy: gradient.y,
                r: gradient.r
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                fill: `url(#gradient-secondary-${address}-${idx})`,
                cx: gradient.y,
                cy: gradient.x,
                r: gradient.r / 2
              }
            )
          ] }, idx)) })
        ] })
      ]
    }
  );
});
const Image = (props) => {
  const { disableAnimation = false, onLoad, ...rest } = props;
  const [isImageLoaded, setImageLoaded] = React.useState(false);
  const handleLoad = (ev) => {
    setImageLoaded(true);
    onLoad == null ? void 0 : onLoad(ev);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: framerMotion.motion.img,
      initial: disableAnimation ? void 0 : { opacity: 0 },
      animate: disableAnimation ? void 0 : { opacity: isImageLoaded ? 1 : 0 },
      transition: { duration: 0.2 },
      onLoad: disableAnimation ? void 0 : handleLoad,
      ...rest
    }
  );
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React__namespace.useRef(null);
  const contentRef = React__namespace.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React__namespace.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger";
var DialogTrigger = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$1 = "DialogPortal";
var [PortalProvider$1, usePortalContext$1] = createDialogContext(PORTAL_NAME$1, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$1, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopeDialog, forceMount, children: React__namespace.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$1;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$2(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$3 = "DialogContent";
var DialogContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME$3;
var DialogContentModal = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const contentRef = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React__namespace.useEffect(() => {
      const content2 = contentRef.current;
      if (content2) return hideOthers(content2);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const hasInteractedOutsideRef = React__namespace.useRef(false);
    const hasPointerDownOutsideRef = React__namespace.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$3, __scopeDialog);
    const contentRef = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$2(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$3,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React__namespace.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React__namespace.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$3 = Dialog;
var Trigger$3 = DialogTrigger;
var Portal$1 = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent;
var Title$1 = DialogTitle;
var Description$1 = DialogDescription;
var Close$1 = DialogClose;
const index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Close: Close$1,
  Content: Content$1,
  Description: Description$1,
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
  Overlay,
  Portal: Portal$1,
  Root: Root$3,
  Title: Title$1,
  Trigger: Trigger$3,
  WarningProvider,
  createDialogScope
}, Symbol.toStringTag, { value: "Module" }));
var scroll = createRuntimeFn({ defaultClassName: "_1vqx0w91 _1vqx0w90 fyvr12g fyvr164", variantClassNames: { direction: { vertical: "_1vqx0w92", horizontal: "_1vqx0w93" } }, defaultVariants: {}, compoundVariants: [] });
var overlay$1 = createRuntimeFn({ defaultClassName: "_1vqx0w94", variantClassNames: { shadows: { true: "_1vqx0w95", false: "_1vqx0w96" }, direction: { vertical: "_1vqx0w97", horizontal: "_1vqx0w98" } }, defaultVariants: {}, compoundVariants: [] });
const Scroll = (props) => {
  const {
    children,
    shadows = true,
    direction = "vertical",
    contentProps,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: overlay$1({ direction, shadows }),
      position: "relative",
      width: "full",
      height: "full",
      ...rest,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          className: scroll({ direction }),
          background: "backgroundPrimary",
          ...contentProps,
          children
        }
      )
    }
  );
};
function getVarName(variable) {
  var matches = variable.match(/^var\((.*)\)$/);
  if (matches) {
    return matches[1];
  }
  return variable;
}
function get(obj, path) {
  var result = obj;
  for (var key of path) {
    if (!(key in result)) {
      throw new Error("Path ".concat(path.join(" -> "), " does not exist in object"));
    }
    result = result[key];
  }
  return result;
}
function walkObject(obj, fn) {
  var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var clone = {};
  for (var key in obj) {
    var _value = obj[key];
    var currentPath = [...path, key];
    if (typeof _value === "string" || typeof _value === "number" || _value == null) {
      clone[key] = fn(_value, currentPath);
    } else if (typeof _value === "object" && !Array.isArray(_value)) {
      clone[key] = walkObject(_value, fn, currentPath);
    } else {
      console.warn('Skipping invalid key "'.concat(currentPath.join("."), '". Should be a string, number, null or object. Received: "').concat(Array.isArray(_value) ? "Array" : typeof _value, '"'));
    }
  }
  return clone;
}
function setVar(element, variable, value) {
  element.style.setProperty(getVarName(variable), value);
}
function setElementVars(element, varsOrContract, tokens2) {
  if (typeof tokens2 === "object") {
    var _contract = varsOrContract;
    walkObject(tokens2, (value2, path) => {
      if (value2 == null) {
        return;
      }
      setVar(element, get(_contract, path), String(value2));
    });
  } else {
    var _vars = varsOrContract;
    for (var varName in _vars) {
      var value = _vars[varName];
      if (value == null) {
        continue;
      }
      setVar(element, varName, _vars[varName]);
    }
  }
}
const THEMES = ["dark", "light"];
const DEFAULT_THEME = "dark";
const THEME_ATTR = "data-theme";
const STORAGE_KEY = "@sequence.theme";
const isTheme = (theme) => THEMES.includes(theme);
const isThemeOverrides = (theme) => typeof theme === "object" && theme !== null && !Array.isArray(theme);
const getStorageKey = (scope) => scope ? `${STORAGE_KEY}.${scope}` : STORAGE_KEY;
const getPersistedTheme = (scope) => {
  const persistedTheme = localStorage.getItem(
    getStorageKey(scope)
  );
  if (persistedTheme && THEMES.includes(persistedTheme)) {
    return persistedTheme;
  }
  return null;
};
const getPreferredColorScheme = () => {
  if (matchMedia(`(prefers-color-scheme: light)`).matches) {
    return "light";
  } else if (matchMedia(`(prefers-color-scheme: dark)`).matches) {
    return "dark";
  }
  return null;
};
const ThemeContext = React.createContext(null);
const ThemeProvider = (props) => {
  const [theme, setTheme] = React.useState(
    props.theme || DEFAULT_THEME
  );
  React.useEffect(() => {
    /Mac/.test(window.navigator.userAgent) && window.document.documentElement.classList.add("is-apple");
  }, []);
  React.useEffect(() => {
    const theme2 = (
      // Use the theme prop if it exists
      props.theme || // or use the persisted theme from local store if it exists
      getPersistedTheme(props.scope) || // or use the browser's preferred color scheme if enabled
      props.prefersColorScheme && getPreferredColorScheme() || // or use the default theme
      DEFAULT_THEME
    );
    setTheme(theme2);
  }, [props.theme, props.scope, props.prefersColorScheme]);
  React.useEffect(() => {
    const rootEl = document.querySelector(props.root || ":root");
    if (rootEl) {
      if (isTheme(theme)) {
        rootEl.setAttribute(THEME_ATTR, theme);
        setElementVars(rootEl, colorSchemeVars, {
          colors: colors[theme]
        });
      } else if (isThemeOverrides(theme)) {
        setElementVars(rootEl, colorSchemeVars, {
          colors: theme
        });
      }
      if (props.root) {
        rootEl.classList.add("seq-root");
      }
    }
  }, [theme, props.root]);
  const value = React.useMemo(() => {
    return {
      theme,
      root: props.root,
      setTheme: (mode) => {
        if (THEMES.includes(mode)) {
          localStorage.setItem(getStorageKey(props.scope), mode);
          setTheme(mode);
        }
      }
    };
  }, [theme, props.root, props.scope]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, { value, children: props.children });
};
const useTheme = () => {
  const context = React.useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};
var root$3 = "_5b32m91 _5b32m90 fyvr11no fyvr11ow fyvr11l8 fyvr11m0 fyvr11rs fyvr1m0 fyvr1qg fyvr1so fyvr1o8";
var overlay = "_5b32m93 _5b32m92 fyvr11m0 fyvr1m0 fyvr1qg fyvr1so fyvr1o8";
var contentVariants = createRuntimeFn({ defaultClassName: "_5b32m95 _5b32m94 fyvr11hg fyvr11i4 fyvr11fo fyvr11g6 fyvr11gc fyvr11gu fyvr11q0 fyvr11qg fyvr1310 fyvr130u fyvr11l8 fyvr11mc fyvr11m0 fyvr11wl fyvr1o8 fyvr1qe", variantClassNames: { size: { sm: "_5b32m96", lg: "_5b32m97" }, autoHeight: { true: "_5b32m98" } }, defaultVariants: {}, compoundVariants: [[{ autoHeight: true, size: "lg" }, "_5b32m99"]] });
var close = "_5b32m9b _5b32m9a fyvr113s fyvr1160 fyvr1188 fyvr11ag fyvr11lw fyvr1so fyvr1m0 fyvr11rs";
const Modal = (props) => {
  const {
    autoHeight = false,
    backdropColor = "backgroundBackdrop",
    // gradientBackdrop for onboarding or special modals
    children,
    disableAnimation = false,
    isDismissible = true,
    onClose,
    scroll: scroll2 = true,
    size: size2 = "lg",
    overlayProps,
    contentProps,
    rootProps = {}
  } = props;
  const { root: root2 } = useTheme();
  const [container, setContainer] = React.useState(null);
  React.useEffect(() => {
    setContainer(document.querySelector(root2 || "body"));
  }, [root2]);
  return container ? /* @__PURE__ */ jsxRuntimeExports.jsx(Root$3, { modal: true, defaultOpen: true, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { forceMount: true, container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      ...rootProps,
      className: clsx("seq-root", root$3, rootProps == null ? void 0 : rootProps.className),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            as: Overlay,
            asChild: true,
            background: backdropColor,
            className: overlay,
            forceMount: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              framerMotion.motion.div,
              {
                initial: disableAnimation ? false : { opacity: 0 },
                animate: disableAnimation ? false : { opacity: 1 },
                exit: disableAnimation ? void 0 : { opacity: 0 },
                transition: {
                  type: "tween",
                  ease: "linear"
                },
                ...overlayProps
              },
              "modal-overlay"
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Content$1,
          {
            asChild: true,
            className: contentVariants({ autoHeight, size: size2 }),
            forceMount: true,
            onEscapeKeyDown: (ev) => {
              if (isDismissible) {
                onClose == null ? void 0 : onClose();
              } else {
                ev.preventDefault();
              }
            },
            onInteractOutside: (ev) => {
              if (!isDismissible) {
                ev.preventDefault();
              }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              framerMotion.motion.div,
              {
                initial: disableAnimation ? false : { y: "100%", opacity: size2 === "sm" ? 0 : 1 },
                animate: disableAnimation ? false : { y: 0, opacity: size2 === "sm" ? 1 : 1 },
                exit: disableAnimation ? void 0 : { y: "100%", opacity: size2 === "sm" ? 0 : 1 },
                transition: { type: "tween", ease: "easeOut" },
                ...contentProps,
                children: [
                  scroll2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Scroll, { children }) : children,
                  isDismissible && /* @__PURE__ */ jsxRuntimeExports.jsx(Close$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IconButton,
                    {
                      icon: SvgCloseIcon,
                      backdropFilter: "blur",
                      size: "xs",
                      className: close,
                      "aria-label": "Close"
                    }
                  ) })
                ]
              },
              "modal-content"
            )
          }
        )
      ]
    }
  ) }) }) : null;
};
var wrap = "_1acm19y1 _1acm19y0 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr1zk fyvr111o fyvr11lk fyvr11ow fyvr11sl fyvr12w9 fyvr1h4 fyvr11cg";
var wrapVariants = createRuntimeFn({ defaultClassName: "_1acm19y5", variantClassNames: { borderRadius: { xs: "_1acm19y6 _1acm19y2 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg", sm: "_1acm19y7 _1acm19y3 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk", md: "_1acm19y8 _1acm19y4 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go" } }, defaultVariants: {}, compoundVariants: [] });
var input = createRuntimeFn({ defaultClassName: "_1acm19ya _1acm19y9 fyvr1z4 fyvr1118 fyvr1vc fyvr1xg fyvr130x fyvr130r fyvr11l4 fyvr11sl fyvr12w9 fyvr12s9 fyvr12g fyvr164", variantClassNames: { numeric: { false: "_1acm19yb _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8", true: "_1acm19yc _1qxj1ib9 _1qxj1ibc _1qxj1ib2 fyvr11r3 fyvr11iw fyvr11kg fyvr11jw fyvr11jg" } }, defaultVariants: {}, compoundVariants: [] });
const TextInput = React.forwardRef(
  (props, ref) => {
    const {
      as = "input",
      autoComplete = "off",
      borderRadius = "md",
      description,
      disabled = false,
      id,
      label = "",
      labelLocation = "hidden",
      leftIcon: LeftIcon,
      rightIcon: RightIcon,
      name,
      controls,
      type = "text",
      numeric = false,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field,
      {
        description,
        disabled,
        display: "grid",
        id: id ?? name,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { width: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            className: clsx(
              wrap,
              wrapVariants({ borderRadius })
            ),
            children: [
              LeftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(LeftIcon, { size: "sm" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  as,
                  autoComplete,
                  spellCheck: "false",
                  className: input({ numeric }),
                  disabled,
                  id: id ?? name,
                  name,
                  ref,
                  type,
                  ...rest
                }
              ),
              RightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(RightIcon, { size: "sm" }),
              controls
            ]
          }
        ) })
      }
    );
  }
);
const ControlledTextInput = ({
  defaultValue,
  name,
  control,
  rules,
  ...inputProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue,
    name,
    control,
    rules,
    render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { ...field, ...inputProps })
  }
);
const inputRegex = RegExp(`^\\d*(?:\\\\[.])?\\d*$`);
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const NumericInput = React.forwardRef(
  (props, ref) => {
    const { name = "amount", placeholder, onChange, onBlur, ...rest } = props;
    const handleChange = (ev) => {
      let { value } = ev.target;
      value = value.replace(/,/g, ".");
      if (value.startsWith(".")) {
        value = "0" + value;
      }
      if (value.startsWith("0")) {
        value = value.replace(/^0+(?=\d)/, "");
      }
      if (value === "" || inputRegex.test(escapeRegExp(value))) {
        onChange == null ? void 0 : onChange({ ...ev, target: { ...ev.target, value } });
      }
    };
    const handleBlur = (ev) => {
      const { value } = ev.target;
      let v = value;
      if (v.endsWith(".")) {
        v = v.slice(0, -1);
      }
      if (v.endsWith(".0")) {
        v = v.slice(0, -2);
      }
      if (v === "0") {
        v = "";
      }
      onBlur == null ? void 0 : onBlur(ev);
      if (v !== value) {
        onChange == null ? void 0 : onChange({ ...ev, target: { ...ev.target, value: v } });
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        name,
        onChange: handleChange,
        onBlur: handleBlur,
        inputMode: "decimal",
        autoComplete: "off",
        autoCorrect: "off",
        type: "text",
        pattern: "^[0-9]*[.,]?[0-9]*$",
        placeholder: placeholder || "0",
        minLength: 1,
        maxLength: 79,
        spellCheck: "false",
        numeric: true,
        ref,
        ...rest
      }
    );
  }
);
var digitInput = "y5zf971 _1qxj1ib9 _1qxj1ibc _1qxj1ib2 fyvr11r3 fyvr11iw fyvr11kg fyvr11jw fyvr11jg _4efw240";
const PINCodeInput = (props) => {
  const {
    value,
    digits = 6,
    group,
    onChange,
    onConfirm,
    disabled = false
  } = props;
  const inputRefs = React.useMemo(() => {
    return range(0, digits).map(() => React.createRef());
  }, [digits]);
  React.useEffect(() => {
    var _a, _b;
    (_b = (_a = inputRefs[0]) == null ? void 0 : _a.current) == null ? void 0 : _b.focus();
  }, [inputRefs]);
  const handleChange = (idx, character) => {
    var _a, _b;
    if (!/^\d$/.test(character)) {
      character = "";
    }
    const curr = [...value];
    curr[idx] = character;
    if (character !== "") {
      (_b = (_a = inputRefs[idx + 1]) == null ? void 0 : _a.current) == null ? void 0 : _b.focus();
    }
    onChange(curr);
  };
  const isValid = () => value.join("").length === digits;
  const handleKeyDown = (idx, ev) => {
    var _a, _b;
    const currentRef = inputRefs[idx].current;
    const prevRef = (_a = inputRefs[idx - 1]) == null ? void 0 : _a.current;
    const nextRef = (_b = inputRefs[idx + 1]) == null ? void 0 : _b.current;
    switch (ev.key) {
      case "Backspace":
        ev.preventDefault();
        if (currentRef) {
          currentRef.value = "";
          handleChange(idx, "");
        }
        prevRef == null ? void 0 : prevRef.focus();
        break;
      case "ArrowLeft":
        ev.preventDefault();
        prevRef == null ? void 0 : prevRef.focus();
        break;
      case "ArrowRight":
        ev.preventDefault();
        nextRef == null ? void 0 : nextRef.focus();
        break;
      case "Enter":
        ev.preventDefault();
        if (isValid()) {
          onConfirm == null ? void 0 : onConfirm();
        }
        break;
      default:
        if ((currentRef == null ? void 0 : currentRef.value) === ev.key) {
          ev.preventDefault();
          handleChange(idx, ev.key);
        }
    }
  };
  const handlePaste = (idx, ev) => {
    var _a, _b;
    const pasted = ev.clipboardData.getData("text/plain");
    const filtered = pasted.replace(/\D/g, "");
    const re = new RegExp(`^\\d{${digits}}$`);
    if (re.test(filtered)) {
      (_b = (_a = inputRefs[0]) == null ? void 0 : _a.current) == null ? void 0 : _b.focus();
      onChange(filtered.split(""));
      setTimeout(() => {
        var _a2, _b2;
        (_b2 = (_a2 = inputRefs[inputRefs.length - 1]) == null ? void 0 : _a2.current) == null ? void 0 : _b2.focus();
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { gap: "2", children: range(0, digits).map((idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
    !!group && idx > 0 && idx % group === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as: "input",
        className: digitInput,
        value: value[idx] || "",
        ref: inputRefs[idx],
        type: "text",
        inputMode: "numeric",
        maxLength: 1,
        disabled,
        onFocus: (ev) => ev.target.select(),
        onPaste: (ev) => handlePaste(idx, ev),
        onChange: (ev) => handleChange(idx, ev.target.value),
        onKeyDown: (ev) => {
          handleKeyDown(idx, ev);
        }
      }
    )
  ] }, idx)) });
};
const range = (start, end) => Array.from({ length: end - start }, (v, k) => k + start);
var skeleton = createRuntimeFn({ defaultClassName: "_1jujggt1", variantClassNames: { size: { sm: "_1jujggt2", normal: "_1jujggt3", md: "_1jujggt4", lg: "_1jujggt5", xl: "_1jujggt6" } }, defaultVariants: {}, compoundVariants: [] });
const Skeleton = (props) => {
  const { size: size2, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: framerMotion.motion.div,
      className: skeleton({ size: size2 }),
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      borderRadius: "sm",
      ...rest
    }
  );
};
var PROGRESS_NAME = "Progress";
var DEFAULT_MAX = 100;
var [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);
var [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME);
var Progress$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeProgress,
      value: valueProp = null,
      max: maxProp,
      getValueLabel = defaultGetValueLabel,
      ...progressProps
    } = props;
    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {
      console.error(getInvalidMaxError(`${maxProp}`, "Progress"));
    }
    const max2 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;
    if (valueProp !== null && !isValidValueNumber(valueProp, max2)) {
      console.error(getInvalidValueError(`${valueProp}`, "Progress"));
    }
    const value = isValidValueNumber(valueProp, max2) ? valueProp : null;
    const valueLabel = isNumber(value) ? getValueLabel(value, max2) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, { scope: __scopeProgress, value, max: max2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "aria-valuemax": max2,
        "aria-valuemin": 0,
        "aria-valuenow": isNumber(value) ? value : void 0,
        "aria-valuetext": valueLabel,
        role: "progressbar",
        "data-state": getProgressState(value, max2),
        "data-value": value ?? void 0,
        "data-max": max2,
        ...progressProps,
        ref: forwardedRef
      }
    ) });
  }
);
Progress$1.displayName = PROGRESS_NAME;
var INDICATOR_NAME$1 = "ProgressIndicator";
var ProgressIndicator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeProgress, ...indicatorProps } = props;
    const context = useProgressContext(INDICATOR_NAME$1, __scopeProgress);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": getProgressState(context.value, context.max),
        "data-value": context.value ?? void 0,
        "data-max": context.max,
        ...indicatorProps,
        ref: forwardedRef
      }
    );
  }
);
ProgressIndicator.displayName = INDICATOR_NAME$1;
function defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber(value) {
  return typeof value === "number";
}
function isValidMaxNumber(max2) {
  return isNumber(max2) && !isNaN(max2) && max2 > 0;
}
function isValidValueNumber(value, max2) {
  return isNumber(value) && !isNaN(value) && value <= max2 && value >= 0;
}
function getInvalidMaxError(propValue, componentName) {
  return `Invalid prop \`max\` of value \`${propValue}\` supplied to \`${componentName}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`;
}
function getInvalidValueError(propValue, componentName) {
  return `Invalid prop \`value\` of value \`${propValue}\` supplied to \`${componentName}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`;
}
var Root$2 = Progress$1;
const Progress = (props) => {
  const { value, color = "positive" } = props;
  const percent = Math.min(value * 100, 100);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      as: Root$2,
      value: percent,
      borderRadius: "circle",
      background: "backgroundPrimary",
      width: "full",
      height: "1",
      overflow: "hidden",
      position: "relative",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          as: ProgressIndicator,
          style: {
            width: `${percent}%`,
            transition: "width 660ms cubic-bezier(0.65, 0, 0.35, 1)",
            backgroundSize: "300% 100%"
          },
          height: "full",
          borderRadius: "circle",
          background: color
        }
      )
    }
  );
};
var RADIO_NAME = "Radio";
var [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);
var [RadioProvider, useRadioContext] = createRadioContext(RADIO_NAME);
var Radio = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadio,
      name,
      checked = false,
      required,
      disabled,
      value = "on",
      onCheck,
      ...radioProps
    } = props;
    const [button, setButton] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React__namespace.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioProvider, { scope: __scopeRadio, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": checked,
          "data-state": getState$1(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...radioProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            if (!checked) onCheck == null ? void 0 : onCheck();
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$1,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Radio.displayName = RADIO_NAME;
var INDICATOR_NAME = "RadioIndicator";
var RadioIndicator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadio, forceMount, ...indicatorProps } = props;
    const context = useRadioContext(INDICATOR_NAME, __scopeRadio);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$1(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef
      }
    ) });
  }
);
RadioIndicator.displayName = INDICATOR_NAME;
var BubbleInput$1 = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = React__namespace.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React__namespace.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input2, checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState$1(checked) {
  return checked ? "checked" : "unchecked";
}
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var RADIO_GROUP_NAME = "RadioGroup";
var [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [
  createRovingFocusGroupScope,
  createRadioScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var useRadioScope = createRadioScope();
var [RadioGroupProvider, useRadioGroupContext] = createRadioGroupContext(RADIO_GROUP_NAME);
var RadioGroup$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRadioGroup,
      name,
      defaultValue,
      value: valueProp,
      required = false,
      disabled = false,
      orientation,
      dir,
      loop = true,
      onValueChange,
      ...groupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioGroupProvider,
      {
        scope: __scopeRadioGroup,
        name,
        required,
        disabled,
        value,
        onValueChange: setValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$4,
          {
            asChild: true,
            ...rovingFocusGroupScope,
            orientation,
            dir: direction,
            loop,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "radiogroup",
                "aria-required": required,
                "aria-orientation": orientation,
                "data-disabled": disabled ? "" : void 0,
                dir: direction,
                ...groupProps,
                ref: forwardedRef
              }
            )
          }
        )
      }
    );
  }
);
RadioGroup$1.displayName = RADIO_GROUP_NAME;
var ITEM_NAME$1 = "RadioGroupItem";
var RadioGroupItem = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = useRadioGroupContext(ITEM_NAME$1, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeRadioGroup);
    const radioScope = useRadioScope(__scopeRadioGroup);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = React__namespace.useRef(false);
    React__namespace.useEffect(() => {
      const handleKeyDown = (event) => {
        if (ARROW_KEYS.includes(event.key)) {
          isArrowKeyPressedRef.current = true;
        }
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !isDisabled,
        active: checked,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radio,
          {
            disabled: isDisabled,
            required: context.required,
            checked,
            ...radioScope,
            ...itemProps,
            name: context.name,
            ref: composedRefs,
            onCheck: () => context.onValueChange(itemProps.value),
            onKeyDown: composeEventHandlers((event) => {
              if (event.key === "Enter") event.preventDefault();
            }),
            onFocus: composeEventHandlers(itemProps.onFocus, () => {
              var _a;
              if (isArrowKeyPressedRef.current) (_a = ref.current) == null ? void 0 : _a.click();
            })
          }
        )
      }
    );
  }
);
RadioGroupItem.displayName = ITEM_NAME$1;
var INDICATOR_NAME2 = "RadioGroupIndicator";
var RadioGroupIndicator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeRadioGroup, ...indicatorProps } = props;
    const radioScope = useRadioScope(__scopeRadioGroup);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioIndicator, { ...radioScope, ...indicatorProps, ref: forwardedRef });
  }
);
RadioGroupIndicator.displayName = INDICATOR_NAME2;
var Root2$3 = RadioGroup$1;
var Item2 = RadioGroupItem;
var Indicator = RadioGroupIndicator;
var radioItemVariants = createRuntimeFn({ defaultClassName: "io59uy3 io59uy0 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr1uw fyvr1x0 fyvr1z4 fyvr1118 fyvr12rl fyvr12k9 fyvr125l fyvr12cx fyvr12rr fyvr12kf fyvr125r fyvr12d3 fyvr11sl fyvr12zf fyvr12zb fyvr1307 fyvr12zz _4efw240", variantClassNames: { size: { sm: "io59uy4 io59uy1 fyvr11eg fyvr11es fyvr11f4 fyvr11fg", lg: "io59uy5 io59uy2 fyvr11ek fyvr11ew fyvr11f8 fyvr11fk" } }, defaultVariants: {}, compoundVariants: [] });
var indicatorVariants = createRuntimeFn({ defaultClassName: "io59uy8 io59uy7 io59uy6 fyvr11l8 fyvr11ow fyvr11no fyvr11m4 fyvr12g fyvr164 fyvr12w9", variantClassNames: { size: { sm: "io59uy9", lg: "io59uya" } }, defaultVariants: {}, compoundVariants: [] });
const RadioOption = (props) => {
  const { id, label, size: size2 = "sm", value, disabled } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      disabled,
      display: "flex",
      id,
      label,
      labelLocation: "right",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Item2,
        {
          className: radioItemVariants({ size: size2 }),
          value,
          id,
          disabled,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, { className: indicatorVariants({ size: size2 }) })
        }
      )
    }
  ) });
};
const RadioGroup = React.forwardRef(
  (props, ref) => {
    const {
      flexDirection = "column",
      disabled = false,
      gap = "2",
      name,
      options,
      size: size2 = "sm",
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$3, { disabled, name, ref, ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { flexDirection, gap, children: options.map(({ label, value, disabled: disabled2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioOption,
      {
        id: `${name}-${value}`,
        label,
        size: size2,
        value,
        disabled: disabled2
      },
      value
    )) }) });
  }
);
const ControlledRadioGroup = ({
  control,
  defaultValue,
  name,
  onValueChange,
  rules,
  ...radioProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue,
    name,
    control,
    rules,
    render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioGroup,
      {
        onValueChange,
        defaultValue,
        ...field,
        ...radioProps
      }
    )
  }
);
function clamp(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
var NAME = "VisuallyHidden";
var VisuallyHidden$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden$1.displayName = NAME;
var Root$1 = VisuallyHidden$1;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  const [trigger2, setTrigger] = React__namespace.useState(null);
  const [valueNode, setValueNode] = React__namespace.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React__namespace.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React__namespace.useRef(null);
  const isFormControl = trigger2 ? Boolean(trigger2.closest("form")) : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React__namespace.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React__namespace.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React__namespace.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection$1(__scopeSelect);
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item2) => !item2.disabled);
      const currentItem = enabledItems.find((item2) => item2.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = () => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false) {
            handleOpen();
            context.triggerPointerDownPosRef.current = {
              x: Math.round(event.pageX),
              y: Math.round(event.pageY)
            };
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var CONTENT_NAME$2 = "SelectContent";
var SelectContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$2, props.__scopeSelect);
    const [fragment, setFragment] = React__namespace.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM__namespace.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
    const [content2, setContent] = React__namespace.useState(null);
    const [viewport2, setViewport] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React__namespace.useState(null);
    const [selectedItemText, setSelectedItemText] = React__namespace.useState(
      null
    );
    const getItems = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = React__namespace.useState(false);
    const firstValidItemFoundRef = React__namespace.useRef(false);
    React__namespace.useEffect(() => {
      if (content2) return hideOthers(content2);
    }, [content2]);
    useFocusGuards();
    const focusFirst2 = React__namespace.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item2) => item2.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport2) viewport2.scrollTop = 0;
          if (candidate === lastItem && viewport2) viewport2.scrollTop = viewport2.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport2]
    );
    const focusSelectedItem = React__namespace.useCallback(
      () => focusFirst2([selectedItem, content2]),
      [focusFirst2, selectedItem, content2]
    );
    React__namespace.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React__namespace.useEffect(() => {
      if (content2) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a = triggerPointerDownPosRef.current) == null ? void 0 : _a.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content2.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content2, onOpenChange, triggerPointerDownPosRef]);
    React__namespace.useEffect(() => {
      const close2 = () => onOpenChange(false);
      window.addEventListener("blur", close2);
      window.addEventListener("resize", close2);
      return () => {
        window.removeEventListener("blur", close2);
        window.removeEventListener("resize", close2);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item2) => !item2.disabled);
      const currentItem = enabledItems.find((item2) => item2.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React__namespace.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React__namespace.useCallback(() => content2 == null ? void 0 : content2.focus(), [content2]);
    const itemTextRefCallback = React__namespace.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content: content2,
        viewport: viewport2,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a;
              (_a = context.trigger) == null ? void 0 : _a.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item2) => !item2.disabled);
                        let candidateNodes = items.map((item2) => item2.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React__namespace.useState(null);
  const [content2, setContent] = React__namespace.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = React__namespace.useRef(false);
  const shouldRepositionRef = React__namespace.useRef(true);
  const { viewport: viewport2, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React__namespace.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content2 && viewport2 && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content2.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left, [CONTENT_MARGIN, rightEdge - contentWidth]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right, [CONTENT_MARGIN, leftEdge - contentWidth]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport2.scrollHeight;
      const contentStyles = window.getComputedStyle(content2);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport2);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content2.clientHeight - viewport2.offsetTop - viewport2.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport2.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport2.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport2.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content2,
    viewport2,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React__namespace.useState();
  useLayoutEffect2(() => {
    if (content2) setContentZIndex(window.getComputedStyle(content2).zIndex);
  }, [content2]);
  const handleScrollButtonChange = React__namespace.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope$1(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$2,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {});
var VIEWPORT_NAME$1 = "SelectViewport";
var SelectViewport = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME$1, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME$1, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React__namespace.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            overflow: "auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport2 = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport2.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport2.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport2.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME$1;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React__namespace.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React__namespace.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a;
        return (_a = contentContext.itemRefCallback) == null ? void 0 : _a.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId();
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React__namespace.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, handleSelect),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a;
                  if (disabled) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  } else {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a;
                  if (event.currentTarget === document.activeElement) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a;
                  const isTypingAhead = ((_a = contentContext.searchRef) == null ? void 0 : _a.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a;
        return (_a = contentContext.itemTextRefCallback) == null ? void 0 : _a.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React__namespace.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM__namespace.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = React__namespace.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React__namespace.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport2.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport2 = contentContext.viewport;
      handleScroll2();
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = React__namespace.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React__namespace.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport2.scrollHeight - viewport2.clientHeight;
        const canScrollDown2 = Math.ceil(viewport2.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport2 = contentContext.viewport;
      handleScroll2();
      viewport2.addEventListener("scroll", handleScroll2);
      return () => viewport2.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport: viewport2, selectedItem } = contentContext;
        if (viewport2 && selectedItem) {
          viewport2.scrollTop = viewport2.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React__namespace.useRef(null);
  const getItems = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = React__namespace.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React__namespace.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a;
    const activeItem = getItems().find((item2) => item2.ref.current === document.activeElement);
    (_a = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a;
        (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME$1 = "SelectArrow";
var SelectArrow = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeSelect);
    const context = useSelectContext(ARROW_NAME$1, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME$1, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME$1;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React__namespace.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React__namespace.useRef("");
  const timerRef = React__namespace.useRef(0);
  const handleTypeaheadSearch = React__namespace.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React__namespace.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React__namespace.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item2) => item2.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$2 = Select$1;
var Trigger$2 = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Content2$1 = SelectContent;
var Viewport$1 = SelectViewport;
var Group = SelectGroup;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var triggerStyle = "gohwum1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 gohwum0 fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr11ow fyvr11sl fyvr11lk fyvr11jc fyvr12w9 fyvr11cc fyvr11o4 fyvr11rc fyvr12zf fyvr12s9";
var triggerVariants = createRuntimeFn({ defaultClassName: "gohwum5", variantClassNames: { borderRadius: { xs: "gohwum6 gohwum2 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg", sm: "gohwum7 gohwum3 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk", md: "gohwum8 gohwum4 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go" } }, defaultVariants: {}, compoundVariants: [] });
var contentStyle = "gohwuma gohwum9 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr11q0 fyvr11qg fyvr11r0 fyvr11y3 fyvr12w9 fyvr11rt";
var optionStyle = "gohwume _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 gohwumd fyvr1zk fyvr111o fyvr1v8 fyvr1xc fyvr1310 fyvr1311 fyvr130u fyvr130v fyvr11l8 fyvr11o4 fyvr11ow fyvr12zf fyvr12zb fyvr12w9 fyvr1309 fyvr12zz";
const SelectItem = React.forwardRef(
  ({ children, className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item,
      {
        className: clsx(optionStyle, className),
        ...props,
        ref,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
      }
    );
  }
);
const Select = React.forwardRef(
  (props, ref) => {
    const {
      borderRadius = "md",
      disabled = false,
      id,
      label = "",
      description,
      labelLocation = "hidden",
      name,
      options,
      placeholder,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field,
      {
        disabled,
        display: "grid",
        id: id ?? name,
        label,
        labelLocation,
        description,
        whiteSpace: "nowrap",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { disabled, name, ...rest, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Trigger$2,
            {
              id: id ?? name,
              className: clsx(triggerStyle, triggerVariants({ borderRadius })),
              ref,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Value, { placeholder }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: Icon, display: "inline-flex", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgChevronDownIcon, {}) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Content2$1, { className: contentStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { children: options.map(({ value, label: label2, ...rest2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value, ...rest2, children: label2 }, value)) }) }) })
        ] })
      }
    );
  }
);
const ControlledSelect = ({
  control,
  defaultValue,
  name,
  onValueChange,
  rules,
  ...selectProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue,
    name,
    control,
    rules,
    render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select,
      {
        onValueChange,
        defaultValue,
        ...field,
        ...selectProps
      }
    )
  }
);
const SearchInput = React.forwardRef(
  (props, ref) => {
    const {
      controls,
      onChange,
      placeholder = "Search",
      name = "search",
      value,
      ...rest
    } = props;
    const defaultClearButton = value ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        icon: SvgCloseIcon,
        size: "xs",
        onClick: () => onChange == null ? void 0 : onChange({
          target: { value: "" }
        })
      }
    ) : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextInput,
      {
        ref,
        name,
        leftIcon: SvgSearchIcon,
        controls: controls || defaultClearButton,
        placeholder,
        value,
        onChange: (ev) => onChange == null ? void 0 : onChange(ev),
        ...rest
      }
    );
  }
);
var variants = createRuntimeFn({ defaultClassName: "en4abt1", variantClassNames: { size: { sm: "en4abt2", md: "en4abt3", lg: "en4abt4" } }, defaultVariants: {}, compoundVariants: [] });
const Spinner = React.forwardRef(
  (props, ref) => {
    const { size: size2 = "md", ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: variants({ size: size2 }),
        color: "text50",
        ref,
        ...rest,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg",
            stroke: "currentColor",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: "12",
                  cy: "12",
                  fill: "none",
                  r: "10.5",
                  strokeDasharray: "42",
                  strokeLinecap: "round"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: "12",
                  cy: "12",
                  fill: "none",
                  opacity: "0.25",
                  r: "10.5",
                  strokeLinecap: "round"
                }
              )
            ]
          }
        )
      }
    );
  }
);
const StopClickPropagation = React.forwardRef(
  ({ children }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      ref,
      width: "fit",
      height: "fit",
      onClick: (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
      },
      onKeyDown: (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          ev.stopPropagation();
        }
      },
      children
    }
  )
);
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      ...switchProps
    } = props;
    const [button, setButton] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = React__namespace.useRef(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch$1.displayName = SWITCH_NAME;
var THUMB_NAME = "SwitchThumb";
var SwitchThumb = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { control, checked, bubbles = true, ...inputProps } = props;
  const ref = React__namespace.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  React__namespace.useEffect(() => {
    const input2 = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      setChecked.call(input2, checked);
      input2.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: checked,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
var Root = Switch$1;
var Thumb = SwitchThumb;
var root$2 = "_1lp2u8e1 _1lp2u8e0 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr1v0 fyvr1x4 fyvr1z8 fyvr111c fyvr11x9 fyvr11m4 fyvr12zf fyvr12s9 _4efw240";
var thumb = "_1lp2u8e3 _1lp2u8e2 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr11lw fyvr1m0 fyvr1qg fyvr1k fyvr148 fyvr11s9";
const Switch = (props) => {
  const {
    disabled,
    label,
    labelLocation = "left",
    description,
    id,
    name,
    ...rest
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Field,
    {
      disabled,
      display: "flex",
      id: id ?? name,
      label,
      labelLocation,
      description,
      whiteSpace: "nowrap",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root,
        {
          className: root$2,
          disabled,
          ...rest,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { position: "relative", width: "full", height: "full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: thumb }) })
        }
      )
    }
  );
};
const ControlledSwitch = ({
  control,
  defaultChecked,
  onCheckedChange,
  name,
  rules,
  ...switchProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue: defaultChecked,
    name,
    control,
    rules,
    render: ({ field: { ref: _, ...fieldProps } }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Switch,
      {
        onCheckedChange,
        defaultChecked,
        ...fieldProps,
        ...switchProps
      }
    )
  }
);
var tabList = "nwwh3z0";
var tabVariants = createRuntimeFn({ defaultClassName: "nwwh3z8", variantClassNames: { variant: { pill: "nwwh3z9", line: "nwwh3za nwwh3z1 fyvr11k8" }, active: { true: "nwwh3zb nwwh3z2 fyvr130d", false: "nwwh3zc" }, disabled: { true: "nwwh3zd nwwh3z3 fyvr12zx" } }, defaultVariants: {}, compoundVariants: [[{ active: true, variant: "pill" }, "nwwh3z4 fyvr11yf fyvr12wr"], [{ active: false, variant: "pill" }, "nwwh3z5 fyvr11sl fyvr12wf"], [{ active: true, variant: "line" }, "nwwh3z6 fyvr12w9"], [{ active: false, variant: "line" }, "nwwh3z7 fyvr12wf"]] });
const TabbedNav = (props) => {
  const {
    className,
    defaultValue,
    onTabChange,
    size: size2 = "sm",
    tabs,
    variant = "pill",
    ...rest
  } = props;
  const [isLoading, setIsLoading] = React.useState(false);
  const [value, setValue] = React.useState(defaultValue ?? tabs[0].value);
  const handleTabClick = async (event, option, tabIndex) => {
    var _a;
    event.preventDefault();
    const prevValue = value;
    if (value === option.value) {
      return;
    }
    setValue(tabs[tabIndex].value);
    setIsLoading(true);
    const loadSucceeded = option.onLoad ? await ((_a = option.onLoad) == null ? void 0 : _a.call(option)) : true;
    setIsLoading(false);
    if (loadSucceeded) {
      onTabChange == null ? void 0 : onTabChange(option.value);
    } else {
      setValue(prevValue);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "nav", ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { as: "ul", gap: "2", className: clsx(tabList), children: tabs.map((option, tabIndex) => {
    const isActive = option.value === value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        as: "li",
        borderTopColor: variant === "line" ? isActive ? "text100" : "transparent" : void 0,
        borderTopStyle: variant === "line" ? "solid" : void 0,
        borderTopWidth: variant === "line" ? "thick" : void 0,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            className: clsx(
              className,
              tabVariants({ active: isActive, variant })
            ),
            variant: variant === "line" ? "text" : "base",
            disabled: isLoading || option.disabled,
            label: option.label,
            leftIcon: option.leftIcon ?? void 0,
            onClick: (ev) => handleTabClick(ev, option, tabIndex),
            padding: variant === "line" ? "2" : void 0,
            paddingLeft: option.leftIcon ? "1" : "2",
            size: size2,
            borderRadius: "circle"
          }
        )
      },
      tabIndex
    );
  }) }) });
};
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$4,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$1 = "TabsTrigger";
var TabsTrigger$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME$1, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$1;
var CONTENT_NAME$1 = "TabsContent";
var TabsContent$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME$1, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = React__namespace.useRef(isSelected);
    React__namespace.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2$1 = Tabs$1;
var List = TabsList$1;
var Trigger$1 = TabsTrigger$1;
var Content = TabsContent$1;
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Content,
  List,
  Root: Root2$1,
  Tabs: Tabs$1,
  TabsContent: TabsContent$1,
  TabsList: TabsList$1,
  TabsTrigger: TabsTrigger$1,
  Trigger: Trigger$1,
  createTabsScope
}, Symbol.toStringTag, { value: "Module" }));
var list = "_10c8o0n1 _10c8o0n0 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr11l8 fyvr11m4 fyvr12g fyvr11wr fyvr14w";
var trigger = "_10c8o0n3 _10c8o0n2 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr130x fyvr130r fyvr12g fyvr164 fyvr12zf fyvr11m4 fyvr11sl fyvr11rc fyvr12wf";
var selector = "_10c8o0n5 _10c8o0n4 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr11lw fyvr1m0 fyvr1qg fyvr14k fyvr11y3 fyvr130f";
var content$1 = "_10c8o0n6 fyvr130x fyvr130r";
const Tabs = (props) => {
  const { tabs, onValueChange, ...rest } = props;
  const [selectedValue, setSelectedValue] = React.useState(
    rest.defaultValue
  );
  if (!tabs.length) {
    return null;
  }
  const handleValueChange = (value) => {
    setSelectedValue(value);
    onValueChange == null ? void 0 : onValueChange(value);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$1, { onValueChange: handleValueChange, ...rest, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TabsHeader, { tabs, value: selectedValue }),
    tabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content,
      {
        className: content$1,
        value: tab.value,
        children: tab.content
      },
      tab.value
    ))
  ] });
};
const TabsHeader = (props) => {
  const { tabs, value } = props;
  if (!tabs.length) {
    return null;
  }
  const selectorWidth = 100 / tabs.length;
  const selectedIdx = tabs.findIndex((tab) => tab.value === value);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(List, { className: list, style: { outline: void 0 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { display: "flex", position: "absolute", inset: "2", height: "8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: selector,
        style: {
          width: `${selectorWidth}%`,
          transform: `translateX(${selectedIdx * 100}%)`
        }
      }
    ) }),
    tabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Trigger$1,
      {
        className: trigger,
        value: tab.value,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "normal", fontWeight: "bold", children: tab.label })
      },
      tab.value
    ))
  ] });
};
const TabsRoot = Root2$1;
const TabsList = TabsList$1;
const TabsTrigger = TabsTrigger$1;
const TabsContent = TabsContent$1;
var tagStyle = "_1ppqbnx1 _1qxj1ib9 _1qxj1ibg _1qxj1ib6 fyvr11r3 fyvr11ig fyvr11k4 fyvr11k0 fyvr11jk _1ppqbnx0 fyvr11h4 fyvr11hs fyvr11fs fyvr11gg fyvr1zc fyvr111g fyvr1v0 fyvr1x4 fyvr11lk fyvr11cc fyvr11rh";
const Tag = React.forwardRef(
  (props, ref) => {
    const { icon: Icon2, label, ...rest } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        className: tagStyle,
        ref,
        background: "buttonGlass",
        color: "text80",
        ...rest,
        children: [
          Icon2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, { size: "xs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: label })
        ]
      }
    );
  }
);
var PROVIDER_NAME$1 = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME$1);
var ToastProvider$1 = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport2, setViewport] = React__namespace.useState(null);
  const [toastCount, setToastCount] = React__namespace.useState(0);
  const isFocusedToastEscapeKeyDownRef = React__namespace.useRef(false);
  const isClosePausedRef = React__namespace.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME$1}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport: viewport2,
      onViewportChange: setViewport,
      onToastAdd: React__namespace.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: React__namespace.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider$1.displayName = PROVIDER_NAME$1;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = React__namespace.useRef(null);
    const headFocusProxyRef = React__namespace.useRef(null);
    const tailFocusProxyRef = React__namespace.useRef(null);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    React__namespace.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a;
        const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) (_a = ref.current) == null ? void 0 : _a.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    React__namespace.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport2 = ref.current;
      if (hasToasts && wrapper && viewport2) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport2.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport2.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = React__namespace.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    React__namespace.useEffect(() => {
      const viewport2 = ref.current;
      if (viewport2) {
        const handleKeyDown = (event) => {
          var _a, _b, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport2;
            if (targetIsViewport && isTabbingBackwards) {
              (_a = headFocusProxyRef.current) == null ? void 0 : _a.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b = headFocusProxyRef.current) == null ? void 0 : _b.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
            }
          }
        };
        viewport2.addEventListener("keydown", handleKeyDown);
        return () => viewport2.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden$1,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a = context.viewport) == null ? void 0 : _a.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open = true, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = React__namespace.useRef(null);
    const swipeDeltaRef = React__namespace.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = React__namespace.useRef(0);
    const closeTimerRemainingTimeRef = React__namespace.useRef(duration);
    const closeTimerRef = React__namespace.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef$1(() => {
      var _a;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast) (_a = context.viewport) == null ? void 0 : _a.focus();
      onClose();
    });
    const startTimer = React__namespace.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    React__namespace.useEffect(() => {
      const viewport2 = context.viewport;
      if (viewport2) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport2.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport2.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport2.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport2.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    React__namespace.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    React__namespace.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = React__namespace.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: ReactDOM__namespace.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$6,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = React__namespace.useState(false);
  const [isAnnounced, setIsAnnounced] = React__namespace.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  React__namespace.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden$1, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME;
var ToastAnnounceExclude = React__namespace.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider$1 = ToastProvider$1;
var Viewport = ToastViewport$1;
var Root2 = Toast$1;
var Title = ToastTitle;
var Description = ToastDescription;
var Close = ToastClose;
var viewport = "_6wut8v1 _6wut8v0 fyvr130x fyvr130r fyvr11m0 fyvr1so fyvr1o8 fyvr12g fyvr11cg fyvr11mc fyvr11l8";
var toast = createRuntimeFn({ defaultClassName: "_6wut8v3", variantClassNames: { variant: { normal: "_6wut8v4", success: "_6wut8v5", error: "_6wut8v6" } }, defaultVariants: {}, compoundVariants: [] });
const ToastQueueContext = React.createContext(null);
const ToastProvider = (props) => {
  const { children, ...rest } = props;
  const [toasts, setToasts] = React.useState(/* @__PURE__ */ new Set());
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Provider$1, { ...rest, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastQueueContext.Provider, { value: setToasts, children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(framerMotion.AnimatePresence, { children: Array.from(toasts).map((toast2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Toast, { ...toast2 }, toast2.id)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
  ] });
};
const ToastViewport = () => /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport, { className: viewport });
const Toast = (props) => {
  const {
    id,
    variant,
    title,
    description,
    icon: Icon2,
    isDismissible = true,
    ...rest
  } = props;
  const renderIcon = () => {
    if (Icon2) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon2, {});
    }
    switch (variant) {
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            background: "positive",
            color: "black",
            borderRadius: "circle",
            width: "8",
            height: "8",
            placeItems: "center",
            minWidth: "0",
            flexShrink: "0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCheckmarkIcon, {})
          }
        );
      case "error":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            background: "negative",
            color: "black",
            borderRadius: "circle",
            width: "8",
            height: "8",
            placeItems: "center",
            minWidth: "0",
            flexShrink: "0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgCloseIcon, {})
          }
        );
      default:
        return null;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2,
    {
      className: toast({ variant }),
      open: true,
      forceMount: true,
      asChild: true,
      ...rest,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Card,
        {
          as: framerMotion.motion.li,
          layoutId: id,
          layout: true,
          initial: { x: "100%" },
          animate: { x: 0 },
          exit: { y: "100%", opacity: 0 },
          borderRadius: "md",
          background: "buttonGlass",
          backdropFilter: "blur",
          position: "relative",
          width: "full",
          justifyContent: "space-between",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { gap: "3", alignItems: "center", children: [
              renderIcon(),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flexDirection: "column", gap: "1", children: [
                title && /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Text,
                  {
                    as: "div",
                    variant: "normal",
                    fontWeight: "bold",
                    color: "text80",
                    children: title
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Text,
                  {
                    as: "div",
                    variant: "normal",
                    fontWeight: "medium",
                    color: "text50",
                    children: description
                  }
                ) })
              ] })
            ] }),
            isDismissible && /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { "aria-label": "Close", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { icon: SvgCloseIcon, size: "xs" }) })
          ]
        }
      )
    }
  );
};
const useToast = () => {
  const setToasts = React.useContext(ToastQueueContext);
  return (props) => {
    const toast2 = {
      ...props,
      id: Math.random().toString(36).slice(2, 12),
      onOpenChange: (open) => {
        if (!open) {
          setToasts((toasts) => {
            toasts.delete(toast2);
            return /* @__PURE__ */ new Set([...toasts]);
          });
        }
      }
    };
    setToasts((toasts) => /* @__PURE__ */ new Set([...toasts, toast2]));
  };
};
var textarea = "_15pztn1 _1qxj1ib9 _1qxj1ibe _1qxj1ib4 fyvr11r3 fyvr11io fyvr11k8 fyvr11k0 fyvr11j8 _15pztn0 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go fyvr1vc fyvr1xg fyvr1zk fyvr111o fyvr11ow fyvr11sl fyvr12w9 fyvr12s9 fyvr130r fyvr12g fyvr11l8";
var resize = "_15pztn2";
const TextArea = React.forwardRef(
  (props, ref) => {
    const {
      as = "textarea",
      autoComplete = "off",
      borderRadius = "md",
      description,
      disabled = false,
      id,
      label = "",
      labelLocation = "hidden",
      name,
      rows,
      resize: resize$1 = false,
      ...rest
    } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Field,
      {
        description,
        disabled,
        display: "grid",
        id: id ?? name,
        label,
        labelLocation,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            as,
            autoComplete,
            spellCheck: "false",
            className: clsx(textarea, resize$1 && resize),
            disabled,
            id: id ?? name,
            name,
            ref,
            rows,
            borderRadius,
            ...rest
          }
        )
      }
    );
  }
);
const ControlledTextArea = ({
  defaultValue,
  name,
  control,
  rules,
  ...rest
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Controller,
  {
    defaultValue,
    name,
    control,
    rules,
    render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TextArea, { ...field, ...rest })
  }
);
var root$1 = createRuntimeFn({ defaultClassName: "_18h918k5 _18h918k0 fyvr11q0 fyvr11qg fyvr11no fyvr11ow fyvr11l8", variantClassNames: { size: { xs: "_18h918k6", sm: "_18h918k7", md: "_18h918k8", lg: "_18h918k9", xl: "_18h918ka" }, borderRadius: { circle: "_18h918kb _18h918k1 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw", lg: "_18h918kc _18h918k2 fyvr11hg fyvr11i4 fyvr11g4 fyvr11gs", md: "_18h918kd _18h918k3 fyvr11hc fyvr11i0 fyvr11g0 fyvr11go", sm: "_18h918ke _18h918k4 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk" } }, defaultVariants: {}, compoundVariants: [] });
var img$1 = "_18h918kf";
const NetworkImage = React.memo((props) => {
  const {
    chainId,
    borderRadius = "circle",
    className,
    disableAnimation = false,
    style,
    src,
    size: size2 = "md",
    ...boxProps
  } = props;
  const logoURI = src || replaceSize(networkImageUrl(chainId), size2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      className: clsx(className, root$1({ borderRadius, size: size2 })),
      style,
      flexShrink: "0",
      ...boxProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Image,
        {
          className: img$1,
          disableAnimation,
          src: logoURI
        }
      )
    }
  );
});
var root = createRuntimeFn({ defaultClassName: "bnrreb1 bnrreb0 fyvr11no fyvr11ow fyvr11m4 fyvr11l8", variantClassNames: { size: { xs: "bnrreb2", sm: "bnrreb3", md: "bnrreb4", lg: "bnrreb5", xl: "bnrreb6" } }, defaultVariants: {}, compoundVariants: [] });
var img = "bnrreb7";
var fallback = "bnrreb9 bnrreb8 fyvr11hk fyvr11i8 fyvr11g8 fyvr11gw fyvr11q0 fyvr11qg fyvr11no fyvr11ow fyvr11wr fyvr12g fyvr164 fyvr11l8";
var cutout = "bnrreba";
const NETWORK_IMAGE_SIZE = "40%";
const NETWORK_IMAGE_OFFSET = "-2%";
const TokenImage = React.memo((props) => {
  const {
    borderRadius = "circle",
    className,
    disableAnimation = false,
    style,
    src,
    symbol,
    size: size2 = "md",
    withNetwork,
    ...boxProps
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      className: clsx(className, root({ size: size2 })),
      style,
      flexShrink: "0",
      ...boxProps,
      children: [
        src ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Image,
          {
            className: clsx(img, withNetwork && cutout),
            disableAnimation,
            borderRadius,
            overflow: "hidden",
            src
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Text,
          {
            className: clsx(fallback, withNetwork && cutout),
            variant: "normal",
            fontWeight: "medium",
            color: "text50",
            borderRadius,
            overflow: "hidden",
            uppercase: true,
            children: symbol == null ? void 0 : symbol.replace(/\s/, "").slice(0, 4)
          }
        ),
        withNetwork && /* @__PURE__ */ jsxRuntimeExports.jsx(
          NetworkImage,
          {
            chainId: withNetwork,
            position: "absolute",
            zIndex: "1",
            disableAnimation,
            style: {
              width: NETWORK_IMAGE_SIZE,
              height: NETWORK_IMAGE_SIZE,
              right: NETWORK_IMAGE_OFFSET,
              bottom: NETWORK_IMAGE_OFFSET
            }
          }
        )
      ]
    }
  );
});
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const [isOpenDelayed, setIsOpenDelayed] = React__namespace.useState(true);
  const isPointerInTransitRef = React__namespace.useRef(false);
  const skipDelayTimerRef = React__namespace.useRef(0);
  React__namespace.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayed,
      delayDuration,
      onOpen: React__namespace.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        setIsOpenDelayed(false);
      }, []),
      onClose: React__namespace.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => setIsOpenDelayed(true),
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React__namespace.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger2, setTrigger] = React__namespace.useState(null);
  const contentId = useId();
  const openTimerRef = React__namespace.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React__namespace.useRef(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    }
  });
  const stateAttribute = React__namespace.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React__namespace.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React__namespace.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React__namespace.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React__namespace.useEffect(() => {
    return () => window.clearTimeout(openTimerRef.current);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: React__namespace.useCallback(() => {
        if (providerContext.isOpenDelayed) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React__namespace.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React__namespace.useRef(false);
    const hasPointerMoveOpenedRef = React__namespace.useRef(false);
    const handlePointerUp = React__namespace.useCallback(() => isPointerDownRef.current = false, []);
    React__namespace.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "TooltipContent";
var TooltipContent = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React__namespace.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);
  const ref = React__namespace.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React__namespace.useState(null);
  const { trigger: trigger2, onClose } = context;
  const content2 = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React__namespace.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React__namespace.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React__namespace.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React__namespace.useEffect(() => {
    if (trigger2 && content2) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content2);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content2.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content2.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content2, handleCreateGraceArea, handleRemoveGraceArea]);
  React__namespace.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content2 == null ? void 0 : content2.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content2, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var TooltipContentImpl = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React__namespace.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React__namespace.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME;
var ARROW_NAME = "TooltipArrow";
var TooltipArrow = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root3 = Tooltip$1;
var Trigger = TooltipTrigger;
var Portal = TooltipPortal;
var Content2 = TooltipContent;
var Arrow2 = TooltipArrow;
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arrow: Arrow2,
  Content: Content2,
  Portal,
  Provider,
  Root: Root3,
  Tooltip: Tooltip$1,
  TooltipArrow,
  TooltipContent,
  TooltipPortal,
  TooltipProvider,
  TooltipTrigger,
  Trigger,
  createTooltipScope
}, Symbol.toStringTag, { value: "Module" }));
var content = "q888p21 q888p20 fyvr11h8 fyvr11hw fyvr11fw fyvr11gk fyvr1zk fyvr111o fyvr11r0 fyvr11xx fyvr1xc fyvr1v4";
const Tooltip = (props) => {
  const {
    align = "center",
    children,
    delayDuration = 0,
    disabled = false,
    hOffset = 0,
    message,
    side = "top",
    vOffset = 0
  } = props;
  return disabled ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root3, { delayDuration, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { asChild: true, children }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Content2,
      {
        className: content,
        side,
        align,
        sideOffset: vOffset,
        alignOffset: hOffset,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { variant: "small", fontWeight: "medium", color: "text80", children: message }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { offset: 12, width: 10, height: 5 })
        ]
      }
    )
  ] }) });
};
const VisuallyHidden = Root$1;
const useMediaQuery = (queryInput, options = {}) => {
  const bp = (/* @__PURE__ */ new Map()).set("isMobile", `@media screen and (max-width: ${breakpoints.lg - 1}px)`).set("isDesktop", `@media screen and (min-width: ${breakpoints.lg}px)`);
  if (!queryInput.startsWith("@media")) {
    const bpQuery = bp.get(queryInput);
    if (!bpQuery || bpQuery === "") {
      throw new Error(
        `useMediaQuery failed to get breakpoint from theme for: ${queryInput}`
      );
    }
    queryInput = bpQuery;
  }
  const query = queryInput.replace(/^@media( ?)/m, "");
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const { defaultMatches = false } = options;
  const [match, setMatch] = React.useState(() => {
    if (supportMatchMedia) {
      return window.matchMedia(query).matches;
    }
    return defaultMatches;
  });
  React.useEffect(() => {
    let active = true;
    if (!supportMatchMedia) {
      return void 0;
    }
    const queryList = window.matchMedia(query);
    const updateMatch = () => {
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, supportMatchMedia]);
  return match;
};
exports.AddIcon = SvgAddIcon;
exports.AirDropperIcon = SvgAirDropperIcon;
exports.AppleIcon = SvgAppleIcon;
exports.ArrowDownIcon = SvgArrowDownIcon;
exports.ArrowRightIcon = SvgArrowRightIcon;
exports.Badge = Badge;
exports.Box = Box;
exports.Breadcrumbs = Breadcrumbs;
exports.BridgeIcon = SvgBridgeIcon;
exports.Button = Button;
exports.Card = Card;
exports.Checkbox = Checkbox;
exports.CheckmarkIcon = SvgCheckmarkIcon;
exports.ChevronDownIcon = SvgChevronDownIcon;
exports.ChevronLeftIcon = SvgChevronLeftIcon;
exports.ChevronRightIcon = SvgChevronRightIcon;
exports.ChevronUpIcon = SvgChevronUpIcon;
exports.CloseIcon = SvgCloseIcon;
exports.Collapsible = Collapsible;
exports.CollapsiblePrimitive = index$5;
exports.ContactsIcon = SvgContactsIcon;
exports.ContextMenuIcon = SvgContextMenuIcon;
exports.ContractIcon = SvgContractIcon;
exports.ControlledCheckbox = ControlledCheckbox;
exports.ControlledFileInput = ControlledFileInput;
exports.ControlledRadioGroup = ControlledRadioGroup;
exports.ControlledSelect = ControlledSelect;
exports.ControlledSwitch = ControlledSwitch;
exports.ControlledTextArea = ControlledTextArea;
exports.ControlledTextInput = ControlledTextInput;
exports.CopyIcon = SvgCopyIcon;
exports.CurrencyIcon = SvgCurrencyIcon;
exports.DashedCircleIcon = SvgDashedCircleIcon;
exports.DeployIcon = SvgDeployIcon;
exports.DeviceIcon = SvgDeviceIcon;
exports.DiscordIcon = SvgDiscordIcon;
exports.Divider = Divider;
exports.DocsIcon = SvgDocsIcon;
exports.DownloadIcon = SvgDownloadIcon;
exports.DragIcon = SvgDragIcon;
exports.DropdownMenuCheckboxItem = DropdownMenuCheckboxItem;
exports.DropdownMenuContent = DropdownMenuContent;
exports.DropdownMenuItem = DropdownMenuItem;
exports.DropdownMenuPortal = DropdownMenuPortal;
exports.DropdownMenuPrimitive = index$3;
exports.DropdownMenuRadioGroup = DropdownMenuRadioGroup;
exports.DropdownMenuRadioItem = DropdownMenuRadioItem;
exports.DropdownMenuRoot = DropdownMenuRoot;
exports.DropdownMenuSeparator = DropdownMenuSeparator;
exports.DropdownMenuTrigger = DropdownMenuTrigger;
exports.EditIcon = SvgEditIcon;
exports.EmailIcon = SvgEmailIcon;
exports.ExpandIcon = SvgExpandIcon;
exports.ExternalLinkIcon = SvgExternalLinkIcon;
exports.FacebookIcon = SvgFacebookIcon;
exports.Field = Field;
exports.FileInput = FileInput;
exports.Form = Form;
exports.GasTankIcon = SvgGasTankIcon;
exports.GlobeIcon = SvgGlobeIcon;
exports.GoogleIcon = SvgGoogleIcon;
exports.GradientAvatar = GradientAvatar;
exports.GridIcon = SvgGridIcon;
exports.HelpIcon = SvgHelpIcon;
exports.HiddenIcon = SvgHiddenIcon;
exports.HomeIcon = SvgHomeIcon;
exports.IconButton = IconButton;
exports.Image = Image;
exports.IndexerIcon = SvgIndexerIcon;
exports.KeyIcon = SvgKeyIcon;
exports.LinkIcon = SvgLinkIcon;
exports.ListIcon = SvgListIcon;
exports.MarketplacesIcon = SvgMarketplacesIcon;
exports.MenuIcon = SvgMenuIcon;
exports.MinterIcon = SvgMinterIcon;
exports.Modal = Modal;
exports.ModalPrimitive = index$2;
exports.MoonIcon = SvgMoonIcon;
exports.NetworkIcon = SvgNetworkIcon;
exports.NetworkImage = NetworkImage;
exports.NodeIcon = SvgNodeIcon;
exports.NumericInput = NumericInput;
exports.PINCodeInput = PINCodeInput;
exports.PaymentsIcon = SvgPaymentsIcon;
exports.PinIcon = SvgPinIcon;
exports.Placeholder = Skeleton;
exports.ProfileIcon = SvgProfileIcon;
exports.Progress = Progress;
exports.QrCodeIcon = SvgQrCodeIcon;
exports.RadioGroup = RadioGroup;
exports.ReceiveIcon = SvgReceiveIcon;
exports.RefreshIcon = SvgRefreshIcon;
exports.RelayerIcon = SvgRelayerIcon;
exports.ScanIcon = SvgScanIcon;
exports.Scroll = Scroll;
exports.SearchIcon = SvgSearchIcon;
exports.SearchInput = SearchInput;
exports.Select = Select;
exports.SendIcon = SvgSendIcon;
exports.SequenceIcon = SvgSequenceIcon;
exports.SettingsIcon = SvgSettingsIcon;
exports.ShareIcon = SvgShareIcon;
exports.ShieldIcon = SvgShieldIcon;
exports.SignoutIcon = SvgSignoutIcon;
exports.Skeleton = Skeleton;
exports.Spinner = Spinner;
exports.StopClickPropagation = StopClickPropagation;
exports.SubtractIcon = SvgSubtractIcon;
exports.SunIcon = SvgSunIcon;
exports.SwapIcon = SvgSwapIcon;
exports.Switch = Switch;
exports.TabbedNav = TabbedNav;
exports.Tabs = Tabs;
exports.TabsContent = TabsContent;
exports.TabsHeader = TabsHeader;
exports.TabsList = TabsList;
exports.TabsPrimitive = index$1;
exports.TabsRoot = TabsRoot;
exports.TabsTrigger = TabsTrigger;
exports.Tag = Tag;
exports.Text = Text;
exports.TextArea = TextArea;
exports.TextInput = TextInput;
exports.ThemeProvider = ThemeProvider;
exports.Toast = Toast;
exports.ToastProvider = ToastProvider;
exports.TokenImage = TokenImage;
exports.Tooltip = Tooltip;
exports.TooltipPrimitive = index;
exports.TransactionIcon = SvgTransactionIcon;
exports.TrashIcon = SvgTrashIcon;
exports.TwitchIcon = SvgTwitchIcon;
exports.UploadIcon = SvgUploadIcon;
exports.VisibleIcon = SvgVisibleIcon;
exports.VisuallyHidden = VisuallyHidden;
exports.WalletConnectIcon = SvgWalletConnectIcon;
exports.WalletIcon = SvgWalletIcon;
exports.WarningIcon = SvgWarningIcon;
exports.ZERO_ADDRESS = ZERO_ADDRESS;
exports.atoms = atoms;
exports.breakpoints = breakpoints;
exports.capitalize = capitalize;
exports.compareAddress = compareAddress;
exports.focusRing = focusRing;
exports.isTruthy = isTruthy;
exports.kebabize = kebabize;
exports.layers = layers_css;
exports.nativeTokenImageUrl = nativeTokenImageUrl;
exports.networkImageUrl = networkImageUrl;
exports.pluralize = pluralize;
exports.replaceSize = replaceSize;
exports.responsiveStyle = responsiveStyle;
exports.selectorize = selectorize;
exports.textVariants = textVariants;
exports.tokenImageUrl = tokenImageUrl;
exports.tokens = tokens;
exports.truncateAddress = truncateAddress;
exports.useCombinedRefs = useCombinedRefs;
exports.useMediaQuery = useMediaQuery;
exports.useTheme = useTheme;
exports.useToast = useToast;
exports.vars = vars;
