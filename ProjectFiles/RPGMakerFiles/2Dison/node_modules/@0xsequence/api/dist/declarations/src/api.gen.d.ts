export declare const WebRPCVersion = "v1";
export declare const WebRPCSchemaVersion = "v0.4.0";
export declare const WebRPCSchemaHash = "470a0f88ea399c2a57ff8c22da54358c033ed5f0";
export declare enum SortOrder {
    DESC = "DESC",
    ASC = "ASC"
}
export declare enum SardinePaymentType {
    ach = "ach",
    debit = "debit",
    credit = "credit",
    us_debit = "us_debit",
    international_debit = "international_debit",
    international_credit = "international_credit"
}
export declare enum SardineQuoteType {
    buy = "buy",
    sell = "sell"
}
export declare enum TokenType {
    ERC20 = "ERC20",
    ERC721 = "ERC721",
    ERC1155 = "ERC1155"
}
export interface Version {
    webrpcVersion: string;
    schemaVersion: string;
    schemaHash: string;
    appVersion: string;
}
export interface RuntimeStatus {
    healthOK: boolean;
    startTime: string;
    uptime: number;
    ver: string;
    branch: string;
    commitHash: string;
    checks: RuntimeChecks;
    numTxnsRelayed: {
        [key: string]: NumTxnsRelayed;
    };
}
export interface NumTxnsRelayed {
    chainID: number;
    prev: number;
    current: number;
    period: number;
}
export interface RuntimeChecks {
}
export interface SequenceContext {
    factory: string;
    mainModule: string;
    mainModuleUpgradable: string;
    guestModule: string;
    utils: string;
}
export interface User {
    address: string;
    username: string;
    avatar: string;
    bio: string;
    location: string;
    locale: string;
    backup?: boolean;
    backupConfirmed?: boolean;
    maxInvites?: number;
    updatedAt?: string;
    createdAt?: string;
}
export interface WalletBackup {
    accountAddress: string;
    secretHash: string;
    encryptedWallet: string;
    userConfirmed: boolean;
    updatedAt?: string;
    createdAt?: string;
}
export interface Friend {
    id: number;
    userAddress: string;
    friendAddress: string;
    nickname: string;
    user?: User;
    createdAt?: string;
}
export interface InviteCode {
    usesLeft: number;
    ownerAccount: string;
    email?: string;
    url: string;
    createdAt?: string;
    expiresAt?: string;
}
export interface InviteCodeAccount {
    claimedByUserAddress: string;
    claimedAt?: string;
}
export interface InviteInfo {
    expiryInHours: number;
    max: number;
    invites: Array<InviteCode>;
}
export interface ContractCall {
    signature: string;
    function: string;
    args: Array<TupleComponent>;
}
export interface TupleComponent {
    name?: string;
    type: string;
    value: any;
}
export interface Transaction {
    delegateCall: boolean;
    revertOnError: boolean;
    gasLimit: string;
    target: string;
    value: string;
    data: string;
    call?: ContractCall;
}
export interface UserStorage {
    userAddress: string;
    key: string;
    value: any;
}
export interface Token {
    chainId: number;
    contractAddress: string;
    tokenId?: string;
}
export interface Price {
    value: number;
    currency: string;
}
export interface TokenPrice {
    token: Token;
    price?: Price;
    price24hChange?: Price;
    floorPrice: Price;
    buyPrice: Price;
    sellPrice: Price;
    updatedAt: string;
}
export interface ExchangeRate {
    name: string;
    symbol: string;
    value: number;
    vsCurrency: string;
    currencyType: string;
}
export interface LinkedWallet {
    id: number;
    walletType?: string;
    walletAddress: string;
    linkedWalletAddress: string;
    createdAt?: string;
}
export interface Page {
    pageSize?: number;
    page?: number;
    totalRecords?: number;
    column?: string;
    before?: any;
    after?: any;
    sort?: Array<SortBy>;
    more?: boolean;
}
export interface SortBy {
    column: string;
    order: SortOrder;
}
export interface SardineNFTCheckoutParams {
    name: string;
    imageUrl: string;
    network: string;
    recipientAddress: string;
    blockchainNftId: string;
    contractAddress: string;
    quantity: number;
    decimals?: number;
    tokenAmount: string;
    tokenAddress: string;
    tokenSymbol: string;
    tokenDecimals?: number;
    calldata: string;
    platform: string;
    approvedSpenderAddress?: string;
}
export interface SardineNFTCheckout {
    token: string;
    expiresAt: string;
    orderId: string;
}
export interface SardineOrder {
    id: string;
    createdAt?: string;
    referenceId: string;
    status: string;
    fiatCurrency: string;
    fiatExchangeRateUSD: number;
    transactionId: string;
    expiresAt?: string;
    total: number;
    subTotal: number;
    transactionFee: number;
    networkFee: number;
    paymentCurrency?: string;
    paymentMethodType?: string;
    transactionType: string;
    name: string;
    price: number;
    imageUrl: string;
    contractAddress?: string;
    transactionHash?: string;
    recipientAddress: string;
}
export interface SardineRegion {
    countryCode: string;
    isAllowedOnRamp: boolean;
    isAllowedOnNFT: boolean;
    isBasicKycRequired: Array<string>;
    isSsnRequired: Array<string>;
    name: string;
    currencyCode: string;
    isPayrollSupported: boolean;
    supportedDocuments: Array<string>;
    paymentMethods: Array<SardineRegionPaymentMethod>;
    states: Array<SardineRegionState>;
}
export interface SardineRegionPaymentMethod {
    name: string;
    isAllowedOnRamp: boolean;
    isAllowedOnNFT: boolean;
    subTypes: Array<string>;
    type: string;
    subType: string;
}
export interface SardineRegionState {
    code: string;
    name: string;
    isAllowedOnRamp: boolean;
    isAllowedOnNFT: boolean;
}
export interface SardineSupportedToken {
    network: string;
    assetSymbol: string;
    assetName: string;
    chainId: string;
    tokenName: string;
    token: string;
    tokenAddress: string;
}
export interface SardineEnabledToken {
    network: string;
    assetSymbol: string;
    assetName: string;
    chainId: string;
    tokenName: string;
    token: string;
    tokenAddress: string;
}
export interface SardineGetQuoteParams {
    assetType: string;
    network: string;
    total: number;
    currency?: string;
    paymentType?: SardinePaymentType;
    quoteType?: SardineQuoteType;
    walletAddress?: string;
}
export interface SardineQuote {
    quantity: number;
    network: string;
    assetType: string;
    total: number;
    currency: string;
    expiresAt: string;
    paymentType: string;
    price: number;
    subtotal: number;
    transactionFee: number;
    networkFee: number;
    highNetworkFee: boolean;
    minTransactionValue: number;
    maxTransactionValue: number;
    liquidityProvider: string;
}
export interface SardineFiatCurrency {
    currencyCode: string;
    name: string;
    currencySymbol: string;
    paymentOptions: Array<SardinePaymentOption>;
    supportingCountries: Array<string>;
}
export interface SardinePaymentOption {
    name: string;
    dailyLimit: number;
    weeklyLimit: number;
    monthlyLimit: number;
    maxAmount: number;
    minAmount: number;
    subTypes: Array<string>;
    type: string;
    subType: string;
    processingTime: string;
}
export interface SwapPrice {
    currencyAddress: string;
    currencyBalance: string;
    price: string;
    to: string;
    transactionValue: string;
}
export interface SwapQuote {
    currencyAddress: string;
    currencyBalance: string;
    price: string;
    maxPrice: string;
    to: string;
    transactionData: string;
    transactionValue: string;
    approveData: string;
}
export interface CurrencyGroup {
    name: string;
    tokens: Array<CurrencyGroupToken>;
}
export interface CurrencyGroupToken {
    chainId: number;
    tokenAddress: string;
}
export interface OffchainInventory {
    id: number;
    projectId: number;
    chainId: number;
    externalProductId: string;
    paymentTokenAddress: string;
    paymentTokenType: TokenType;
    paymentTokenId: number;
    paymentAmount: number;
    paymentRecipient: string;
    chainedCallAddress?: string;
    chainedCallData?: string;
    allowCrossChainPayments?: boolean;
    callbackURL?: string;
    createdAt: string;
    deletedAt?: string;
}
export interface OffchainPayment {
    id: number;
    offchainInventoryId: number;
    productRecipient: string;
    paymentChainId: number;
    paymentTokenAddress: string;
    expiration: string;
    createdAt: string;
    completedAt?: string;
    processedAt?: string;
}
export interface PaymentResponse {
    paymentId: number;
    offchainInventoryId: number;
    chainId: number;
    externalProductId: string;
    paymentTokenAddress: string;
    paymentTokenType: TokenType;
    paymentTokenId: number;
    paymentTotal: number;
    expiration: string;
    signature: string;
    txTo: string;
    txData: string;
}
export interface API {
    ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>;
    version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>;
    runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>;
    clock(headers?: object, signal?: AbortSignal): Promise<ClockReturn>;
    getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn>;
    getAuthToken(args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenReturn>;
    getAuthToken2(args: GetAuthToken2Args, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Return>;
    sendPasswordlessLink(args: SendPasswordlessLinkArgs, headers?: object, signal?: AbortSignal): Promise<SendPasswordlessLinkReturn>;
    friendList(args: FriendListArgs, headers?: object, signal?: AbortSignal): Promise<FriendListReturn>;
    getFriendByAddress(args: GetFriendByAddressArgs, headers?: object, signal?: AbortSignal): Promise<GetFriendByAddressReturn>;
    searchFriends(args: SearchFriendsArgs, headers?: object, signal?: AbortSignal): Promise<SearchFriendsReturn>;
    addFriend(args: AddFriendArgs, headers?: object, signal?: AbortSignal): Promise<AddFriendReturn>;
    updateFriendNickname(args: UpdateFriendNicknameArgs, headers?: object, signal?: AbortSignal): Promise<UpdateFriendNicknameReturn>;
    removeFriend(args: RemoveFriendArgs, headers?: object, signal?: AbortSignal): Promise<RemoveFriendReturn>;
    contractCall(args: ContractCallArgs, headers?: object, signal?: AbortSignal): Promise<ContractCallReturn>;
    decodeContractCall(args: DecodeContractCallArgs, headers?: object, signal?: AbortSignal): Promise<DecodeContractCallReturn>;
    lookupContractCallSelectors(args: LookupContractCallSelectorsArgs, headers?: object, signal?: AbortSignal): Promise<LookupContractCallSelectorsReturn>;
    userStorageFetch(args: UserStorageFetchArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchReturn>;
    userStorageSave(args: UserStorageSaveArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveReturn>;
    userStorageDelete(args: UserStorageDeleteArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageDeleteReturn>;
    userStorageFetchAll(args: UserStorageFetchAllArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchAllReturn>;
    getMoonpayLink(args: GetMoonpayLinkArgs, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkReturn>;
    resolveENSAddress(args: ResolveENSAddressArgs, headers?: object, signal?: AbortSignal): Promise<ResolveENSAddressReturn>;
    isValidSignature(args: IsValidSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidSignatureReturn>;
    isValidMessageSignature(args: IsValidMessageSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidMessageSignatureReturn>;
    isValidTypedDataSignature(args: IsValidTypedDataSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidTypedDataSignatureReturn>;
    isValidETHAuthProof(args: IsValidETHAuthProofArgs, headers?: object, signal?: AbortSignal): Promise<IsValidETHAuthProofReturn>;
    sardineGetClientToken(headers?: object, signal?: AbortSignal): Promise<SardineGetClientTokenReturn>;
    sardineGetNFTCheckoutToken(args: SardineGetNFTCheckoutTokenArgs, headers?: object, signal?: AbortSignal): Promise<SardineGetNFTCheckoutTokenReturn>;
    sardineGetNFTCheckoutOrderStatus(args: SardineGetNFTCheckoutOrderStatusArgs, headers?: object, signal?: AbortSignal): Promise<SardineGetNFTCheckoutOrderStatusReturn>;
    sardineGetSupportedRegions(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedRegionsReturn>;
    sardineGetSupportedFiatCurrencies(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedFiatCurrenciesReturn>;
    sardineGetSupportedTokens(headers?: object, signal?: AbortSignal): Promise<SardineGetSupportedTokensReturn>;
    sardineGetEnabledTokens(headers?: object, signal?: AbortSignal): Promise<SardineGetEnabledTokensReturn>;
    sardineGetQuote(args: SardineGetQuoteArgs, headers?: object, signal?: AbortSignal): Promise<SardineGetQuoteReturn>;
    getSardineClientToken(headers?: object, signal?: AbortSignal): Promise<GetSardineClientTokenReturn>;
    getSardineNFTCheckoutToken(args: GetSardineNFTCheckoutTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetSardineNFTCheckoutTokenReturn>;
    getSardineNFTCheckoutOrderStatus(args: GetSardineNFTCheckoutOrderStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetSardineNFTCheckoutOrderStatusReturn>;
    getCoinPrices(args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesReturn>;
    getCollectiblePrices(args: GetCollectiblePricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectiblePricesReturn>;
    getExchangeRate(args: GetExchangeRateArgs, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateReturn>;
    memoryStore(args: MemoryStoreArgs, headers?: object, signal?: AbortSignal): Promise<MemoryStoreReturn>;
    memoryLoad(args: MemoryLoadArgs, headers?: object, signal?: AbortSignal): Promise<MemoryLoadReturn>;
    getInviteInfo(headers?: object, signal?: AbortSignal): Promise<GetInviteInfoReturn>;
    isValidAccessCode(args: IsValidAccessCodeArgs, headers?: object, signal?: AbortSignal): Promise<IsValidAccessCodeReturn>;
    internalClaimAccessCode(args: InternalClaimAccessCodeArgs, headers?: object, signal?: AbortSignal): Promise<InternalClaimAccessCodeReturn>;
    blockNumberAtTime(args: BlockNumberAtTimeArgs, headers?: object, signal?: AbortSignal): Promise<BlockNumberAtTimeReturn>;
    paperSessionSecret(args: PaperSessionSecretArgs, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecretReturn>;
    paperSessionSecret2(args: PaperSessionSecret2Args, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecret2Return>;
    linkWallet(args: LinkWalletArgs, headers?: object, signal?: AbortSignal): Promise<LinkWalletReturn>;
    getLinkedWallets(args: GetLinkedWalletsArgs, headers?: object, signal?: AbortSignal): Promise<GetLinkedWalletsReturn>;
    removeLinkedWallet(args: RemoveLinkedWalletArgs, headers?: object, signal?: AbortSignal): Promise<RemoveLinkedWalletReturn>;
    generateWaaSVerificationURL(args: GenerateWaaSVerificationURLArgs, headers?: object, signal?: AbortSignal): Promise<GenerateWaaSVerificationURLReturn>;
    validateWaaSVerificationNonce(args: ValidateWaaSVerificationNonceArgs, headers?: object, signal?: AbortSignal): Promise<ValidateWaaSVerificationNonceReturn>;
    getSwapPrices(args: GetSwapPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapPricesReturn>;
    getSwapQuote(args: GetSwapQuoteArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapQuoteReturn>;
    listCurrencyGroups(headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsReturn>;
    addOffchainInventory(args: AddOffchainInventoryArgs, headers?: object, signal?: AbortSignal): Promise<AddOffchainInventoryReturn>;
    getOffchainInventory(args: GetOffchainInventoryArgs, headers?: object, signal?: AbortSignal): Promise<GetOffchainInventoryReturn>;
    listOffchainInventories(args: ListOffchainInventoriesArgs, headers?: object, signal?: AbortSignal): Promise<ListOffchainInventoriesReturn>;
    updateOffchainInventory(args: UpdateOffchainInventoryArgs, headers?: object, signal?: AbortSignal): Promise<UpdateOffchainInventoryReturn>;
    deleteOffchainInventory(args: DeleteOffchainInventoryArgs, headers?: object, signal?: AbortSignal): Promise<DeleteOffchainInventoryReturn>;
    requestOffchainPayment(args: RequestOffchainPaymentArgs, headers?: object, signal?: AbortSignal): Promise<RequestOffchainPaymentReturn>;
    listOffchainPayments(args: ListOffchainPaymentsArgs, headers?: object, signal?: AbortSignal): Promise<ListOffchainPaymentsReturn>;
}
export interface PingArgs {
}
export interface PingReturn {
    status: boolean;
}
export interface VersionArgs {
}
export interface VersionReturn {
    version: Version;
}
export interface RuntimeStatusArgs {
}
export interface RuntimeStatusReturn {
    status: RuntimeStatus;
}
export interface ClockArgs {
}
export interface ClockReturn {
    serverTime: string;
}
export interface GetSequenceContextArgs {
}
export interface GetSequenceContextReturn {
    data: SequenceContext;
}
export interface GetAuthTokenArgs {
    ewtString: string;
    testnetMode?: boolean;
}
export interface GetAuthTokenReturn {
    status: boolean;
    jwtToken: string;
    address: string;
    user?: User;
}
export interface GetAuthToken2Args {
    ewtString: string;
    chainID: string;
}
export interface GetAuthToken2Return {
    status: boolean;
    jwtToken: string;
    address: string;
    user?: User;
}
export interface SendPasswordlessLinkArgs {
    email: string;
    redirectUri: string;
    intent: string;
}
export interface SendPasswordlessLinkReturn {
    status: boolean;
}
export interface FriendListArgs {
    nickname?: string;
    page?: Page;
}
export interface FriendListReturn {
    page: Page;
    friends: Array<Friend>;
}
export interface GetFriendByAddressArgs {
    friendAddress: string;
}
export interface GetFriendByAddressReturn {
    status: boolean;
    friend: Friend;
}
export interface SearchFriendsArgs {
    filterUsername: string;
    page?: Page;
}
export interface SearchFriendsReturn {
    friends: Array<Friend>;
}
export interface AddFriendArgs {
    friendAddress: string;
    optionalNickname?: string;
}
export interface AddFriendReturn {
    status: boolean;
    friend?: Friend;
}
export interface UpdateFriendNicknameArgs {
    friendAddress: string;
    nickname: string;
}
export interface UpdateFriendNicknameReturn {
    status: boolean;
    friend?: Friend;
}
export interface RemoveFriendArgs {
    friendAddress: string;
}
export interface RemoveFriendReturn {
    status: boolean;
}
export interface ContractCallArgs {
    chainID: string;
    contract: string;
    inputExpr: string;
    outputExpr: string;
    args: Array<string>;
}
export interface ContractCallReturn {
    returns: Array<string>;
}
export interface DecodeContractCallArgs {
    callData: string;
}
export interface DecodeContractCallReturn {
    call: ContractCall;
}
export interface LookupContractCallSelectorsArgs {
    selectors: Array<string>;
}
export interface LookupContractCallSelectorsReturn {
    signatures: Array<Array<string>>;
}
export interface UserStorageFetchArgs {
    key: string;
}
export interface UserStorageFetchReturn {
    object: any;
}
export interface UserStorageSaveArgs {
    key: string;
    object: any;
}
export interface UserStorageSaveReturn {
    ok: boolean;
}
export interface UserStorageDeleteArgs {
    key: string;
}
export interface UserStorageDeleteReturn {
    ok: boolean;
}
export interface UserStorageFetchAllArgs {
    keys?: Array<string>;
}
export interface UserStorageFetchAllReturn {
    objects: {
        [key: string]: any;
    };
}
export interface GetMoonpayLinkArgs {
    url: string;
}
export interface GetMoonpayLinkReturn {
    signedUrl: string;
}
export interface ResolveENSAddressArgs {
    ens: string;
}
export interface ResolveENSAddressReturn {
    address: string;
    ok: boolean;
}
export interface IsValidSignatureArgs {
    chainId: string;
    walletAddress: string;
    digest: string;
    signature: string;
}
export interface IsValidSignatureReturn {
    isValid: boolean;
}
export interface IsValidMessageSignatureArgs {
    chainId: string;
    walletAddress: string;
    message: string;
    signature: string;
}
export interface IsValidMessageSignatureReturn {
    isValid: boolean;
}
export interface IsValidTypedDataSignatureArgs {
    chainId: string;
    walletAddress: string;
    typedData: any;
    signature: string;
}
export interface IsValidTypedDataSignatureReturn {
    isValid: boolean;
}
export interface IsValidETHAuthProofArgs {
    chainId: string;
    walletAddress: string;
    ethAuthProofString: string;
}
export interface IsValidETHAuthProofReturn {
    isValid: boolean;
}
export interface SardineGetClientTokenArgs {
}
export interface SardineGetClientTokenReturn {
    token: string;
}
export interface SardineGetNFTCheckoutTokenArgs {
    params: SardineNFTCheckoutParams;
}
export interface SardineGetNFTCheckoutTokenReturn {
    resp: SardineNFTCheckout;
}
export interface SardineGetNFTCheckoutOrderStatusArgs {
    orderId: string;
}
export interface SardineGetNFTCheckoutOrderStatusReturn {
    resp: SardineOrder;
}
export interface SardineGetSupportedRegionsArgs {
}
export interface SardineGetSupportedRegionsReturn {
    regions: Array<SardineRegion>;
}
export interface SardineGetSupportedFiatCurrenciesArgs {
}
export interface SardineGetSupportedFiatCurrenciesReturn {
    tokens: Array<SardineFiatCurrency>;
}
export interface SardineGetSupportedTokensArgs {
}
export interface SardineGetSupportedTokensReturn {
    tokens: Array<SardineSupportedToken>;
}
export interface SardineGetEnabledTokensArgs {
}
export interface SardineGetEnabledTokensReturn {
    tokens: Array<SardineEnabledToken>;
}
export interface SardineGetQuoteArgs {
    params: SardineGetQuoteParams;
}
export interface SardineGetQuoteReturn {
    quote: SardineQuote;
}
export interface GetSardineClientTokenArgs {
}
export interface GetSardineClientTokenReturn {
    token: string;
}
export interface GetSardineNFTCheckoutTokenArgs {
    params: SardineNFTCheckoutParams;
}
export interface GetSardineNFTCheckoutTokenReturn {
    resp: SardineNFTCheckout;
}
export interface GetSardineNFTCheckoutOrderStatusArgs {
    orderId: string;
}
export interface GetSardineNFTCheckoutOrderStatusReturn {
    resp: SardineOrder;
}
export interface GetCoinPricesArgs {
    tokens: Array<Token>;
}
export interface GetCoinPricesReturn {
    tokenPrices: Array<TokenPrice>;
}
export interface GetCollectiblePricesArgs {
    tokens: Array<Token>;
}
export interface GetCollectiblePricesReturn {
    tokenPrices: Array<TokenPrice>;
}
export interface GetExchangeRateArgs {
    toCurrency: string;
}
export interface GetExchangeRateReturn {
    exchangeRate: ExchangeRate;
}
export interface MemoryStoreArgs {
    key: string;
    value: string;
}
export interface MemoryStoreReturn {
    ok: boolean;
}
export interface MemoryLoadArgs {
    key: string;
}
export interface MemoryLoadReturn {
    value: string;
}
export interface GetInviteInfoArgs {
}
export interface GetInviteInfoReturn {
    inviteInfo: InviteInfo;
}
export interface IsValidAccessCodeArgs {
    accessCode: string;
}
export interface IsValidAccessCodeReturn {
    status: boolean;
}
export interface InternalClaimAccessCodeArgs {
    address: string;
    accessCode: string;
}
export interface InternalClaimAccessCodeReturn {
    status: boolean;
}
export interface BlockNumberAtTimeArgs {
    chainId: number;
    timestamps: Array<number>;
}
export interface BlockNumberAtTimeReturn {
    blocks: Array<number>;
}
export interface PaperSessionSecretArgs {
    chainName: string;
    contractAddress: string;
    paramsJson: string;
    contractType: string;
}
export interface PaperSessionSecretReturn {
    secret: string;
}
export interface PaperSessionSecret2Args {
    chainName: string;
    contractAddress: string;
    paramsJson: string;
    abi: string;
}
export interface PaperSessionSecret2Return {
    secret: string;
}
export interface LinkWalletArgs {
    parentWalletAddress: string;
    parentWalletMessage: string;
    parentWalletSignature: string;
    linkedWalletAddress: string;
    linkedWalletMessage: string;
    linkedWalletSignature: string;
    signatureChainId: string;
    linkedWalletType?: string;
}
export interface LinkWalletReturn {
    status: boolean;
}
export interface GetLinkedWalletsArgs {
    parentWalletAddress: string;
    parentWalletMessage: string;
    parentWalletSignature: string;
    signatureChainId: string;
}
export interface GetLinkedWalletsReturn {
    linkedWallets: Array<LinkedWallet>;
}
export interface RemoveLinkedWalletArgs {
    parentWalletAddress: string;
    parentWalletMessage: string;
    parentWalletSignature: string;
    linkedWalletAddress: string;
    linkedWalletMessage: string;
    linkedWalletSignature: string;
    signatureChainId: string;
}
export interface RemoveLinkedWalletReturn {
    status: boolean;
}
export interface GenerateWaaSVerificationURLArgs {
    walletAddress: string;
}
export interface GenerateWaaSVerificationURLReturn {
    nonce: string;
    verificationURL: string;
}
export interface ValidateWaaSVerificationNonceArgs {
    nonce: string;
    signature: string;
    sessionId: string;
    chainId: string;
}
export interface ValidateWaaSVerificationNonceReturn {
    walletAddress: string;
}
export interface GetSwapPricesArgs {
    userAddress: string;
    buyCurrencyAddress: string;
    buyAmount: string;
    chainId: number;
}
export interface GetSwapPricesReturn {
    swapPrices: Array<SwapPrice>;
}
export interface GetSwapQuoteArgs {
    userAddress: string;
    buyCurrencyAddress: string;
    sellCurrencyAddress: string;
    buyAmount: string;
    chainId: number;
    includeApprove: boolean;
}
export interface GetSwapQuoteReturn {
    swapQuote: SwapQuote;
}
export interface ListCurrencyGroupsArgs {
}
export interface ListCurrencyGroupsReturn {
    currencyGroups: Array<CurrencyGroup>;
}
export interface AddOffchainInventoryArgs {
    inventory: OffchainInventory;
}
export interface AddOffchainInventoryReturn {
    inventoryId: number;
}
export interface GetOffchainInventoryArgs {
    inventoryId: number;
}
export interface GetOffchainInventoryReturn {
    inventory: OffchainInventory;
}
export interface ListOffchainInventoriesArgs {
    projectId: number;
}
export interface ListOffchainInventoriesReturn {
    inventory: Array<OffchainInventory>;
}
export interface UpdateOffchainInventoryArgs {
    inventory: OffchainInventory;
}
export interface UpdateOffchainInventoryReturn {
}
export interface DeleteOffchainInventoryArgs {
    inventoryId: number;
}
export interface DeleteOffchainInventoryReturn {
    ok: boolean;
}
export interface RequestOffchainPaymentArgs {
    inventoryId: number;
    recipient: string;
    chainId?: number;
    tokenAddress?: string;
}
export interface RequestOffchainPaymentReturn {
    payment: PaymentResponse;
}
export interface ListOffchainPaymentsArgs {
    inventoryId: number;
    page?: Page;
}
export interface ListOffchainPaymentsReturn {
    page: Page;
    payments: Array<OffchainPayment>;
}
export declare class API implements API {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    ping: (headers?: object, signal?: AbortSignal) => Promise<PingReturn>;
    version: (headers?: object, signal?: AbortSignal) => Promise<VersionReturn>;
    runtimeStatus: (headers?: object, signal?: AbortSignal) => Promise<RuntimeStatusReturn>;
    clock: (headers?: object, signal?: AbortSignal) => Promise<ClockReturn>;
    getSequenceContext: (headers?: object, signal?: AbortSignal) => Promise<GetSequenceContextReturn>;
    getAuthToken: (args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal) => Promise<GetAuthTokenReturn>;
    getAuthToken2: (args: GetAuthToken2Args, headers?: object, signal?: AbortSignal) => Promise<GetAuthToken2Return>;
    sendPasswordlessLink: (args: SendPasswordlessLinkArgs, headers?: object, signal?: AbortSignal) => Promise<SendPasswordlessLinkReturn>;
    friendList: (args: FriendListArgs, headers?: object, signal?: AbortSignal) => Promise<FriendListReturn>;
    getFriendByAddress: (args: GetFriendByAddressArgs, headers?: object, signal?: AbortSignal) => Promise<GetFriendByAddressReturn>;
    searchFriends: (args: SearchFriendsArgs, headers?: object, signal?: AbortSignal) => Promise<SearchFriendsReturn>;
    addFriend: (args: AddFriendArgs, headers?: object, signal?: AbortSignal) => Promise<AddFriendReturn>;
    updateFriendNickname: (args: UpdateFriendNicknameArgs, headers?: object, signal?: AbortSignal) => Promise<UpdateFriendNicknameReturn>;
    removeFriend: (args: RemoveFriendArgs, headers?: object, signal?: AbortSignal) => Promise<RemoveFriendReturn>;
    contractCall: (args: ContractCallArgs, headers?: object, signal?: AbortSignal) => Promise<ContractCallReturn>;
    decodeContractCall: (args: DecodeContractCallArgs, headers?: object, signal?: AbortSignal) => Promise<DecodeContractCallReturn>;
    lookupContractCallSelectors: (args: LookupContractCallSelectorsArgs, headers?: object, signal?: AbortSignal) => Promise<LookupContractCallSelectorsReturn>;
    userStorageFetch: (args: UserStorageFetchArgs, headers?: object, signal?: AbortSignal) => Promise<UserStorageFetchReturn>;
    userStorageSave: (args: UserStorageSaveArgs, headers?: object, signal?: AbortSignal) => Promise<UserStorageSaveReturn>;
    userStorageDelete: (args: UserStorageDeleteArgs, headers?: object, signal?: AbortSignal) => Promise<UserStorageDeleteReturn>;
    userStorageFetchAll: (args: UserStorageFetchAllArgs, headers?: object, signal?: AbortSignal) => Promise<UserStorageFetchAllReturn>;
    getMoonpayLink: (args: GetMoonpayLinkArgs, headers?: object, signal?: AbortSignal) => Promise<GetMoonpayLinkReturn>;
    resolveENSAddress: (args: ResolveENSAddressArgs, headers?: object, signal?: AbortSignal) => Promise<ResolveENSAddressReturn>;
    isValidSignature: (args: IsValidSignatureArgs, headers?: object, signal?: AbortSignal) => Promise<IsValidSignatureReturn>;
    isValidMessageSignature: (args: IsValidMessageSignatureArgs, headers?: object, signal?: AbortSignal) => Promise<IsValidMessageSignatureReturn>;
    isValidTypedDataSignature: (args: IsValidTypedDataSignatureArgs, headers?: object, signal?: AbortSignal) => Promise<IsValidTypedDataSignatureReturn>;
    isValidETHAuthProof: (args: IsValidETHAuthProofArgs, headers?: object, signal?: AbortSignal) => Promise<IsValidETHAuthProofReturn>;
    sardineGetClientToken: (headers?: object, signal?: AbortSignal) => Promise<SardineGetClientTokenReturn>;
    sardineGetNFTCheckoutToken: (args: SardineGetNFTCheckoutTokenArgs, headers?: object, signal?: AbortSignal) => Promise<SardineGetNFTCheckoutTokenReturn>;
    sardineGetNFTCheckoutOrderStatus: (args: SardineGetNFTCheckoutOrderStatusArgs, headers?: object, signal?: AbortSignal) => Promise<SardineGetNFTCheckoutOrderStatusReturn>;
    sardineGetSupportedRegions: (headers?: object, signal?: AbortSignal) => Promise<SardineGetSupportedRegionsReturn>;
    sardineGetSupportedFiatCurrencies: (headers?: object, signal?: AbortSignal) => Promise<SardineGetSupportedFiatCurrenciesReturn>;
    sardineGetSupportedTokens: (headers?: object, signal?: AbortSignal) => Promise<SardineGetSupportedTokensReturn>;
    sardineGetEnabledTokens: (headers?: object, signal?: AbortSignal) => Promise<SardineGetEnabledTokensReturn>;
    sardineGetQuote: (args: SardineGetQuoteArgs, headers?: object, signal?: AbortSignal) => Promise<SardineGetQuoteReturn>;
    getSardineClientToken: (headers?: object, signal?: AbortSignal) => Promise<GetSardineClientTokenReturn>;
    getSardineNFTCheckoutToken: (args: GetSardineNFTCheckoutTokenArgs, headers?: object, signal?: AbortSignal) => Promise<GetSardineNFTCheckoutTokenReturn>;
    getSardineNFTCheckoutOrderStatus: (args: GetSardineNFTCheckoutOrderStatusArgs, headers?: object, signal?: AbortSignal) => Promise<GetSardineNFTCheckoutOrderStatusReturn>;
    getCoinPrices: (args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal) => Promise<GetCoinPricesReturn>;
    getCollectiblePrices: (args: GetCollectiblePricesArgs, headers?: object, signal?: AbortSignal) => Promise<GetCollectiblePricesReturn>;
    getExchangeRate: (args: GetExchangeRateArgs, headers?: object, signal?: AbortSignal) => Promise<GetExchangeRateReturn>;
    memoryStore: (args: MemoryStoreArgs, headers?: object, signal?: AbortSignal) => Promise<MemoryStoreReturn>;
    memoryLoad: (args: MemoryLoadArgs, headers?: object, signal?: AbortSignal) => Promise<MemoryLoadReturn>;
    getInviteInfo: (headers?: object, signal?: AbortSignal) => Promise<GetInviteInfoReturn>;
    isValidAccessCode: (args: IsValidAccessCodeArgs, headers?: object, signal?: AbortSignal) => Promise<IsValidAccessCodeReturn>;
    internalClaimAccessCode: (args: InternalClaimAccessCodeArgs, headers?: object, signal?: AbortSignal) => Promise<InternalClaimAccessCodeReturn>;
    blockNumberAtTime: (args: BlockNumberAtTimeArgs, headers?: object, signal?: AbortSignal) => Promise<BlockNumberAtTimeReturn>;
    paperSessionSecret: (args: PaperSessionSecretArgs, headers?: object, signal?: AbortSignal) => Promise<PaperSessionSecretReturn>;
    paperSessionSecret2: (args: PaperSessionSecret2Args, headers?: object, signal?: AbortSignal) => Promise<PaperSessionSecret2Return>;
    linkWallet: (args: LinkWalletArgs, headers?: object, signal?: AbortSignal) => Promise<LinkWalletReturn>;
    getLinkedWallets: (args: GetLinkedWalletsArgs, headers?: object, signal?: AbortSignal) => Promise<GetLinkedWalletsReturn>;
    removeLinkedWallet: (args: RemoveLinkedWalletArgs, headers?: object, signal?: AbortSignal) => Promise<RemoveLinkedWalletReturn>;
    generateWaaSVerificationURL: (args: GenerateWaaSVerificationURLArgs, headers?: object, signal?: AbortSignal) => Promise<GenerateWaaSVerificationURLReturn>;
    validateWaaSVerificationNonce: (args: ValidateWaaSVerificationNonceArgs, headers?: object, signal?: AbortSignal) => Promise<ValidateWaaSVerificationNonceReturn>;
    getSwapPrices: (args: GetSwapPricesArgs, headers?: object, signal?: AbortSignal) => Promise<GetSwapPricesReturn>;
    getSwapQuote: (args: GetSwapQuoteArgs, headers?: object, signal?: AbortSignal) => Promise<GetSwapQuoteReturn>;
    listCurrencyGroups: (headers?: object, signal?: AbortSignal) => Promise<ListCurrencyGroupsReturn>;
    addOffchainInventory: (args: AddOffchainInventoryArgs, headers?: object, signal?: AbortSignal) => Promise<AddOffchainInventoryReturn>;
    getOffchainInventory: (args: GetOffchainInventoryArgs, headers?: object, signal?: AbortSignal) => Promise<GetOffchainInventoryReturn>;
    listOffchainInventories: (args: ListOffchainInventoriesArgs, headers?: object, signal?: AbortSignal) => Promise<ListOffchainInventoriesReturn>;
    updateOffchainInventory: (args: UpdateOffchainInventoryArgs, headers?: object, signal?: AbortSignal) => Promise<UpdateOffchainInventoryReturn>;
    deleteOffchainInventory: (args: DeleteOffchainInventoryArgs, headers?: object, signal?: AbortSignal) => Promise<DeleteOffchainInventoryReturn>;
    requestOffchainPayment: (args: RequestOffchainPaymentArgs, headers?: object, signal?: AbortSignal) => Promise<RequestOffchainPaymentReturn>;
    listOffchainPayments: (args: ListOffchainPaymentsArgs, headers?: object, signal?: AbortSignal) => Promise<ListOffchainPaymentsReturn>;
}
export declare class WebrpcError extends Error {
    name: string;
    code: number;
    message: string;
    status: number;
    cause?: string;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    msg: string;
    constructor(name: string, code: number, message: string, status: number, cause?: string);
    static new(payload: any): WebrpcError;
}
export declare class WebrpcEndpointError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcRequestFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRouteError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadMethodError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRequestError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadResponseError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcServerPanicError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcInternalErrorError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcClientDisconnectedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamLostError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamFinishedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnauthorizedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class PermissionDeniedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class SessionExpiredError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class AbortedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class GeoblockedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class InvalidArgumentError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnavailableError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class QueryFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class NotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare enum errors {
    WebrpcEndpoint = "WebrpcEndpoint",
    WebrpcRequestFailed = "WebrpcRequestFailed",
    WebrpcBadRoute = "WebrpcBadRoute",
    WebrpcBadMethod = "WebrpcBadMethod",
    WebrpcBadRequest = "WebrpcBadRequest",
    WebrpcBadResponse = "WebrpcBadResponse",
    WebrpcServerPanic = "WebrpcServerPanic",
    WebrpcInternalError = "WebrpcInternalError",
    WebrpcClientDisconnected = "WebrpcClientDisconnected",
    WebrpcStreamLost = "WebrpcStreamLost",
    WebrpcStreamFinished = "WebrpcStreamFinished",
    Unauthorized = "Unauthorized",
    PermissionDenied = "PermissionDenied",
    SessionExpired = "SessionExpired",
    Aborted = "Aborted",
    Geoblocked = "Geoblocked",
    InvalidArgument = "InvalidArgument",
    Unavailable = "Unavailable",
    QueryFailed = "QueryFailed",
    NotFound = "NotFound"
}
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>;
