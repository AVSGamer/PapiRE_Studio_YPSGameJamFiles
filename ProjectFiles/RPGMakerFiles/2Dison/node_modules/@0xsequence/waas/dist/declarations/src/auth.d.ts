import { Observer } from "./base.js";
import { Account, IdentityType, IntentResponseIdToken } from "./clients/intent.gen.js";
import { Store } from "./store.js";
import { SendContractCallArgs, SendERC1155Args, SendERC20Args, SendERC721Args, SendTransactionsArgs, SignMessageArgs } from "./intents/index.js";
import { FeeOptionsResponse, MaySentTransactionResponse, SignedMessageResponse } from "./intents/responses.js";
import { Chain, Session } from "./clients/authenticator.gen.js";
import { SimpleNetwork, WithSimpleNetwork } from "./networks.js";
import { EmailAuth } from "./email.js";
import { SubtleCryptoBackend } from "./subtle-crypto.js";
import { SecureStoreBackend } from "./secure-store.js";
import { Challenge } from "./challenge.js";
export type Sessions = (Session & {
    isThis: boolean;
})[];
export type { Account };
export { IdentityType };
export type SequenceConfig = {
    projectAccessKey: string;
    waasConfigKey: string;
    network?: SimpleNetwork;
    disableHttpSignatureCheck?: boolean;
};
export type ExtendedSequenceConfig = {
    rpcServer: string;
    emailRegion?: string;
};
export type WaaSConfigKey = {
    projectId: number;
    emailClientId?: string;
};
export type GuestIdentity = {
    guest: true;
};
export type IdTokenIdentity = {
    idToken: string;
};
export type EmailIdentity = {
    email: string;
};
export type PlayFabIdentity = {
    playFabTitleId: string;
    playFabSessionTicket: string;
};
export type Identity = IdTokenIdentity | EmailIdentity | PlayFabIdentity | GuestIdentity;
export type SignInResponse = {
    sessionId: string;
    wallet: string;
    email?: string;
};
export type ValidationArgs = {
    onValidationRequired?: () => boolean;
};
export type CommonAuthArgs = {
    validation?: ValidationArgs;
    identifier?: string;
};
export type Network = Chain;
export type NetworkList = Network[];
export type EmailConflictInfo = {
    type: IdentityType;
    email: string;
    issuer: string;
};
export declare function parseSequenceWaaSConfigKey<T>(key: string): Partial<T>;
export declare function defaultArgsOrFail(config: SequenceConfig & Partial<ExtendedSequenceConfig>): Required<SequenceConfig> & Required<WaaSConfigKey> & ExtendedSequenceConfig;
export declare class SequenceWaaS {
    private readonly store;
    private readonly cryptoBackend;
    private readonly secureStoreBackend;
    private waas;
    private client;
    private validationRequiredCallback;
    private emailConflictCallback;
    private emailAuthCodeRequiredCallback;
    private validationRequiredSalt;
    readonly config: Required<SequenceConfig> & Required<WaaSConfigKey> & ExtendedSequenceConfig;
    private readonly deviceName;
    private emailClient;
    private lastDate;
    private signatureVerificationFailed;
    constructor(config: SequenceConfig & Partial<ExtendedSequenceConfig>, store?: Store, cryptoBackend?: SubtleCryptoBackend | null, secureStoreBackend?: SecureStoreBackend | null);
    _fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response>;
    get email(): EmailAuth;
    onValidationRequired(callback: () => void): Promise<() => void>;
    onEmailConflict(callback: (info: EmailConflictInfo, forceCreate: () => Promise<void>) => Promise<void>): () => void;
    onEmailAuthCodeRequired(callback: (respondWithCode: (code: string) => Promise<void>) => Promise<void>): () => void;
    private handleValidationRequired;
    private headers;
    private updateTimeDrift;
    private sendIntent;
    isSignedIn(): Promise<boolean>;
    signIn(creds: Identity, sessionName: string): Promise<SignInResponse>;
    initAuth(identity: Identity): Promise<Challenge>;
    private initGuestAuth;
    private initIdTokenAuth;
    private initEmailAuth;
    private initPlayFabAuth;
    completeAuth(challenge: Challenge, opts?: {
        sessionName?: string;
        forceCreateAccount?: boolean;
    }): Promise<SignInResponse>;
    private registerSession;
    private refreshSession;
    getSessionId(): Promise<string>;
    getSessionHash(): Promise<string>;
    dropSession({ sessionId, strict }?: {
        sessionId?: string;
        strict?: boolean;
    }): Promise<void>;
    listSessions(): Promise<Sessions>;
    getAddress(): Promise<string>;
    validateSession(args?: ValidationArgs): Promise<boolean>;
    finishValidateSession(challenge: string): Promise<boolean>;
    isSessionValid(): Promise<boolean>;
    waitForSessionValid(timeout?: number, pollRate?: number): Promise<boolean>;
    sessionAuthProof({ nonce, network, validation }: {
        nonce?: string;
        network?: string;
        validation?: ValidationArgs;
    }): Promise<import("./intents/responses.js").SessionAuthProofResponse>;
    listAccounts(): Promise<import("./clients/intent.gen.js").IntentResponseAccountList>;
    linkAccount(challenge: Challenge): Promise<import("./clients/intent.gen.js").IntentResponseAccountFederated>;
    removeAccount(accountId: string): Promise<void>;
    getIdToken(args?: {
        nonce?: string;
    }): Promise<IntentResponseIdToken>;
    useIdentifier<T extends CommonAuthArgs>(args: T): Promise<T & {
        identifier: string;
    }>;
    private trySendIntent;
    signMessage(args: WithSimpleNetwork<SignMessageArgs> & CommonAuthArgs): Promise<SignedMessageResponse>;
    private trySendTransactionIntent;
    sendTransaction(args: WithSimpleNetwork<SendTransactionsArgs> & CommonAuthArgs): Promise<MaySentTransactionResponse>;
    sendERC20(args: WithSimpleNetwork<SendERC20Args> & CommonAuthArgs): Promise<MaySentTransactionResponse>;
    sendERC721(args: WithSimpleNetwork<SendERC721Args> & CommonAuthArgs): Promise<MaySentTransactionResponse>;
    sendERC1155(args: WithSimpleNetwork<SendERC1155Args> & CommonAuthArgs): Promise<MaySentTransactionResponse>;
    callContract(args: WithSimpleNetwork<SendContractCallArgs> & CommonAuthArgs): Promise<MaySentTransactionResponse>;
    feeOptions(args: WithSimpleNetwork<SendTransactionsArgs> & CommonAuthArgs): Promise<FeeOptionsResponse>;
    networkList(): Promise<NetworkList>;
    onSessionStateChanged(callback: Observer<string>): () => void;
    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;
}
