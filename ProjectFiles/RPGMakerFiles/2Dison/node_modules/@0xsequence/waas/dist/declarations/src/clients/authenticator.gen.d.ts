export declare const WebRPCVersion = "v1";
export declare const WebRPCSchemaVersion = "v0.1.0";
export declare const WebRPCSchemaHash = "35f86317a98af91896d1114ad52dd22102d9de9f";
export declare enum IntentName {
    initiateAuth = "initiateAuth",
    openSession = "openSession",
    closeSession = "closeSession",
    validateSession = "validateSession",
    finishValidateSession = "finishValidateSession",
    listSessions = "listSessions",
    getSession = "getSession",
    sessionAuthProof = "sessionAuthProof",
    feeOptions = "feeOptions",
    signMessage = "signMessage",
    sendTransaction = "sendTransaction",
    getTransactionReceipt = "getTransactionReceipt",
    federateAccount = "federateAccount",
    removeAccount = "removeAccount",
    listAccounts = "listAccounts",
    getIdToken = "getIdToken"
}
export declare enum IntentResponseCode {
    authInitiated = "authInitiated",
    sessionOpened = "sessionOpened",
    sessionClosed = "sessionClosed",
    sessionList = "sessionList",
    validationRequired = "validationRequired",
    validationStarted = "validationStarted",
    validationFinished = "validationFinished",
    sessionAuthProof = "sessionAuthProof",
    signedMessage = "signedMessage",
    feeOptions = "feeOptions",
    transactionReceipt = "transactionReceipt",
    transactionFailed = "transactionFailed",
    getSessionResponse = "getSessionResponse",
    accountList = "accountList",
    accountFederated = "accountFederated",
    accountRemoved = "accountRemoved",
    idToken = "idToken"
}
export declare enum IdentityType {
    None = "None",
    Guest = "Guest",
    OIDC = "OIDC",
    Email = "Email",
    PlayFab = "PlayFab",
    Stytch = "Stytch"
}
export interface Intent {
    version: string;
    name: IntentName;
    expiresAt: number;
    issuedAt: number;
    data: any;
    signatures: Array<Signature>;
}
export interface Signature {
    sessionId: string;
    signature: string;
}
export interface IntentResponse {
    code: IntentResponseCode;
    data: any;
}
export interface Version {
    webrpcVersion: string;
    schemaVersion: string;
    schemaHash: string;
    appVersion: string;
}
export interface RuntimeStatus {
    healthOK: boolean;
    startTime: string;
    uptime: number;
    ver: string;
    pcr0: string;
}
export interface Chain {
    id: number;
    name: string;
    isEnabled: boolean;
}
export interface Identity {
    type: IdentityType;
    iss: string;
    sub: string;
    email: string;
}
export interface OpenIdProvider {
    iss: string;
    aud: Array<string>;
}
export interface AuthEmailConfig {
    enabled: boolean;
}
export interface AuthGuestConfig {
    enabled: boolean;
}
export interface AuthPlayfabConfig {
    enabled: boolean;
    titleId?: string;
}
export interface AuthStytchConfig {
    enabled: boolean;
    projectId?: string;
}
export interface AuthConfig {
    email?: AuthEmailConfig;
    guest?: AuthGuestConfig;
    playfab?: AuthPlayfabConfig;
    stytch?: AuthStytchConfig;
}
export interface Tenant {
    projectId: number;
    version: number;
    oidcProviders: Array<OpenIdProvider>;
    allowedOrigins: Array<string>;
    authConfig: AuthConfig;
    updatedAt: string;
}
export interface TenantData {
    projectId: number;
    privateKey: string;
    parentAddress: string;
    userSalt: string;
    sequenceContext: MiniSequenceContext;
    upgradeCode: string;
    waasAccessToken: string;
    authConfig: AuthConfig;
    oidcProviders: Array<OpenIdProvider>;
    kmsKeys: Array<string>;
    allowedOrigins: Array<string>;
}
export interface MiniSequenceContext {
    factory: string;
    mainModule: string;
}
export interface AccountData {
    projectId: number;
    userId: string;
    identity: string;
    createdAt: string;
}
export interface Session {
    id: string;
    projectId: number;
    userId: string;
    identity: Identity;
    friendlyName: string;
    createdAt: string;
    refreshedAt: string;
    expiresAt: string;
}
export interface SessionData {
    id: string;
    projectId: number;
    userId: string;
    identity: string;
    createdAt: string;
    expiresAt: string;
}
export interface VerificationContext {
    projectId: number;
    sessionId: string;
    identityType: IdentityType;
    verifier: string;
    challenge?: string;
    answer?: string;
    attempts: number;
    lastAttemptAt?: string;
    expiresAt: string;
}
export interface WaasAuthenticator {
    registerSession(args: RegisterSessionArgs, headers?: object, signal?: AbortSignal): Promise<RegisterSessionReturn>;
    sendIntent(args: SendIntentArgs, headers?: object, signal?: AbortSignal): Promise<SendIntentReturn>;
    chainList(headers?: object, signal?: AbortSignal): Promise<ChainListReturn>;
}
export interface RegisterSessionArgs {
    intent: Intent;
    friendlyName: string;
}
export interface RegisterSessionReturn {
    session: Session;
    response: IntentResponse;
}
export interface SendIntentArgs {
    intent: Intent;
}
export interface SendIntentReturn {
    response: IntentResponse;
}
export interface ChainListArgs {
}
export interface ChainListReturn {
    chains: Array<Chain>;
}
export interface WaasAuthenticatorAdmin {
    version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>;
    runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>;
    clock(headers?: object, signal?: AbortSignal): Promise<ClockReturn>;
    getTenant(args: GetTenantArgs, headers?: object, signal?: AbortSignal): Promise<GetTenantReturn>;
    createTenant(args: CreateTenantArgs, headers?: object, signal?: AbortSignal): Promise<CreateTenantReturn>;
    updateTenant(args: UpdateTenantArgs, headers?: object, signal?: AbortSignal): Promise<UpdateTenantReturn>;
}
export interface VersionArgs {
}
export interface VersionReturn {
    version: Version;
}
export interface RuntimeStatusArgs {
}
export interface RuntimeStatusReturn {
    status: RuntimeStatus;
}
export interface ClockArgs {
}
export interface ClockReturn {
    serverTime: string;
}
export interface GetTenantArgs {
    projectId: number;
}
export interface GetTenantReturn {
    tenant: Tenant;
}
export interface CreateTenantArgs {
    projectId: number;
    waasAccessToken: string;
    authConfig: AuthConfig;
    oidcProviders: Array<OpenIdProvider>;
    allowedOrigins: Array<string>;
    password?: string;
}
export interface CreateTenantReturn {
    tenant: Tenant;
    upgradeCode: string;
}
export interface UpdateTenantArgs {
    projectId: number;
    upgradeCode: string;
    authConfig: AuthConfig;
    oidcProviders: Array<OpenIdProvider>;
    allowedOrigins: Array<string>;
}
export interface UpdateTenantReturn {
    tenant: Tenant;
}
export declare class WaasAuthenticator implements WaasAuthenticator {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    registerSession: (args: RegisterSessionArgs, headers?: object, signal?: AbortSignal) => Promise<RegisterSessionReturn>;
    sendIntent: (args: SendIntentArgs, headers?: object, signal?: AbortSignal) => Promise<SendIntentReturn>;
    chainList: (headers?: object, signal?: AbortSignal) => Promise<ChainListReturn>;
}
export declare class WaasAuthenticatorAdmin implements WaasAuthenticatorAdmin {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    version: (headers?: object, signal?: AbortSignal) => Promise<VersionReturn>;
    runtimeStatus: (headers?: object, signal?: AbortSignal) => Promise<RuntimeStatusReturn>;
    clock: (headers?: object, signal?: AbortSignal) => Promise<ClockReturn>;
    getTenant: (args: GetTenantArgs, headers?: object, signal?: AbortSignal) => Promise<GetTenantReturn>;
    createTenant: (args: CreateTenantArgs, headers?: object, signal?: AbortSignal) => Promise<CreateTenantReturn>;
    updateTenant: (args: UpdateTenantArgs, headers?: object, signal?: AbortSignal) => Promise<UpdateTenantReturn>;
}
export declare class WebrpcError extends Error {
    name: string;
    code: number;
    message: string;
    status: number;
    cause?: string;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    msg: string;
    constructor(name: string, code: number, message: string, status: number, cause?: string);
    static new(payload: any): WebrpcError;
}
export declare class WebrpcEndpointError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcRequestFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRouteError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadMethodError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRequestError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadResponseError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcServerPanicError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcInternalErrorError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcClientDisconnectedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamLostError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamFinishedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnauthorizedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class TenantNotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class EmailAlreadyInUseError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class AccountAlreadyLinkedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ProofVerificationFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class AnswerIncorrectError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ChallengeExpiredError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class TooManyAttemptsError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare enum errors {
    WebrpcEndpoint = "WebrpcEndpoint",
    WebrpcRequestFailed = "WebrpcRequestFailed",
    WebrpcBadRoute = "WebrpcBadRoute",
    WebrpcBadMethod = "WebrpcBadMethod",
    WebrpcBadRequest = "WebrpcBadRequest",
    WebrpcBadResponse = "WebrpcBadResponse",
    WebrpcServerPanic = "WebrpcServerPanic",
    WebrpcInternalError = "WebrpcInternalError",
    WebrpcClientDisconnected = "WebrpcClientDisconnected",
    WebrpcStreamLost = "WebrpcStreamLost",
    WebrpcStreamFinished = "WebrpcStreamFinished",
    Unauthorized = "Unauthorized",
    TenantNotFound = "TenantNotFound",
    EmailAlreadyInUse = "EmailAlreadyInUse",
    AccountAlreadyLinked = "AccountAlreadyLinked",
    ProofVerificationFailed = "ProofVerificationFailed",
    AnswerIncorrect = "AnswerIncorrect",
    ChallengeExpired = "ChallengeExpired",
    TooManyAttempts = "TooManyAttempts"
}
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>;
