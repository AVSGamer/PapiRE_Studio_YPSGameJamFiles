import { VERSION as VERSION$1 } from '@0xsequence/core';
import { ethers } from 'ethers';
import { canonicalize } from 'json-canonicalize';
import { toHexString } from '@0xsequence/utils';
import { networks as networks$1 } from '@0xsequence/network';
import { openDB } from 'idb';
import { CognitoIdentityProviderClient, SignUpCommand, InitiateAuthCommand, UserLambdaValidationException, RespondToAuthChallengeCommand } from '@aws-sdk/client-cognito-identity-provider';
import { jwtDecode } from 'jwt-decode';

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}

const _excluded$3 = ["signatures"];
const INTENTS_VERSION = 1;
const VERSION = `${INTENTS_VERSION} (Web ${VERSION$1})`;
let timeDrift;
const timeDriftKey = '@sequence.timeDrift';
function isSessionStorageAvailable() {
  return typeof window === 'object' && typeof window.sessionStorage === 'object';
}
function getTimeDrift() {
  if (isSessionStorageAvailable()) {
    const drift = window.sessionStorage.getItem(timeDriftKey);
    if (drift) {
      return parseInt(drift, 10);
    }
  }
  return timeDrift;
}
function updateTimeDrift(serverTime) {
  timeDrift = (Date.now() - serverTime.getTime()) / 1000;
  if (isSessionStorageAvailable()) {
    window.sessionStorage.setItem(timeDriftKey, timeDrift.toString(10));
  }
}
function makeIntent(name, lifespan, data) {
  const drift = Math.abs(Math.floor(getTimeDrift() || 0));
  const issuedAt = Math.floor(Date.now() / 1000 - drift);
  const expiresAt = issuedAt + lifespan + 2 * drift;
  return {
    version: VERSION,
    issuedAt,
    expiresAt,
    name,
    data
  };
}
async function signIntent(session, intent) {
  const hash = hashIntent(intent);
  const signature = await session.sign(new Uint8Array(hash));
  return _extends({}, intent, {
    signatures: [{
      sessionId: await session.sessionId(),
      signature
    }]
  });
}
function hashIntent(intent) {
  // Discard all fields other than the explicitly listed
  const {
    version,
    issuedAt,
    expiresAt,
    name,
    data
  } = intent;
  const hashableIntent = {
    version,
    issuedAt,
    expiresAt,
    name,
    data
  };
  const encoded = ethers.toUtf8Bytes(canonicalize(hashableIntent));
  return ethers.getBytes(ethers.keccak256(encoded));
}
function changeIntentTime(intent, now) {
  const unsignedIntent = _objectWithoutPropertiesLoose(intent, _excluded$3);
  const lifespan = intent.expiresAt - intent.issuedAt;
  unsignedIntent.issuedAt = Math.floor(now.getTime() / 1000);
  unsignedIntent.expiresAt = unsignedIntent.issuedAt + lifespan;
  return unsignedIntent;
}

/* eslint-disable */
// sequence-waas-intents v0.1.0 2e4f5d4a4107d8e8c74c252f4d1a7aad391db6e7
// --
// Code generated by webrpc-gen@v0.19.3 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=intent.ridl -target=typescript -out=./intent.gen.ts

// WebRPC description and code-gen version
const WebRPCVersion = 'v1';

// Schema version of your RIDL schema
const WebRPCSchemaVersion = 'v0.1.0';

// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = '2e4f5d4a4107d8e8c74c252f4d1a7aad391db6e7';

//
// Types
//

let IntentName = /*#__PURE__*/function (IntentName) {
  IntentName["initiateAuth"] = "initiateAuth";
  IntentName["openSession"] = "openSession";
  IntentName["closeSession"] = "closeSession";
  IntentName["validateSession"] = "validateSession";
  IntentName["finishValidateSession"] = "finishValidateSession";
  IntentName["listSessions"] = "listSessions";
  IntentName["getSession"] = "getSession";
  IntentName["sessionAuthProof"] = "sessionAuthProof";
  IntentName["feeOptions"] = "feeOptions";
  IntentName["signMessage"] = "signMessage";
  IntentName["sendTransaction"] = "sendTransaction";
  IntentName["getTransactionReceipt"] = "getTransactionReceipt";
  IntentName["federateAccount"] = "federateAccount";
  IntentName["removeAccount"] = "removeAccount";
  IntentName["listAccounts"] = "listAccounts";
  IntentName["getIdToken"] = "getIdToken";
  return IntentName;
}({});
let TransactionType = /*#__PURE__*/function (TransactionType) {
  TransactionType["transaction"] = "transaction";
  TransactionType["erc20send"] = "erc20send";
  TransactionType["erc721send"] = "erc721send";
  TransactionType["erc1155send"] = "erc1155send";
  TransactionType["delayedEncode"] = "delayedEncode";
  TransactionType["contractCall"] = "contractCall";
  return TransactionType;
}({});
let IntentResponseCode = /*#__PURE__*/function (IntentResponseCode) {
  IntentResponseCode["authInitiated"] = "authInitiated";
  IntentResponseCode["sessionOpened"] = "sessionOpened";
  IntentResponseCode["sessionClosed"] = "sessionClosed";
  IntentResponseCode["sessionList"] = "sessionList";
  IntentResponseCode["validationRequired"] = "validationRequired";
  IntentResponseCode["validationStarted"] = "validationStarted";
  IntentResponseCode["validationFinished"] = "validationFinished";
  IntentResponseCode["sessionAuthProof"] = "sessionAuthProof";
  IntentResponseCode["signedMessage"] = "signedMessage";
  IntentResponseCode["feeOptions"] = "feeOptions";
  IntentResponseCode["transactionReceipt"] = "transactionReceipt";
  IntentResponseCode["transactionFailed"] = "transactionFailed";
  IntentResponseCode["getSessionResponse"] = "getSessionResponse";
  IntentResponseCode["accountList"] = "accountList";
  IntentResponseCode["accountFederated"] = "accountFederated";
  IntentResponseCode["accountRemoved"] = "accountRemoved";
  IntentResponseCode["idToken"] = "idToken";
  return IntentResponseCode;
}({});
let FeeTokenType = /*#__PURE__*/function (FeeTokenType) {
  FeeTokenType["unknown"] = "unknown";
  FeeTokenType["erc20Token"] = "erc20Token";
  FeeTokenType["erc1155Token"] = "erc1155Token";
  return FeeTokenType;
}({});
let IdentityType = /*#__PURE__*/function (IdentityType) {
  IdentityType["None"] = "None";
  IdentityType["Guest"] = "Guest";
  IdentityType["OIDC"] = "OIDC";
  IdentityType["Email"] = "Email";
  IdentityType["PlayFab"] = "PlayFab";
  IdentityType["Stytch"] = "Stytch";
  return IdentityType;
}({});

function signMessage({
  wallet,
  chainId,
  message,
  lifespan
}) {
  return makeIntent(IntentName.signMessage, lifespan, {
    wallet,
    network: chainId.toString(),
    message: message.startsWith('0x') ? message : ethers.hexlify(ethers.toUtf8Bytes(message))
  });
}

const _excluded$2 = ["lifespan"],
  _excluded2$2 = ["lifespan"],
  _excluded3$2 = ["lifespan"],
  _excluded4$1 = ["lifespan"],
  _excluded5 = ["lifespan"],
  _excluded6 = ["lifespan"],
  _excluded7 = ["lifespan"],
  _excluded8 = ["lifespan"],
  _excluded9 = ["lifespan"];
async function initiateAuth(_ref) {
  let {
      lifespan
    } = _ref,
    data = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  return makeIntent(IntentName.initiateAuth, lifespan, data);
}
async function openSession(_ref2) {
  let {
      lifespan
    } = _ref2,
    data = _objectWithoutPropertiesLoose(_ref2, _excluded2$2);
  return makeIntent(IntentName.openSession, lifespan, data);
}
async function validateSession(_ref3) {
  let {
      lifespan
    } = _ref3,
    data = _objectWithoutPropertiesLoose(_ref3, _excluded3$2);
  return makeIntent(IntentName.validateSession, lifespan, data);
}
function finishValidateSession(_ref4) {
  let {
      lifespan
    } = _ref4,
    data = _objectWithoutPropertiesLoose(_ref4, _excluded4$1);
  return makeIntent(IntentName.finishValidateSession, lifespan, data);
}
function closeSession(_ref5) {
  let {
      lifespan
    } = _ref5,
    data = _objectWithoutPropertiesLoose(_ref5, _excluded5);
  return makeIntent(IntentName.closeSession, lifespan, data);
}
function listSessions(_ref6) {
  let {
      lifespan
    } = _ref6,
    data = _objectWithoutPropertiesLoose(_ref6, _excluded6);
  return makeIntent(IntentName.listSessions, lifespan, data);
}
function getSession(_ref7) {
  let {
      lifespan
    } = _ref7,
    data = _objectWithoutPropertiesLoose(_ref7, _excluded7);
  return makeIntent(IntentName.getSession, lifespan, data);
}
function sessionAuthProof(_ref8) {
  let {
      lifespan
    } = _ref8,
    data = _objectWithoutPropertiesLoose(_ref8, _excluded8);
  return makeIntent(IntentName.sessionAuthProof, lifespan, data);
}
function getIdToken(_ref9) {
  let {
      lifespan
    } = _ref9,
    data = _objectWithoutPropertiesLoose(_ref9, _excluded9);
  return makeIntent(IntentName.getIdToken, lifespan, data);
}

const _excluded$1 = ["token", "to", "value"],
  _excluded2$1 = ["token", "to", "id", "safe", "data"],
  _excluded3$1 = ["token", "to", "values", "data"],
  _excluded4 = ["to", "value", "abi", "func", "args"];

// Deprecated: please use SendContractCallArgs instead

function feeOptions({
  lifespan,
  wallet,
  identifier,
  chainId,
  transactions
}) {
  return makeIntent(IntentName.feeOptions, lifespan, {
    identifier,
    wallet,
    network: chainId.toString(),
    transactions: transactions.map(tx => {
      if (!tx.to || tx.to === ethers.ZeroAddress) {
        throw new Error('Contract creation not supported');
      }
      if (!isEthersTx(tx)) {
        return tx;
      }
      return {
        type: 'transaction',
        to: tx.to,
        value: toHexString(BigInt(tx.value || 0)),
        data: ethers.hexlify(tx.data || '0x')
      };
    })
  });
}
function sendTransactions({
  lifespan,
  wallet,
  identifier,
  chainId,
  transactions,
  transactionsFeeQuote,
  transactionsFeeOption
}) {
  return makeIntent(IntentName.sendTransaction, lifespan, {
    identifier,
    wallet,
    network: chainId.toString(),
    transactions: withTransactionFee(transactions, transactionsFeeOption).map(tx => {
      if (!tx.to || tx.to === ethers.ZeroAddress) {
        throw new Error('Contract creation not supported');
      }
      if (!isEthersTx(tx)) {
        return tx;
      }
      return {
        type: 'transaction',
        to: tx.to,
        value: toHexString(BigInt(tx.value || 0)),
        data: ethers.hexlify(tx.data || '0x')
      };
    }),
    transactionsFeeQuote
  });
}
function withTransactionFee(transactions, feeOption) {
  const extendedTransactions = [...transactions];
  if (feeOption) {
    switch (feeOption.token.type) {
      case FeeTokenType.unknown:
        extendedTransactions.push({
          to: feeOption.to,
          value: feeOption.value
        });
        break;
      case FeeTokenType.erc20Token:
        if (!feeOption.token.contractAddress) {
          throw new Error('contract address is required');
        }
        extendedTransactions.push(erc20({
          tokenAddress: feeOption.token.contractAddress,
          to: feeOption.to,
          value: feeOption.value
        }));
        break;
      case FeeTokenType.erc1155Token:
        if (!feeOption.token.contractAddress) {
          throw new Error('contract address is required');
        }
        if (!feeOption.token.tokenID) {
          throw new Error('token ID is required');
        }
        extendedTransactions.push(erc1155({
          tokenAddress: feeOption.token.contractAddress,
          to: feeOption.to,
          vals: [{
            id: feeOption.token.tokenID,
            amount: feeOption.value
          }]
        }));
        break;
    }
  }
  return extendedTransactions;
}
function getTransactionReceipt({
  lifespan,
  chainId,
  wallet,
  metaTxHash
}) {
  return makeIntent(IntentName.getTransactionReceipt, lifespan, {
    wallet,
    network: chainId.toString(),
    metaTxHash
  });
}
function sendERC20(_ref) {
  let {
      token,
      to,
      value
    } = _ref,
    args = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  return sendTransactions(_extends({
    transactions: [erc20({
      tokenAddress: token,
      to,
      value: value.toString()
    })]
  }, args));
}
function sendERC721(_ref2) {
  let {
      token,
      to,
      id,
      safe,
      data
    } = _ref2,
    args = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
  return sendTransactions(_extends({
    transactions: [erc721({
      tokenAddress: token,
      to,
      id,
      data,
      safe
    })]
  }, args));
}
function sendERC1155(_ref3) {
  let {
      token,
      to,
      values,
      data
    } = _ref3,
    args = _objectWithoutPropertiesLoose(_ref3, _excluded3$1);
  const vals = values.map(v => ({
    id: v.id,
    amount: BigInt(v.amount).toString()
  }));
  return sendTransactions(_extends({
    transactions: [erc1155({
      tokenAddress: token,
      to,
      vals,
      data
    })]
  }, args));
}
function sendContractCall(_ref4) {
  let {
      to,
      value,
      abi,
      func,
      args
    } = _ref4,
    otherArgs = _objectWithoutPropertiesLoose(_ref4, _excluded4);
  return sendTransactions(_extends({
    transactions: [contractCall({
      to,
      value: BigInt(value || 0).toString(),
      data: {
        abi,
        func,
        args
      }
    })]
  }, otherArgs));
}
function erc20(data) {
  const sendERC20Args = data;
  const transactionERC20 = data;
  if (sendERC20Args.token !== undefined) {
    return {
      type: 'erc20send',
      tokenAddress: sendERC20Args.token,
      to: sendERC20Args.to,
      value: sendERC20Args.value.toString()
    };
  } else if (transactionERC20.tokenAddress !== undefined) {
    return _extends({
      type: 'erc20send'
    }, transactionERC20);
  } else {
    throw new Error('Invalid ERC20 transaction');
  }
}
function erc721(data) {
  const sendERC721Args = data;
  const transactionERC721 = data;
  if (sendERC721Args.token !== undefined) {
    return {
      type: 'erc721send',
      tokenAddress: sendERC721Args.token,
      to: sendERC721Args.to,
      id: sendERC721Args.id,
      data: sendERC721Args.data,
      safe: sendERC721Args.safe
    };
  } else if (transactionERC721.tokenAddress !== undefined) {
    return _extends({
      type: 'erc721send'
    }, transactionERC721);
  } else {
    throw new Error('Invalid ERC721 transaction');
  }
}
function erc1155(data) {
  const sendERC1155Args = data;
  const transactionERC1155 = data;
  if (sendERC1155Args.values !== undefined) {
    return {
      type: 'erc1155send',
      vals: sendERC1155Args.values.map(v => ({
        id: v.id,
        amount: v.amount.toString()
      })),
      tokenAddress: sendERC1155Args.token,
      to: sendERC1155Args.to,
      data: sendERC1155Args.data
    };
  } else if (transactionERC1155.vals !== undefined) {
    return {
      type: 'erc1155send',
      vals: transactionERC1155.vals.map(v => ({
        id: v.id,
        amount: v.amount
      })),
      tokenAddress: transactionERC1155.tokenAddress,
      to: transactionERC1155.to,
      data: transactionERC1155.data
    };
  } else {
    throw new Error('Invalid ERC1155 transaction');
  }
}
function contractCall(data) {
  const sendContractCallArgs = data;
  const transactionContractCall = data;
  if (sendContractCallArgs.abi !== undefined) {
    return {
      type: 'contractCall',
      to: sendContractCallArgs.to,
      value: toHexString(BigInt(sendContractCallArgs.value || 0)),
      data: {
        abi: sendContractCallArgs.abi,
        func: sendContractCallArgs.func,
        args: sendContractCallArgs.args
      }
    };
  } else if (transactionContractCall.data !== undefined) {
    return {
      type: 'contractCall',
      to: transactionContractCall.to,
      value: transactionContractCall.value,
      data: transactionContractCall.data
    };
  } else {
    throw new Error('Invalid contract transaction');
  }
}

// Deprecated
function delayedEncode(data) {
  const sendDelayedEncodeArgs = data;
  const transactionDelayedEncode = data;
  if (sendDelayedEncodeArgs.abi !== undefined) {
    return {
      type: 'delayedEncode',
      to: sendDelayedEncodeArgs.to,
      value: toHexString(BigInt(sendDelayedEncodeArgs.value)),
      data: {
        abi: sendDelayedEncodeArgs.abi,
        func: sendDelayedEncodeArgs.func,
        args: sendDelayedEncodeArgs.args
      }
    };
  } else if (transactionDelayedEncode.data !== undefined) {
    return {
      type: 'delayedEncode',
      to: transactionDelayedEncode.to,
      value: transactionDelayedEncode.value,
      data: transactionDelayedEncode.data
    };
  } else {
    throw new Error('Invalid delayed encode transaction');
  }
}
function combineTransactionIntents(intents) {
  if (intents.length === 0) {
    throw new Error('No packets provided');
  }

  // Ensure that all packets are for the same network and wallet
  const network = intents[0].data.network;
  const wallet = intents[0].data.wallet;
  const lifespan = intents[0].expiresAt - intents[0].issuedAt;
  const identifier = intents[0].data.identifier;
  const transactionsFeeQuote = intents[0].data.transactionsFeeQuote;
  if (!intents.every(intent => intent.data.network === network)) {
    throw new Error('All packets must have the same chainId');
  }
  if (!intents.every(intent => intent.data.wallet === wallet)) {
    throw new Error('All packets must have the same wallet');
  }
  return makeIntent(IntentName.sendTransaction, lifespan, {
    network,
    wallet,
    identifier,
    transactions: intents.flatMap(intent => intent.data.transactions),
    transactionsFeeQuote
  });
}
function isEthersTx(tx) {
  return !['transaction', 'erc20send', 'erc721send', 'erc1155send', 'delayedEncode', 'contractCall'].includes(tx.type);
}

class StoreObj {
  constructor(store, key, defaultValue) {
    this.store = store;
    this.key = key;
    this.defaultValue = defaultValue;
  }
  async get() {
    const value = await this.store.get(this.key);
    return value ? value : this.defaultValue;
  }
  async set(value) {
    if (value) {
      await this.store.set(this.key, value);
    } else {
      await this.store.set(this.key, null);
    }
  }
}
class LocalStore {
  constructor() {
    this.store = void 0;
    if (WindowLocalStorage.isAvailable()) {
      this.store = new WindowLocalStorage();
    } else {
      this.store = new MemoryStore();
    }
  }
  async get(key) {
    return this.store.get(key);
  }
  async set(key, value) {
    return this.store.set(key, value);
  }
}
class WindowLocalStorage {
  static isAvailable() {
    return typeof window === 'object' && typeof window.localStorage === 'object';
  }
  constructor() {
    if (!WindowLocalStorage.isAvailable()) {
      throw new Error('No localStorage');
    }
  }
  async get(key) {
    return window.localStorage.getItem(key);
  }
  async set(key, value) {
    if (!value) {
      window.localStorage.removeItem(key);
    } else {
      window.localStorage.setItem(key, value);
    }
  }
}
class MemoryStore {
  constructor() {
    this.store = {};
    this.store = {};
  }
  async get(key) {
    return this.store[key] || null;
  }
  async set(key, value) {
    if (value) {
      this.store[key] = value;
    } else {
      delete this.store[key];
    }
  }
}

var store = /*#__PURE__*/Object.freeze({
  __proto__: null,
  StoreObj: StoreObj,
  LocalStore: LocalStore,
  WindowLocalStorage: WindowLocalStorage,
  MemoryStore: MemoryStore
});

const idbName$1 = 'seq-waas-session-p256k1';
const idbStoreName$1 = 'seq-waas-session';
async function newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend) {
  const privateKey = await secureStoreBackend.get(idbName$1, idbStoreName$1, sessionId);
  if (!privateKey) {
    throw new Error('No private key found');
  }
  const wallet = new ethers.Wallet(privateKey);
  return {
    sessionId() {
      return wallet.getAddress();
    },
    sign(message) {
      return wallet.signMessage(message);
    },
    clear: async () => {
      await secureStoreBackend.delete(idbName$1, idbStoreName$1, sessionId);
    }
  };
}
async function newSECP256K1SessionFromPrivateKey(privateKey, secureStoreBackend) {
  const wallet = new ethers.Wallet(privateKey);
  const sessionId = await wallet.getAddress();
  await secureStoreBackend.set(idbName$1, idbStoreName$1, sessionId, privateKey);
  return newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend);
}
async function newSECP256K1Session(secureStoreBackend) {
  const wallet = ethers.Wallet.createRandom();
  return newSECP256K1SessionFromPrivateKey(wallet.privateKey, secureStoreBackend);
}

let KeyTypes = /*#__PURE__*/function (KeyTypes) {
  KeyTypes[KeyTypes["ECDSAP256K1"] = 0] = "ECDSAP256K1";
  KeyTypes[KeyTypes["ECDSAP256R1"] = 1] = "ECDSAP256R1";
  return KeyTypes;
}({});

const idbName = 'seq-waas-session-p256r1';
const idbStoreName = 'seq-waas-session';

// TODO: We need to update this to use the secure store backend
// Currently it ignores the override and leverages idb
// This is because the CryptoKeyPair is a bit more complicated
// than a simple string that SecureStoreBackend can handle

async function newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend) {
  const keys = await secureStoreBackend.get(idbName, idbStoreName, sessionId);
  if (!keys || !keys.privateKey) {
    throw new Error('No private key found');
  }
  const encoder = new TextEncoder();
  return {
    sessionId: async () => {
      const pubKeyRaw = await cryptoBackend.exportKey('raw', keys.publicKey);
      const pubKeyTypedRaw = new Uint8Array(pubKeyRaw.byteLength + 1);

      // set the first byte to the key type
      pubKeyTypedRaw[0] = KeyTypes.ECDSAP256R1;
      pubKeyTypedRaw.set(new Uint8Array(pubKeyRaw), 1);
      return ethers.hexlify(pubKeyTypedRaw);
    },
    sign: async message => {
      if (typeof message === 'string') {
        if (message.startsWith('0x')) {
          message = message.slice(2);
          message = ethers.getBytes(message);
        } else {
          message = encoder.encode(message);
        }
      }
      const signatureBuff = await cryptoBackend.sign({
        name: 'ECDSA',
        hash: {
          name: 'SHA-256'
        }
      }, keys.privateKey, message);
      return ethers.hexlify(new Uint8Array(signatureBuff));
    },
    clear: async () => {
      await secureStoreBackend.delete(idbName, idbStoreName, sessionId);
    }
  };
}
async function newSECP256R1SessionFromKeyPair(keyPair, cryptoBackend, secureStoreBackend) {
  const sessionId = await pubKeyToSessionId(cryptoBackend, keyPair.publicKey);
  await secureStoreBackend.set(idbName, idbStoreName, sessionId, keyPair);
  return newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend);
}
async function newSECP256R1Session(cryptoBackend, secureStoreBackend) {
  const generatedKeys = await cryptoBackend.generateKey({
    name: 'ECDSA',
    namedCurve: 'P-256'
  }, false, ['sign', 'verify']);
  return newSECP256R1SessionFromKeyPair(generatedKeys, cryptoBackend, secureStoreBackend);
}
async function pubKeyToSessionId(cryptoBackend, pubKey) {
  const pubKeyRaw = await cryptoBackend.exportKey('raw', pubKey);
  const pubKeyTypedRaw = new Uint8Array(pubKeyRaw.byteLength + 1);

  // set the first byte to the key type
  pubKeyTypedRaw[0] = KeyTypes.ECDSAP256R1;
  pubKeyTypedRaw.set(new Uint8Array(pubKeyRaw), 1);
  return ethers.hexlify(pubKeyTypedRaw);
}

async function newSessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend) {
  if (!secureStoreBackend) {
    throw new Error('No secure store available');
  }
  if (cryptoBackend) {
    return newSECP256R1SessionFromSessionId(sessionId, cryptoBackend, secureStoreBackend);
  } else {
    return newSECP256K1SessionFromSessionId(sessionId, secureStoreBackend);
  }
}
async function newSession(cryptoBackend, secureStoreBackend) {
  if (!secureStoreBackend) {
    throw new Error('No secure store available');
  }
  if (cryptoBackend) {
    return newSECP256R1Session(cryptoBackend, secureStoreBackend);
  } else {
    return newSECP256K1Session(secureStoreBackend);
  }
}

const _excluded = ["lifespan"],
  _excluded2 = ["lifespan"],
  _excluded3 = ["lifespan"];
function listAccounts(_ref) {
  let {
      lifespan
    } = _ref,
    data = _objectWithoutPropertiesLoose(_ref, _excluded);
  return makeIntent(IntentName.listAccounts, lifespan, data);
}
function federateAccount(_ref2) {
  let {
      lifespan
    } = _ref2,
    data = _objectWithoutPropertiesLoose(_ref2, _excluded2);
  return makeIntent(IntentName.federateAccount, lifespan, data);
}
function removeAccount(_ref3) {
  let {
      lifespan
    } = _ref3,
    data = _objectWithoutPropertiesLoose(_ref3, _excluded3);
  return makeIntent(IntentName.removeAccount, lifespan, data);
}

const RPC_BASE = 'https://nodes.sequence.app/';
const nameToId = Object.entries(networks$1).reduce((acc, [key, value]) => {
  acc[value.name] = value.chainId;
  return acc;
}, {});
const idToName = Object.entries(nameToId).reduce((acc, [key, value]) => {
  acc[value] = key;
  return acc;
}, {});
function isSimpleNetwork(network) {
  return toNetworkID(network) in nameToId;
}
function toNetworkID(network) {
  const networkNumber = typeof network === 'number' ? network : parseInt(network);
  if (networkNumber in idToName) {
    return networkNumber;
  }
  const networkLower = network.toString().toLowerCase();
  if (networkLower in nameToId) {
    return nameToId[networkLower];
  }
  throw new Error(`Unknown network: ${network}`);
}
function nameOfNetwork(network) {
  return idToName[toNetworkID(network)];
}
function rpcNode(network) {
  return RPC_BASE + nameOfNetwork(network);
}

var networks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isSimpleNetwork: isSimpleNetwork,
  toNetworkID: toNetworkID,
  nameOfNetwork: nameOfNetwork,
  rpcNode: rpcNode
});

const getDefaultSubtleCryptoBackend = () => {
  if (isWindowSubtleCryptoAvailable()) {
    return new WindowSubtleCryptoBackend();
  } else {
    return null;
  }
};
function isWindowSubtleCryptoAvailable() {
  return typeof window === 'object' && typeof window.crypto === 'object' && typeof window.crypto.subtle === 'object';
}
class WindowSubtleCryptoBackend {
  constructor() {
    if (!isWindowSubtleCryptoAvailable()) {
      throw new Error('window.crypto.subtle is not available');
    }
  }
  generateKey(algorithm, extractable, keyUsages) {
    return window.crypto.subtle.generateKey(algorithm, extractable, keyUsages);
  }
  importKey(format, keyData, algorithm, extractable, keyUsages) {
    return window.crypto.subtle.importKey(format, keyData, algorithm, extractable, keyUsages);
  }
  async exportKey(format, key) {
    const keyData = await window.crypto.subtle.exportKey(format, key);
    return new Uint8Array(keyData);
  }
  async digest(algorithm, data) {
    const digest = await window.crypto.subtle.digest(algorithm, data);
    return new Uint8Array(digest);
  }
  async sign(algorithm, key, data) {
    const signature = await window.crypto.subtle.sign(algorithm, key, data);
    return new Uint8Array(signature);
  }
  verify(algorithm, key, signature, data) {
    return window.crypto.subtle.verify(algorithm, key, signature, data);
  }
  getRandomValues(len) {
    const randomValues = new Uint8Array(len);
    return window.crypto.getRandomValues(randomValues);
  }
}

const getDefaultSecureStoreBackend = () => {
  if (isIndexedDbAvailable()) {
    return new IndexedDbSecureStoreBackend();
  } else {
    return null;
  }
};
function isIndexedDbAvailable() {
  return typeof indexedDB === 'object';
}
class IndexedDbSecureStoreBackend {
  constructor() {
    this.db = void 0;
    if (!isIndexedDbAvailable()) {
      throw new Error('IndexedDB is not available');
    }
    this.db = null;
  }
  async openDB(dbName, dbStoreName, version) {
    if (this.db) {
      return this.db;
    }
    this.db = await openDB(dbName, 1, {
      upgrade(db) {
        db.createObjectStore(dbStoreName);
      }
    });
    return this.db;
  }
  async get(dbName, dbStoreName, key) {
    const db = await this.openDB(dbName, dbStoreName, 1);
    const tx = db.transaction(dbStoreName, 'readonly');
    const value = await db.get(dbStoreName, key);
    await tx.done;
    return value;
  }
  async set(dbName, dbStoreName, key, value) {
    const db = await this.openDB(dbName, dbStoreName, 1);
    const tx = db.transaction(dbStoreName, 'readwrite');
    await db.put(dbStoreName, value, key);
    await tx.done;
    return true;
  }
  async delete(dbName, dbStoreName, key) {
    const db = await this.openDB(dbName, dbStoreName, 1);
    const tx = db.transaction(dbStoreName, 'readwrite');
    await db.delete(dbStoreName, key);
    await tx.done;
    return true;
  }
}

const SEQUENCE_WAAS_WALLET_KEY = '@0xsequence.waas.wallet';
const SEQUENCE_WAAS_SESSION_ID_KEY = '@0xsequence.waas.session_id';
const SEQUENCE_WAAS_STATUS_KEY = '@0xsequence.waas.status';

// 5 minutes of default lifespan
const DEFAULT_LIFESPAN = 5 * 60;
class SequenceWaaSBase {
  constructor(config = {
    network: 1
  }, store = new LocalStore(), cryptoBackend = getDefaultSubtleCryptoBackend(), secureStoreBackend = getDefaultSecureStoreBackend()) {
    this.config = config;
    this.store = store;
    this.cryptoBackend = cryptoBackend;
    this.secureStoreBackend = secureStoreBackend;
    this.status = void 0;
    this.sessionId = void 0;
    this.wallet = void 0;
    this.sessionObservers = [];
    this.gettingSessionIdPromise = void 0;
    this.status = new StoreObj(this.store, SEQUENCE_WAAS_STATUS_KEY, 'signed-out');
    this.sessionId = new StoreObj(this.store, SEQUENCE_WAAS_SESSION_ID_KEY, undefined);
    this.wallet = new StoreObj(this.store, SEQUENCE_WAAS_WALLET_KEY, undefined);
  }
  async getAddress() {
    return this.getWalletAddress();
  }
  async getWalletAddress() {
    if (!(await this.isSignedIn())) {
      throw new Error('Not signed in');
    }
    const wallet = await this.wallet.get();
    if (!wallet) {
      throw new Error('No wallet');
    }
    return wallet;
  }
  async commonArgs(args) {
    var _args$lifespan;
    return _extends({}, args, {
      identifier: args == null ? void 0 : args.identifier,
      wallet: await this.getWalletAddress(),
      lifespan: (_args$lifespan = args == null ? void 0 : args.lifespan) != null ? _args$lifespan : DEFAULT_LIFESPAN,
      chainId: toNetworkID(args.network || this.config.network)
    });
  }

  /**
   * Builds a payload that can be sent to the WaaS API to sign a transaction.
   * It automatically signs the payload, and attaches the current wallet address.
   *
   * @param packet The action already packed into a packet
   * @returns A payload that can be sent to the WaaS API
   */
  async signIntent(intent) {
    const sessionId = await this.getSessionId();
    if (sessionId === undefined) {
      throw new Error('session not open');
    }
    const session = await newSessionFromSessionId(sessionId, this.cryptoBackend, this.secureStoreBackend);
    return signIntent(session, intent);
  }
  async signUsingSessionKey(message) {
    const sessionId = await this.getSessionId();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const signer = await newSessionFromSessionId(sessionId, this.cryptoBackend, this.secureStoreBackend);
    return signer.sign(message);
  }
  /**
   * This method will return session id.
   *
   * @returns an id of the session
   */
  async getSessionId() {
    var _this = this;
    if (this.gettingSessionIdPromise) {
      return this.gettingSessionIdPromise;
    }
    const promiseGenerator = async function promiseGenerator() {
      let sessionId = await _this.sessionId.get();
      if (!sessionId) {
        const session = await newSession(_this.cryptoBackend, _this.secureStoreBackend);
        sessionId = await session.sessionId();
        await _this.sessionId.set(sessionId);
        _this.signalObservers(_this.sessionObservers, sessionId);
      }
      _this.gettingSessionIdPromise = undefined;
      return sessionId;
    };
    this.gettingSessionIdPromise = promiseGenerator();
    return this.gettingSessionIdPromise;
  }

  /**
   * This method will initiate a sign-in process with the waas API. It must be performed
   * when the user wants to sign in to the app, in parallel with the authentication of the
   * application's own authentication system.
   *
   * This method begins the sign-in process, but does not complete it. The returned payload
   * must be sent to the waas API to complete the sign-in. The waas API will return a receipt
   * that must be sent to the `completeSignIn` method to complete the sign-in.
   *
   * @param idToken Information about the user that can be used to prove their identity
   * @returns a session payload that **must** be sent to the waas API to complete the sign-in
   * @throws {Error} If the session is already signed in or there is a pending sign-in
   */
  async signInWithIdToken(idToken) {
    const status = await this.status.get();
    if (status !== 'signed-out') {
      await this.completeSignOut();
      throw new Error('you are already signed in'); // TODO change this awful msg
    }
    const sessionId = await this.getSessionId();
    const intent = await openSession({
      sessionId,
      identityType: IdentityType.None,
      idToken,
      lifespan: DEFAULT_LIFESPAN
    });
    await this.status.set('pending');
    return this.signIntent(intent);
  }
  async initiateGuestAuth() {
    const sessionId = await this.getSessionId();
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Guest,
      verifier: sessionId,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateEmailAuth(email) {
    const sessionId = await this.getSessionId();
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Email,
      verifier: `${email};${sessionId}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateIdTokenAuth(idToken, exp) {
    const sessionId = await this.getSessionId();
    const idTokenHash = ethers.id(idToken);
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.OIDC,
      verifier: `${idTokenHash};${exp}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiateStytchAuth(idToken, exp) {
    const sessionId = await this.getSessionId();
    const idTokenHash = ethers.id(idToken);
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.Stytch,
      verifier: `${idTokenHash};${exp}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async initiatePlayFabAuth(titleId, sessionTicket) {
    const sessionId = await this.getSessionId();
    const ticketHash = ethers.id(sessionTicket);
    const intent = await initiateAuth({
      sessionId,
      identityType: IdentityType.PlayFab,
      verifier: `${titleId}|${ticketHash}`,
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async completeAuth(params, optParams) {
    const sessionId = await this.getSessionId();
    const intent = await openSession(_extends({}, optParams, {
      sessionId,
      lifespan: DEFAULT_LIFESPAN
    }, params));
    await this.status.set('pending');
    return this.signIntent(intent);
  }
  onSessionStateChanged(callback) {
    this.sessionObservers.push(callback);
    return () => {
      this.sessionObservers = this.sessionObservers.filter(o => o != callback);
    };
  }
  async signOut({
    lifespan,
    sessionId
  } = {}) {
    sessionId = sessionId || (await this.sessionId.get());
    if (!sessionId) {
      throw new Error('session not open');
    }
    const intent = closeSession({
      lifespan: lifespan || DEFAULT_LIFESPAN,
      sessionId: sessionId
    });
    return this.signIntent(intent);
  }
  async signOutSession(sessionId) {
    const intent = closeSession({
      lifespan: DEFAULT_LIFESPAN,
      sessionId: sessionId
    });
    return this.signIntent(intent);
  }
  async listSessions() {
    const intent = listSessions({
      lifespan: DEFAULT_LIFESPAN,
      wallet: await this.getWalletAddress()
    });
    return this.signIntent(intent);
  }
  async completeSignOut() {
    await Promise.all([this.status.set('signed-out'), this.wallet.set(undefined), this.sessionId.set(undefined)]);
    this.signalObservers(this.sessionObservers, null);
  }

  /**
   * This method will complete a sign-in process with the waas API. It must be performed
   * after the `signIn` method, when the waas API has returned a receipt.
   *
   * This method completes the sign-in process by validating the receipt's proof.
   * If the proof is invalid or there is no pending sign-in, it will throw an error.
   *
   * After this method is called, the wallet is ready to be used to sign transactions.
   *
   * @param receipt The receipt returned by the waas API after the `signIn` method
   * @returns The wallet address of the user that signed in
   * @throws {Error} If there is no pending sign-in or the receipt is invalid
   */
  async completeSignIn(receipt) {
    if (receipt.result) {
      return this.completeSignIn(receipt.result);
    }
    const status = await this.status.get();
    if (receipt.code !== 'sessionOpened') {
      throw new Error('Invalid receipt');
    }
    if (status !== 'pending') {
      throw new Error('No pending sign in');
    }
    await Promise.all([this.status.set('signed-in'), this.wallet.set(receipt.data.wallet)]);
    return receipt.data.wallet;
  }
  async isSignedIn() {
    const status = await this.status.get();
    return status === 'signed-in';
  }
  async sessionAuthProof(args) {
    var _args$lifespan2;
    const packet = sessionAuthProof({
      lifespan: (_args$lifespan2 = args.lifespan) != null ? _args$lifespan2 : DEFAULT_LIFESPAN,
      network: toNetworkID(args.network || this.config.network).toString(),
      wallet: await this.getWalletAddress(),
      nonce: args.nonce
    });
    return this.signIntent(packet);
  }

  //
  // Signer methods
  //

  /**
   * This method can be used to sign message using waas API. It can only be used
   * after successfully signing in with the `signIn` and `completeSignIn` methods.
   *
   * The method does not sign the message. It only returns a payload
   * that must be sent to the waas API to complete the sign process.
   *
   * @param chainId The network on which the message will be signed
   * @param message  The message that will be signed
   * @return a payload that must be sent to the waas API to complete sign process
   */
  async signMessage(args) {
    var _args$lifespan3;
    const packet = signMessage(_extends({
      chainId: toNetworkID(args.network || this.config.network)
    }, args, {
      lifespan: (_args$lifespan3 = args.lifespan) != null ? _args$lifespan3 : DEFAULT_LIFESPAN,
      wallet: await this.getWalletAddress()
    }));
    return this.signIntent(packet);
  }

  /**
   * This method can be used to send transactions to the waas API. It can only be used
   * after successfully signing in with the `signIn` and `completeSignIn` methods.
   *
   * The method does not send the transactions to the network. It only returns a payload
   * that must be sent to the waas API to complete the transaction.
   *
   * @param transactions The transactions to be sent
   * @param chainId The network on which the transactions will be sent
   * @returns a payload that must be sent to the waas API to complete the transaction
   */
  async sendTransaction(args) {
    const intent = sendTransactions(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async getTransactionReceipt(args) {
    const intent = getTransactionReceipt(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC20(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error('Cannot burn tokens using sendERC20');
    }
    const intent = sendERC20(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC721(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error('Cannot burn tokens using sendERC721');
    }
    const intent = sendERC721(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async sendERC1155(args) {
    if (args.token.toLowerCase() === args.to.toLowerCase()) {
      throw new Error('Cannot burn tokens using sendERC1155');
    }
    const intent = sendERC1155(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async callContract(args) {
    const intent = sendContractCall(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async feeOptions(args) {
    const intent = feeOptions(await this.commonArgs(args));
    return this.signIntent(intent);
  }
  async validateSession({
    deviceMetadata
  }) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const intent = await validateSession({
      lifespan: DEFAULT_LIFESPAN,
      sessionId: sessionId,
      deviceMetadata,
      wallet: await this.getWalletAddress()
    });
    return this.signIntent(intent);
  }
  async getSession() {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const intent = getSession({
      sessionId,
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async finishValidateSession(salt, challenge) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const wallet = await this.getWalletAddress();
    const intent = finishValidateSession({
      sessionId,
      wallet,
      lifespan: DEFAULT_LIFESPAN,
      salt,
      challenge
    });
    return this.signIntent(intent);
  }
  async listAccounts() {
    const intent = listAccounts({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN
    });
    return this.signIntent(intent);
  }
  async linkAccount(params) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const intent = federateAccount(_extends({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      sessionId
    }, params));
    return this.signIntent(intent);
  }
  async removeAccount({
    accountId
  }) {
    const intent = removeAccount({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      accountId
    });
    return this.signIntent(intent);
  }
  async getIdToken({
    nonce
  }) {
    const sessionId = await this.sessionId.get();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const intent = getIdToken({
      wallet: await this.getWalletAddress(),
      lifespan: DEFAULT_LIFESPAN,
      sessionId,
      nonce
    });
    return this.signIntent(intent);
  }
  async batch(intents) {
    const combined = combineTransactionIntents(intents);
    return this.signIntent(combined);
  }
  signalObservers(observers, value) {
    observers.forEach(observer => observer(value));
  }
  async updateIntentTime(intent, time) {
    const newIntent = changeIntentTime(intent, time);
    return this.signIntent(newIntent);
  }
}

//
// Client
//
class WaasAuthenticator {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/WaasAuthenticator/';
    this.registerSession = (args, headers, signal) => {
      return this.fetch(this.url('RegisterSession'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            session: _data.session,
            response: _data.response
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.sendIntent = (args, headers, signal) => {
      return this.fetch(this.url('SendIntent'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            response: _data.response
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.chainList = (headers, signal) => {
      return this.fetch(this.url('ChainList'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chains: _data.chains
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      });
    }
    if (!res.ok) {
      const code = typeof data.code === 'number' ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};

//
// Errors
//

class WebrpcError extends Error {
  constructor(name, code, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    this.msg = void 0;
    this.name = name || 'WebrpcError';
    this.code = typeof code === 'number' ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === 'number' ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}

// Webrpc errors

class WebrpcEndpointError extends WebrpcError {
  constructor(name = 'WebrpcEndpoint', code = 0, message = 'endpoint error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
}
class WebrpcRequestFailedError extends WebrpcError {
  constructor(name = 'WebrpcRequestFailed', code = -1, message = 'request failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
}
class WebrpcBadRouteError extends WebrpcError {
  constructor(name = 'WebrpcBadRoute', code = -2, message = 'bad route', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
}
class WebrpcBadMethodError extends WebrpcError {
  constructor(name = 'WebrpcBadMethod', code = -3, message = 'bad method', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
}
class WebrpcBadRequestError extends WebrpcError {
  constructor(name = 'WebrpcBadRequest', code = -4, message = 'bad request', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
}
class WebrpcBadResponseError extends WebrpcError {
  constructor(name = 'WebrpcBadResponse', code = -5, message = 'bad response', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
}
class WebrpcServerPanicError extends WebrpcError {
  constructor(name = 'WebrpcServerPanic', code = -6, message = 'server panic', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
}
class WebrpcInternalErrorError extends WebrpcError {
  constructor(name = 'WebrpcInternalError', code = -7, message = 'internal error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
}
class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(name = 'WebrpcClientDisconnected', code = -8, message = 'client disconnected', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
}
class WebrpcStreamLostError extends WebrpcError {
  constructor(name = 'WebrpcStreamLost', code = -9, message = 'stream lost', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
}
class WebrpcStreamFinishedError extends WebrpcError {
  constructor(name = 'WebrpcStreamFinished', code = -10, message = 'stream finished', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
}

// Schema errors

class UnauthorizedError extends WebrpcError {
  constructor(name = 'Unauthorized', code = 1000, message = 'Unauthorized access', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}
class TenantNotFoundError extends WebrpcError {
  constructor(name = 'TenantNotFound', code = 1001, message = 'Tenant not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, TenantNotFoundError.prototype);
  }
}
class EmailAlreadyInUseError extends WebrpcError {
  constructor(name = 'EmailAlreadyInUse', code = 7000, message = 'Could not create account as the email is already in use', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, EmailAlreadyInUseError.prototype);
  }
}
class AccountAlreadyLinkedError extends WebrpcError {
  constructor(name = 'AccountAlreadyLinked', code = 7001, message = 'Could not link account as it is linked to another wallet', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, AccountAlreadyLinkedError.prototype);
  }
}
class ProofVerificationFailedError extends WebrpcError {
  constructor(name = 'ProofVerificationFailed', code = 7002, message = 'The authentication proof could not be verified', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ProofVerificationFailedError.prototype);
  }
}
class AnswerIncorrectError extends WebrpcError {
  constructor(name = 'AnswerIncorrect', code = 7003, message = 'The provided answer is incorrect', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, AnswerIncorrectError.prototype);
  }
}
class ChallengeExpiredError extends WebrpcError {
  constructor(name = 'ChallengeExpired', code = 7004, message = 'The challenge has expired', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ChallengeExpiredError.prototype);
  }
}
class TooManyAttemptsError extends WebrpcError {
  constructor(name = 'TooManyAttempts', code = 7005, message = 'Too many attempts', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, TooManyAttemptsError.prototype);
  }
}
let errors = /*#__PURE__*/function (errors) {
  errors["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors["WebrpcInternalError"] = "WebrpcInternalError";
  errors["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors["Unauthorized"] = "Unauthorized";
  errors["TenantNotFound"] = "TenantNotFound";
  errors["EmailAlreadyInUse"] = "EmailAlreadyInUse";
  errors["AccountAlreadyLinked"] = "AccountAlreadyLinked";
  errors["ProofVerificationFailed"] = "ProofVerificationFailed";
  errors["AnswerIncorrect"] = "AnswerIncorrect";
  errors["ChallengeExpired"] = "ChallengeExpired";
  errors["TooManyAttempts"] = "TooManyAttempts";
  return errors;
}({});
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: TenantNotFoundError,
  [7000]: EmailAlreadyInUseError,
  [7001]: AccountAlreadyLinkedError,
  [7002]: ProofVerificationFailedError,
  [7003]: AnswerIncorrectError,
  [7004]: ChallengeExpiredError,
  [7005]: TooManyAttemptsError
};

function isInitiateAuthResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.authInitiated && typeof receipt.data === 'object' && typeof receipt.data.sessionId === 'string' && typeof receipt.data.identityType === 'string' && typeof receipt.data.expiresIn === 'number';
}
function isOpenSessionResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'sessionOpened' && typeof receipt.data === 'object' && typeof receipt.data.sessionId === 'string' && typeof receipt.data.wallet === 'string';
}
function isSentTransactionResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'transactionReceipt' && typeof receipt.data === 'object' && typeof receipt.data.txHash === 'string' && typeof receipt.data.receipt === 'object' && typeof receipt.data.request === 'object';
}
function isTimedOutTransactionResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'transactionReceipt' && typeof receipt.data === 'object' && typeof receipt.data.metaTxHash === 'string' && !receipt.data.txHash && typeof receipt.data.request === 'object';
}
function isFailedTransactionResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'transactionFailed' && typeof receipt.data === 'object' && typeof receipt.data.request === 'object' && Array.isArray(receipt.data.simulations) && typeof receipt.data.error === 'string';
}
function isMaySentTransactionResponse(receipt) {
  return isSentTransactionResponse(receipt) || isFailedTransactionResponse(receipt) || isTimedOutTransactionResponse(receipt);
}
function isSignedMessageResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'signedMessage' && typeof receipt.data === 'object' && typeof receipt.data.message === 'string' && typeof receipt.data.signature === 'string';
}
function isSessionAuthProofResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'sessionAuthProof' && typeof receipt.data === 'object' && typeof receipt.data.sessionId === 'string' && typeof receipt.data.network === 'string' && typeof receipt.data.wallet === 'string' && typeof receipt.data.message === 'string' && typeof receipt.data.signature === 'string';
}
function isFeeOptionsResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'feeOptions' && typeof receipt.data === 'object' && Array.isArray(receipt.data.feeOptions);
}
function isValidationRequiredResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.validationRequired && typeof receipt.data === 'object' && typeof receipt.data.sessionId === 'string';
}
function isValidateSessionResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.validationStarted && typeof receipt.data === 'object';
}
function isFinishValidateSessionResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.validationFinished && typeof receipt.data === 'object';
}
function isCloseSessionResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'sessionClosed';
}
function isGetSessionResponse(receipt) {
  return typeof receipt === 'object' && typeof receipt.code === 'string' && receipt.code === 'getSessionResponse' && typeof receipt.data === 'object' && typeof receipt.data.session === 'string' && typeof receipt.data.wallet === 'string';
}
function isLinkAccountResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.accountFederated && typeof receipt.data === 'object' && typeof receipt.data.account === 'object';
}
function isListAccountsResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.accountList && typeof receipt.data === 'object';
}
function isIntentTimeError(error) {
  var _error$cause, _error$cause2;
  return !!(error instanceof WebrpcError && ((_error$cause = error.cause) != null && _error$cause.endsWith('intent is invalid: intent expired') || (_error$cause2 = error.cause) != null && _error$cause2.endsWith('intent is invalid: intent issued in the future')));
}
function isGetIdTokenResponse(receipt) {
  return typeof receipt === 'object' && receipt.code === IntentResponseCode.idToken && typeof receipt.data === 'object' && typeof receipt.data.idToken === 'string';
}

class EmailAuth {
  constructor(region, clientId) {
    this.region = region;
    this.clientId = clientId;
    this.cognitoMemo = void 0;
  }
  cognito() {
    if (!this.cognitoMemo) {
      this.cognitoMemo = new CognitoIdentityProviderClient({
        region: this.region
      });
    }
    return this.cognitoMemo;
  }
  signUp(email) {
    email = email.toLowerCase().trim();
    return this.cognito().send(new SignUpCommand({
      ClientId: this.clientId,
      Username: email,
      Password: 'aB1%' + getRandomString(14),
      UserAttributes: [{
        Name: 'email',
        Value: email
      }]
    }));
  }
  signIn(email) {
    email = email.toLowerCase().trim();
    return this.cognito().send(new InitiateAuthCommand({
      AuthFlow: 'CUSTOM_AUTH',
      ClientId: this.clientId,
      AuthParameters: {
        USERNAME: email
      }
    }));
  }
  async initiateAuth({
    email
  }) {
    let res;
    email = email.toLowerCase().trim();
    try {
      // Try sign in directly first
      res = await this.signIn(email);
    } catch (e) {
      if (e instanceof UserLambdaValidationException && e.message.includes('user not found')) {
        // Sign up and sign in
        await this.signUp(email);
        res = await this.signIn(email);
      } else {
        throw e;
      }
    }
    if (!res.Session) {
      throw new Error('response session is empty');
    }
    return {
      // Notice: rename session to instance to avoid
      // confusion with the native waas session
      instance: res.Session,
      email: email
    };
  }
  async finalizeAuth({
    instance,
    email,
    answer,
    sessionHash
  }) {
    email = email.toLowerCase().trim();
    const res = await this.cognito().send(new RespondToAuthChallengeCommand({
      ClientId: this.clientId,
      Session: instance,
      ChallengeName: 'CUSTOM_CHALLENGE',
      ChallengeResponses: {
        USERNAME: email,
        ANSWER: answer
      },
      ClientMetadata: {
        SESSION_HASH: sessionHash
      }
    }));
    if (!res.AuthenticationResult || !res.AuthenticationResult.IdToken) {
      throw new Error('AuthenticationResult.IdToken is empty');
    }
    return {
      idToken: res.AuthenticationResult.IdToken
    };
  }
}
function getRandomString(len) {
  return Array.from(getRandomValues(len)).map(nr => nr.toString(16).padStart(2, '0')).join('');
}
function getRandomValues(len) {
  const randomValues = new Uint8Array(len);
  if (typeof window === 'object' && typeof window.crypto === 'object') {
    return window.crypto.getRandomValues(randomValues);
  } else {
    console.warn('window.crypto.getRandomValues is not available. Falling back to less secure Math.random().');
    const _randomValues = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      const randomInteger = Math.floor(Math.random() * 256);
      _randomValues[i] = randomInteger;
    }
    return _randomValues;
  }
}

class Challenge {}
class GuestChallenge extends Challenge {
  constructor(sessionId, challenge) {
    super();
    this.sessionId = sessionId;
    this.challenge = challenge;
  }
  getIntentParams() {
    const answer = ethers.id(this.challenge + this.sessionId);
    return {
      identityType: IdentityType.Guest,
      verifier: this.sessionId,
      answer
    };
  }
  withAnswer(answer) {
    return this;
  }
}
class EmailChallenge extends Challenge {
  constructor(email, sessionId, challenge) {
    super();
    this.email = email;
    this.sessionId = sessionId;
    this.challenge = challenge;
    this.hashedAnswer = void 0;
  }
  getIntentParams() {
    return {
      identityType: IdentityType.Email,
      verifier: `${this.email};${this.sessionId}`,
      answer: this.hashedAnswer
    };
  }
  setAnswer(answer) {
    this.hashedAnswer = ethers.id(this.challenge + answer);
  }
  withAnswer(answer) {
    const challenge = new EmailChallenge(this.email, this.sessionId, this.challenge);
    challenge.setAnswer(answer);
    return challenge;
  }
}
class IdTokenChallenge extends Challenge {
  constructor(idToken) {
    super();
    this.idToken = idToken;
  }
  getIntentParams() {
    const decoded = jwtDecode(this.idToken);
    const idTokenHash = ethers.id(this.idToken);
    return {
      identityType: IdentityType.OIDC,
      verifier: `${idTokenHash};${decoded.exp}`,
      answer: this.idToken
    };
  }
  withAnswer() {
    return this;
  }
}
class StytchChallenge extends IdTokenChallenge {
  constructor(idToken) {
    super(idToken);
    this.idToken = idToken;
  }
  getIntentParams() {
    return _extends({}, super.getIntentParams(), {
      identityType: IdentityType.Stytch
    });
  }
}
class PlayFabChallenge extends Challenge {
  constructor(titleId, sessionTicket) {
    super();
    this.titleId = titleId;
    this.sessionTicket = sessionTicket;
  }
  getIntentParams() {
    const ticketHash = ethers.id(this.sessionTicket);
    return {
      identityType: IdentityType.PlayFab,
      verifier: `${this.titleId}|${ticketHash}`,
      answer: this.sessionTicket
    };
  }
  withAnswer() {
    return this;
  }
}

function parseSequenceWaaSConfigKey(key) {
  return JSON.parse(atob(key));
}
function defaultArgsOrFail(config) {
  const key = config.waasConfigKey;
  const keyOverrides = key ? parseSequenceWaaSConfigKey(key) : {};
  const preconfig = _extends({}, config, keyOverrides);
  if (preconfig.network === undefined) {
    preconfig.network = 1;
  }
  if (preconfig.projectId === undefined) {
    throw new Error('Missing project id');
  }
  if (preconfig.projectAccessKey === undefined) {
    throw new Error('Missing access key');
  }
  return preconfig;
}
const fetch = globalThis.fetch;
const jwksDev = {
  keys: [{
    alg: 'RS256',
    e: 'AQAB',
    kid: '9LkLZyHdNq1N2aeHMlC5jw',
    kty: 'RSA',
    n: 'qllUB_ERsOjbKx4SirGow4XDov05lQyhiF7Duo4sPkH9CwMN11OqhLuIqeIXPq0rPNIXGP99A7riXTcpRNk-5ZNL29zs-Xjj3idp7nZQZLIU1CBQErTcbxbwUYp8Q46k7lJXVlMmwoLQvQAgH8BZLuSe-Xk1tye0mDC-bHvmrMfqm2zmuWeDnZercU3Jg2iYwyPrjKWx7YSBSMTXTKPGndws4m3s3XIEpI2alLcLLWsPQk2UjIlux6I7vLwvjM_BgjFhYHqgg1tgZUPn_Xxt4wvhobF8UIacRVmGcuyYBnhRxKnBQhEClGSBVtnFYYBSvRjTgliOwf3DhFoXdnmyPQ',
    use: 'sig'
  }]
};
const jwksProd = {
  keys: [{
    alg: 'RS256',
    e: 'AQAB',
    kid: 'nWh-_3nQ1lnhhI1ZSQTQmw',
    kty: 'RSA',
    n: 'pECaEq2k0k22J9e7hFLAFmKbzPLlWToUJJmFeWAdEiU4zpW17EUEOyfjRzjgBewc7KFJQEblC3eTD7Vc5bh9-rafPEj8LaKyZzzS5Y9ZATXhlMo5Pnlar3BrTm48XcnT6HnLsvDeJHUVbrYd1JyE1kqeTjUKWvgKX4mgIJiuYhpdzbOC22cPaWb1dYCVhArDVAPHGqaEwRjX7JneETdY5hLJ6JhsAws706W7fwfNKddPQo2mY95S9q8HFxMr5EaXEMmhwxk8nT5k-Ouar2dobMXRMmQiEZSt9fJaGKlK7KWJSnbPOVa2cZud1evs1Rz2SdCSA2bhuZ6NnZCxkqnagw',
    use: 'sig'
  }]
};
class SequenceWaaS {
  constructor(config, store = new LocalStore(), cryptoBackend = getDefaultSubtleCryptoBackend(), secureStoreBackend = getDefaultSecureStoreBackend()) {
    var _this = this;
    this.store = store;
    this.cryptoBackend = cryptoBackend;
    this.secureStoreBackend = secureStoreBackend;
    this.waas = void 0;
    this.client = void 0;
    this.validationRequiredCallback = [];
    this.emailConflictCallback = [];
    this.emailAuthCodeRequiredCallback = [];
    this.validationRequiredSalt = void 0;
    this.config = void 0;
    this.deviceName = void 0;
    this.emailClient = void 0;
    // The last Date header value returned by the server, used for users with desynchronised clocks
    this.lastDate = void 0;
    // Flag for disabling consequent requests if signature verification fails
    this.signatureVerificationFailed = false;
    this._fetch = (input, init) => {
      if (this.signatureVerificationFailed) {
        throw new Error('Signature verification failed');
      }
      if (this.cryptoBackend && this.config.disableHttpSignatureCheck !== true && init != null && init.headers) {
        const headers = {};
        headers['Accept-Signature'] = 'sig=();alg="rsa-v1_5-sha256"';
        init.headers = _extends({}, init.headers, headers);
      }
      const response = fetch(input, init);
      if (this.cryptoBackend && this.config.disableHttpSignatureCheck !== true) {
        response.then(async function (r) {
          try {
            var _contentDigest$match, _signature$match;
            const clone = r.clone();
            const responseBodyText = await clone.text();
            const contentDigest = r.headers.get('Content-Digest');
            const signatureInput = r.headers.get('Signature-Input');
            const signature = r.headers.get('Signature');
            if (!contentDigest) {
              throw new Error('Content-Digest header not set');
            }
            if (!signatureInput) {
              throw new Error('Signature-Input header not set');
            }
            if (!signature) {
              throw new Error('Signature header not set');
            }
            const contentDigestSha = (_contentDigest$match = contentDigest.match(':(.*):')) == null ? void 0 : _contentDigest$match[1];
            if (!contentDigestSha) {
              throw new Error('Content digest not found');
            }
            const responseBodyTextUint8Array = new TextEncoder().encode(responseBodyText);
            const responseBodyTextDigest = await _this.cryptoBackend.digest('SHA-256', responseBodyTextUint8Array);
            const base64EncodedDigest = btoa(String.fromCharCode(...responseBodyTextDigest));
            if (contentDigestSha !== base64EncodedDigest) {
              throw new Error('Digest mismatch');
            }

            // we're removing the first 4 characters from signatureInput to trim the sig= prefix
            const message = `"content-digest": ${contentDigest}\n"@signature-params": ${signatureInput.substring(4)}`;
            const algo = {
              name: 'RSASSA-PKCS1-v1_5',
              hash: 'SHA-256'
            };
            const jwks = r.url.includes('dev-waas') ? jwksDev : jwksProd;
            const key = await _this.cryptoBackend.importKey('jwk', jwks.keys[0], algo, false, ['verify']);
            const sig = (_signature$match = signature.match(':(.*):')) == null ? void 0 : _signature$match[1];
            if (!sig) {
              throw new Error('Signature not found');
            }
            const signatureBuffer = Uint8Array.from(atob(sig), c => c.charCodeAt(0));
            const verifyResult = await _this.cryptoBackend.verify(algo, key, signatureBuffer, new TextEncoder().encode(message));
            if (!verifyResult) {
              throw new Error('Signature verification failed, consequent requests will fail');
            }
          } catch (e) {
            _this.signatureVerificationFailed = true;
            throw e;
          }
        });
      }
      return response;
    };
    this.config = defaultArgsOrFail(config);
    this.waas = new SequenceWaaSBase(_extends({
      network: 1
    }, config), this.store, this.cryptoBackend, this.secureStoreBackend);
    this.client = new WaasAuthenticator(this.config.rpcServer, this._fetch);
    this.deviceName = new StoreObj(this.store, '@0xsequence.waas.auth.deviceName', undefined);
  }
  get email() {
    if (this.emailClient) {
      return this.emailClient;
    }
    if (!this.config.emailRegion) {
      throw new Error('Missing emailRegion');
    }
    if (!this.config.emailClientId) {
      throw new Error('Missing emailClientId');
    }
    this.emailClient = new EmailAuth(this.config.emailRegion, this.config.emailClientId);
    return this.emailClient;
  }
  async onValidationRequired(callback) {
    this.validationRequiredCallback.push(callback);
    return () => {
      this.validationRequiredCallback = this.validationRequiredCallback.filter(c => c !== callback);
    };
  }
  onEmailConflict(callback) {
    this.emailConflictCallback.push(callback);
    return () => {
      this.emailConflictCallback = this.emailConflictCallback.filter(c => c !== callback);
    };
  }
  onEmailAuthCodeRequired(callback) {
    this.emailAuthCodeRequiredCallback.push(callback);
    return () => {
      this.emailAuthCodeRequiredCallback = this.emailAuthCodeRequiredCallback.filter(c => c !== callback);
    };
  }
  async handleValidationRequired({
    onValidationRequired
  } = {}) {
    var _await$this$deviceNam;
    const proceed = onValidationRequired ? onValidationRequired() : true;
    if (!proceed) {
      return false;
    }
    const intent = await this.waas.validateSession({
      deviceMetadata: (_await$this$deviceNam = await this.deviceName.get()) != null ? _await$this$deviceNam : 'Unknown device'
    });
    const sendIntent = await this.sendIntent(intent);
    this.validationRequiredSalt = sendIntent.data.salt;
    for (const callback of this.validationRequiredCallback) {
      callback();
    }
    return this.waitForSessionValid();
  }
  headers() {
    return {
      'X-Access-Key': this.config.projectAccessKey
    };
  }
  async updateTimeDrift() {
    if (getTimeDrift() === undefined) {
      const res = await fetch(`${this.config.rpcServer}/status`);
      const date = res.headers.get('Date');
      if (!date) {
        throw new Error('failed to get Date header value from /status');
      }
      updateTimeDrift(new Date(date));
    }
  }
  async sendIntent(intent) {
    const sessionId = await this.waas.getSessionId();
    if (!sessionId) {
      throw new Error('session not open');
    }
    try {
      const res = await this.client.sendIntent({
        intent: intent
      }, this.headers());
      return res.response;
    } catch (e) {
      if (isIntentTimeError(e) && this.lastDate) {
        const newIntent = await this.waas.updateIntentTime(intent, this.lastDate);
        const res = await this.client.sendIntent({
          intent: newIntent
        }, this.headers());
        return res.response;
      }
      throw e;
    }
  }
  async isSignedIn() {
    return this.waas.isSignedIn();
  }
  async signIn(creds, sessionName) {
    var _this2 = this;
    // We clear and drop session regardless of whether it's signed in or not
    const currentSessionId = await this.waas.getSessionId();
    if (currentSessionId) {
      await this.dropSession({
        sessionId: currentSessionId,
        strict: false
      });
    }
    const isEmailAuth = 'email' in creds;
    if (isEmailAuth && this.emailAuthCodeRequiredCallback.length == 0) {
      return Promise.reject('Missing emailAuthCodeRequired callback');
    }
    return new Promise(async function (resolve, reject) {
      let challenge;
      try {
        challenge = await _this2.initAuth(creds);
      } catch (e) {
        return reject(e);
      }
      const respondToChallenge = async function respondToChallenge(answer) {
        try {
          const res = await _this2.completeAuth(challenge.withAnswer(answer), {
            sessionName
          });
          resolve(res);
        } catch (e) {
          if (e instanceof AnswerIncorrectError) {
            // This will NOT resolve NOR reject the top-level promise returned from signIn, it'll keep being pending
            // It allows the caller to retry calling the respondToChallenge callback
            throw e;
          } else if (e instanceof EmailAlreadyInUseError) {
            const forceCreate = async function forceCreate() {
              try {
                const res = await _this2.completeAuth(challenge.withAnswer(answer), {
                  sessionName,
                  forceCreateAccount: true
                });
                resolve(res);
              } catch (e) {
                reject(e);
              }
            };
            const info = {
              type: IdentityType.None,
              email: '',
              issuer: ''
            };
            if (e.cause) {
              const parts = e.cause.split('|');
              if (parts.length >= 2) {
                info.type = parts[0];
                info.email = parts[1];
              }
              if (parts.length >= 3) {
                info.issuer = parts[2];
              }
            }
            for (const callback of _this2.emailConflictCallback) {
              callback(info, forceCreate);
            }
          } else {
            reject(e);
          }
        }
      };
      if (isEmailAuth) {
        for (const callback of _this2.emailAuthCodeRequiredCallback) {
          callback(respondToChallenge);
        }
      } else {
        respondToChallenge('');
      }
    });
  }
  async initAuth(identity) {
    await this.updateTimeDrift();
    if ('guest' in identity && identity.guest) {
      return this.initGuestAuth();
    } else if ('idToken' in identity) {
      return this.initIdTokenAuth(identity.idToken);
    } else if ('email' in identity) {
      return this.initEmailAuth(identity.email);
    } else if ('playFabTitleId' in identity) {
      return this.initPlayFabAuth(identity.playFabTitleId, identity.playFabSessionTicket);
    }
    throw new Error('invalid identity');
  }
  async initGuestAuth() {
    const sessionId = await this.waas.getSessionId();
    const intent = await this.waas.initiateGuestAuth();
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new GuestChallenge(sessionId, res.data.challenge);
  }
  async initIdTokenAuth(idToken) {
    var _decoded$iss;
    const decoded = jwtDecode(idToken);
    const isStytch = ((_decoded$iss = decoded.iss) == null ? void 0 : _decoded$iss.startsWith('stytch.com/')) || false;
    const intent = isStytch ? await this.waas.initiateStytchAuth(idToken, decoded.exp) : await this.waas.initiateIdTokenAuth(idToken, decoded.exp);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return isStytch ? new StytchChallenge(idToken) : new IdTokenChallenge(idToken);
  }
  async initEmailAuth(email) {
    const sessionId = await this.waas.getSessionId();
    const intent = await this.waas.initiateEmailAuth(email);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new EmailChallenge(email, sessionId, res.data.challenge);
  }
  async initPlayFabAuth(titleId, sessionTicket) {
    const intent = await this.waas.initiatePlayFabAuth(titleId, sessionTicket);
    const res = await this.sendIntent(intent);
    if (!isInitiateAuthResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return new PlayFabChallenge(titleId, sessionTicket);
  }
  async completeAuth(challenge, opts) {
    await this.updateTimeDrift();

    // initAuth can start while user is already signed in and continue with linkAccount method,
    // but it can't be used to completeAuth while user is already signed in. In this
    // case we should throw an error.
    const isSignedIn = await this.isSignedIn();
    if (isSignedIn) {
      throw new Error('You are already signed in. Use dropSession to sign out from current session first.');
    }
    if (!opts) {
      opts = {};
    }
    if (!opts.sessionName) {
      opts.sessionName = 'session name';
    }
    const intent = await this.waas.completeAuth(challenge.getIntentParams(), {
      forceCreateAccount: opts.forceCreateAccount
    });
    try {
      const res = await this.registerSession(intent, opts.sessionName);
      await this.waas.completeSignIn({
        code: 'sessionOpened',
        data: {
          sessionId: res.session.id,
          wallet: res.response.data.wallet
        }
      });
      return {
        sessionId: res.session.id,
        wallet: res.response.data.wallet,
        email: res.session.identity.email
      };
    } catch (e) {
      if (!(e instanceof EmailAlreadyInUseError) && !(e instanceof AnswerIncorrectError)) {
        await this.waas.completeSignOut();
      }
      throw e;
    }
  }
  async registerSession(intent, name) {
    try {
      const res = await this.client.registerSession({
        intent,
        friendlyName: name
      }, this.headers());
      return res;
    } catch (e) {
      if (isIntentTimeError(e) && this.lastDate) {
        const newIntent = await this.waas.updateIntentTime(intent, this.lastDate);
        return await this.client.registerSession({
          intent: newIntent,
          friendlyName: name
        }, this.headers());
      }
      throw e;
    }
  }
  async refreshSession() {
    throw new Error('Not implemented');
  }
  async getSessionId() {
    return this.waas.getSessionId();
  }
  async getSessionHash() {
    const sessionId = (await this.waas.getSessionId()).toLowerCase();
    return ethers.id(sessionId);
  }
  async dropSession({
    sessionId,
    strict
  } = {}) {
    await this.updateTimeDrift();
    const thisSessionId = await this.waas.getSessionId();
    if (!thisSessionId) {
      throw new Error('session not open');
    }
    const closeSessionId = sessionId || thisSessionId;
    try {
      const intent = await this.waas.signOutSession(closeSessionId);
      const result = await this.sendIntent(intent);
      if (!isCloseSessionResponse(result)) {
        throw new Error(`Invalid response: ${JSON.stringify(result)}`);
      }
    } catch (e) {
      if (strict) {
        throw e;
      }
      console.error(e);
    }
    if (closeSessionId === thisSessionId) {
      if (!this.secureStoreBackend) {
        throw new Error('No secure store available');
      }
      const session = await newSessionFromSessionId(thisSessionId, this.cryptoBackend, this.secureStoreBackend);
      session.clear();
      await this.waas.completeSignOut();
      await this.deviceName.set(undefined);
    }
  }
  async listSessions() {
    await this.updateTimeDrift();
    const sessionId = await this.waas.getSessionId();
    if (!sessionId) {
      throw new Error('session not open');
    }
    const intent = await this.waas.listSessions();
    const res = await this.sendIntent(intent);
    return res.data.map(session => _extends({}, session, {
      isThis: session.id === sessionId
    }));
  }

  // WaaS specific methods
  async getAddress() {
    return this.waas.getAddress();
  }
  async validateSession(args) {
    await this.updateTimeDrift();
    if (await this.isSessionValid()) {
      return true;
    }
    return this.handleValidationRequired(args);
  }
  async finishValidateSession(challenge) {
    await this.updateTimeDrift();
    const intent = await this.waas.finishValidateSession(this.validationRequiredSalt, challenge);
    const result = await this.sendIntent(intent);
    if (!isFinishValidateSessionResponse(result)) {
      throw new Error(`Invalid response: ${JSON.stringify(result)}`);
    }
    this.validationRequiredSalt = '';
    return result.data.isValid;
  }
  async isSessionValid() {
    await this.updateTimeDrift();
    const intent = await this.waas.getSession();
    const result = await this.sendIntent(intent);
    if (!isGetSessionResponse(result)) {
      throw new Error(`Invalid response: ${JSON.stringify(result)}`);
    }
    return result.data.validated;
  }
  async waitForSessionValid(timeout = 600000, pollRate = 2000) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (await this.isSessionValid()) {
        return true;
      }
      await new Promise(resolve => setTimeout(resolve, pollRate));
    }
    return false;
  }
  async sessionAuthProof({
    nonce,
    network,
    validation
  }) {
    await this.updateTimeDrift();
    const intent = await this.waas.sessionAuthProof({
      nonce,
      network
    });
    return await this.trySendIntent({
      validation
    }, intent, isSessionAuthProofResponse);
  }
  async listAccounts() {
    await this.updateTimeDrift();
    const intent = await this.waas.listAccounts();
    const res = await this.sendIntent(intent);
    if (!isListAccountsResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async linkAccount(challenge) {
    await this.updateTimeDrift();
    const intent = await this.waas.linkAccount(challenge.getIntentParams());
    const res = await this.sendIntent(intent);
    if (!isLinkAccountResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async removeAccount(accountId) {
    await this.updateTimeDrift();
    const intent = await this.waas.removeAccount({
      accountId
    });
    await this.sendIntent(intent);
  }
  async getIdToken(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.getIdToken({
      nonce: args == null ? void 0 : args.nonce
    });
    const res = await this.sendIntent(intent);
    if (!isGetIdTokenResponse(res)) {
      throw new Error(`Invalid response: ${JSON.stringify(res)}`);
    }
    return res.data;
  }
  async useIdentifier(args) {
    if (args.identifier) {
      return args;
    }

    // Generate a new identifier
    const identifier = `ts-sdk-${Date.now()}-${await this.waas.getSessionId()}`;
    return _extends({}, args, {
      identifier
    });
  }
  async trySendIntent(args, intent, isExpectedResponse) {
    const response = await this.sendIntent(intent);
    if (isExpectedResponse(response)) {
      return response;
    }
    if (isValidationRequiredResponse(response)) {
      const proceed = await this.handleValidationRequired(args.validation);
      if (proceed) {
        const response2 = await this.sendIntent(intent);
        if (isExpectedResponse(response2)) {
          return response2;
        }
      }
    }
    throw new Error(JSON.stringify(response));
  }
  async signMessage(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.signMessage(await this.useIdentifier(args));
    return this.trySendIntent(args, intent, isSignedMessageResponse);
  }
  async trySendTransactionIntent(intent, args) {
    let result = await this.trySendIntent(args, intent, isMaySentTransactionResponse);
    while (isTimedOutTransactionResponse(result)) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      const receiptArgs = {
        metaTxHash: result.data.metaTxHash,
        network: intent.data.network,
        identifier: intent.data.identifier,
        validation: args.validation
      };
      const receiptIntent = await this.waas.getTransactionReceipt(await this.useIdentifier(receiptArgs));
      result = await this.trySendIntent(receiptArgs, receiptIntent, isMaySentTransactionResponse);
    }
    return result;
  }
  async sendTransaction(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.sendTransaction(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC20(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.sendERC20(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC721(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.sendERC721(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async sendERC1155(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.sendERC1155(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async callContract(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.callContract(await this.useIdentifier(args));
    return this.trySendTransactionIntent(intent, args);
  }
  async feeOptions(args) {
    await this.updateTimeDrift();
    const intent = await this.waas.feeOptions(await this.useIdentifier(args));
    return this.trySendIntent(args, intent, isFeeOptionsResponse);
  }
  async networkList() {
    const networks = [];
    const chainList = await this.client.chainList({
      'X-Access-Key': this.config.projectAccessKey
    });
    for (const chain of chainList.chains) {
      networks.push({
        id: chain.id,
        name: chain.name,
        isEnabled: chain.isEnabled
      });
    }
    return networks;
  }
  onSessionStateChanged(callback) {
    return this.waas.onSessionStateChanged(callback);
  }

  // Special version of fetch that keeps track of the last seen Date header
  async fetch(input, init) {
    const res = await globalThis.fetch(input, init);
    const headerValue = res.headers.get('date');
    if (headerValue) {
      this.lastDate = new Date(headerValue);
    }
    return res;
  }
}

export { AccountAlreadyLinkedError, AnswerIncorrectError, Challenge, ChallengeExpiredError, EmailAlreadyInUseError, EmailChallenge, FeeTokenType, GuestChallenge, IdTokenChallenge, IdentityType, IntentName, IntentResponseCode, PlayFabChallenge, ProofVerificationFailedError, SequenceWaaS, SequenceWaaSBase, StytchChallenge, TenantNotFoundError, TooManyAttemptsError, TransactionType, UnauthorizedError, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion, WebrpcBadMethodError, WebrpcBadRequestError, WebrpcBadResponseError, WebrpcBadRouteError, WebrpcClientDisconnectedError, WebrpcEndpointError, WebrpcError, WebrpcInternalErrorError, WebrpcRequestFailedError, WebrpcServerPanicError, WebrpcStreamFinishedError, WebrpcStreamLostError, contractCall, defaultArgsOrFail, delayedEncode, erc1155, erc20, erc721, errors, isCloseSessionResponse, isFailedTransactionResponse, isFeeOptionsResponse, isFinishValidateSessionResponse, isGetIdTokenResponse, isGetSessionResponse, isInitiateAuthResponse, isIntentTimeError, isLinkAccountResponse, isListAccountsResponse, isMaySentTransactionResponse, isOpenSessionResponse, isSentTransactionResponse, isSessionAuthProofResponse, isSignedMessageResponse, isTimedOutTransactionResponse, isValidateSessionResponse, isValidationRequiredResponse, networks, parseSequenceWaaSConfigKey, store };
